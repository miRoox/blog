{"meta":{"title":"miRoox的博客","subtitle":"我唯一知道的就是我一无所知 ——苏格拉底","description":"现役研究生","author":"miRoox","url":"http://miRoox.github.io/blog"},"pages":[{"title":"404 Not Found","date":"2020-01-27T14:03:29.667Z","updated":"2020-01-23T14:16:13.000Z","comments":true,"path":"404.html","permalink":"http://miRoox.github.io/blog/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2020-01-27T14:03:29.679Z","updated":"2020-01-16T15:32:23.000Z","comments":true,"path":"about/index.html","permalink":"http://miRoox.github.io/blog/about/index.html","excerpt":"","text":"偏理的工科生，字面意义的死宅。 感兴趣的领域包括但不限于：编程、动漫、科幻小说、数学、科学哲学… 好像什么都会一点，又好像什么都不懂。 本质上是个theorist 。 目前科研方向主要是计算光学成像。 常用社交帐号:微博、Bangumi、GitHub 不喜欢传统社交，不谈政治，少谈时事。 动画、漫画、轻小说都看，不过后两者相对看得少。 国产动画、漫画挑着看一些，欧美的基本不看。 对动画的评价标准不确定，好评的重要一点是电波对的上（如《人类衰退之后》），某一方面很优秀的作品也会给好评（如《永生之酒》），差评的作品基本上是我很难看下去的。 典型的对我电波的作品有《人类衰退之后》，《物语》系列，《四叠半神话大系》。 魔禁是入宅作。 不混圈，不是很懂你们二刺猿。 没打过原作的伪东方厨。 不打Gal，也不玩各类手游。 游戏基本只玩红警2及其Mod。时代变了，Win10对红警兼容性太差，也不再玩了。 不过依然只玩单机游戏。 喜欢科幻小说，自己也尝试着写过一些，虽然写得不怎么样。 目前最喜欢的科幻作家是特德·姜，如果限于国内的话，则是韩松。 刘慈欣的作品也很喜欢，但韩松的更对电波一些。 九州非忠实粉丝，不分南北。 西方文学作品看得少，其主要原因是记不住人名。 时常觉得文学作品中的所用的手法比所讲的内容更重要。 万物皆可后现代。 曾自称红警Modder，但其实从未做出过一个完成品。 编程从C语言入门，目前主要使用C++、Wolfram Language （Mathematica）和Julia。 C++是一门包罗万象的语言，也因此是门垃圾语言。 希望Rust早日干爆C++之流。 吹一波Mathematica，吊打MatLab。现在改吹Julia了，吊打前面两位。 还要吹一波Qt，至少人家支持的平台多。 算法和数据结构都只是略有接触，不怎么用，也不怎么会用。 哲学理念以康德哲学为核心，认为理性分为纯粹理性与实践理性。纯粹理性的认识论基于康德的“物自体-现象”模型；实践理性以马克思的辩证唯物主义为主，但对历史唯物主义偏向于否定。 形式（几乎）是数学的全部内容。 有关科学哲学方面的想法比较多，以后专门撰文来说。坑放得太久，都已经忘了。 更多信息请见个人知识库维基"},{"title":"所有分类","date":"2020-01-27T14:03:29.679Z","updated":"2020-01-23T13:51:07.000Z","comments":true,"path":"categories/index.html","permalink":"http://miRoox.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-01-27T14:03:29.679Z","updated":"2020-01-25T10:05:03.000Z","comments":true,"path":"friends/index.html","permalink":"http://miRoox.github.io/blog/friends/index.html","excerpt":"","text":"友链交换示例： 名称： miRoox 头像： https://miroox.github.io/blog/images/avatar.jpg 网址： https://miroox.github.io/blog/ 标签： 编程 吹水"},{"title":"所有标签","date":"2020-01-27T14:03:29.679Z","updated":"2020-01-16T15:32:23.000Z","comments":true,"path":"tags/index.html","permalink":"http://miRoox.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"利用 GitHub Actions 自动化构建和发布 Qt 程序的一点经验","slug":"AboutGitHubActionsCIQt","date":"2019-12-10T14:24:54.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/12/AboutGitHubActionsCIQt/","link":"","permalink":"http://miRoox.github.io/blog/2019/12/AboutGitHubActionsCIQt/","excerpt":"前一阵子 GitHub 正式发布了 Actions 功能来提供内置的持续集成和持续发布。而我正好最近在利用 Qt 写数字图像处理的作业，就想利用这个机会尝试一下基于 GitHub Actions 的持续集成。","text":"前一阵子 GitHub 正式发布了 Actions 功能来提供内置的持续集成和持续发布。而我正好最近在利用 Qt 写数字图像处理的作业，就想利用这个机会尝试一下基于 GitHub Actions 的持续集成。 当然，有问题首先是找轮子。很快我就找到了 jaredtao/HelloActions-Qt，以及相关的几篇博客文章[1] [2]。照猫画虎很快就把各个平台下的自动构建弄成了。但那篇关于自动发行的文章[2:1]对多配置下 create-release 重复执行导致失败这一问题的解决方案不太令我满意，总觉得太繁琐了，而且我对其中所用的 PowerShell 也不熟。不过这个问题显然不是特殊情况，想必也曾有人就此提出了问题，而也许已经有别人回答了更好的解决方案也不一定。果不其然，早就有人在 create-release 的仓库下的 issues 中提出过这个问题，并且这个 issue 尚未关闭，也就是并没有一个非常令人满意的解答。不过，其中有一个回答[3]给我一点启发，它将使用多种配置的发布任务与创建 release 的任务分开，而通过 upload-artifact 和 download-artifact 来传递 release URL。另一个关联的仓库也有人给出了类似的思路[4]： 123456789build(mac) build(linux) build(win) │ │ │ └──────────────────┼─────────────────┘ │ create_release() │ ┌──────────────────┼─────────────────┐ │ │ │upload(mac) upload(linux) upload(win) 不过这种任务结构让构建和上传两个阶段的文件对应变得麻烦起来。受此启发，我想到了另一种可能——create_release()真的一定要在build(...)完成之后才能进行吗？因为我们需要创建 release 的时候一定是在发布 tag 的时候，这时我们通常已经在 commit 时检验过一遍是否通过构建/测试了，因此不妨将create_release()提前，于是有 1234567 create_release()* │ ┌──────────────────┼─────────────────┐ │ │ │ build(mac) build(linux) build(win) &amp; &amp; &amp;upload(mac)* upload(linux)* upload(win)* *表示只在发布 tag 的时候才会进行这个步骤。这里将build(...)和upload(...)两个阶段合在同一个job中，便于传递文件。最终配置如 .github/workflows/build.yml 所示。 Qt使用github-Actions自动化编译 ↩︎ Qt使用github-Actions自动化发行 ↩︎ ↩︎ How to prevent creating multiple releases when using a build matrix? ↩︎ Support matrix build ↩︎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://miRoox.github.io/blog/tags/GitHub/"},{"name":"Qt","slug":"Qt","permalink":"http://miRoox.github.io/blog/tags/Qt/"},{"name":"持续集成","slug":"持续集成","permalink":"http://miRoox.github.io/blog/tags/持续集成/"}]},{"title":"为什么我们需要术语——兼谈科普的危害性","slug":"TerminologyAndPopularScience","date":"2019-11-05T13:03:42.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/11/TerminologyAndPopularScience/","link":"","permalink":"http://miRoox.github.io/blog/2019/11/TerminologyAndPopularScience/","excerpt":"写下这篇文章的起源是在知乎上看到的一个回答[1]： 很简单，就是硬抬杠。 举个例子，我说偶数跟正整数一样多，你就说怎么可能，正整数包含奇数和偶数，所以肯定正整数多。 我解释说偶数跟正整数存在一个一一映射，并且都含有无穷多元素，所以一样多。你就说我听不懂什么一一映射，我只知道我是你的两倍，所以肯定比你多。 那我解释，1对应2，2对应4，3对应6，一直这样下去，每个正整数都对应一个偶数。他就是不同意，说你说话就在放屁，我给你一百块，你给我两百块，一直这样我们看看最后谁的钱多？ 我说这在有限的情况下是对的，但是无穷的情况下就不一定了。你就说无穷不就是特别大的数嘛，那我大一你倍不是大你更多？ 我说wdnmd吧，你就说你怎么骂人呢？ 在这个回答里，作者似乎把对于无法将无穷集合的等势理解成“一样多”的普通人思维当作抬杠。但这件事就真的只是抬杠这么肤浅吗？","text":"写下这篇文章的起源是在知乎上看到的一个回答[1]： 很简单，就是硬抬杠。 举个例子，我说偶数跟正整数一样多，你就说怎么可能，正整数包含奇数和偶数，所以肯定正整数多。 我解释说偶数跟正整数存在一个一一映射，并且都含有无穷多元素，所以一样多。你就说我听不懂什么一一映射，我只知道我是你的两倍，所以肯定比你多。 那我解释，1对应2，2对应4，3对应6，一直这样下去，每个正整数都对应一个偶数。他就是不同意，说你说话就在放屁，我给你一百块，你给我两百块，一直这样我们看看最后谁的钱多？ 我说这在有限的情况下是对的，但是无穷的情况下就不一定了。你就说无穷不就是特别大的数嘛，那我大一你倍不是大你更多？ 我说wdnmd吧，你就说你怎么骂人呢？ 在这个回答里，作者似乎把对于无法将无穷集合的等势理解成“一样多”的普通人思维当作抬杠。但这件事就真的只是抬杠这么肤浅吗？ 需要明确的是，“一样多”是自然语言的提法，不是一个严格的数学术语。基于基数的比较方式可以在有限的时候和我们平时说的一样多是一致的，因此我们将其推广到无穷意义下的一样多。但这个对应不是唯一的，我们可以构造另一个比较方式依然满足有限意义的“一样多”，却在无限集的比较晚得到不同的结果。比如： 不妨定义区间 [−a,a][-a,a][−a,a] 与集合 AAA 的交集的元素个数为 NA(a)N_A(a)NA​(a) ，然后定义集合 AAA 和集合 BBB 的“元素比值”为 p(A,B)=lim⁡a→∞NA(a)NB(a)p(A,B)=\\lim_{a\\to\\infty}\\frac{N_A(a)}{N_B(a)} p(A,B)=a→∞lim​NB​(a)NA​(a)​ 当“元素比值” p(A,B)=1p(A,B)=1p(A,B)=1 时，则称集合 AAA 和 BBB 的元素“一样多”。显然，这个定义在集合有限时和我们的认知依然是一致的，因此也可以作为“一样多”的一个推广。但如果拿来比较整数和偶数，结果则不会是“一样多”，而前者对后者的“元素比值”为2，似乎更符合我们的直观认识。 当然，上面这个定义显然不会是我们的数学所想要的。因为这个定义过于平凡了，以至于即使在面对像有理数集这样的可数集时也会无法定义，这与数学所追求最广泛意义上的一致性是相违背的。因而，“势”依然是对任意集合的大小进行度量的最佳方式，也是我们在数学中普遍采用的。但这一概念如果反过来作为日常用语中的“一样多”的替代，则无疑是术语的滥觞，只会令人更加迷惑，无益于辨清问题的边界。 也许一个来自数学自身的例子更能展现这种概念拓展的不唯一性：维数——我们有线性空间的维数（自由度）、拓扑维数乃至各式各样的分形维数，它们最初都来自我们日常对空间方位的直观认知。但它们都是在各自领域中抽象出来的概念，并不能简单地断言谁是一般意义上最佳的定义。 不过，概念的推广与取代在学术界内部确实广为存在，每一次取代本身可以认为是对概念更深刻的理解。虽说如此，明辨问题的边界和语境对业内人士同样重要，至少应该采取明确的上下文或者精准唯一的术语来进行描述。 如果说概念的泛化推广是抽象和发散思维的体现，那么划定专有术语和明晰边界则是具体和确定性的追求。这两点对于研究者而言都具有程度相当的重要性。如何在两者间取得平衡，对科研人员也并非易事，更遑论科普读物和它们的读者了。能把握住这当中的微妙的，大概《物理学咬文嚼字》尚且能算一个比较好的例子吧。 针对科普作品，19世纪伟大的物理学家麦克斯韦曾写下这样的忠告[2]： In the popular treatise, whatever shreds of the science are allowed to appear, are exhibited in an exceedingly diffuse and attenuated form, apparently with the hope that the mental faculties of the reader, though they would reject any stronger food, may insensibly become saturated with scientific phraseology, provided it is diluted with a sufncient quantity of more familiar language. In this way, by simple reading, the student may become possessed of the phrases of the science without having been put to the trouble of thinking a single thought about it. The loss implied in such an acquisition can be estimated only by those who have been compelled to unlearn a science that they might at length begin to learn it. The technical treatises do less harm, for no one ever reads them except under compulsion. From the establishment of the general equations to the end of the book, every page is full of symbols with indices and suffixes, so that there is not a paragraph of plain English on which the eye may rest. 确实，科普读物对专业术语的稀释一定程度上也是对读者深入思维能力的一种伤害。进一步地，这种对术语的浅薄化，对业已进入专业行列的“原读者”乃至科普作者自身的辨析能力也会造成不经意的伤害；而这种伤害又反过来进一步拉大了科学概念与一般人之间的距离，令人以为这些被“通俗化”所粉饰的概念就一定能为大众所理解，构成现代科学版的“何不食肉糜”，不得不令人扼腕。 当然，科普工作也不尽然都是坏的。哪怕是稀释过的概念知识，倘若能抓住精要，不会因为注水过多而浅尝辄止，那么从科普中浸润的少量知识反而更能让人甘之如饴，激发探索深入的兴趣。只是，倘若能在科普中就更好的明辨当中的概念和术语，大概会减少那些因模糊的粉饰而对长远的研究道路所造成的伤害吧。 如何激怒一位数学爱好者？ - 孙泰英的回答 - 知乎 ↩︎ MAXWELL J C. Tait’s “Thermodynamics”[J]. Nature, 1878, 17(431): 257–259. ↩︎","categories":[{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miRoox.github.io/blog/categories/杂谈散记/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://miRoox.github.io/blog/tags/杂谈/"},{"name":"科普","slug":"科普","permalink":"http://miRoox.github.io/blog/tags/科普/"}]},{"title":"如何提交函数到 Wolfram Function Repository","slug":"SubmitFunctionToWFR","date":"2019-10-12T07:23:32.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/10/SubmitFunctionToWFR/","link":"","permalink":"http://miRoox.github.io/blog/2019/10/SubmitFunctionToWFR/","excerpt":"首先，你需要一个 Wolfram 账户。","text":"首先，你需要一个 Wolfram 账户。 然后，你需要申请一个 Publisher ID，这点在许多讲述提交函数到WFR的文章中都没提到。大致的申请流程可以在参考文档里找到。 然后在 Mathematica 中新建一个函数知识库项。按风格指南编写函数代码和文档。 提交前要检查 Mathematica 有没有登录到你的 Wolfram 账户，可以根据 $WolframID 的值确认。而且应该将 $PublisherID 的值设置为你申请到的 Publisher ID。 当然，提交之前还应该用菜单中的“Check”按钮检查格式无误后再提交。最后点击“Submit to Repository”，接下来就等邮件吧。无论 review 有没有通过一般都会发邮件进行通知。没有通过的话往往还会附上 review comments 指导你改进，并且可以完善后再提交更新。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"}]},{"title":"尝试用TiddlyWiki搭建个人维基知识库","slug":"PersonalWiki","date":"2019-10-10T12:44:23.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/10/PersonalWiki/","link":"","permalink":"http://miRoox.github.io/blog/2019/10/PersonalWiki/","excerpt":"搭建一个个人维基用来整理知识的想法早已有之，但具体该使用什么方案却迟迟没能定下来。在最初的想法里，我希望满足下面的几项需求： 内容与表现分离 自动化构建 可以使用自己定制的模板 词条的分类灵活，以适应知识体系的逐渐完善 方便建立知识点（词条）间的联系 需要用笔记时能快速提取 LaTeX\\LaTeXLATE​X 公式输入 代码块语法高亮","text":"搭建一个个人维基用来整理知识的想法早已有之，但具体该使用什么方案却迟迟没能定下来。在最初的想法里，我希望满足下面的几项需求： 内容与表现分离 自动化构建 可以使用自己定制的模板 词条的分类灵活，以适应知识体系的逐渐完善 方便建立知识点（词条）间的联系 需要用笔记时能快速提取 LaTeX\\LaTeXLATE​X 公式输入 代码块语法高亮 作为参考，见过别人用 Dokuwiki 的，也有直接拿 Hexo 的 Wikitte 主题搭建的，等等。当然，我自己也做过一些尝试，比如 Zim Wiki ，不过这个太简陋了，完全无法满足我的需求；甚至受 小时物理百科 的影响，尝试过用 LaTeX\\LaTeXLATE​X 构建维基，但 LaTeX\\LaTeXLATE​X 对于我的需求而言又稍显复杂了，而且大量交叉引用在PDF中也并不方便阅读。最后在一番比较和取舍之下选择了TiddlyWiki[1]。 TiddlyWiki，按官方说法是「一款非线性个人 Web 笔记本」。相比其他笔记和 Wiki 系统，其最大的特点之一是程序本体和数据全部都在一个 html 文件内，这意味着组织和阅读多个词条可以在同一个页面内直接完成，内容的关联更加直接，方便互相比照。同时，还有着非常强大的条目管理功能和插件系统，可扩展性和可定制性都很强。 TiddlyWiki 的优点还有很多[2]，这里就不多赘述了。就我而言，更想简单说一下 TiddlyWiki 是如何满足前面提到的几项需求的： 内容与表现分离： 这一项近乎是一种哲学理念，实践起来是否须要完全符合还是看具体情况。 典型地，WikiText 就提供了很多特定语义的语法元素，还有宏、模板嵌入等各种自定义工具。 当然，经典地 HTML-CSS-JS 结构也是可以使用的。 自动化构建： 通过使用 Node.js 上的 TiddlyWiki 服务可以在本地同步保存修改； 用 Git 和 Travis CI 实现向 Github Pages 自动部署。 可以使用自己定制的模板： 这一项其实是“内容与表现分离”的具体实践方法之一。 WikiText 支持模板条目和宏。 词条的分类灵活，以适应知识体系的逐渐完善： TiddlyWiki 是基于标签分类的，一个词条可以分到多个标签下，这一点比许多按树状层级分类的方案要灵活得多。 方便建立知识点（词条）间的联系： 词条链接和词条嵌入。 需要用笔记时能快速提取： 能自动部署到网页上，有网就能看； 还有灵活的搜索语法。 LaTeX公式输入： KaTeX插件：支持的命令较少，不过是官方提供的，安装很容易。 MathJax插件：第三方提供的，比较老了，好像和新版不太兼容，需要折腾（反正我没能折腾成功）。 代码块语法高亮 Highlight.js插件：这也是官方提供的。 除此之外，TiddlyWiki 还有一大优点是简单，几乎所有操作都可以在网页上完成，基本不用到处配置。这对于我这种对web技术基本一无所知的人来说是一个极大的优势。 不过也因为我对web技术的不了解，导致很大的功夫都花在自动部署的配置上了，最终也只是是照猫画虎。其间主要参考了 alexashley 的个人Wiki源码[3]、JavaScript 标准参考教程（alpha）[4]、《Blog自动部署实践: Hugo + Travis CI -&gt; GitHub Pages》[5]等资料。 最终弄出来的成品在：https://miroox.github.io/wiki/ 参考资料： TiddlyWiki中文网站 ↩︎ 使用 TiddlyWiki 打造轻便个人 Wiki 知识库 ↩︎ alexashley 的个人Wiki源码 ↩︎ package.json文件 - JavaScript 标准参考教程（alpha） ↩︎ Blog自动部署实践: Hugo + Travis CI -&gt; GitHub Pages ↩︎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"Wiki","slug":"Wiki","permalink":"http://miRoox.github.io/blog/tags/Wiki/"},{"name":"Web","slug":"Web","permalink":"http://miRoox.github.io/blog/tags/Web/"}]},{"title":"MatrixForm赋值问题","slug":"MatrixFormProblem","date":"2019-09-19T12:27:34.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/09/MatrixFormProblem/","link":"","permalink":"http://miRoox.github.io/blog/2019/09/MatrixFormProblem/","excerpt":"我们知道，赋值等过程中使用 MatrixForm 往往会导致后续的计算失效。比如：","text":"我们知道，赋值等过程中使用 MatrixForm 往往会导致后续的计算失效。比如： 对于这个问题，最正统的解决办法当然是在赋值等计算过程中不使用 MatrixForm，而只在显示时以 MatrixForm 呈现[1]。典型的方案是在输出部分才加上 MatrixForm 包装。不过对于既有代码的问题，一个个手动修改可能略显麻烦，这时可以借助 EchoFunction 在实现类似效果的同时保持代码结构基本不变： 要将既有代码调整为这种方式，只需简单的文本替换就可以实现目标。 不过，本文要主要要谈的并不是这类传统解决方案，而是通过给 Mathematica 系统打上补丁来实现几乎零修改的解决方案。 我们知道，MatrixForm 这类格式封装，当它位于结果的最外层时，Out 输出历史中不会对其进行储存[2]。事实上，所有在 $OutputForms 中的格式封装都具有这样的性质。 受此启发，我们不妨把这个性质推广到赋值的情况上来，即这类格式封装出现在赋值运算的右侧时不会将其记录到赋值中。事实上，通过重载 Set 的定义很容易实现这一功能： 123GeneralUtilities`BlockProtected[&#123;Set&#125;, Set[lhs_,(form:Alternatives@@$OutputForms)[rhs_]] := form@Set[lhs,rhs]] 效果如图： 参考： Q&amp;A: Compute with MatrixForm ↩︎ 为什么我的代码加了MatrixForm后就出问题了？ ↩︎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miRoox.github.io/blog/tags/踩坑/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"}]},{"title":"基于规则的带步骤符号求导器","slug":"RuleBasedStepByStepDerivative","date":"2019-07-12T14:27:17.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/07/RuleBasedStepByStepDerivative/","link":"","permalink":"http://miRoox.github.io/blog/2019/07/RuleBasedStepByStepDerivative/","excerpt":"我们知道，Wolfram|Alpha 有一个名为 Step-by-Step Solutions 的功能，可以显示一些数学问题求解的过程。又比如，著名的 Rubi 可以在求解积分的同时显示积分的求解步骤。实际上，这些系统背后大抵都是基于模式匹配和规则变换而实现的，因而原则上来说自己也可以实现一个。当然，就实践而言这些系统都过于复杂了，例如 Rubi 包含了超过六千条规则，其背后的原理远非三言两语可以阐明的。不过，相比于积分，微分的运算规则要简明得多，而且对规则的应用总是简单机械的，并不像积分那样可能会运用到各种技巧。因此，本文将利用 Mathematica 的模式匹配和规则实现一个带步骤符号求导器。","text":"我们知道，Wolfram|Alpha 有一个名为 Step-by-Step Solutions 的功能，可以显示一些数学问题求解的过程。又比如，著名的 Rubi 可以在求解积分的同时显示积分的求解步骤。实际上，这些系统背后大抵都是基于模式匹配和规则变换而实现的，因而原则上来说自己也可以实现一个。当然，就实践而言这些系统都过于复杂了，例如 Rubi 包含了超过六千条规则，其背后的原理远非三言两语可以阐明的。不过，相比于积分，微分的运算规则要简明得多，而且对规则的应用总是简单机械的，并不像积分那样可能会运用到各种技巧。因此，本文将利用 Mathematica 的模式匹配和规则实现一个带步骤符号求导器。 求导规则 实现的核心首先在于对求导法则的代码表示。由于 Rule-Based 也是 Wolfram 语言的基本范式，因此这些规则写起来也很直观。 首先是几个基本运算规则 123456baseRules=&#123; d[c_,x_]/;FreeQ[c,x]:&gt;0, d[lf_Plus,x_]:&gt;Thread[d[lf,x],Plus], d[c_*f_,x_]/;FreeQ[c,x]:&gt;c*d[f,x], d[f_*g_,x_]:&gt;d[f,x]g+d[g,x]f&#125;; 这里，使用 d[f,x] 表示 dfdx\\tfrac{\\mathrm{d}f}{\\mathrm{d}x}dxdf​。上述的代码表示了常数求导法则、线性求导法则和乘法求导法则的作用规则。 对于复合函数和反函数，需要一个间接的包装来表示类似 f′(g(x))f&#x27;(g(x))f′(g(x)) 的情况，这里将其表示为dfunc[f,gx]类似的形式，其中gx对应于g(x)g(x)g(x)。 123456higherRules=&#123; HoldPattern@d[InverseFunction[f_][x_],x_]:&gt;1/dfunc[f,InverseFunction[f][x]], d[f_[g_],x_]/;g=!=x:&gt;dfunc[f,g]d[g,x], d[f_[g_,c_],x_]/;FreeQ[c,x]&amp;&amp;g=!=x:&gt;dfunc[f[#,c]&amp;,g]d[g,x], d[f_[c_,g_],x_]/;FreeQ[c,x]&amp;&amp;g=!=x:&gt;dfunc[f[c,#]&amp;,g]d[g,x]&#125;; 需要注意的是，为了避免问题过于复杂化，这里求导的对象都只限于初等函数。因此在考虑复合函数的链导法则时实际不包含多元函数。对于可能遇到地二元初等函数，要么其中一个参数与自变量无关，本质还是一元函数，要么可以通过变形转化成一元形式。 此外还有一点需要注意，在链式法则的规则中，模式条件g=!=x是必要的，否则可能陷入无限自递归的窘境。 在上面的高阶（反函数、复合函数）规则中，dfunc只是徒具形式的一个表示。为了确实有效地计算这种情况，还需要引入一个替换规则。即在计算得到f′(u)f&#x27;(u)f′(u)后，再进行u→g(x)u\\to g(x)u→g(x)的变量替换。直接表达出来就比如 1substRules=dfunc[f_,g_]:&gt;d[f[u],u]/.&#123;u-&gt;g&#125;; 不过这种写法当遇到函数f本身蕴含名为u的参量时就可能会出现错误的结果。因而需要使用Module来引入哑元形式，即 1substRules=dfunc[f_,g_]:&gt;Module[&#123;u&#125;,d[f[u],u]/.&#123;u-&gt;g&#125;]; 但这是错误的。因为我们希望在计算出f′(x)f&#x27;(x)f′(x)后再做变量替换。但上面的实现中，d[f[u],u]本身并不会求值，而是通过应用这些规则进行替换而得到的计算结果，从而导致替换发生在计算导数之前，那样就没有意义了。因此需要一个d的立即求值版，命名为dEval。 1substRules=dfunc[f_,g_]:&gt;Module[&#123;u&#125;,dEval[f[u],u]/.&#123;u-&gt;g&#125;]; 关于dEval的实现，一个粗浅的想法是在完成全部规则的定义后，对输入按这些规则进行ReplaceRepeated。当然，这其中还需要一些细节，我们这里暂且按下不表，留待后面再讨论。 接下来就是对具体函数的求导规则进行列举，比如 123456functionRules=&#123; HoldPattern[d[IgnoringInactive[Exp[x_]],x_]]:&gt;Exp[x], HoldPattern[d[IgnoringInactive[Log[x_]],x_]]:&gt;1/x, HoldPattern[d[IgnoringInactive[Sin[x_]],x_]]:&gt;Cos[x], HoldPattern[d[IgnoringInactive[Cos[x_]],x_]]:&gt;-Sin[x]&#125;; 这样一个个手动枚举也比较繁琐，因此我们不妨利用 Mathematica 既有的求导功能来生成结果 123456789101112functionRules=Table[ With[&#123;f=f&#125;,HoldPattern@d[IgnoringInactive@f[x_],x_]]-&gt;D[f[x],x], &#123;f,&#123; Sqrt,CubeRoot,RealAbs, Exp,Log,Log2,Log10, Sin,Cos,Tan,Cot,Sec,Csc, ArcSin,ArcCos,ArcTan,ArcCot,ArcSec,ArcCsc, Sinh,Cosh,Tanh,Coth,Sech,Csch, ArcSinh,ArcCosh,ArcTanh,ArcCoth,ArcSech,ArcCsch &#125; &#125;]/.&#123;Rule-&gt;RuleDelayed&#125;; 除了这些可以直接表示的一元函数，还有一些形式上是二元函数的一元函数情况，这里简单列举一下 12345functionExtRules=&#123; HoldPattern@d[x_^a_.,x_]/;FreeQ[a,x]:&gt;a x^(a-1), HoldPattern@d[a_^x_,x_]/;FreeQ[a,x]:&gt;a^x Log[a], HoldPattern@d[IgnoringInactive@Surd[x_,n_],x_]/;FreeQ[n,x]:&gt;1/(n Surd[x,n]^(n-1))&#125;; 稍微值得一提的是，由于Power的OneIdentity属性，模式x_^a_.也会直接匹配x这种情况。 除此之外，还有一些二元函数可以通过变形得到上述一元函数的组合 1234transferRules=&#123; HoldPattern@d[IgnoringInactive[f_^g_],x_]/;!(FreeQ[f,x]||FreeQ[g,x]):&gt;d[Inactive[Exp][Log[f]g],x], HoldPattern@d[IgnoringInactive@Log[f_,g_],x_]:&gt;d[Log[g]/Log[f],x]&#125;; 这里的Inactive[Exp]是为了抑制指数函数的内置化简规则。也正是为了方面使用Inactive控制变形的方向，前面的函数求导规则的模式中都包含了IgnoringInactive。 这样，一个囊括了初等函数的符号求导规则就全部完成了。 最后将所有规则整合到一起 12345678allRules=Flatten@&#123; transferRules, baseRules, functionRules, functionExtRules, substRules, higherRules&#125;; 如果只需要进行求导计算，那么直接对输入按这些规则进行替换即可 1dEval[f_,x_]:=d[f,x]//.allRules 举一个简单的例子测试一下 12(dEval==D)[(x^Sin[x]+3x+ArcTan[x])^2/(x^4-3Surd[x^5,3]RealAbs@Log[x]+2),x]//Through//Simplify(*Out: True*) 也就是说利用这些规则已经可以实现对初等函数的求导运算了。然而，假如输入的待求导函数不只包含初等函数，那么dEval就无法完全计算，得到的结果中会包含错误的形式。诚然，我们的目标只在解决初等函数的求导，对于初等函数以外的情况无法解决也是正常的，不过从健壮性的角度考虑，这里最好再增加一个条件以避免某些可能出现的潜在问题。 12345substRules=dfunc[f_,g_]:&gt;Module[&#123;u&#125;, With[&#123;df=dEval[f[u],u]&#125;, (df/.&#123;u-&gt;g&#125;)/;FreeQ[df,_d|_dfunc] ]]; 这里利用作用域里的条件模式来保证遇到dEval无法解决的情况时会保持既有的dfunc形式不变。可以试试下面的代码测试一下效果 1dEval[Erf[Sin[x]]^2,x] 步骤回显 然后是对计算步骤的输出显示。我们希望将替换的每一步都显示出来，因此不能直接使用//.，而应该使用NestWhile之类的方式对每次替换获得更精确的控制。在输出显示上，用CellPrint比较方便，也比单纯的Print好控制格式。 首先，对于输出步骤的每个单元，我们希望前面有一个=标记，就像Echo产生的单元前的&gt;&gt;标志符一样。这一点可以利用CellDingbat实现： 12345echoStep[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[removeLabels@expr,TraditionalForm],TraditionalForm]],\"Print\", CellDingbat-&gt;Cell[\"=\",\"EchoLabel\"]]; expr) 然后，与之类似地，还需要一个函数输出显示最初地状态作为等式的起点。需要注意的是，为了比较好地对齐，需要对两者使用不同的边距： 1234567891011echoStep0[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[expr,TraditionalForm],TraditionalForm]],\"Print\", CellMargins-&gt;&#123;&#123;Inherited, Inherited&#125;,&#123;Inherited,Inherited&#125;&#125;]; expr)echoStep[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[expr,TraditionalForm],TraditionalForm]],\"Print\", CellDingbat-&gt;Cell[\"=\",\"EchoLabel\"], CellMargins-&gt;&#123;&#123;Inherited+20, Inherited&#125;,&#123;Inherited,Inherited&#125;&#125;]; expr) 进一步地，考虑到复合函数求导时需要转入对其它函数求导的过程，这将打断正在进行的求导步骤间的顺叙关系，从逻辑上进入更深的层级。为了表现这种层级关系，这里同样通过调整边距实现。引入一个层级标志量$dDepth：每当计算dEval时都增加这一标志量，结束时就将其还原；同时利用$dDepth控制边距以实现对边距的适应调整。 123456789101112$dDepth=0;echoStep0[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[expr,TraditionalForm],TraditionalForm]],\"Print\", CellMargins-&gt;&#123;&#123;Inherited+20($dDepth-1), Inherited&#125;,&#123;Inherited,Inherited&#125;&#125;]; expr)echoStep[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[expr,TraditionalForm],TraditionalForm]],\"Print\", CellDingbat-&gt;Cell[\"=\",\"EchoLabel\"], CellMargins-&gt;&#123;&#123;Inherited+20$dDepth, Inherited&#125;,&#123;Inherited,Inherited&#125;&#125;]; expr) 123dEval[f_,x_]:=Block[&#123;$dDepth=$dDepth+1&#125;,dEvalR[f,x]]dEvalR[f_,x_]:=NestWhile[echoStep@*ReplaceAll[allRules],echoStep0[d[f,x]],!FreeQ[#2,_d|_dfunc]&amp;&amp;UnsameQ[##]&amp;,2]stepD[f_,x_]:=With[&#123;eval=dEval[f,x]&#125;,eval/;FreeQ[eval,_d|_dfunc]] 这里将具体的求导运算过程委托到dEvalR函数上，利用以是否存在未完成的求导形式为基本判据，同时辅以不变性作为无法完成时的终止条件。再把stepD作为封装的外部接口，通过条件模式限制，在失败时保持输入形式，避免内部dfunc等内部符号暴露到输出中。 测试一下 润色外观 可以看到步骤显示中的输出形式很难看。为了增加步骤的可读性，我们可以通过自定义显示格式来润色外观。考虑我们本身使用的代码结构，将公式输出为Leibniz符号的形式比较方便。 1234567891011d/:MakeBoxes[d[f_,x_],TraditionalForm]:=Module[&#123;boxes&#125;, boxes=MakeBoxes[f, TraditionalForm]; If[Precedence[Plus]&gt;=Precedence[boxes,TraditionalForm],boxes=RowBox[&#123;\"(\", boxes, \")\"&#125;]]; RowBox[&#123;FractionBox[\"\\[DifferentialD]\", RowBox[&#123;\"\\[DifferentialD]\", MakeBoxes[x, TraditionalForm]&#125;]], boxes&#125;]]dfunc/:MakeBoxes[dfunc[f_, g_], TraditionalForm]:=Module[&#123;fboxes, gboxes&#125;, fboxes=ToBoxes[f[g], TraditionalForm]; gboxes=ToBoxes[g, TraditionalForm]; If[Precedence[Plus]&gt;=Precedence[fboxes, TraditionalForm],fboxes=RowBox[&#123;\"(\", fboxes, \")\"&#125;]]; If[Precedence[Plus]&gt;=Precedence[gboxes, TraditionalForm],gboxes=RowBox[&#123;\"(\", gboxes, \")\"&#125;]]; FractionBox[RowBox[&#123;\"\\[DifferentialD]\", fboxes&#125;], RowBox[&#123;\"\\[DifferentialD]\", gboxes&#125;]]] 然后对于被Module局域化符号的显示，像u$nnn这样的形式显然不太好看，在这里也可以给出一个美化模板，它将这类符号的输出形式显示为首字母 1makeXForm[sym_Symbol]:=sym/:MakeBoxes[sym,TraditionalForm]=ToBoxes[Symbol[StringPart[SymbolName[sym],1]],TraditionalForm] 再用在替换规则中 123456substRules=dfunc[f_,g_]:&gt;Module[&#123;u&#125;, makeXForm[u]; With[&#123;df=dEval[f[u],u]&#125;, (df/.&#123;u-&gt;g&#125;)/;FreeQ[df,_d|_dfunc] ]]; 得到的结果就更接近于数学中的写法了 标注步骤 最后，我们还希望给每一步中所使用的特殊规则标注名称，方便理解各个步骤到底做了什么。比如 “乘法法则” “链式法则” 这样的注解。我们首先将这些注解都标记在求导的规则中 12345678910111213baseRules=&#123; d[c_,x_]/;FreeQ[c,x]:&gt;dLabeled[0,\"Constant Rule\"], d[lf_Plus,x_]:&gt;dLabeled[Thread[d[lf,x],Plus],\"Linearity Rule\"], d[c_*f_,x_]/;FreeQ[c,x]:&gt;dLabeled[c*d[f,x],\"Linearity Rule\"], d[f_*g_,x_]:&gt;dLabeled[d[f,x]g+d[g,x]f,\"Product Rule\"]&#125;;higherRules=&#123; HoldPattern@d[InverseFunction[f_][x_],x_]:&gt;dLabeled[1/dfunc[f,InverseFunction[f][x]],\"Inverse Function Rule\"], d[f_[g_],x_]/;g=!=x:&gt;dLabeled[dfunc[f,g]d[g,x],\"Chain Rule\"], d[f_[g_,c_],x_]/;FreeQ[c,x]&amp;&amp;g=!=x:&gt;dLabeled[dfunc[f[#,c]&amp;,g]d[g,x],\"Chain Rule\"], d[f_[c_,g_],x_]/;FreeQ[c,x]&amp;&amp;g=!=x:&gt;dLabeled[dfunc[f[c,#]&amp;,g]d[g,x],\"Chain Rule\"]&#125;; 还有链式法则使用时，替换后的变元原本指代的是什么也应该标记出来，以方便阅读和理解。 1234567substRules=dfunc[f_,g_]:&gt;Module[&#123;u&#125;, makeXForm[u]; With[ &#123;df=dEval[dLabeled[f[u],Row@&#123;\"where \",TraditionalForm[u==g]&#125;],u]&#125;, (df/.&#123;u-&gt;g&#125;)/;FreeQ[df,_d|_dfunc] ]]; 有了规则中的标记，我们就需要能够从表达式里将标记都提取出来的方法。 12345getLabels[expr_]:=With[ &#123;lbs=DeleteDuplicates@Cases[expr,dLabeled[_,lb_]:&gt;lb,&#123;0,Infinity&#125;]&#125;, Row@Flatten@&#123;\"(\",Riffle[lbs,\"; \"],\")\"&#125;/;lbs=!=&#123;&#125;]getLabels[_]=\"\"; 注意一步计算可以会运用多个规则，输出应该为分割得到的一组。同时，对于重复项最好也应该删除。 而这些dLabeled标记形式本身不应出现在求导的过程中，所以应该在每步计算完成后移除 1removeLabels[expr_]:=expr/.&#123;dLabeled[e_,_]:&gt;e&#125; 然后在输出时，注解通过CellFrameLabels显示在每个单元的右侧。 12345678910111213echoStep0[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[removeLabels@expr,TraditionalForm],TraditionalForm]],\"Print\", CellMargins-&gt;&#123;&#123;Inherited+20($dDepth-1), Inherited&#125;,&#123;Inherited,Inherited&#125;&#125;, CellFrameLabels-&gt;&#123;&#123;None,Cell[BoxData@ToBoxes@getLabels[expr],\"MessageText\"]&#125;,&#123;None,None&#125;&#125;]; expr)echoStep[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[removeLabels@expr,TraditionalForm],TraditionalForm]],\"Print\", CellDingbat-&gt;Cell[\"=\",\"EchoLabel\"], CellMargins-&gt;&#123;&#123;Inherited+20$dDepth, Inherited&#125;,&#123;Inherited,Inherited&#125;&#125;, CellFrameLabels-&gt;&#123;&#123;None,Cell[BoxData@ToBoxes@getLabels[expr],\"MessageText\"]&#125;,&#123;None,None&#125;&#125;]; expr) 最后将这些过程添加到计算的每一步中 12345dEvalR[f_,x_]:=NestWhile[ removeLabels@*echoStep@*ReplaceAll[allRules], removeLabels@echoStep0[d[f,x]], !FreeQ[#2,_d|_dfunc]&amp;&amp;UnsameQ[##]&amp;,2] 就大功告成了。 简单测试一下 小结 最终整理得到的完整代码放在 Github 上。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"},{"name":"符号计算","slug":"符号计算","permalink":"http://miRoox.github.io/blog/tags/符号计算/"}]},{"title":"关于LaTeX插入矢量图的格式问题","slug":"FormatOfVectorInLaTeX","date":"2019-07-09T06:51:22.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/07/FormatOfVectorInLaTeX/","link":"","permalink":"http://miRoox.github.io/blog/2019/07/FormatOfVectorInLaTeX/","excerpt":"","text":"简单来说，外部插入矢量图图尽量使用 PDF 格式，以避免生成时的转换。 只要输出介质为pdf，那么使用PSTricks和eps插图都是陋习。 如果输出介质为pdf，那么所有eps都需要转换为pdf后插入。 之所以需要转换，是因为pdfTeX/LuaTeX不带任何PostScript解释器，所以一定要转换成pdf才能插图。而pTeX/XeTeX，则通常需要使用dvipdfmx输出pdf，在用到PostScript代码的时候，即PSTricks和eps图，都会通过管道使用GhostScript转换，这也是拖慢dvipdfmx的一个主要原因。 当然，很多编辑部的期刊模板都要求是eps图，甚至是png都要求转成eps（里面其实还是点阵图）。这时候，eps文件留给他们解决，自己该用什么用什么。 这都2018年了，别想不开老是用eps图。 来自 为什么 用TeXstudio在 XeLaTeX下eps图片不显示, pdflatex下反而可以 ? - 李阿玲的回答 - 知乎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"http://miRoox.github.io/blog/tags/踩坑/"},{"name":"LaTeX","slug":"LaTeX","permalink":"http://miRoox.github.io/blog/tags/LaTeX/"}]},{"title":"如何在Wolfram语言里造一个Wolfram语言风格的对象","slug":"WLStyleObject","date":"2019-05-06T14:27:17.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/05/WLStyleObject/","link":"","permalink":"http://miRoox.github.io/blog/2019/05/WLStyleObject/","excerpt":"最近在做 ComputationalOptics包 的时候为了把 LightField 实现为一个比较典型的Wolfram语言风格的对象，使用了很多undocumented方法，这里主要是做一下记录。 需要注意的是，这里的“对象”不是指“面向对象”里所说的对象（虽然也有点关系），而是类似于 Entity 或者 TemporalData 这类的对象。","text":"最近在做 ComputationalOptics包 的时候为了把 LightField 实现为一个比较典型的Wolfram语言风格的对象，使用了很多undocumented方法，这里主要是做一下记录。 需要注意的是，这里的“对象”不是指“面向对象”里所说的对象（虽然也有点关系），而是类似于 Entity 或者 TemporalData 这类的对象。 这里就以前面提到的LightField为例说明一下如何造一个WL风格的对象。首先，分析需求，来看看预期要实现的效果： 首先能看到的是LightField对象在输出时显示为一个类似于SparseArray那样的一个摘要框；然后，对象的属性可以通过函数参数的形式读写访问，而且对写入数据参数还会进行检查，这一点应该是WL风格的对象最核心的特征；最后，对象是能被认为是一个原子对象，这点实质是一种封装，可以避免直接用表达式的部分操作来访问对象内容，同样类似SparseArray。 进行具体实现前，最基本的，LightField对象数据的组织结构需要确定下来。这里采用的是LightField[type_String, props_Association]的模式，主要是考虑到这种表达式结构在表达光场信息的时候能具有较好的泛化能力。上面的type用来标记光场描述的类型（比如单色平面复振幅），而props则是描述光场所需的具体属性，以关联容器的方式组织数据内容。当然，这些含义对本文而言并不是重点，但也是对象设计和实现中最基本最重要的一步。 然后是对属性的读写的实现。单纯的读操作实现起来并不困难，不过需要注意的一点是我们接下来还要将对象转化为原子的，因此不能直接将问题变为利用[[]]提取部分。 我们知道，复数Complex也是原子的，它虽然不能直接对部分进行提取，但可以利用模式匹配来获得实部和虚部。基于同样的原理，读属性的核心实现长这样 12345getProperty[HoldPattern@LightField[_,props_],prop_]:=Lookup[ props,prop, Message[LightField::ptprop,prop];Missing[\"NotAvailable\",prop]](obj_LightField?LightFieldQ)[prop_]:=getProperty[obj,prop] 这其中，LightFieldQ是一个基于模式匹配判断输入是否为格式正确的LightField对象的函数。毕竟，如果基本格式都不正确的话，后面的模式匹配获取部分也无从谈起。 而写方法在wolfram语言寻常的语法上就非常困难了，因为WL概念上并不存在引用或者指针这一类东西，符号本身几乎总是充当引用的作用，但在形如a[&quot;Wavelength&quot;] = xxx的表达式里，左侧表达式并不是一个符号，而这种形式常常会将定义关联到符号a的下值中，也就是我们常见的函数定义方式。那么怎么让计算上述形式表达式的时候把它当做一个类似于部分赋值的方式进行处理呢？ 一个非常自然地想法可能是对LightField赋予上值，不过很遗憾的是这种方案必然是不可行的，因为可变性意味着参数必须以保持的形式传递符号，那么在模式匹配的阶段必然没有机会接触到需要匹配的LightField，这样上值的关联就无法成立。 另一种想法则是Unprotect[Set]后添加赋值规则，比如 1Set[(sym_Symbol?LightFieldQ)[prop_],val_]:=... 这的确不失为一种解决办法，但这一方法实在有些太笨重了。这会导致所有满足模式sym_Symbol[prop_]=val_的代码都还要用LightFieldQ检查一遍，无论sym中是否隐含着LightField。 尝试下面的代码，感受一下鬼畜的效果 123456gQ[_g]:=(Print[\"Ok\"];True)gQ[_]:=(Print[\"Oops\"];False)Unprotect[Set];Set[(sym_Symbol?gQ)[prop_],val_]:=(Print[Unevaluated[sym[prop]],\"=\",val])Protect[Set];Do[a[1]=1,&#123;a,&#123;1,&lt;||&gt;,g[]&#125;&#125;] （记得清除Set的附加定义） 因而我们需要一个更好的解决办法，这就是Language`SetMutationHandler，它的基本用法可以参见下面的相关资料，基本上照葫芦画瓢就行。作为对照，这里给一个与前述Unprotect方法完全类似测试代码 123456fQ[_f]:=(Print[\"Ok\"];True)fQ[_]:=(Print[\"Oops\"];False)SetAttributes[mutationHandler,HoldAllComplete]mutationHandler[Set[(sym_Symbol?fQ)[prop_],val_]]:=(Print[Unevaluated[sym[prop]],\"=\",val])Language`SetMutationHandler[f,mutationHandler]Do[a[1]=1,&#123;a,&#123;1,&lt;||&gt;,f[]&#125;&#125;] 从输出中可以看到，只有当a的值变为f[]时，上面的匹配测试才会触发。完美符合要求。 在具体实现上，还有一些细节，比如对非属性参数检查和报错，对属性值的检查其实是由LightFieldQ对改变后的临时结果整体进行的检查，还有对失败结果需要Language`MutationFallthrough传递到正常的处理流程中，以及Protect[LightField]来避免fallthrough后干扰到LightField自身的定义等等，下面摘取了其中主要的部分 1234567891011121314151617181920212223SetAttributes[setProperty,HoldFirst]setProperty[sym_Symbol,prop_,val_]:=Block[ &#123;tmp=sym,tmpprops&#125;, tmpprops=getProperty[tmp,All]; If[KeyExistsQ[tmpprops,prop], tmpprops[prop]=val; tmp=Replace[tmp,HoldPattern@LightField[type_,props_]:&gt;LightField[type,tmpprops]]; If[LightFieldQ[tmp], sym=tmp;val, Message[LightField::setptvp,val,prop]; $Failed ], Message[LightField::setptp,prop]; $Failed ]]SetAttributes[mutationHandler,HoldAllComplete]mutationHandler[Set[(sym_Symbol?LightFieldQ)[prop_],val_]]:=With[ &#123;result=setProperty[sym,prop,val]&#125;, result/;!FailureQ[result]]mutationHandler[_]:=Language`MutationFallthroughLanguage`SetMutationHandler[LightField,mutationHandler] 对象的原子化则是利用System`Private`SetNoEntry系列的函数，同样，下面的相关资料里有很详细的介绍。这个系列的函数在不少内部对象的实现里也可以见到，比如Dataset，我们不妨照着做一个。利用神器GeneralUtilities`PrintDefinitions获得其定义，抛开那些无关的，很容易找到下面的内容 中间有一些Dataset内部使用的注册机制，抛开那些不看，无非就是System`Private`SetNoEntry原子化后，利用System`Private`NoEntryQ检查防止无限自递归，注意两处的Unevaluated也是防止无限自递归的一环。在相关资料里我们看到10.4以后又引入了几个更便利的函数，于是依葫芦画瓢就可以写成 1234(obj_LightField?holdLightFieldQ)/;System`Private`HoldEntryQ[obj]:=With[ &#123;valid=System`Private`HoldSetNoEntry[obj]&#125;, valid] 其中holdLightFieldQ就是个保持版的LightFieldQ，作用当然也就不言而喻了。 最后是摘要框，这部分其实完全没有必要，不过说到Mathematica，优雅和颜值也是非常重要的一环，而且同样也用到了一套undocumented函数。这部分可以参考下面的相关资料，也可以用神器GeneralUtilities`PrintDefinitions来hack既有摘要框的对象，比如SparseArray 其核心无非就是BoxForm`ArrangeSummaryBox，中间量的命名也非常直白，即使不看参考资料也不难猜出使用方法。 这三部分都完成了以后，也算是有了一点Wolfram语言风格对象的神韵了。尽管为了这样优雅的使用对象，付出不少丑陋肮脏的实现代码，不过上面看到的一些官方的实现同样也丑陋无比，这倒也算是Wolfram语言的传统艺能了（ 相关资料： Language`* documentation project - Language`*Mutation* What are some useful, undocumented Mathematica functions? - System`Private`*Entry* functions How to create expanding summary boxes like the ones displayed for InterpolatingFunction, NearestFunction, etc.? Object Oriented Programming","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"},{"name":"Undocumented","slug":"Undocumented","permalink":"http://miRoox.github.io/blog/tags/Undocumented/"}]},{"title":"记Mathematica求导的一些坑","slug":"TrapAboutDerivativeInMma","date":"2019-05-01T08:02:10.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/05/TrapAboutDerivativeInMma/","link":"","permalink":"http://miRoox.github.io/blog/2019/05/TrapAboutDerivativeInMma/","excerpt":"这篇文章主要是记录一下在回答贴吧上这个问题时所发现的关于Mathematica求导的一些坑。 原问题虽然没有明说，但我推测问题背景应该是波特图之类的问题，具体问题如下： 对这个函数的幅角求导，代入一个数值为什么求出了个复数值啊，实函数求导应该是实数啊。声明了一下x是实数后好像也不行。 12345f[x_] := Arg[(-(x - 1)^2 + 4 (4 x^3 - 3 x^2 - x^4))/((x - 1)^2 + 4 (4 x^3 - 3 x^2 - x^4) - 4*I*(x^3 - 3 x^2 + 2 x))]f'[5](*Out: (513125/13791752+(342351 I)/3447938) Arg'[2499/2626-(765 I)/2626]*)N[(513125/13791752+(342351 I)/3447938) Arg'[2499/2626-(765 I)/2626]](*Out: 0.0109427 + 0.0292034 I*) 这是程序，我觉得可能是程序表达的问题，那么该怎么去写这个程序呢？新手上路，老哥请指点","text":"这篇文章主要是记录一下在回答贴吧上这个问题时所发现的关于Mathematica求导的一些坑。 原问题虽然没有明说，但我推测问题背景应该是波特图之类的问题，具体问题如下： 对这个函数的幅角求导，代入一个数值为什么求出了个复数值啊，实函数求导应该是实数啊。声明了一下x是实数后好像也不行。 12345f[x_] := Arg[(-(x - 1)^2 + 4 (4 x^3 - 3 x^2 - x^4))/((x - 1)^2 + 4 (4 x^3 - 3 x^2 - x^4) - 4*I*(x^3 - 3 x^2 + 2 x))]f'[5](*Out: (513125/13791752+(342351 I)/3447938) Arg'[2499/2626-(765 I)/2626]*)N[(513125/13791752+(342351 I)/3447938) Arg'[2499/2626-(765 I)/2626]](*Out: 0.0109427 + 0.0292034 I*) 这是程序，我觉得可能是程序表达的问题，那么该怎么去写这个程序呢？新手上路，老哥请指点 这段程序恰好碰到了Mathematica在求导问题上的两个坑： Mathematica总是假设链式求导法则是有效的，但这里遇到的Arg本身是一个不可导的函数，链导法则是不成立的。这一点是一个非常常见的坑。 然后Mathematica的数值导数设计的也欠合理，在遇到符号求导失效的情况时，Mathematica在计算函数导数时会利用其沿着实轴方向的变化率来近似求导（事实上Arg沿复平面不同方向的变化率通常不相等），而Arg本身总是实数，这样一来得到的Arg'[...]的结果就总是一个实数，然而前面根据链导法则乘出的那一坨又是个复数，自然得到的最终结果也是复数。 针对这个问题，可以提出两种解决办法： 一个很自然的想法是直接绕开Arg这个不可导的函数，即可以将通过ComplexExpand其转化为ArcTan形式，再去求导就不会有这些问题了： 123f[x_]=ComplexExpand[Arg[(-(x-1)^2+4 (4 x^3-3 x^2-x^4))/((x-1)^2+4 (4 x^3-3 x^2-x^4)-4*I*(x^3-3 x^2+2 x))],TargetFunctions-&gt;&#123;Re,Im&#125;];f'[5](*Out: 1117/10504*) 还可以反过来利用上述数值导数的坑来解决：因为这里就是要求f沿实轴方向的导数，所以我们不妨利用数值导数始终沿实轴发生这一特性，先从f上就避免符号计算引入错误的链导法则，然后直接让Mathematica对f进行数值求导，于是可以这么写： 1234Clear[f]f[x_?NumericQ]:=Arg[(-(x-1)^2+4 (4 x^3-3 x^2-x^4))/((x-1)^2+4 (4 x^3-3 x^2-x^4)-4*I*(x^3-3 x^2+2 x))]f'[5.](*Out: 0.10634*) 如果只需要近似的数值值得话，同样可以解决问题。 相关链接： 来个老哥抬一手~ Why does Arg’[1. + I] return -0.5?","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miRoox.github.io/blog/tags/踩坑/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"}]},{"title":"Mathematica写作自动化技巧","slug":"MmaAutoLiterature","date":"2019-04-07T14:45:31.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/04/MmaAutoLiterature/","link":"","permalink":"http://miRoox.github.io/blog/2019/04/MmaAutoLiterature/","excerpt":"在使用Mathematica的笔记本的过程中，我们常常希望将它的代码和文档功能结合起来，例如自动将符号计算的公式、图形以文档的书写习惯展示出来，同时隐藏生成代码，使文档显示自然协调。","text":"在使用Mathematica的笔记本的过程中，我们常常希望将它的代码和文档功能结合起来，例如自动将符号计算的公式、图形以文档的书写习惯展示出来，同时隐藏生成代码，使文档显示自然协调。 为了达到这一目的，首先需要的是将输入自动隐藏。我们知道，即使在自然状态下，双击输出单元的单元括号]即可隐藏输入单元。这一操作实际相当于选中输出单元后执行了前端令牌&quot;SelectionCloseUnselectedCells&quot;，因此，可以将其写作程序代码 12SelectionMove[EvaluationNotebook[],All,GeneratedCell];FrontEndTokenExecute[\"SelectionCloseUnselectedCells\"]; 在输入单元最后加入上述代码即可在执行后自动折叠隐藏输入单元。 不过，当我们需要展示公式时，我们往往希望使用DisplayFormula或者DisplayFormulaNumbered等公式样式。但直接使用CellPrint以此样式输出的话，则因为输入单元与输出的公式单元不会自动编组而无法通过上述方式折叠。所幸单元也支持应用多个样式，将公式样式与Output样式同时应用即可解决。例如： 123CellPrint[ExpressionCell[D[x^2,x],\"Output\",\"DisplayFormulaNumbered\"]];SelectionMove[EvaluationNotebook[],All,GeneratedCell];FrontEndTokenExecute[\"SelectionCloseUnselectedCells\"]; 我们也可以将这些功能都整合进样式表中，在CellEpilog中添加折叠单元代码，在GeneratedCellStyles中改变输出单元的样式。例如，我们可以通过在样式表中添加如下内容来自定义一个FormulaGenerator样式 123456Cell[StyleData[\"FormulaGenerator\", StyleDefinitions -&gt; StyleData[\"Input\"]], CellEpilog:&gt;(SelectionMove[ EvaluationNotebook[], All, GeneratedCell]; FrontEndTokenExecute[\"SelectionCloseUnselectedCells\"]), GeneratedCellStyles-&gt;&#123;\"Output\"-&gt;&#123;\"Output\", \"DisplayFormulaNumbered\"&#125;&#125;, MenuSortingValue-&gt;10000] 这样，使用FormulaGenerator样式的输入单元在计算后就会生成一个带标号的公式单元并自动隐藏起来。 参见： 隐藏笔记本的输入 How to Keep Input Cells Hidden After Evaluating Notebook How to set the output be generated in a cell different from “Output”","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"},{"name":"文学编程","slug":"文学编程","permalink":"http://miRoox.github.io/blog/tags/文学编程/"}]},{"title":"Mathematica通用工具包参考（一）：宏","slug":"WLGeneralUtilitiesMacro","date":"2019-02-27T15:00:13.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/02/WLGeneralUtilitiesMacro/","link":"","permalink":"http://miRoox.github.io/blog/2019/02/WLGeneralUtilitiesMacro/","excerpt":"GeneralUtilities` 是Mathematica从版本10开始新加入的一个上下文。其中提供了大量的实用函数，包括代码生成、调试、静态分析、迭代器对象等各个领域，一定程度上弥补了Mathematica基础设施不足的状况。 这个工具包内包含的函数十分繁杂，在当前版本11.3下，可以通过Names[&quot;GeneralUtilities`*&quot;]//Length看到其共包含了514个符号。这篇文章简单介绍与宏有关的部分。 “宏”在编程领域往往作为一种代码生成技术使用，例如在一些编译型语言中，宏展开往往发生在编译或预编译阶段。而在GeneralUtilities`的语境下，宏默认在定义时自动展开，同样也是一种代码生成技术。","text":"GeneralUtilities` 是Mathematica从版本10开始新加入的一个上下文。其中提供了大量的实用函数，包括代码生成、调试、静态分析、迭代器对象等各个领域，一定程度上弥补了Mathematica基础设施不足的状况。 这个工具包内包含的函数十分繁杂，在当前版本11.3下，可以通过Names[&quot;GeneralUtilities`*&quot;]//Length看到其共包含了514个符号。这篇文章简单介绍与宏有关的部分。 “宏”在编程领域往往作为一种代码生成技术使用，例如在一些编译型语言中，宏展开往往发生在编译或预编译阶段。而在GeneralUtilities`的语境下，宏默认在定义时自动展开，同样也是一种代码生成技术。 1Needs[\"GeneralUtilities`\"] 下面介绍GeneralUtilities`中的一些实用宏 Scope/ModuleScope 我们知道，Mathematica中的局部符号往往需要显式地引入，而不像很多语言在函数体内自动带有作用域。这在使用大量局部变量的时候会带来一些麻烦。而Scope给出了一个解决办法，它自动解析Scope[body]内部的赋值语句，提取与之相关联的符号自动局域化。通过?GeneralUtilities`Scope可以看到它的用法如下： Scope[body] is a macro that expands to a Block with automatically populated local variable list. Variables are detected syntactically by the presence of = and := within body. ^= and ^:= can be used to avoid this localization. {sym1,sym2,...} = rhs will localize sym1,sym2,.... sym := rhs will localize sym. Local functions definitions head[...] := rhs do not cause localizalization of head. 而且它作为一个宏，使用在定义中，则展开发生在定义阶段，从而可以避免调用时因解析和变换带来的额外开销。例如 123f[x_]:=Scope[a=x;b^=a;c:=a++;&#123;d,e&#125;=&#123;b,c&#125;;a]Definition[f](*Out[*]= f[x_]:=Block[&#123;a,c,d,e&#125;,a=x;b=a;c:=a++;&#123;d,e&#125;=&#123;b,c&#125;;a]*) 可以看到f的定义中，Scope已经转换成了Block作用域，并自动将需要局域化的符号按Block的规则列出了。 类似的，ModuleScope自动展开成Module作用域结构。 Memoized Memoized[body] specifies that body should be evaluted but cached so that subsequent calls with the same value for any bound symbol use the cached value. Memoized[body,Method-&gt;method] can be used, where method is one of {&quot;Association&quot;, &quot;Symbol&quot;, &quot;Inline&quot;, &quot;SystemCache&quot;}, to choose a specific caching method. 即所谓的记忆化手法，可以实现空间换时间的优化目的。例如对于Mathematica中一个比较经典的记忆化案例 123fib[0]=0;fib[1]=1;fib[n_]:=fib[n]=fib[n-1]+fib[n-2] 利用Memoized可以等价地写成 123fib[0]=0;fib[1]=1;fib[n_]:=Memoized[fib[n-1]+fib[n-2],Method-&gt;\"Inline\"] 除了&quot;Inline&quot;，Memoized还提供了其它几种记忆化的实现手段，包括默认的&quot;SystemCache&quot;、基于关联&quot;Association&quot;和面向符号的&quot;Symbol&quot;，这里不多赘述了。不过似乎目前的&quot;Symbol&quot;方法的实现有问题，无法应用于函数定义中。 SetupTeardown SetupTeardown[setup,body,teardown] evaluates setup, then body, and then teardown, even if an Abort or Throw occurs during evaluation. SetupTeardown是一个确保“初始化-主体-清理”执行顺序的封装，哪怕其中某部分中断或者抛出也会确保其余部分顺序进行。 举一个简单的例子 1f[]:=SetupTeardown[Print[\"setup\"],Print[\"before\"];Abort[];Print[\"after\"],Print[\"teardown\"]] 调用f[]，可以看到即使Abort[]中断计算后，依然继续进行了Print[&quot;teardown&quot;]的计算。 这个宏可以用于在计算流程中确保资源的获取和释放，不过实际在Mathematica中应用比较少。 Match/StringMatch Match[value,patt1:&gt;val1,patt2:&gt;val2,…,default] matches the value to the patti in turn and gives the corresponding vali, or evaluates default if none matched. Match[value,patts...,...] panics if none of the patts matched. Match[patts] is the operator form of Match. 长得像Rust的match，用法大抵类似Switch，实际只是Replace的一个封装。 StringMatch无非是StringReplace的一个封装。 CatchFailure/CatchFailureAsMessage CatchFailure[body] is a macro evaluates body, but returns a Failure[...] object if a ThrowFailure[...] occurred during evaluation. The current function is automatically used as the message head. CatchFailure[head,body] explicitly uses head as the message head for the failure message. CatchFailureAsMessage[body] is a macro evaluates body, but issues a message if a ThrowFailure[...] occurred during evaluation. The current function is automatically used as the message head. CatchFailureAsMessage[head,body] explicitly uses head as the message head for the failure message. 需要配合ThrowFailure一起使用，语义比较清晰的错误捕获。 UnpackAssociation/UnpackOptions UnpackAssociation[assoc,“Name1”,“Name2”,…] extracts the given keys from the association and sets variables named Namei. UnpackAssociation[assoc,symbol1,symbol2,…] uppercases the first letter of the symbol name to get the key. UnpackAssociation[assoc,symbol1:“Name1”,…] gives an explicit name for each symbol. UnpackOptions[sym1,sym2,…] extracts options with names “Sym1”, “Sym1”, … and assigns them to the symi, where the keys are the title cased version of the symbol names. 用法说明已经介绍得比较详细了，下面给一个简单的用例 1234Options[f] = &#123;\"A\" -&gt; 1, \"Op\" -&gt; 2&#125;;f[OptionsPattern[]]:=Scope[UnpackOptions[a,op];&#123;a,op&#125;]&#123;f[], f[\"A\" -&gt; 17], f[\"Op\" -&gt; 18], f[\"A\" -&gt; 16, \"Op\" -&gt; 19]&#125;(*Out[*]= &#123;&#123;1,2&#125;,&#123;17,2&#125;,&#123;1,18&#125;,&#123;16,19&#125;&#125;*) CollectTo CollectTo需要配合BagInsert使用，实际是Internal`Bag相关函数的封装，目前来看意义不大，不过这个宏没有用法说明，也可能尚未完善。 根据定义，可以大致推测CollectTo[{x,y,...},body]可以通过在body部分使用BagInsert[x,val]或者BagInsert[x,val,index]的方式高效地将val添加或插入到动态列表x中。 下面给一个简单的用例说明一下用法 123f1[n_]:=Scope[CollectTo[&#123;x&#125;,Do[BagInsert[x,i],&#123;i,n&#125;]];x]f2[n_]:=Scope[x=&#123;&#125;;Do[AppendTo[x,i],&#123;i,n&#125;];x]BenchmarkPlot[&#123;f1,f2&#125;,Identity] 我的电脑上给出的结果为： 可以看到Bag的添加效率基本是普通列表的好几倍。 DoWhile DoWhile[body,test]就像C语言之类的一样，先计算body，再计算test并决定是否循环， 实际上就等价于While[body;test]。 Excise Excise[args...] evaluates to an empty sequence, effectively removing its arguments without evaluation. 个人认为没什么用，注释可以做到同样的事，甚至用途更广（Excise只能在使用宏的情况下工作）。 UseMacros UseMacros[body] does nothing more than trigger macro expansion, use it if you want to use macros in a function but don’t need Scope. 在不了解GeneralUtilities`中宏的作用机理的情况下，这个宏的作用可能会令人困惑。事实上，在默认条件下，上述各种宏的自动展开只会发生在赋值等号右边的最外层使用了宏的时候发生。这一事实可以在上述各种的定义中一窥究竟，以Scope为例 123Scope /: HoldPattern[s:Set[_, _Scope]] := MacroEvaluate @ s;Scope /: HoldPattern[sd:SetDelayed[_, _Scope]] := MacroEvaluate @ sd;Scope /: HoldPattern[tsd:TagSetDelayed[_, _, _Scope]] := MacroEvaluate @ tsd; 同样，UseMacros位于赋值等号右边的最外层时会触发宏自动展开，从而可以解决在内层使用宏无法展开的问题。 GeneralUtilities`除了提供上述宏之外，还提供了一些计算和生成宏的辅助工具。 Quoted Quoted[code] is the inert body of code for the purposes of macro expansion. 一个代码封装，作用基本和HoldComplete一样，不过使用了一个漂亮的方式输出显示代码。 在宏的实现中大量使用。 MacroExpand/MacroExpandList MacroExpand[expr] evaluates all macros present in expr and returns the result in a Quoted expression. Anywhere in a macro, ' can be used to inject EchoRaw calls, '' to inject EchoHold calls, and ''' to wrap a function in Tap. MacroExpandList[expr] expands all macros that occur in expr, returning a list of Quoted expressions that give the intermediate results after each expansion step. MacroExpand展开宏，但是不计算，可以用来预览宏使用的效果。而MacroExpandList列出展开宏的每一步。 MacroEvaluate MacroEvaluate[expr] evaluates all macros present in expr and then evaluates the result. 展开宏并计算。 可以尝试令$Pre=MacroEvaluate，这样每次计算都会尝试展开宏，从而也就不需要UseMacros来触发展开了。 MacroRules MacroRules[symbol] gives all the macro application rules associated with the head symbol. 可以通过PrintDefinitions[MacroRules]hack得到已定义的函数宏和变换规则。 DefineLiteralMacro/DefineMacro/DefineAlias DefineLiteralMacro[symbol,lhs:=rhs,...] defines a literal macro such that when lhs it is substituted for rhs without evaluation. The same replacement is attached to symbol for use outside a macro context. DefineAlias[newsymbol,oldsymbol] does what it says on the tin. 这三者都用来实现自定义宏，但使用和效果上略有不同： DefineLiteralMacro[symbol,lhs:=rhs,...] 定义的是一个字面宏，在替换展开的过程中并不会计算rhs。 DefineMacro[symbol,lhs:=rhs,...] 定义的宏则会在展开时计算rhs。 DefineAlias[newsymbol,oldsymbol] 定义符号的别名，只对符号有效，而且其展开发生在其它宏展开之前。 尝试下面的例子以便更直观地认识到这三者间的联系和区别： 123456789DefineMacro[fac1, fac1[x_]:=x!];DefineLiteralMacro[fac2, fac2[x_]:=x!];DefineAlias[fac3, Factorial];MacroExpand[fac1[3]]MacroExpand[fac2[3]]MacroExpand[fac3[3]]MacroExpand[fac2[]]MacroExpand[fac3[]]","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"参考","slug":"参考","permalink":"http://miRoox.github.io/blog/tags/参考/"},{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"},{"name":"Undocumented","slug":"Undocumented","permalink":"http://miRoox.github.io/blog/tags/Undocumented/"}]},{"title":"在Wolfram语言中模拟指针语义","slug":"PointerInWolfram","date":"2019-01-18T15:15:37.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/01/PointerInWolfram/","link":"","permalink":"http://miRoox.github.io/blog/2019/01/PointerInWolfram/","excerpt":"背景和问题的引入 众所周知，Wolfram语言作为一个极为“高级”的编程语言，并没有提供指针这类较为底层的内存管理手段。而符号本身几乎总是充当了类似引用的作用，比如 1234set[sym_Symbol]:=sym=1b=a;set[b];a 可以看到符号a的值通过set[b]赋为了1。在这里b形式上充当了类似其它语言中的引用的作用。但这种方式并不通用，只要a已经具有值了，这种平凡的方式就不能起作用了。有的读者可能会想到:=或者Hold封装，不过单靠这些也不能简单地对已具有本值的符号进行修改。因此，本文试图提出一种具有类似其它语言中指针语义的封装，实现对符号的间接操作。","text":"背景和问题的引入 众所周知，Wolfram语言作为一个极为“高级”的编程语言，并没有提供指针这类较为底层的内存管理手段。而符号本身几乎总是充当了类似引用的作用，比如 1234set[sym_Symbol]:=sym=1b=a;set[b];a 可以看到符号a的值通过set[b]赋为了1。在这里b形式上充当了类似其它语言中的引用的作用。但这种方式并不通用，只要a已经具有值了，这种平凡的方式就不能起作用了。有的读者可能会想到:=或者Hold封装，不过单靠这些也不能简单地对已具有本值的符号进行修改。因此，本文试图提出一种具有类似其它语言中指针语义的封装，实现对符号的间接操作。 预期的目标 这里想实现一种具有类似C语言用法的指针（引用）封装。当然，由于Mathematica没有直接访问内存的手法，所有引用都是针对符号展开的。具体而言，应该可以实现下面的效果： 解引用： 123a=1;b=ref[a];deref@b 得到1； 左值语义： 1234a=1;b=ref[a];deref@b=2;a 得到2； 更复杂的左值： 1234a=&#123;1,2,3&#125;;b=ref[a];deref[b][[2]]=4;a 得到{1,4,3}； 多重引用： 12345a=1;b=ref[a];c=ref[b];deref@deref@c=2;a 得到2。 这里只是举几个例子，文章毕竟不是测试集，也就不再赘述。 当然，我们希望能更接近C语言指针的语义。在这里，ref相当于C语言中的&amp;单目运算符，而deref则相当于C语言的*单目运算符。 思路与实现 考虑我们需要保有符号，才可能对符号进行引用，因此首先ref必须具有HoldFirst属性。然后deref能在计算时解引用，也就是 1deref[ref[sym_]] := sym 然后我们需要重载Set以获得左值语义。由于deref可能出现在很深的层次中，单靠TagSetDelayed不能覆盖重载的各种情况。但需要重载的情况必定含有deref，因此可以利用条件模式决定重载策略 123Unprotect[Set];Set[lhs_, rhs_] /; MemberQ[Unevaluated[lhs], _deref, &#123;0, Infinity&#125;] := &lt;&lt;具体实现&gt;&gt;Protect[Set]; 由于引用在这里总是保有着符号，因此左值语义在这里更类似一个宏展开，将=左侧的所有直接或隐含的deref[ref[sym]]结构展开成对应的sym。为了达到这个目的，首先需要保护=的左侧不进行计算，这里只需要一个简单的Hold封装即可。然后上面的所说的“宏展开”细节上应该分两步进行： 一是将“隐含”转换为“显含”：直观上来说，可能大家会写成这样的替换规则：deref[r_]:&gt;deref[Evaluate[r]]，但这是不对的。由于Hold封装的存在，需要用到一个名为Trott-Strzebonski的技巧，而且由于前面已经定义了deref[ref[sym_]]:=sym，因此这里必须借助Block局部地清除这个定义才行，另一方面，为了处理多重引用，还需要排除deref[deref[xxx]]这种模式被直接展开。 二是对显式结构进行替换：这部分比较简单，直接使用deref@ref[sym_Symbol]:&gt;sym即可。同样也是因为Hold封装的存在，符号sym即使有本值也不会计算。 最后将展开的结果还原为赋值表达式即可。 综合一下，我们可以得到一个比较完整的代码 12345678910111213SetAttributes[ref, HoldFirst]deref[ref[sym_]] := symUnprotect[Set];Set[lhs_, rhs_] /; MemberQ[Unevaluated[lhs], _deref, &#123;0, Infinity&#125;] := With[&#123; lhs1 = Block[&#123;deref&#125;, Hold[lhs] //. &#123; deref@ref[sym_Symbol] :&gt; sym, deref[r : Except[_deref]] :&gt; With[&#123;eval = deref[r]&#125;, eval /; True] (*Trott-Strzebonski*) &#125;]&#125;, Replace[Hold[Set[lhs1, rhs]], Hold[Set[Hold[lhs2_], rhs2_]] :&gt; Set[lhs2, rhs2]] ]Protect[Set]; 当然，对于一个真正实用的模块而言，还需要一些诸如错误处理之类的细节，但如果只考虑正确使用的话，实现指针语义的核心部分都已经列在这里了。一个相对实用的版本可以在 https://github.com/miRoox/LValueRef 找到。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"功能模拟","slug":"功能模拟","permalink":"http://miRoox.github.io/blog/tags/功能模拟/"},{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"}]},{"title":"Mathematica黑魔法：符号沙盒","slug":"SymbolSandbox","date":"2019-01-17T15:02:13.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/01/SymbolSandbox/","link":"","permalink":"http://miRoox.github.io/blog/2019/01/SymbolSandbox/","excerpt":"问题的引入 ValueQ是Matheamtica中的一个非常有趣的函数，它判断一个表达式是否会进行求值，而且这种判断有时可以做到无副作用，哪怕求值本身是具有副作用的。比如 1234x=0;y:=++xv=ValueQ[y];&#123;v,x&#125; 会得到{True,0}的结果。这里的ValueQ[y]显然并没有真正对y求值就作出了判断。不过很遗憾的是这其中哪怕只有略微的改动也会使其作用发生变化，例如 1234x=0;y:=++xv=ValueQ[y+0];&#123;v,x&#125; 则会得到{True,1}。","text":"问题的引入 ValueQ是Matheamtica中的一个非常有趣的函数，它判断一个表达式是否会进行求值，而且这种判断有时可以做到无副作用，哪怕求值本身是具有副作用的。比如 1234x=0;y:=++xv=ValueQ[y];&#123;v,x&#125; 会得到{True,0}的结果。这里的ValueQ[y]显然并没有真正对y求值就作出了判断。不过很遗憾的是这其中哪怕只有略微的改动也会使其作用发生变化，例如 1234x=0;y:=++xv=ValueQ[y+0];&#123;v,x&#125; 则会得到{True,1}。 具有值集知识的读者可能很容易猜想ValueQ可能具有类似下面的实现 123Attributes[ValueQ] = &#123;HoldAll, Protected, ReadProtected&#125;ValueQ[sym_Symbol]:=Hold[sym]=!=Hold[sym]/.OwnValues[sym]ValueQ[expr_]:=Unevaluated[expr]=!=expr 因而具有上面那样的行为也是可以理解的。 不过这种不一致性总归让人觉得别扭，尽管这种不一致性本质上来源于Wolfram语言求值策略的复杂性，尤其是Condition的灵活性，使得上面这种策略注定无法真正消除副作用。哪怕是现在这种状况，我们依然可以让ValueQ对符号作用时产生副作用， 例如 1234x=0;y:=With[&#123;e=++x&#125;, e/;True]v=ValueQ[y];&#123;v,x&#125; 也会得到{True,1}。这里用到的技巧叫Trott-Strzebonski，是一种常用的元编程技巧，不过这里不做赘述，对于理解Condition的工作方式的读者想必并不复杂。 因此，这里想介绍另一种消去副作用的思路，也就是所谓的“符号沙盒”。 思路与实现 如果说ValueQ的思路是尽可能避免求值来消去副作用的话，那么接下来的处理方式则是尽可能将副作用局域化，就好像在沙盒环境中一样。而这也正是标题由来。 事实上，Block动态作用域就具有类似的效果。不过直接使用Block的话则略显繁琐，我们希望有一个能自动分析需要局域化的符号并且能继承既有定义的动态作用域。幸运的是，Mathematica中既有的函数足以覆盖我们的需求：Internal`EmbeddedSymbols和Internal`InheritedBlock。尽管这两者都是没有文档的“内部函数”，不过通过测试和分析可以推测他们的功能： Internal`EmbeddedSymbols：可以获取一个表达式所有直接或间接使用的符号 Internal`InheritedBlock：继承符号既有定义的动态作用域 组合这两者不难得到 12345678SetAttributes[&#123;embeddedUserSymbols,symbolSandbox&#125;,HoldFirst]embeddedUserSymbols[expr_]:= Select[Internal`EmbeddedSymbols[expr], Function[sym,ContainsNone[Attributes[sym],&#123;Locked,Protected&#125;],HoldAll] ]/. &#123;Hold[syms___]:&gt;Hold[&#123;syms&#125;]&#125;symbolSandbox[expr_]:=With[&#123;syms=Unevaluated@@embeddedUserSymbols[expr]&#125;, Internal`InheritedBlock[syms,expr] ] 这里需要注意的是Internal`EmbeddedSymbols获得的符号不能全部局域化，因此加入了Select滤过具有Locked和Protected属性的符号。 然后我们可以给出一个更“安全”的ValueQ 12SetAttributes[valueQ,HoldFirst]valueQ[expr_]:=Unevaluated[expr]=!=symbolSandbox[expr] 此时 1234x=0;y:=++xv=valueQ[y+0];&#123;v,x&#125; 会给出{True, 0}的结果，x因对y的求值而产生的改变被限制在valueQ的计算过程中。 不过这种局域化仅限于符号，并不能限制诸如文件IO等其它方式的副作用，因此只能叫“符号沙盒”。 补充： 经过更多测试，发现Internal`EmbeddedSymbols似乎有不太稳定，有时会导致内核崩溃，而且似乎不能完全获取有关的符号。这部分可能有待改进。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"},{"name":"Undocumented","slug":"Undocumented","permalink":"http://miRoox.github.io/blog/tags/Undocumented/"}]},{"title":"Mathematica下标赋值问题补遗","slug":"SubcriptInMma-Addendum","date":"2019-01-16T06:55:47.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2019/01/SubcriptInMma-Addendum/","link":"","permalink":"http://miRoox.github.io/blog/2019/01/SubcriptInMma-Addendum/","excerpt":"我曾经写过一篇关于Mathematica中下标与赋值问题的文章，不过那篇文章重点解决的是符号关联的问题。但有时，我们可能会遇到另一种问题，比如","text":"我曾经写过一篇关于Mathematica中下标与赋值问题的文章，不过那篇文章重点解决的是符号关联的问题。但有时，我们可能会遇到另一种问题，比如 也就是定义了符号的本值之后又想定义带有同样符号的下标值。当然，我们是不推荐这么写的，这会使符号的含义很含混。 不过单从实用的角度考虑，让上面的代码正常工作并不困难，只需要对Subscript添加HoldFirst属性即可。 1SetAttributes[Subscript,HoldFirst]","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miRoox.github.io/blog/tags/踩坑/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"}]},{"title":"突然发现部分Wolfram演示项目支持在线运行了","slug":"WolframOnlineDemo","date":"2018-12-01T12:09:39.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2018/12/WolframOnlineDemo/","link":"","permalink":"http://miRoox.github.io/blog/2018/12/WolframOnlineDemo/","excerpt":"如题，已经有部分Wolfram演示项目支持在线运行，尽管这个功能貌似还在测试中。","text":"如题，已经有部分Wolfram演示项目支持在线运行，尽管这个功能貌似还在测试中。 甚至还支持以内联框架的形式嵌入网页。比如下面这个例子就来自 https://demonstrations.wolfram.com/FraunhoferDiffractionThroughARectangularAperture。 不过这个在线运行机制似乎是基于 Wolfram Cloud 实现的，而不是 Web Assembly 之类的本地计算，因此响应速度会有点慢。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"}]},{"title":"解决CurrentValue等动态刷新无法控制的问题","slug":"FixCurrentValueRefresh","date":"2018-11-28T15:09:13.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2018/11/FixCurrentValueRefresh/","link":"","permalink":"http://miRoox.github.io/blog/2018/11/FixCurrentValueRefresh/","excerpt":"All problems in computer science can be solved by another level of indirection. [1] 最近在拿Mathematica做一些小东西的时候发现CurrentValue等函数在动态中刷新不受Refresh等方式影响。比如 1Dynamic[Refresh[CurrentValue[\"MousePosition\"], None]] 输出会不断刷新，并不受Refresh[□, None]结构控制。","text":"All problems in computer science can be solved by another level of indirection. [1] 最近在拿Mathematica做一些小东西的时候发现CurrentValue等函数在动态中刷新不受Refresh等方式影响。比如 1Dynamic[Refresh[CurrentValue[\"MousePosition\"], None]] 输出会不断刷新，并不受Refresh[□, None]结构控制。 另一方面，同样被设计为“过分敏感”的Clock则受Refresh控制， 1Dynamic[Refresh[Clock[]], None]] 其输出则不会更新。 鉴于文档中并没有提到过这个问题，我个人认为这是一个bug。不过几个Current开头的函数都有这个问题，包括CurrentImage、CurrentNotebookImage、CurrentScreenImage，或许这其实是这类函数的一个feature也说不定。然而，出于某些应用场合的需求，我希望这些函数能像其它动态一样受控，这篇文章也因此而来。 当然，前面的例子太过“平凡”了，直接使用静态输出就没有那么多事了。如果我们考虑一个定时刷新的光标位置，那么按照一般的写法，可能写成 1Dynamic[CurrentValue[\"MousePosition\"], UpdateInterval -&gt; 1] 但正如前面指出的，上面这段代码并不能正常地工作。要解决这个问题，实际要引入一个受控的中间层，来间接表示CurrentValue[&quot;MousePosition&quot;]。正如文档中所提到的，通过组合TrackedSymbols和UpdateInterval，我们可以精确控制只受符号变化影响的动态更新。再借助DynamicWrapper同步受控符号与CurrentValue表达式即可。最终我们得到 123456DynamicModule[&#123;p&#125;, DynamicWrapper[ Dynamic[p, UpdateInterval -&gt; 1, TrackedSymbols :&gt; &#123;&#125;], p = CurrentValue[\"MousePosition\"] ]] 至此，CurrentValue等动态刷新无法控制的问题圆满解决。 2019年1月22日补充： 这大概确实是一个bug，在SE上的这个问题中作者表示已经将这一情况向Wolfram公司提出了。 https://www2.dmst.aueb.gr/dds/pubs/inbook/beautiful_code/html/Spi07g.html ↩︎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miRoox.github.io/blog/tags/踩坑/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"}]},{"title":"如何方便快捷地查看Mathematica中的符号定义？","slug":"PrintDefinitions","date":"2018-10-07T05:50:12.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2018/10/PrintDefinitions/","link":"","permalink":"http://miRoox.github.io/blog/2018/10/PrintDefinitions/","excerpt":"使用 1GeneralUtilities`PrintDefinitions[symbol] 即可，如下图","text":"使用 1GeneralUtilities`PrintDefinitions[symbol] 即可，如下图 不过就这么结束了好像也不太好，再补充几点： 生成的笔记本文档中的符号可以通过点击打开其定义，就好像许多其它语言的IDE中的“Jump to Definition”功能一样。 有许多内置函数的定义是看不到的，因为它们的实现可能不是通过Wolfram语言完成的。这时你可能只能看到&lt;&lt;kernel function&gt;&gt;的字样。 有些包里的符号可能没有预先加载，也许在第一次调用的时候只会得到一个空的笔记本，这时，你可能需要再运行一次才能得到正确的结果。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"}]},{"title":"Mathematica下标与导数赋值问题的解决方法","slug":"SubscriptAndDerivateInMma","date":"2018-08-23T07:22:43.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2018/08/SubscriptAndDerivateInMma/","link":"","permalink":"http://miRoox.github.io/blog/2018/08/SubscriptAndDerivateInMma/","excerpt":"众所周知，Mathematica中虽然使用下标形式非常方便，但如果对下标结构进行直接赋值，它将关联到内部符号Subscript上。这样，在我们大量清理符号定义的时候可能会漏掉一些定义。类似地，导数Derivative有同样的问题，比如对于 1f'=df 使用 12Clear[f]Clear[\"`*\"] 并不能清除f'的定义。","text":"众所周知，Mathematica中虽然使用下标形式非常方便，但如果对下标结构进行直接赋值，它将关联到内部符号Subscript上。这样，在我们大量清理符号定义的时候可能会漏掉一些定义。类似地，导数Derivative有同样的问题，比如对于 1f'=df 使用 12Clear[f]Clear[\"`*\"] 并不能清除f'的定义。 虽说将直接赋值改为用UpSet或者TagSet替代可以将赋值关联到符号f上而不是别的，比如下面的代码。 1f/:f'=df 但每次多打一些东西总归是不方便，我们总会想找一个一劳永逸的办法。 官方文档中提到的对数量值的处理给了我启发。 在Wolfram语言中，数量值的处理与上值类似，当定义了f的数量值以后，Wolfram语言就象求值运算N中f的上值一样来输入这一定义. 下标的情况相对比较容易处理，类似an的结构在Wolfram语言中实质就是Subscript[a,n]，我们只要把普通的赋值转化为TagSet即可，就如下面的代码所示 1234Subscript /: Set[Subscript[a_Symbol, rest__], val_] := TagSet[a, Subscript[a, rest], val]Subscript /: SetDelayed[Subscript[a_Symbol, rest__], val_] := TagSetDelayed[a, Subscript[a, rest], val] Derivative的情况相对要复杂一些，因为即使看上去非常简单的f'[x]在Wolfram语言内部也会表示为Derivative[1][f][x]，我们认为的主要符号f在这个表达式中层次太深，无法直接将TagSet应用在上面，因此只能采取一些迂回的办法。 值得庆幸的是，Mathematica也支持纯函数式的导数，例如Sin'会得到Cos[#1]&amp;。而在Derivative[1][f]结构中，f是可以通过TagSet赋予上值的。对于这种情况，采用和前面类似的方法就能解决。 1234Derivative /: Set[Derivative[ns__Integer][f_Symbol], val_] := TagSet[f, Derivative[ns][f], val]Derivative /: SetDelayed[Derivative[ns__Integer][f_Symbol], val_] := TagSetDelayed[f, Derivative[ns][f], val] 而对于类似Derivative[1][f][x]的情况，虽然我们无法直接对其使用TagSet，但我们可以考虑将其转换为纯函数的情况。 动手前先分析，例如f'[x_]:=x我们希望将其转换为f':=Function[{x},x]，为了达到这个目的，需要去掉原本赋值中的模式结构:_。 我们知道，像x_的完整形式是Pattern[x,Blanck[]]。因此，提取x_的x只要将其第一部分提取出来即可。综合一下可以写成如下的代码 123456Derivative /: Set[Derivative[ns__Integer][f_Symbol][args__Pattern], val_] := Set[Derivative[ns][f], Evaluate[First /@ &#123;args&#125;] \\[Function] val]Derivative /: SetDelayed[Derivative[ns__Integer][f_Symbol][args__Pattern], val_] := Set[Derivative[ns][f], Evaluate[First /@ &#123;args&#125;] \\[Function] val] 其中，Evaluate是为了解决Function的HoldAll属性的。 除此之外，还有一点值得注意。像Derivative[1]和Derivative[1,0]是不同的，Derivative的参数个数应该与被求导函数的参数个数匹配。 考虑了这个问题后，可以将上面的代码改成下面这样，以避免出现类似f'[x_,y_]:=df[x,y]错误形式。 12345678910Derivative /: Set[Derivative[ns__Integer][f_Symbol][x__Pattern], val_] := If[Length@&#123;ns&#125; == Length@&#123;x&#125;, Set[Derivative[ns][f], Evaluate[First /@ &#123;x&#125;] \\[Function] val], $Failed]Derivative /: SetDelayed[Derivative[ns__Integer][f_Symbol][x__Pattern], val_] := If[Length@&#123;ns&#125; == Length@&#123;x&#125;, Set[Derivative[ns][f], Evaluate[First /@ &#123;x&#125;] \\[Function] val], $Failed] 当然，这种方法不能应对类似f'[1]=0这样的单点导数赋值。但这种基于模式的单点导数定义本身也不是很合适的做法，比如 123f'[1]=0;f'[x_]:=xD[f[x],x] 其结果是无法体现出f'[1]=0的。 因此对于一个函数的某阶导数，应该避免重载。如果有需要，也应该使用Piecewise之类的手段整合成一个函数。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miRoox.github.io/blog/tags/踩坑/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"}]},{"title":"Mathematica程序包的中文与Unicode处理","slug":"UnicodeCharInMmaPackage","date":"2018-08-08T04:28:23.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2018/08/UnicodeCharInMmaPackage/","link":"","permalink":"http://miRoox.github.io/blog/2018/08/UnicodeCharInMmaPackage/","excerpt":"Mathematica在处理字符时默认总会将所有字符转换为ASCII字符表示，例如π会转化为\\[Pi]，而像汉字仪这样的一般字符会转化为\\:4eea。 这种设计固然可以避免某些环境对非ASCII字符不支持的困难，而且在Mathematica环境下会自动转换成原本的字符，但对于一般的文本阅读环境而言，尤其是在代码中使用一些中文文本或者注释时，这样的内容阅读起来根本无法理解。 为了方便在没有Mathematica的环境下也能方便的阅读程序包中的非ASCII的一般字符，下面脚本提供了将\\:nnnn形式的转义序列转换为UTF-8编码下对应的Unicode字符的简单方法","text":"Mathematica在处理字符时默认总会将所有字符转换为ASCII字符表示，例如π会转化为\\[Pi]，而像汉字仪这样的一般字符会转化为\\:4eea。 这种设计固然可以避免某些环境对非ASCII字符不支持的困难，而且在Mathematica环境下会自动转换成原本的字符，但对于一般的文本阅读环境而言，尤其是在代码中使用一些中文文本或者注释时，这样的内容阅读起来根本无法理解。 为了方便在没有Mathematica的环境下也能方便的阅读程序包中的非ASCII的一般字符，下面脚本提供了将\\:nnnn形式的转义序列转换为UTF-8编码下对应的Unicode字符的简单方法 123456#!/usr/bin/env wolframscriptfileName=Last[$ScriptCommandLine];in=Import[fileName,\"Text\"];out=StringReplace[in,(\"\\\\:\"~~(n:Repeated[HexadecimalCharacter,&#123;4&#125;])):&gt;FromCharacterCode[FromDigits[n,16],\"UTF-8\"]];Export[fileName,out,\"Text\",CharacterEncoding-&gt;\"UTF-8\"]; 经过处理的文件用Mathematica也可以正常打开显示，只是每次保存时又会重新使用转义序列表示非ASCII字符，因而每次修改都应该重新运行脚本。 对于程序包，如果在代码正文中也使用了中文等非ASCII字符的话，在使用Get等方式导入包时，可能需要添加选项CharacterEncoding-&gt;&quot;UTF-8&quot;才能正确地显示其中的内容。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miRoox.github.io/blog/tags/踩坑/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"}]},{"title":"Wolfram语言中的作用域结构","slug":"ScopeInWolframLang","date":"2018-08-06T03:06:12.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2018/08/ScopeInWolframLang/","link":"","permalink":"http://miRoox.github.io/blog/2018/08/ScopeInWolframLang/","excerpt":"Wolfram语言中的作用域结构主要有如下5种: Module Block With DynamicModule 命名空间","text":"Wolfram语言中的作用域结构主要有如下5种: Module Block With DynamicModule 命名空间 Module 按照文档中的说法，Module提供变量的词法(lexical)定界。它使范围内的变量具有类似C语言中局部变量的行为。 然而，和C语言等不同，Wolfram语言没有对变量的名称和对象的区分，同样的名称总是用于指代同一变量。因此，Module在创建局部变量时，实际是创建新的符号并进行替换，比如运行下面的代码： 1Module[&#123;x&#125;, x] 从输出结果中可以看到形如x$nnn的局部变量。 正如前面提到的，Module提供的是变量的词法定界。因此，只有显式出现在作用域中的变量会被局部化。偶尔，这可能带来一些意想不到的结果。典型地，下面的代码 12m = i^2;Module[&#123;i = a&#125;, i + m] 会输出a+i2。 为了有效地实现定界，Module创建的变量都有Temporary属性来控制变量的生存期。它采用类似引用计数的方式来考察一个变量是否还在使用，并决定是否要将变量移除。因此，我们基本不需要考虑可能的变量冲突。 12Module[&#123;x&#125;, Print[x]; Attributes[x]]Names[\"x*\"] 多数时候，我们可能喜欢使用Module，因为它确实会如我们期望地那样创建新的变量。但它毕竟不是万能的，只有始终明确它的含义和适用的场合，才能保证正确地使用它。 思考题1： 下面的程序会输出什么？ 123456x = 1;Module[&#123;x = 2&#125;, Print[x]; Print[Symbol[\"x\"]];]Print[x] 延伸阅读： 模块和局部变量、模块工作方式 Block 与Module不同，Block提供变量的动态定界。它不产生新的变量，只是在作用域内临时地修改变量的值。因此，前面的例子如果用Block改写 12m = i^2;Block[&#123;i = a&#125;, i + m] 则会输出a+a2。 基于这种特性，Block经常被用在将副作用局域化的场合。 比如，局部地进行深度递归 1234cl[1] = 1;cl[n_Integer?EvenQ] := cl[n/2] + 1cl[n_Integer?OddQ] := cl[3 n + 1] + 1Block[&#123;$RecursionLimit = Infinity&#125;, cl[9780657630]] 又比如，局部地清除值 12x = 0;Block[&#123;x&#125;, Print[Expand[(1 + x)^3]]] 值得注意的是，上面使用了Print直接输出来避免从Block返回的值再被计算。如果普通地从Block返回值，则其中的表达式会由于x=0而重新计算，从而输出1。利用Trace我们可以看到这其中的过程 12x = 0;Block[&#123;x&#125;, Expand[(1 + x)^3]] // Trace // Column 12345678Block[&#123;x&#125;,Expand[(1+x)^3]]&#123;Expand[(1+x)^3],1+3 x+3 x^2+x^3&#125;1+3 x+3 x^2+x^3&#123;&#123;x,0&#125;,3 0,0&#125;&#123;&#123;&#123;x,0&#125;,0^2,0&#125;,3 0,0&#125;&#123;&#123;x,0&#125;,0^3,0&#125;1+0+0+01 Block虽然很便利，但“成也动态定界败也动态定界”，它所带来副作用往往不是显然的，更容易引入一些潜在的错误。另一点值得注意的是，像Table、Plot之类的函数在运算时使用与Block相同的方式局部化变量的值。这意味着使用这些函数时必须同使用Block一样小心 123f[x_] := i*xTable[f[i], &#123;i, 5&#125;]Table[f[j], &#123;j, 5&#125;] 123&#123;1, 4, 9, 16, 25&#125;&#123;i, 2 i, 3 i, 4 i, 5 i&#125; 另一方面，这个特性在使用EvaluationMonitor之类的监视器时会带来很大的方便。比如下面的代码可以直接追踪出求根过程中的步骤 1FindRoot[x^2 - 2, &#123;x, 1&#125;, EvaluationMonitor :&gt; Print[\"x=\", x, \" Bias:\", Abs[x^2 - 2]]] 思考题2： 下面的程序会输出什么？与Module时的情况进行比较。 123456x = 1;Block[&#123;x = 2&#125;, Print[x]; Print[Symbol[\"x\"]];]Print[x] 延伸阅读： 块与模块的比较、块和局部值 With With的目的是实现局部常量，但它实质上不过是一个替换罢了。在大多数情况下 1With[&#123;x = x0, y = y0&#125;, expr] 等价于 1Unevaluated[expr] /. &#123;HoldPattern[x] -&gt; x0, HoldPattern[y] -&gt; y0&#125; 可以看到，With并不会创建变量，相反，在替换的过程中往往还会减少变量。这个性质往往非常有用。比如，它可以把值插入到保持(held)表达式中： 1Table[With[&#123;i = i&#125;, Hold[i]], &#123;i, 5&#125;] 输出为 1&#123;Hold[1], Hold[2], Hold[3], Hold[4], Hold[5]&#125; 但如果不借助With传递一下的话 1Table[Hold[i], &#123;i, 5&#125;] 输出结果则会是 1&#123;Hold[i], Hold[i], Hold[i], Hold[i], Hold[i]&#125; 在下面的延伸阅读中的“How To”主题里，可以看到有关这种性质更实际的用法。 思考题3： 下面的程序会输出什么？ 12345With[&#123;x = y&#125;, x = 1; Evaluate[Symbol[\"x\"]] = 2;]&lt;|\"x\" -&gt; x, \"y\" -&gt; y|&gt; 思考题4： 前面提到With可以将值插入保持表达式，考虑如果将With替换为Module或者Block是否能实现同样的效果？为什么？ 思考题5： 前面提到，大多数情况下，With可以等价于一个替换。那么，在什么情况下不能简单地进行替换？比较下面两段程序，思考造成差异的原因， 并考虑With的适用范围。 1With[&#123;y = x + a&#125;, Function[&#123;x&#125;, x + y]] 1Unevaluated[Function[&#123;x&#125;, x + y]] /. &#123;HoldPattern[y] -&gt; x + a&#125; 延伸阅读： 局部常量、How To | 在 Dynamic 或 Manipulate 内部计算表达式、纯函数和规则中的变量 DynamicModule 与Module类似，DynamicModule也建立变量的词法作用域，但两者又有不同：如果说Module将变量局域在一个时间段的话，那么DynamicModule将变量局域在其输出的一个空间区域上。而为了实现这一点，Module对变量的局域化发生在内核中，而DynamicModule对变量的局域化发生在前端。这也可以通过运行下面两段代码验证 1Module[&#123;x&#125;, Slider[Dynamic[x]]] // FullForm 1DynamicModule[&#123;x&#125;, Slider[Dynamic[x]]] // FullForm 从输出结果中可以看到DynamicModule在内核中是以不计算的方式保持着原本的形式，实际上DynamicModule在前端产生一个DynamicModuleBox的框符结构，它虽然不会像ButtonBox或者RowBox之类的显示成一个控件或者布局，但前端会根据它来对内部的变量局域化。 1DynamicModule[&#123;x&#125;, Slider[Dynamic[x]]] 复制上面代码的输出，在后面加上 //ToBoxes 并计算，得到其框符表示。滑动滑动条，再次计算，可以看到滑动条的值其实是由DynamicModuleBox结构所记录的。这也正是DynamicModule内的状态能保存在文件中，并在跨越不同的内核会话时保持一致的原因。 相对地，Module就没有这个能力，比如下面这段代码 1Module[&#123;x&#125;, Slider[Dynamic[x]]] 由其得到的滑动条，随意滑动一下，如果关闭文件并退出内核的话，再次打开文件它会回到初始的位置上；而如果不关闭文件直接退出内核的话，甚至会出现拖动滑动条却无法将其移动的情况。对后一种情况，个人猜测是由于前端和内核重新连接后，前端原有控件没能和内核中的变量关联上的缘故。 思考题6： 分别将由DynamicModule和Module得到的滑动条复制到其它地方，拖动滑动条，观察其现象，思考造成这种现象的原因。 延伸阅读： 动态简介、高级动态功能 命名空间 命名空间也被称作上下文。顾名思义，它可以看作一段程序执行的语境，它影响符号的含义。 附带的笔记本中，在不同单元中多次出现符号x，但它们之间没有任何关联，也不会互相干扰。这是由于该笔记本默认在每个单元编组都使用独立的上下文。通过计算$Context获取当前上下文，可以得到一个形如Cell$$nnnn`的上下文名称。 事实上，Wolfram语言中任何符号的全名都包括两个部分：上下文和短名。全名的典型形式是context`short。其中，符号`在Wolfram语言中被称为上下文标记，它是符号全名的一部分，在使用时又有些类似文件系统中的路径分隔符/或\\。 正如我们在命令行环境下键入程序不需要完整的路径，系统会自动在PATH环境变量指定的路径中搜索，在Wolfram语言中的如果只键入符号短名的话，系统首先会在$ContextPath指定的上下文中搜索，如果在既有上下文中找不到该符号，才会在当前上下文中创建一个以此为短名的新符号。 上下文的应用通常和程序包联系在一起，以减少不同程序包间可能的符号冲突。因而在Wolfram语言中有两组典型的方式来开启一个上下文环境： 一组是Begin[&quot;context`&quot;]和End[]；另一组是BeginPackage[&quot;context`&quot;]和EndPackage[]。下面的代码简单演示了两者对上下文环境的作用 12345678910111213Print[\"0:\", $Context, \"|\", $ContextPath]BeginPackage[\"test`\"]; Print[\"1:\", $Context, \"|\", $ContextPath] Begin[\"test1`\"]; Print[\"2:\", $Context, \"|\", $ContextPath] End[]; Print[\"3:\", $Context, \"|\", $ContextPath] Begin[\"`test2`\"]; Print[\"4:\", $Context, \"|\", $ContextPath] End[]; Print[\"5:\", $Context, \"|\", $ContextPath]EndPackage[];Print[\"6:\", $Context, \"|\", $ContextPath] 123456789101112130:Cell$$nnnn`|&#123;Cell$$nnnn`,System`&#125;1:test`|&#123;test`,System`&#125;2:test1`|&#123;test`,System`&#125;3:test`|&#123;test`,System`&#125;4:test`test2`|&#123;test`,System`&#125;5:test`|&#123;test`,System`&#125;6:Cell$$nnnn`|&#123;test`,Cell$$nnnn`,System`&#125; 可以看到，Begin-End所产生的作用比较纯粹，就是在其作用的范围内改变当前上下文$Context，而对$ContextPath毫无影响。相对地，BeginPackage-EndPackage则有几项副作用，它除了在作用范围内改变$Context和$ContextPath外，在使用EndPackage[]离开其作用范围时不仅将$Context和$ContextPath复原，而且会将还原前的上下文添加到$ContextPath中，从而方便我们直接使用导入包中的符号。 在实际的程序包开发中，这两种结构一般都会用到。比如在Mathematica自带示例程序包ExampleData/Collatz.m中有如下代码 123456789101112131415161718BeginPackage[\"Collatz`\"]Collatz::usage = \"Collatz[n] gives a list of the iterates in the 3n+1 problem, starting from n. The conjecture is that this sequence always terminates.\"Begin[\"`Private`\"]Collatz[1] := &#123;1&#125;Collatz[n_Integer] := Prepend[Collatz[3 n + 1], n] /; OddQ[n] &amp;&amp; n &gt; 0Collatz[n_Integer] := Prepend[Collatz[n/2], n] /; EvenQ[n] &amp;&amp; n &gt; 0End[ ]EndPackage[ ] 这个例子中我们可以看到一个程序包典型的上下文结构安排。BeginPackage-EndPackage主要用于引入接口性质的符号，而具体实现部分则往往置于Begin-End结构中以尽可能避免符号污染。 思考题7： x和`x之间有什么区别？运行下面两段代码，观察结果。思考并理解`的含义。 12345x = 1;Begin[\"`test`\"];x = 2;&#123;Context[], Context[x]&#125;End[]; 12345`x = 1;Begin[\"`test`\"];`x = 2;End[];&#123;`x, `test`x&#125; 延伸阅读： 上下文、上下文和程序包、建立 Wolfram 语言程序包、对不同的笔记本自动使用独立的上下文环境、处理符号名称遮盖的问题 相关代码交互见 笔记本。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"语法","slug":"语法","permalink":"http://miRoox.github.io/blog/tags/语法/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"}]},{"title":"理解Wolfram语言（上）","slug":"UnderstandWolframLang-I","date":"2018-06-04T06:02:10.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2018/06/UnderstandWolframLang-I/","link":"","permalink":"http://miRoox.github.io/blog/2018/06/UnderstandWolframLang-I/","excerpt":"“一切皆表达式” Everything is an expression. 是的，理解了上面这句话，就基本理解了Wolfram语言。至于其它的，那都是细枝末节。","text":"“一切皆表达式” Everything is an expression. 是的，理解了上面这句话，就基本理解了Wolfram语言。至于其它的，那都是细枝末节。 当然，想要理解这句话，首先要明白Wolfram语言里的表达式是什么。典型地，f[x,y] 就是一个表达式，它由一个头部 f，以及两个项 x 和 y 构成。通常，我们会用 f[x,y] 来表示一个函数 f(x,y)f(x,y)f(x,y)，但同时，这种形式也代表了Wolfram语言里表达式的一般结构。 一般的，表达式由头部和项组成，而头部和项同样也是表达式。这种结构不仅可以用来表示函数，它也可以用来表示列表、图形、动态控件，甚至是笔记本。表达式的这种灵活性为Wolfram语言语法的高度一致性，在理解了这种一致性的基础上，再去看Wolfram语言的各种行为，就会变得好理解很多。 再举几个例子(通过FullForm可以获得一个表达式的完整形式)： 算术表达式 列表 图形 非符号头部的表达式 按钮控件 笔记本对象（输出仅供参考） 对象是结构化的表达式 前面提到了Wolfram语言表达式的一般结构，即：一个表达式由头部和若干项构成，而头部和项同样也是表达式，直到某个不可再分的原子对象，比如数字、字符串和符号。在最初的例子里，f[x,y]中，头部f，项x，y都是符号。而对于更复杂的表达式，往往有较深的层次和较多的子项，但如果掌握了一些方法（比如 善用 TreeForm），分析一个表达式的结构并不困难。 理解了表达式的结构，以及Wolfram语言的这种一致性，那么Wolfram语言的很多设计与行为就好理解了。 比如，列表的下标为何从1开始？因为本质上，运算符[[...]]提供的是按索引获取表达式各个项的一般方法，而作为语言一致性的表现，[[0]]获取的是表达式的头部。因此，对任何列表，获取“下标”为0的部分得到的结果都会是List。同样，像1[[0]]这种在别的语言的使用者眼里看起来莫名奇妙的表达式，在Wolfram语言中是完全正确的（当然，我们推荐使用语义更清晰的Head[1]进行表达）。事实上，不仅仅是[[...]]，有相当一部分的列表操作可以以完全一致的行为用在任何表达式上，例如Length、Cases、Sort、Map……掌握好这些函数，在面对很多问题的时候都会有所帮助。 而表达式的这种结构特性使得它可以承载并组织各种各样的信息。自然而然地，我们可以使用表达式来表示对象。 作为展示“对象是结构化的表达式”的例子，再来看一个有趣的小trick： 上面这个例子实际展示了Plot 函数在绘图时是如何进行抽样的。而方法也很简单，只是把图中的线段替换为点。而这种操作之所以可行，也是表达式一致性的体现。在这里，函数Plot输出的图形实际是一个Graphics 对象，从构成上看，无非就是包含一些图形基元和图形指令的Graphics表达式，只要将连接点的Line替换为不连接的Point就可以显示出那些抽样点了。 小结 “一切皆表达式”是Wolfram语言语法的核心。Wolfram语言用表达式来表示算式、数据、图形、控件等等。而掌握了表达式的结构，对Wolfram语言里的各种对象、操作都会有更清晰准确地认识。在下篇里，将会讲到Wolfram语言中表达式的另一个重点——表达式的计算，以及我们如何控制计算。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"语法","slug":"语法","permalink":"http://miRoox.github.io/blog/tags/语法/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"}]},{"title":"解除GitHub仓库的Fork连接","slug":"2018-5-19-RemoveGitHubFork","date":"2018-05-19T15:45:10.000Z","updated":"2020-01-23T12:17:55.000Z","comments":true,"path":"2018/05/2018-5-19-RemoveGitHubFork/","link":"","permalink":"http://miRoox.github.io/blog/2018/05/2018-5-19-RemoveGitHubFork/","excerpt":"这是一篇灌水文。 GitHub的Fork功能实际上主要是服务于Pull Request，然而我以前并没有正确地认识到这一点，简单地把Fork当clone使，导致有些时候不太方便。比如生成这个博客的仓库，以前是直接Forkleopardpan的博客得到的。现在我想解除这种Fork关系，但同时保留提交的历史。然而在网上却没有找到有关的教程，没办法，只能自己试试。","text":"这是一篇灌水文。 GitHub的Fork功能实际上主要是服务于Pull Request，然而我以前并没有正确地认识到这一点，简单地把Fork当clone使，导致有些时候不太方便。比如生成这个博客的仓库，以前是直接Forkleopardpan的博客得到的。现在我想解除这种Fork关系，但同时保留提交的历史。然而在网上却没有找到有关的教程，没办法，只能自己试试。 实际做起来却意外的简单。 首先，把删去所有与本地仓库连接的远程仓库 12$ git remote remove origin$ git remote remove upstream 然后，把GitHub上自己的远程仓库给删了。 最后，在GitHub上重新建立同名仓库，然后把本地仓库关联上去。 1$ git remote add origin &lt;your repo&gt; 于是就大功告成了。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://miRoox.github.io/blog/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://miRoox.github.io/blog/tags/GitHub/"}]},{"title":"C/C++的一些常见的坑(1)","slug":"TrapInCCpp-1","date":"2017-11-17T16:12:34.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2017/11/TrapInCCpp-1/","link":"","permalink":"http://miRoox.github.io/blog/2017/11/TrapInCCpp-1/","excerpt":"根据个人经验和见闻总结而来。主要涉及C和C++语法和语义方面的一些陷阱。","text":"根据个人经验和见闻总结而来。主要涉及C和C++语法和语义方面的一些陷阱。 求值顺序 在著名的《谭C》教材的误导下，中国学生对表达式的求值顺序的误解可能是最深的。首先要明确地是，运算符对运算数的求值顺序与运算符的结合性没有任何关系，而且，无论是C语言还是C++，几乎所有运算符对运算数进行求值的顺序都是 未指定的，甚至在某些情况下会构成 未定义行为。 另一方面，C和C++在这方面的规定较为复杂，而且随着标准版本的变化，相关概念也有较大的变化。因此，除非你自认为自己对这方面的规定十分清楚，我建议尽量让程序里的每一个表达式保持结构简单，尤其避免在一个表达式对同一个对象里产生超过一次 副作用。这不光可以避免未定义行为或者未指定行为，也有助于增强程序的可读性。例如： 123456789//badi = ++i + i++; // C 和 C++ 中都为未定义的行为i = ++i + 1; // C 中始终为未定义行为；C++11 前为未定义的行为f(i = -2, i = -2); // C 中始终为未定义行为；C++17 前为未定义的行为a[i] = i++; // C 中始终为未定义行为；C++17 前为未定义的行为 1234567891011//good//i = ++i + i++; // what does the coder want to do?i = i + 2;i = -2;f(i, i);++i;a[i] = i; 参见 C：求值顺序、C++：求值顺序 字符常量/字面量的类型 简而言之，C语言中无前缀修饰的 字符常量 的类型是 int ；而C++中无前缀修饰的 字符字面量 的类型默认是 char （除非字符在执行字符集中无法用单字节表示，这时其类型为 int ）。 是的，在 C 和 C++ 里他们的叫法都不同。C 把嵌入代码的常量值称为 常量 或 字面量 ，其中 常量 是 右值表达式， 字面量 是 左值表达式 ；而 C++ 中统称为 字面量 。 其它编码的字符常量/字面量的具体内容参见下面的链接。 参见： C：字符常量、C++：字符字面量 数组指代器不是指针常量 同样是受《谭C》等一批国内教科书的毒害，有不少人认为数组就是指针常量。但实际上数组的类型就是数组类型，只是使用时大多数情况下会隐式转换成其首元素指针的 非左值 。正因为这种转换的存在，所以我们才能像指针一般使用数组，又因为其结果是非左值，所以不可以被赋值。 但另一方面，在C语言中，函数参数列表中的数组声明，在对应的函数调用时其实际参数的值是一个指针。（可以说是C的一个黑点了） 详细的转换规则见下面的链接。 参见： C：数组到指针转换、C++：数组到指针转换 static 储存类指定符 之所以写这一条，是因为听说有驱动程序把以 static 修饰的对象定义在头文件里导致内存爆炸的传闻。这么看 static 确实有一些坑，无论是C语言还是C++，作为储存类指定符的 static 都具有多重语义，而且在不同情况下含义不尽相同。 简洁起见，这里不考虑与 thread_local（或者 _Thread_local ）组合的情况；标识符（C）和名称（C++）统称为名称。 首先要明确的是，储存类指定符都包含两层内涵，一是指定 对象 的 储存期 ，一是指定 名称 的 链接 。这是两个层次的内涵，也是很多初学者比较模糊的。 一方面，被 static 修饰的对象拥有 静态储存期 ，该对象生存期基本和整个程序一样长；另一方面，被 static 修饰的名称通常为 内部链接 ，即该名称的只在当前的翻译单元可被引用；除非被 static 修饰的是一个局部变量，那么它（的名称）的链接为 无链接 ，即该名称只能在它所在的作用域中被引用。 可以看出，static 确实可以让我们在头文件里定义函数或者对象而不引发重定义错误，因为包含一个头文件就是把整个头文件复制到源文件里，那么在每一个包含该头文件的源文件里都有一个被 static 修饰的对象/函数，它们虽然具有同样的名称，但由于所用是内部链接，所以它们指代的是（各自翻译单元的）不同实体，因而在内存受限的设备上大量包含这样的头文件就有可能导致内存爆炸。 还要注意的一点是，对于C，无论是全局还是块作用域中的静态对象，其初始化器必须为常量表达式，且初始化发生于主函数前。而对于C++，静态局部变量的可以不用常量表达式初始化，而且可能等到控制流首次经过其声明时才初始化。 （注1：对于C++，类中的 static 声明代表不绑定到类实例的 静态成员 ） （注2：C99后 static 还可能用于函数声明中的 静态数组下标 ） 参考： C：存储类指定符、C++：存储类指定符、C：静态初始化器、C++：静态初始化、C++：静态局部变量 某些整数运算的坑 懒得写了，见 @孙明琦 的 整理一发C++整数运算的所有细节 main 函数的原型 著名语言律师 @幻の上帝 对此 早有论述。这里只摘录一下主要结论： void main() 在 C 仍然可以是符合标准(conforming)的扩展； 在 C++ 中不返回 int 的 main 直接不符合标准。 参见 C：主函数、C++：主函数 volatile 类型限定符 volatile 大概是被误解最多的 C/C++ 语言特性之一。 简而言之，volatile 只是代表 读副作用 ，与什么 多线程、 原子性 以及 memory barrier 都没什么关系（尽管 MSVC 提供了额外的语义使之可以用于多线程编程，但这种特性不可移植，不推荐使用）。而 volatile 本来的意图主要是用于模拟映射于内存的硬件I/O，以及信号处理函数。 （注：Java 里的 volatile 具有原子访问的语义。） 参见 C：volatile 类型限定符、C++：cv 类型限定符、MSDN：volatile、C：信号处理函数、C++：如同规则 应该会有下一篇的，大概。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"参考","slug":"参考","permalink":"http://miRoox.github.io/blog/tags/参考/"},{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"C语言","slug":"C语言","permalink":"http://miRoox.github.io/blog/tags/C语言/"},{"name":"C++","slug":"C","permalink":"http://miRoox.github.io/blog/tags/C/"},{"name":"语法","slug":"语法","permalink":"http://miRoox.github.io/blog/tags/语法/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miRoox.github.io/blog/tags/踩坑/"}]},{"title":"基于改进的Chirikov映射的彩色图像加密算法","slug":"https://miroox.github.io/image-encryption-with-improved-Chirikov-map/","date":"2017-10-18T15:10:11.000Z","updated":"2020-01-27T13:59:10.000Z","comments":true,"path":"2017/10/https://miroox.github.io/image-encryption-with-improved-Chirikov-map//","link":"","permalink":"http://miRoox.github.io/blog/2017/10/https:/miroox.github.io/image-encryption-with-improved-Chirikov-map/","excerpt":"摘要： 基于改进的Chirikov映射来实现一种彩色图像加密的算法。该方法通过在Chirikov映射中增加一个参数来增加算法的随机性。采用像素数据置乱的方法实现图像加密。并进行了一些数值仿真来验证加密方案的性能。 关键词：图像加密；混沌映射；数据安全","text":"摘要： 基于改进的Chirikov映射来实现一种彩色图像加密的算法。该方法通过在Chirikov映射中增加一个参数来增加算法的随机性。采用像素数据置乱的方法实现图像加密。并进行了一些数值仿真来验证加密方案的性能。 关键词：图像加密；混沌映射；数据安全","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"图像加密","slug":"图像加密","permalink":"http://miRoox.github.io/blog/tags/图像加密/"},{"name":"图像处理","slug":"图像处理","permalink":"http://miRoox.github.io/blog/tags/图像处理/"},{"name":"混沌","slug":"混沌","permalink":"http://miRoox.github.io/blog/tags/混沌/"},{"name":"算法","slug":"算法","permalink":"http://miRoox.github.io/blog/tags/算法/"},{"name":"项目","slug":"项目","permalink":"http://miRoox.github.io/blog/tags/项目/"}]},{"title":"使用Mathematica实现基于类的面向对象","slug":"ClassBasedOOPWithMma","date":"2017-09-01T15:54:41.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2017/09/ClassBasedOOPWithMma/","link":"","permalink":"http://miRoox.github.io/blog/2017/09/ClassBasedOOPWithMma/","excerpt":"Mathematica 通常被宣传为 符号式 、 函数式 的编程语言，不过 维基百科 宣称它支持 13种编程范式，其中还包括 面向对象 编程。尽管大家似乎都不把 Mathematica 当编程语言，不过出于兴趣，也为了提升对 Mathematica 语言特性和面向对象的理解，于是有了这篇文章。 比较理想的情况是能够以类似 C++ 或者 Java 那样的形式来创建和使用类与对象，以此为目标进行设计。","text":"Mathematica 通常被宣传为 符号式 、 函数式 的编程语言，不过 维基百科 宣称它支持 13种编程范式，其中还包括 面向对象 编程。尽管大家似乎都不把 Mathematica 当编程语言，不过出于兴趣，也为了提升对 Mathematica 语言特性和面向对象的理解，于是有了这篇文章。 比较理想的情况是能够以类似 C++ 或者 Java 那样的形式来创建和使用类与对象，以此为目标进行设计。 首先考虑的当然是上网搜索，可惜网上的实现大多不完善，封装、继承、多态都不全。一番查找之下，这篇文章 给我的启发最大，让我确立了封装类的基本思路。而继承与多态受到 Lua 中利用元表来模拟继承的启发。 （注：本文中提到的多态主要指 子类多态 ） 好，废话不多说，先上代码。 1234567891011121314151617181920212223242526272829303132333435363738394041(*nil*)SetAttributes[nil,ReadProtected];nil[___]=nil;(*default*)(*new*)SetAttributes[new,&#123;ReadProtected,HoldFirst&#125;];new[nil]=nil;(*type of*)SetAttributes[typeOf,ReadProtected];typeOf[obj_]:=If[Evaluate[obj@type]===nil,nil,obj@type,Head[obj]];(*to make sure every expression has a type*)(*classQ*)SetAttributes[classQ,ReadProtected];classQ[obj_]:=typeOf[obj]==class||typeOf[obj]==nil;(*nil is a special class*)(*class*)SetAttributes[class,&#123;ReadProtected,HoldAll&#125;];class[identifier_Symbol,&#123;privDecls___Symbol&#125;,body_]:=class[identifier,nil,&#123;privDecls&#125;,body];class[identifier_Symbol,baseClass_?classQ,&#123;privDecls___Symbol&#125;,body_]:=With[ &#123;className=SymbolName[identifier], upperClassName=StringReplace[SymbolName[identifier],StartOfString~~h_:&gt;ToUpperCase[h]]&#125;, SetAttributes[identifier,&#123;ReadProtected,HoldAll&#125;]; identifier@type=class; (*'type'Q*) SetAttributes[Evaluate[Symbol[className&lt;&gt;\"Q\"]],ReadProtected]; Evaluate[Symbol[className&lt;&gt;\"Q\"]][obj_]:=If[ obj[Evaluate[Symbol[\"is\"&lt;&gt;upperClassName]]], True,False,False ]; (*constructor*) new[identifier]:=Module[ &#123;$self,$base,privDecls&#125;, SetAttributes[$self,&#123;HoldAll,ReadProtected&#125;]; SetAttributes[$base,ReadProtected]; SetAttributes[#,ReadProtected]&amp;/@&#123;privDecls&#125;;(*encapsulation*) $base=new[baseClass];(*inheritance*) $self[mem_]:=$base@mem;(*polymorphism*) $self@type=identifier;(*type*) $self[Evaluate[Symbol[\"is\"&lt;&gt;upperClassName]]]=True;(*subtyping*) (*body*) ReleaseHold[Hold[body]/.&#123;self-&gt;$self,base-&gt;$base,public-&gt;$self&#125;]; $self(*reference semantics*) ];] 在分析这些代码前，先来看一个简单的例子，看看如何做到封装继承多态。 定义一个基类 123456789class[testBase, &#123;text&#125;, (*initialize*) text=\"Base\"; (*public method*) public@setText[str_String]:=(text=str); public@getText[]:=text; public@print[]:=Print[\"This is base. The text is \"&lt;&gt;text]] 再定义一个派生类 1234class[testDerived,testBase, &#123;&#125;, public@print[]:=Print[\"This is derived. The text is \"&lt;&gt;self@getText[]]] 最后定义一个（带类型约束的）测试函数（注：testBaseQ 由 class 自动生成） 1testFun[obj_?testBaseQ]:=obj@print[]; 对于一个基类对象执行 12obj1=new[testBase];testFun[obj1] 会输出 1This is base. The text is Base 而对于一个派生类对象执行 123obj2=new[testDerived];obj2@setText[\"Derived\"];testFun[obj2] 则会输出 1This is derived. The text is Derived 可以看到，之前提到的目标基本已经满足了。封装继承多态都有，形式和 C++ 、Java 也很相似。下面大致分析它的实现方式。 首先，随处可见的 SetAttributes[_,ReadProtected] 只是为了在包装成函数包后让实现对外不可见，不是重点。 然后看代码的开始，定义了一个 nil 。它的定位大概类似于 C++ 中的 nullptr ，表示一个“空”对象。略有不同的是， nil 既是对象又是类型，这是 Mathematica 符号式编程的优势。 1nil[___]=nil;(*default*) 这段代码表示的是 nil 的任何方法得到的结果都是 nil 。结合后面利用责任链模式（见后文）实现的多态，这里事实上给所有对象的方法提供了一个缺省的实现。也就是说，如果一个对象调用了一个不存在的方法，那么它得到的结果就是 nil 。这比 Mathematica 本身默认以保持符号形式不变的方法具有更清晰的类型语义。 接下来是 new 。设计上，它的意义同 C++ 基本是一致的。 1new[nil]=nil; 这段代码的目的和前面差不多，也是责任链传递的底端。 而后是 typeOf ，一个获取类型的辅助函数。由于 Mathematica 的动态性，它可以对应于 C++ 中的 decltype() 或者 typeof() 。 1typeOf[obj_]:=If[Evaluate[obj@type]===nil,nil,obj@type,Head[obj]];(*to make sure every expression has a type*) 正如后面的注释所述，最后的 Head[obj] 只是为了保证任何表达式都能有一个类型。注意使用时尽量不要用它来约束类型。至于这里为什么要用 Evaluate ，读者不妨自己想想。 接着是 classQ ，同样也是个类型判断的辅助类，用于约束 class 的参数。 1classQ[obj_]:=typeOf[obj]==class||typeOf[obj]==nil;(*nil is a special class*) 读者不妨想想我为什么要把 nil 也视作类。 然后终于进入正题 class 了。 1class[identifier_Symbol,&#123;privDecls___Symbol&#125;,body_]:=class[identifier,nil,&#123;privDecls&#125;,body]; 这句没什么好说的，给不做任何继承的类提供一个默认参数。 中间略过一些细枝末节，直接看到 (*'type'Q*) 那里。 1234Evaluate[Symbol[className&lt;&gt;\"Q\"]][obj_]:=If[ obj[Evaluate[Symbol[\"is\"&lt;&gt;upperClassName]]], True,False,False]; 同样是利用 Mathematica 的动态性，自动生成一个多态的类型测试函数。注意 If 最后一项 False 使得它的行为更为确定。 然后是最为核心的 new 函数的特化（这个词从 C++ 里来，我觉得这么说更有表现力）。 Module 开始声明了这几个局部变量 1&#123;$self,$base,privDecls&#125;, $ 开头约定为内部符号，避免名称冲突。 $self 即要创建的对象实例自身，new 最后返回的就是它。由于从模块返回的就是它，因而它的生存期会被延长（参见 属性 Temporary ）。受它影响，那些间接被 $self 引用的对象生存期也会延长，这就是利用 Module 封装对象属性的机理。 $base 是基类对象。用于实现继承机制。 privDecls 即用户定义的私有成员，注意它是 class 传参进来的，这似乎可以限制 Module 的自动改名能力。 12$base=new[baseClass];(*inheritance*)$self[mem_]:=$base@mem;(*polymorphism*) 这两段就是实现继承多态的核心部分。学过设计模式的话很容易可以看出这其实就是一种 责任链模式 。责任链模式简单的说就是向一条候选的对象链发出请求，根据请求以及运行时的情况决定一个对象是响应请求还是将其传递给下一级。在这里，就是将 $self 处理不了的成员调用传递给 $base 从而实现继承。而对于基类定义过的方法，在派生类中重写即可实现多态（准确地说，还需要类型约束）。 1$self@type=identifier;(*type*) 没什么好说的。 1$self[Evaluate[Symbol[\"is\"&lt;&gt;upperClassName]]]=True;(*subtyping*) 这条就是 'type'Q 的实现部分。注意它也是 $self 的成员，也就是继承的部分。也就是说一个派生类对象一定也会满足基类的类型测试函数。藉此，一套完整的子类多态就实现了。 最后是类定义的主体。 1ReleaseHold[Hold[body]/.&#123;self-&gt;$self,base-&gt;$base,public-&gt;$self&#125;]; 由于 ReplaceAll 没有任何 Hold 系列属性，因此替换前需要 Hold 。 public-&gt;$self 就是一个语法糖。 1$self(*reference semantics*) new 最后返回 $self ，因此赋值操作，如 obj=new[object] 只是让 obj 成了一个指向 $self 的引用。也就如大家知道的那样，面向对象编程使用的大多是引用语义而不是值语义，这点需要注意。 还有一点值得注意的是，继承只继承公有部分，即使你是以 public@privMethod 的形式（其中 privMethod 在 privDecls 中声明了）定义的，因为你无法在外部获取被模块改名了的 privMethod ） 结语略。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"功能模拟","slug":"功能模拟","permalink":"http://miRoox.github.io/blog/tags/功能模拟/"},{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miRoox.github.io/blog/tags/Wolfram/"}]},{"title":"基于Qt实现类似Notepad++的标签页拖放功能","slug":"DnDTabWithQt","date":"2017-08-16T03:31:23.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2017/08/DnDTabWithQt/","link":"","permalink":"http://miRoox.github.io/blog/2017/08/DnDTabWithQt/","excerpt":"在我的常用软件中，Google Chrome 和 Notepad++ 都可以做到拖拽标签页在标签栏移动，在两个窗口间移动，以及创建新的窗口。作为 这个项目 的一部分，打算实现一个功能类似的 Tab Widget 。","text":"在我的常用软件中，Google Chrome 和 Notepad++ 都可以做到拖拽标签页在标签栏移动，在两个窗口间移动，以及创建新的窗口。作为 这个项目 的一部分，打算实现一个功能类似的 Tab Widget 。 设计目标 Google Chrome 和 Notepad++ 的拖放标签页功能基本上是类似的，但细节上也略有差别 Google Chrome Notepad++ 标签栏内移动标签时是平滑过渡的 标签栏内移动标签时没有过渡动画 两个窗口间移动根据释放的位置插入到标签栏 两窗口间移动只是简单附加到标签栏最后 标签移动到标签栏外立即产生一个新窗口 在 Notepad++ 窗口外释放鼠标产生一个新窗口 移动产生的新窗口不是独立的进程 移动产生的新窗口是独立的进程 可以看出 Google Chrome 和 Notepad++ 功能上各有千秋，综合一下两者各自的优点并考虑可实现性，基本的设计目标为： 在标签栏内移动标签可以改变标签的顺序，且是平滑过渡。（事实上 Qt 自带的 QTabWidget 在 setMovable(true) 后就是这种效果。） 在两窗口间移动时，如果释放点在标签栏上，就根据释放的位置插入标签栏，否则附加到标签栏的最后。 拖拽标签到主窗口外释放鼠标产生一个新窗口，且新窗口是独立的进程。如果新窗口不是独立的进程，那问题就简化了一大半，而且这样的例子网上也有很多，如：QTabWidget 实现类似QQ聊天窗口 ） 当然，我们还需要一个具体的情境。出于简单考虑，以多文档浏览器为例，使用只读的 QTextBrowser 作为标签页，其 source 属性还可以用来保存文件路径，十分便利。 设计思路及实践过程 显然，设计目标1是很容易满足的，只要 tabWidget-&gt;setMovable(true) ，因此把重点放在目标2、3上。 首先想到的当然是参考现有的源码，考虑到 Chromium 太过复杂，于是选择参考了 Notepad++ 的 源码 然而发现里面依赖于一些诸如 ::WindowFromPoint() 、::GetClassName() 之类的Win32函数，旋即放弃了这条道路。 考虑将目标的问题分解。基本的，移动这个操作实际上是创建和删除的复合。对于 QTabWidget ，虽然提供了QTabWidget::addTab() 、QTabWidget::insertTab() 之类的创建函数，但 QTabWidget::removeTab() 并不实际上销毁对应的页面，因此还需要一个确实能删除标签页的函数。 定义 QTabWidget 的子类 MyTabWidget （以下所有代码中的省略号 ... 都表示我们目前不关心这些部分，其细节将在后面逐渐补全） 123456789101112131415161718//mytabwidget.h#ifndef MYTABWIDGET_H#define MYTABWIDGET_H#include &lt;QTabWidget&gt;class MyTabWidget : public QTabWidget&#123; Q_OBJECTpublic: MyTabWidget(QWidget * parent = Q_NULLPTR); ~MyTabWidget() &#123;&#125; void removeTabActually(int index); ...&#125;;#endif // MYTABWIDGET_H 实现删除标签页的方法 1234567891011//mytabwidget.cpp#include \"mytabwidget.h\"...void MyTabWidget::removeTabActually(int index)&#123; widget(index)-&gt;deleteLater(); removeTab(index);&#125;... 虽然现在看上去没有必要派生一个新类 MyTabWidget ，但这个类在后面还会有其它用途。 接下来考虑拖放如何传递数据。最容易想到的当然是 QDrag ，而且我们知道文本编辑器通常通过传递 URLs 来实现拖放打开文件。类似地，我们也可以借助 URL 来传递拖放标签页的信息。 由于目标2中对释放点在标签栏上和其它地方有不同要求，因此对标签栏和主窗口分别重新实现 dragEnterEvent() 和 dropEvent() 。 主窗口很容易处理 12345678910111213141516171819202122232425//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;class QString;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: explicit MainWindow(QWidget *parent = 0); ~MainWindow() &#123;&#125; void openFile(QString fileName); void openFileAt(QString fileName, int tabIndex); ...protected: void dragEnterEvent(QDragEnterEvent *event) override; void dropEvent(QDropEvent *event) override; ...&#125;;#endif // MAINWINDOW_H 123456789101112131415161718192021222324252627282930313233343536373839//mainwindow.cpp#include \"mainwindow.h\"#include \"mytabwidget.h\"#include &lt;QUrl&gt;#include &lt;QMimeData&gt;#include &lt;QDragEnterEvent&gt;#include &lt;QDropEvent&gt;...MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; ... setAcceptDrops(true); ...&#125;...void MainWindow::dragEnterEvent(QDragEnterEvent *event)&#123; if(event-&gt;mimeData()-&gt;hasUrls()) event-&gt;acceptProposedAction(); else event-&gt;ignore();&#125;void MainWindow::dropEvent(QDropEvent *event)&#123; const QMimeData * mimeData = event-&gt;mimeData(); if(mimeData-&gt;hasUrls()) &#123; for (const QUrl&amp; url : mimeData-&gt;urls()) &#123; openFile(url.toLocalFile()); &#125; event-&gt;acceptProposedAction(); &#125; else &#123; event-&gt;ignore(); &#125;&#125; 而对于标签栏，借助 Qt 的信号-槽机制同样也不难实现 1234567891011121314151617181920212223242526//mytabbar.h#ifndef MYTABBAR_H#define MYTABBAR_H#include &lt;QTabBar&gt;class QString;class MyTabBar : public QTabBar&#123; Q_OBJECTpublic: MyTabBar(QWidget * parent = Q_NULLPTR); ~MyTabBar() &#123;&#125;signals: void openFileRequest(QString/*fileName*/,int/*tabIndex*/); ...protected: void dragEnterEvent(QDragEnterEvent *event) override; void dropEvent(QDropEvent *event) override; ...&#125;;#endif // MYTABBAR_H 1234567891011121314151617181920212223242526272829303132333435363738//mytabbar.cpp#include \"mytabbar.h\"#include &lt;QUrl&gt;#include &lt;QMimeData&gt;#include &lt;QDragEnterEvent&gt;#include &lt;QDropEvent&gt;MyTabBar::MyTabBar(QWidget *parent) : QTabBar(parent)&#123; setMovable(true); setAcceptDrops(true);&#125;...void MyTabBar::dragEnterEvent(QDragEnterEvent *event)&#123; if(event-&gt;mimeData()-&gt;hasUrls()) event-&gt;acceptProposedAction(); else event-&gt;ignore();&#125;void MyTabBar::dropEvent(QDropEvent *event)&#123; const QMimeData * mimeData = event-&gt;mimeData(); if(mimeData-&gt;hasUrls()) &#123; for (const QUrl&amp; url : mimeData-&gt;urls()) &#123; emit openFileRequest(url.toLocalFile(),tabAt(event-&gt;pos())); &#125; event-&gt;acceptProposedAction(); &#125; else &#123; event-&gt;ignore(); &#125;&#125;... 注意到 MyTabBar 的信号 void MyTabBar::openFileRequest(QString/*fileName*/,int/*tabIndex*/) 与MainWindow 的函数 void MainWindow::openFileAt(QString fileName, int tabIndex) 间参数的对应关系，显然要将他们连接起来。不过在此之前，我们还需要 MyTabWidget 做一个中继，于是 123456789101112131415161718192021//mytabwidget.h#ifndef MYTABWIDGET_H#define MYTABWIDGET_H#include &lt;QTabWidget&gt;class MyTabWidget : public QTabWidget&#123; Q_OBJECTpublic: MyTabWidget(QWidget * parent = Q_NULLPTR); ~MyTabWidget() &#123;&#125; void removeTabActually(int index);signals: void openFileRequest(QString/*fileName*/,int/*tabIndex*/); ...&#125;;#endif // MYTABWIDGET_H 12345678910111213141516171819//mytabwidget.cpp#include \"mytabwidget.h\"#include \"mytabbar.h\"MyTabWidget::MyTabWidget(QWidget * parent) : QTabWidget(parent)&#123; auto mTabBar = new MyTabBar(this); setTabBar(mTabBar); connect(mTabBar,&amp;MyTabBar::openFileRequest,this,&amp;MyTabWidget::openFileRequest); ...&#125;void MyTabWidget::removeTabActually(int index)&#123; widget(index)-&gt;deleteLater(); removeTab(index);&#125; 然后在主窗口中连接信号 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//mainwindow.cpp#include \"mainwindow.h\"#include \"mytabwidget.h\"#include &lt;QTextBrowser&gt;#include &lt;QMessageBox&gt;#include &lt;QFileInfo&gt;#include &lt;QFile&gt;#include &lt;QTextStream&gt;#include &lt;QUrl&gt;#include &lt;QMimeData&gt;#include &lt;QDragEnterEvent&gt;#include &lt;QDropEvent&gt;...MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; ... auto tabWidget = new MyTabWidget(this); setCentralWidget(tabWidget); setAcceptDrops(true); connect(tabWidget,&amp;MyTabWidget::openFileRequest,this,&amp;MainWindow::openFileAt); ...&#125;void MainWindow::openFile(QString fileName)&#123; return openFileAt(fileName,-1); //If index is out of range, the tab is simply appended. //see http://doc.qt.io/qt-5/qtabwidget.html#insertTab&#125;void MainWindow::openFileAt(QString fileName, int tabIndex)&#123; QFile file(fileName); if(! file.open(QFile::ReadOnly | QFile::Text)) &#123; QMessageBox::warning(this,tr(\"Error\"), tr(\"Cannot open file %1:\\n%2\").arg(fileName).arg(file.errorString())); return ; &#125; QTextStream in(&amp;file); auto browser = new QTextBrowser(this); auto tabWidget = qobject_cast&lt;MyTabWidget*&gt;(centralWidget()); Q_ASSERT(tabWidget); auto index = tabWidget-&gt;insertTab(tabIndex,browser,QFileInfo(fileName).baseName()); tabWidget-&gt;setCurrentIndex(index); browser-&gt;setAcceptDrops(false); QGuiApplication::setOverrideCursor(Qt::WaitCursor); browser-&gt;setSource(QUrl::fromLocalFile(fileName)); browser-&gt;setPlainText(in.readAll()); QGuiApplication::restoreOverrideCursor(); file.close();&#125;...void MainWindow::dragEnterEvent(QDragEnterEvent *event)&#123; if(event-&gt;mimeData()-&gt;hasUrls()) event-&gt;acceptProposedAction(); else event-&gt;ignore();&#125;void MainWindow::dropEvent(QDropEvent *event)&#123; const QMimeData * mimeData = event-&gt;mimeData(); if(mimeData-&gt;hasUrls()) &#123; for (const QUrl&amp; url : mimeData-&gt;urls()) &#123; openFile(url.toLocalFile()); &#125; event-&gt;acceptProposedAction(); &#125; else &#123; event-&gt;ignore(); &#125;&#125; 从上面我们可以看到，openFileAt() 打开文件后将其插入标签栏上特定的位置，而 openFile() 只是普通的打开并附到标签栏最后，和目标2是对应的。由于拖放接收的是 URL ，所以普通的文件拖放打开也顺便实现了。至此，两窗口间拖放的接收部分就完成了。 在考虑发送部分之前，先考虑目标3情况下创建的新窗口如何接收数据。虽然乍一看似乎也可以通过 QDrag 来传递信息，但由于创建新窗口和释放拖放基本是同时发生的，而 QDrag 本身不能创建新窗口，因此在一次拖放中不能指望只携带 URL 信息的 QDrag 给新窗口传递信息。 注意到我们是在启动新进程的同时传递信息，最传统的方法就是命令行参数。显然，命令行参数里肯定要有要打开的文件路径。而且我们还希望在鼠标释放的地方创建新窗口，所以还需要有窗口的位置参数。即 123456789101112131415161718192021222324252627282930313233343536//main.cpp#include \"mainwindow.h\"#include &lt;QApplication&gt;#include &lt;QCommandLineParser&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); QCommandLineParser parser; parser.addOptions(&#123; &#123;\"x\",\"move window to indicated left side position on screen\",\"posX\",\"100\"&#125;, &#123;\"y\",\"move window to indicated top position on screen\",\"posY\",\"100\"&#125; /*name, description, value name, default value*/ &#125;); parser.addPositionalArgument(\"filePath\",\"file to open\"); parser.process(a); bool converted; auto x = parser.value(\"x\").toInt(&amp;converted); if(!converted) x = 100; auto y = parser.value(\"y\").toInt(&amp;converted); if(!converted) y = 100; QStringList filePaths = parser.positionalArguments(); MainWindow w; w.move(x,y); w.show(); for(const QString&amp; filePath : filePaths) &#123; w.openFile(filePath); &#125; return a.exec();&#125; 这样，新窗口接收数据的部分也完成了。 然后是发送数据的部分。 移动标签显然是要覆写标签栏的鼠标移动事件。由于标签栏内的移动 Qt 本身已经有实现了，因此只考虑标签栏外的情况。 123456789101112131415161718192021222324252627//mytabbar.h#ifndef MYTABBAR_H#define MYTABBAR_H#include &lt;QTabBar&gt;class QString;class MyTabBar : public QTabBar&#123; Q_OBJECTpublic: MyTabBar(QWidget * parent = Q_NULLPTR); ~MyTabBar() &#123;&#125;signals: void openFileRequest(QString/*fileName*/,int/*tabIndex*/); void dragTabRequest(int/*tabIndex*/);protected: void dragEnterEvent(QDragEnterEvent *event) override; void dropEvent(QDropEvent *event) override; void mouseMoveEvent (QMouseEvent *event) override;&#125;;#endif // MYTABBAR_H 123456789101112131415161718192021222324252627282930313233343536373839404142434445//mytabbar.cpp#include \"mytabbar.h\"#include &lt;QUrl&gt;#include &lt;QMimeData&gt;#include &lt;QDragEnterEvent&gt;#include &lt;QDropEvent&gt;#include &lt;QMouseEvent&gt;MyTabBar::MyTabBar(QWidget *parent) : QTabBar(parent)&#123; setMovable(true); setAcceptDrops(true);&#125;void MyTabBar::dragEnterEvent(QDragEnterEvent *event)&#123; if(event-&gt;mimeData()-&gt;hasUrls()) event-&gt;acceptProposedAction(); else event-&gt;ignore();&#125;void MyTabBar::dropEvent(QDropEvent *event)&#123; const QMimeData * mimeData = event-&gt;mimeData(); if(mimeData-&gt;hasUrls()) &#123; for (const QUrl&amp; url : mimeData-&gt;urls()) &#123; emit openFileRequest(url.toLocalFile(),tabAt(event-&gt;pos())); &#125; event-&gt;acceptProposedAction(); &#125; else &#123; event-&gt;ignore(); &#125;&#125;void MyTabBar::mouseMoveEvent(QMouseEvent *event)&#123; if(event-&gt;buttons()==Qt::LeftButton) &#123; if(!geometry().contains(event-&gt;pos())) &#123; emit dragTabRequest(currentIndex()); &#125; &#125; QTabBar::mouseMoveEvent(event);&#125; 同样是利用信号-槽机制 12345678910111213141516171819202122//mytabwidget.h#ifndef MYTABWIDGET_H#define MYTABWIDGET_H#include &lt;QTabWidget&gt;class MyTabWidget : public QTabWidget&#123; Q_OBJECTpublic: MyTabWidget(QWidget * parent = Q_NULLPTR); ~MyTabWidget() &#123;&#125; void removeTabActually(int index);signals: void openFileRequest(QString/*fileName*/,int/*tabIndex*/); void dragTabRequest(int/*tabIndex*/);&#125;;#endif // MYTABWIDGET_H 12345678910111213141516171819#include \"mytabwidget.h\"#include \"mytabbar.h\"#include &lt;QDebug&gt;MyTabWidget::MyTabWidget(QWidget * parent) : QTabWidget(parent)&#123; auto mTabBar = new MyTabBar(this); setTabBar(mTabBar); connect(mTabBar,&amp;MyTabBar::openFileRequest,this,&amp;MyTabWidget::openFileRequest); connect(mTabBar,&amp;MyTabBar::dragTabRequest,this,&amp;MyTabWidget::dragTabRequest);&#125;void MyTabWidget::removeTabActually(int index)&#123; widget(index)-&gt;deleteLater(); removeTab(index);&#125; 最后是关键的拖放实现。注意到既然接收拖放就是在窗口间移动标签页，那么不接收拖放就可以作为创建新窗口。当然这么做会有一定的副作用，只能说是一种委曲求全的方法。具体的问题在后面再谈。 12345678910111213141516171819202122232425//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;class QString;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: explicit MainWindow(QWidget *parent = 0); ~MainWindow() &#123;&#125; void openFile(QString fileName); void openFileAt(QString fileName, int tabIndex); void dragTab(int tabIndex);protected: void dragEnterEvent(QDragEnterEvent *event) override; void dropEvent(QDropEvent *event) override;&#125;;#endif // MAINWINDOW_H 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120//mainwindow.cpp#include \"mainwindow.h\"#include \"mytabwidget.h\"#include &lt;QTextBrowser&gt;#include &lt;QMessageBox&gt;#include &lt;QFileInfo&gt;#include &lt;QFile&gt;#include &lt;QTextStream&gt;#include &lt;QUrl&gt;#include &lt;QMimeData&gt;#include &lt;QDrag&gt;#include &lt;QWindow&gt;#include &lt;QScreen&gt;#include &lt;QProcess&gt;#include &lt;QCursor&gt;#include &lt;QDragEnterEvent&gt;#include &lt;QDropEvent&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; ...//setup ui auto tabWidget = new MyTabWidget(this); setCentralWidget(tabWidget); setAcceptDrops(true); connect(tabWidget,&amp;MyTabWidget::openFileRequest,this,&amp;MainWindow::openFileAt); connect(tabWidget,&amp;MyTabWidget::dragTabRequest,this,&amp;MainWindow::dragTab);&#125;void MainWindow::openFile(QString fileName)&#123; return openFileAt(fileName,-1); //If index is out of range, the tab is simply appended. //see http://doc.qt.io/qt-5/qtabwidget.html#insertTab&#125;void MainWindow::openFileAt(QString fileName, int tabIndex)&#123; QFile file(fileName); if(! file.open(QFile::ReadOnly | QFile::Text)) &#123; QMessageBox::warning(this,tr(\"Error\"), tr(\"Cannot open file %1:\\n%2\").arg(fileName).arg(file.errorString())); return ; &#125; QTextStream in(&amp;file); in.setAutoDetectUnicode(true); auto browser = new QTextBrowser(this); auto tabWidget = qobject_cast&lt;MyTabWidget*&gt;(centralWidget()); Q_ASSERT(tabWidget); auto index = tabWidget-&gt;insertTab(tabIndex,browser,QFileInfo(fileName).baseName()); tabWidget-&gt;setCurrentIndex(index); browser-&gt;setAcceptDrops(false); QGuiApplication::setOverrideCursor(Qt::WaitCursor); browser-&gt;setSource(QUrl::fromLocalFile(fileName)); browser-&gt;setPlainText(in.readAll()); QGuiApplication::restoreOverrideCursor(); file.close();&#125;void MainWindow::dragTab(int tabIndex)&#123;// if(!isTabMovable(tabIndex)) // ...//impossible in this situation auto tabWidget = qobject_cast&lt;MyTabWidget*&gt;(centralWidget()); Q_ASSERT(tabWidget); auto browser = qobject_cast&lt;QTextBrowser*&gt;(tabWidget-&gt;widget(tabIndex)); Q_ASSERT(browser); auto drag = new QDrag(this); auto mimeData = new QMimeData; QPixmap thumbnail = windowHandle()-&gt;screen()-&gt;grabWindow(browser-&gt;winId()); mimeData-&gt;setUrls(&#123;browser-&gt;source()&#125;); drag-&gt;setMimeData(mimeData); drag-&gt;setPixmap(thumbnail.scaled(200,200)); auto dragAction = drag-&gt;exec(/*Qt::MoveAction*/Qt::LinkAction); int currentIndex = tabWidget-&gt;indexOf(browser); if (dragAction==Qt::LinkAction/*Qt::MoveAction*/) &#123; tabWidget-&gt;removeTabActually(currentIndex); &#125; else if (dragAction==Qt::IgnoreAction) &#123; if(QProcess::startDetached(qApp-&gt;applicationFilePath(), &#123;\"-x\",QString::number(QCursor::pos().x()), \"-y\",QString::number(QCursor::pos().y()), browser-&gt;source().toLocalFile()&#125;)) &#123; tabWidget-&gt;removeTabActually(currentIndex); &#125; &#125; else &#123; return; &#125; if(tabWidget-&gt;count()==0) &#123; qApp-&gt;closeAllWindows(); &#125;&#125;void MainWindow::dragEnterEvent(QDragEnterEvent *event)&#123; if(event-&gt;mimeData()-&gt;hasUrls()) event-&gt;acceptProposedAction(); else event-&gt;ignore();&#125;void MainWindow::dropEvent(QDropEvent *event)&#123; const QMimeData * mimeData = event-&gt;mimeData(); if(mimeData-&gt;hasUrls()) &#123; for (const QUrl&amp; url : mimeData-&gt;urls()) &#123; openFile(url.toLocalFile()); &#125; event-&gt;acceptProposedAction(); &#125; else &#123; event-&gt;ignore(); &#125;&#125; 这里值得注意的有两点。一个是在 drag-&gt;exec() 之后重新获取了部件当前的索引 currentIndex ，这是由于拖放后可能会导致索引改变；另一个是拖放提供的行为是 Qt::LinkAction 而不是 Qt::MoveAction ，这是由于桌面（即资源管理器）以及相当一部分常见程序对 Qt::MoveAction 和 Qt:: CopyAction 的拖放是可以直接接收的，导致创建新窗口几乎不会发生，而且还会带来一些意料外的副作用，因此最后选择了大多数常见程序不会接收的 Qt::LinkAction 。 这样，一个具有标签页拖放功能的多文本浏览器就基本完成了。 完整源码参见 https://github.com/miRoox/MyTabWidget","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"功能模拟","slug":"功能模拟","permalink":"http://miRoox.github.io/blog/tags/功能模拟/"},{"name":"编程","slug":"编程","permalink":"http://miRoox.github.io/blog/tags/编程/"},{"name":"Qt","slug":"Qt","permalink":"http://miRoox.github.io/blog/tags/Qt/"},{"name":"拖放","slug":"拖放","permalink":"http://miRoox.github.io/blog/tags/拖放/"}]},{"title":"【翻译】代数数据类型的代数结构（中）","slug":"TheAlgebraOfADT-II","date":"2017-07-02T14:54:34.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2017/07/TheAlgebraOfADT-II/","link":"","permalink":"http://miRoox.github.io/blog/2017/07/TheAlgebraOfADT-II/","excerpt":"原文链接 我以此题目在2012年11月的伦敦Haskell会议上做了演讲。演讲的视频见 YouTube ，幻灯片见 GitHub 。这篇是系列的第二部分；你可以在这里阅读第一部分 上一次我介绍了单位类型 Unit 或者 () 以及零类型 Void 。我同时还介绍了类型运算符 Add 和 Mul ，以及函数类型 a-&gt;b 。","text":"原文链接 我以此题目在2012年11月的伦敦Haskell会议上做了演讲。演讲的视频见 YouTube ，幻灯片见 GitHub 。这篇是系列的第二部分；你可以在这里阅读第一部分 上一次我介绍了单位类型 Unit 或者 () 以及零类型 Void 。我同时还介绍了类型运算符 Add 和 Mul ，以及函数类型 a-&gt;b 。 在这篇文章中，我将同时使用Haskell记号和数学记号。下面这个表可以帮助你在这两者之间转换。 Void⁡↔0() ,Unit⁡↔1Add⁡ a b↔a+b(a,b) , Mul⁡ a b↔a⋅ba→b↔ba\\begin{aligned} \\operatorname{Void} &amp;&amp; \\leftrightarrow &amp;&amp; 0 \\\\ () \\,, \\operatorname{Unit} &amp;&amp; \\leftrightarrow &amp;&amp; 1 \\\\ \\operatorname{Add} \\; a \\; b &amp;&amp; \\leftrightarrow &amp;&amp; a + b \\\\ (a,b) \\,,\\; \\operatorname{Mul} \\; a \\; b &amp;&amp; \\leftrightarrow &amp;&amp; a \\cdot b \\\\ a \\rightarrow b &amp;&amp; \\leftrightarrow &amp;&amp; b ^ a \\end{aligned}Void(),UnitAddab(a,b),Mulaba→b​​↔↔↔↔↔​​01a+ba⋅bba​ 在这篇文章中我将着眼于递归类型，并展示如何在以各种方式使用类型代数来推导出关于类型的有趣事实。 Maybe 类型构造子 让我们通过探索 Maybe a 来放松一下。这表示它这个类型可能包含类型 aaa 的一个值，也可能为空。它定义如下： 1data Maybe a = Nothing | Just a 竖线表示这是一个和类型，所以如果我们已经定义了类型 Nothing 和 Just a ，我们可以使用我们上次定义的类型 Add 来写。它看起来就像下面这样： 1234data Nothing = Nothingdata Just a = Just atype Maybe a = Add Nothing (Just a) 看我们是怎么把 data 声明替换为 type 声明的？这意味着 Maybe a 不再是一个新类型 —— 而只是一个已知类型的同义词。 但我们可以更进一步。注意到 Nothing 只具有一个值，所以它等价于 () 。类似的，Just 是类型 aaa 的一个单一值的容器，故它等价于 aaa 。因而我们有 1type Maybe a = Add () a 也就是说，Maybe aaa 与 1 + aaa 是一样的。Maybe 所做的事就是给一个类型添加一个可能的值。 递归类型 列表 Haskell中基本的列表是 链式表 。一个列表 asasas 要么是空的，记作 [] ，要么是将单个 aaa 附加到另一个列表 asasas 上而构成的，记作 a : as 。如果我们想要自己定义一个列表，我们可以写成 1data List a = Nil | Cons a (List a) 让我们来花点时间看一下这个声明的结构。和 Maybe 一样，List 类型是两种更简单类型的和。 加数是 Nil ，是一个等价于 () 的无参构造子。 被加数是 Cons a (List a) ，是一个包含 aaa 和列表 asasas 的乘积。 如果我们将列表写作 L(a)L(a)L(a) ，那么它的代数形式是 L(a)=1+a⋅L(a)L(a) = 1 + a \\cdot L(a) L(a)=1+a⋅L(a) 这好像意味着我们可以在Haskell中将列表类型写作 1type List a = Add () (a, (List a)) 但实际上这不能通过编译。其原因是类型别名会在类型检查之后，编译之前的编译期被展开。这个定义永远不会停止展开 —— 它会像下面这样一直展开 1Add () (a, Add () (a, Add () (a, ...))) 等等。这不行的原因与Haskell处理递归类型定义的方式有关（和大多数具有复杂的类型系统的语言一样，它使用 同构递归类型而不是等同递归类型 [1] ） 它的方式是使用 newtype 声明替代 type 声明，并将类型包装在一个新的类型构造子 L 中： 1newtype List a = L (Add () (a, List a)) 这样只是为了满足类型检查器 —— 当代码被编译时，额外的构造子会被优化掉，我们所剩的与上面使用 type 的声明相同。 如果我们将类型 List a 写作 L(a)L(a)L(a) ，那么这个列表的声明就是说 L(a)=1+a⋅L(a)L(a) = 1 + a \\cdot L(a) L(a)=1+a⋅L(a) 为了看清列表 实际上 是什么，我们可以开始通过反复替代来展开定义。在展开式中，无论何时我看见了具有 a⋅aa\\cdot aa⋅a 形式的类型，我都会用 a2a^2a2 替代以节省空间。 练习 ：表达式 a2a^2a2 可以用序对 (a,a)(a,a)(a,a) 或函数 2→a2\\rightarrow a2→a 表示。证明它们是一样的。 L(a)=1+a⋅L(a)=1+a⋅(1+a⋅L(a))=1+a+a2⋅(1+a⋅L(a))=1+a+a2+a3⋅(1+a⋅L(a))=…=1+a+a2+a3+a4+a5+⋯\\begin{aligned} L(a) &amp; = 1 + a \\cdot L(a) \\\\ &amp; = 1 + a \\cdot (1 + a \\cdot L(a)) \\\\ &amp; = 1 + a + a ^ 2 \\cdot (1 + a \\cdot L(a)) \\\\ &amp; = 1 + a + a ^ 2 + a ^ 3 \\cdot (1 + a \\cdot L(a)) \\\\ &amp; = \\ldots \\\\ &amp; = 1 + a + a ^ 2 + a ^ 3 + a ^ 4 + a ^ 5 + \\cdots \\end{aligned}L(a)​=1+a⋅L(a)=1+a⋅(1+a⋅L(a))=1+a+a2⋅(1+a⋅L(a))=1+a+a2+a3⋅(1+a⋅L(a))=…=1+a+a2+a3+a4+a5+⋯​ 这告诉我们 aaa 的列表要么是空列表，要么是包含单个 aaa 的列表，要么是包含两个 aaa 的列表，要么是包含三个 aaa 的列表，等等。也许你已经知道这一点 —— 但代数告诉我们的更加简洁！ 但现在，这有一件确实很酷的事情。让我们从列表的方程式开始，而不是使用反复替代的方法，同时忘掉一会儿我们的对象是类型，并假装它们是任意的表达式。这意味着我们有理由使用任何我们喜欢的技巧来“求解 L(a)L(a)L(a) ”。 首先在等式两边同时减去 L(a)L(a)L(a) ： L(a)−a⋅L(a)=1L(a) - a \\cdot L(a) = 1 L(a)−a⋅L(a)=1 然后分解出等式左侧的因子： (1−a)⋅L(a)=1(1 - a) \\cdot L(a) = 1 (1−a)⋅L(a)=1 最后，两边同时除以 1−a1-a1−a ： L(a)=11−aL(a) = \\frac{1}{1-a} L(a)=1−a1​ 这看起来没有意义，因为我们不知道一个类型减去另一个类型是什么意思，也不知道一个类型除以另一个类型是什么意思。但是它一点有意思的事都不能告诉我们吗？ 如果你学习过微积分，你也许记得许多函数都可以按照 泰勒级数 进行展开。我们可以 问一问 Wolfram Alpha 1/(1−a)1/(1-a)1/(1−a) 的泰勒级数是什么，然后它会告诉我们： L(a)=1+a+a2+a3+a4+⋯L(a) = 1 + a + a ^ 2 + a ^ 3 + a ^ 4 + \\cdots L(a)=1+a+a2+a3+a4+⋯ 也就是说，L(a)L(a)L(a) 的级数展开，恰恰就是我们通过反复替代化简得到的式子。尽管我们通过对类型进行了一些完全不合理的操作，极大地滥用了代数，但还是得到了一个合理的结果。 树 考虑节点处有值的二叉树。在Haskell中你可以像这样写 1data Tree a = Empty | Node a (Tree a) (Tree a) 以一种可能令人熟悉的方式，我们可以将它看作两个类型的和 —— 一个等价于 () 的无参类型，和一个积类型。这一次它是三个项的乘积，但这并不是个问题 —— 我们可以使用嵌套的乘积，其形式为 (a, (b, c)) 。 根据我们所知道的运算关系（再一次，我们使用 newtype 来获得一个递归的定义），其定义为 1newtype Tree a = T (Add () (a, (Tree a, Tree a))) 在代数的语言中，如果把 T(a)T(a)T(a) 作为树的类型，我们可以写出 T(a)=1+a⋅T(a)2T(a) = 1 + a\\cdot T(a)^2 T(a)=1+a⋅T(a)2 为了更好地解决树是什么，我们可以采用与列表相同的方式进行重复替换，但那会更加麻烦。相对的，我们可以用重新排列方程的技巧来求解 T(a)T(a)T(a) 吗？ 首先，将所有东西移到方程的同一侧： a⋅T(a)2−T(a)+1=0a \\cdot T(a)^2 - T(a) + 1 = 0 a⋅T(a)2−T(a)+1=0 我们可以看出它是关于 T(a)T(a)T(a) 的 二次方程 ，因此我们可以使用二次方程求根公式求出 T(a)=1−1−4a2aT(a) = \\frac{1 - \\sqrt{1 - 4 a}}{2a} T(a)=2a1−1−4a​​ 这比列表类型的方程更没意义。取一个类型的平方根是个什么意思？但是，不要慌张，我们再一次 问问 Wolfram Alpha 它的级数展开，然后它会告诉我们 T(a)=1+a+2a2+5a3+14a4+⋯T(a) = 1 + a + 2a ^ 2 + 5a ^ 3 + 14a ^ 4 + \\cdots T(a)=1+a+2a2+5a3+14a4+⋯ 那么我们如何理解它呢？前两项告诉我们，一个树可以是空的（如果它是 Empty ），或者可以有一个类型为 aaa 的值（如果它是 Node a Empty Empty ）。 然后下一项告诉我们，一个树可以以两种不同的方式包含两个类型为 aaa 的值。而再下一项告诉我们，一个树可以以五种不同的方式包含三个类型为 aaa 的值。 但我们确实可以看出这些，如果我们枚举所有二叉树，并且将他们按所包含的值的个数分组。有一棵树没有值，有一棵树有一个值，有两棵树有两个值，有五棵树有三个值 —— 正如这个图片中描述的（从 Flajolet 和 Sedgewick 所著的优秀书籍 《解析组合数学》 中摘来的）。 方程能计算可以存在的不同二叉树的数目！这一计数属性与我们在第一篇文章中看到的简单计数实例有关，也与 组合种类（combinatorial species） [2] 有关，正如 Brent Yorgey 所写的有关拓展。种类（species）和类型（types）有许多的共同点，尽管它们并不是同一样东西。 七树合一（Seven Trees In One） 如果我们限制树只包含单位类型，例如 Tree () ，那么 T(a)T(a)T(a) 中的 aaa 就等于 1 ，然后我们可以写出树的定义式方程 T=1+T2T = 1 + T^2 T=1+T2 通过代数方法，重复地使用公式 T2=T−1T ^ 2 = T - 1T2=T−1 ，我们可以化简为 T6=(T−1)3=T3−3T2+3T−1=T(T−1)−3T2+3T−1=−2T2+2T−1=−2(T−1)+2T−1=1\\begin{aligned} T^6 &amp; = (T-1) ^ 3 \\\\ &amp; = T ^ 3 - 3T ^ 2 + 3T - 1 \\\\ &amp; = T (T - 1) - 3T ^ 2 + 3T - 1 \\\\ &amp; = - 2T ^ 2 + 2T - 1 \\\\ &amp; = -2(T-1) + 2T - 1 \\\\ &amp; = 1 \\end{aligned}T6​=(T−1)3=T3−3T2+3T−1=T(T−1)−3T2+3T−1=−2T2+2T−1=−2(T−1)+2T−1=1​ 当你把它解释为语言的类型时，这表示一个树的六元组与单位类型等价。换句话说，只存在一个树的六元组。 这显然是无意义的，那么是哪里出了问题呢？更神秘的是如果我们在等式两边同时乘 TTT ，我们会得到 T7=TT ^ 7 = T T7=T 这并 不是 没有意义的 —— 它表明一个树的七元组和单个树等价。 乍一看，这不是一个深刻的结果。任何两个具有 可数无限多 个可能值的类型都是等价的 —— 这就是可数的意思。 然而，还有比这更巧妙的。在论文 七树合一（Seven Trees In One） 中，Andreas Blass 不仅展示了如何找到七个树到一个树的确切映射和逆映射（实质上，他就是告诉你如何写出前一篇所说的 from 和 to 函数），而且还表明，这些函数从来都不需要再任何树上深入四层以上。 最后，他解释了为什么 T7=TT ^ 7 = TT7=T 是有效的，而 T6=1T ^ 6 = 1T6=1 却不是。事实上，通过我上面给出的使用减法的方法，派生出类似的方法，你可以转换为不使用减法的“诚实的”证明，因此对于类型也是有效的 —— 但当你开始所用的 TTT 的幂必须是一个大于6的倍数的幂。因此你可以将 T7T ^ 7T7 化简为 TTT（因为 7 = 6 + 1 ），而不能将 T6T ^ 6T6 化简为 1 。 一个解释？ 如果你认为这篇文章提出的问题比提供的答案还要多，这是十分公正的。例如： 类型的减法、除法和开方是什么意思？ 对于仍然具有意义、可计算、可解释的类型方程，我们还可以做什么？ 为什么对类型方程进行不合理的操作却可以得到有意义的答案？ 作为最后一个问题的预热，一个可以给类型建模的数学结构叫 半环 。这也就是说，你可以加或乘对象，并且你有对应于 0 和 1 的对象。这里有一篇 Marcelo Fiore 和 Tom Leinster 的论文，表明如果你从一个 复数 TTT 开始，它由方程 t=p(t)t = p(t) t=p(t) 定义 ，其中 ppp 是一个多项式，并且化简为 q1(t)=q2(t)q_1(t) = q_2(t) q1​(t)=q2​(t) 其中 q1q_1q1​ 和 q2q_2q2​ 不是常量（他们不能只是 1 ），那么同样的结果对于半环也是正确的。特别地，它对于类型也是正确的，也就是你可以找到一个不使用减法以及其它对于类型而言非法的运算的证明。 下一次，我将解释拉链（zippers）数据结构是什么，然后描述如何对类型进行微积分。 原文中的 “isorecursive” 和 “equirecursive” 找不到已有的翻译，我按照wikipedia中的描述做了一定的意译。简单地说，isorecursive 类型与其展开之间是不同的类型，只是两者之间是同构的；而 equirecursive 类型与其展开是完全等同的。 ↩︎ 原文中的 “combinatorial species” 找不到既有的翻译，根据字面意思翻译了一下。 ↩︎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"},{"name":"翻译作品","slug":"翻译作品","permalink":"http://miRoox.github.io/blog/categories/翻译作品/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://miRoox.github.io/blog/tags/翻译/"},{"name":"科普","slug":"科普","permalink":"http://miRoox.github.io/blog/tags/科普/"},{"name":"Haskell","slug":"Haskell","permalink":"http://miRoox.github.io/blog/tags/Haskell/"}]},{"title":"从马克思主义基本原理看程序设计","slug":"MarxismInProgramDesign","date":"2017-06-04T16:56:23.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2017/06/MarxismInProgramDesign/","link":"","permalink":"http://miRoox.github.io/blog/2017/06/MarxismInProgramDesign/","excerpt":"（这篇是马克思主义基本原理课程的大作业，各位要是看到什么觉得不对的地方，也还请一笑了之）","text":"（这篇是马克思主义基本原理课程的大作业，各位要是看到什么觉得不对的地方，也还请一笑了之） 马克思主义是关于自然、社会和人类思维发展一般规律的学说，而马克思主义基本原理是马克思主义理论体系的核心内容，是对马克思主义立场、观点和方法的集中概括。另一方面，随着计算机技术、移动技术的飞速发展，各种各样的的应用程序已经渗透到了人们生活的方方面面，而程序设计是关于程序如何编写设计的方法和范式，其思想也体现了许多马克思主义的原理。 我们知道，编程语言是人们与计算机对话的一种方式，是程序的一种表达形式。显然，我们可以使用不同的编程语言实现同样的效果或达到同样的目的。另一方面，由于不同编程语言本身有不同的设计目标，因而对同一问题采用不同语言解决的难易不同，选取合适的编程语言也就非常重要了，比如要与硬件打交道则需要像汇编语言或C语言这样偏底层的语言，要面对高并发环境则需要像Erlang这样低耦合的函数式语言，要制作用户界面那么选择XAML或QML这样的陈述性语言可能更为合适，等等。当然，我们既反对忽视程序设计而夸大编程语言的作用，也要积极利用合适的编程语言去促进程序的设计，这与马克思主义中的内容决定形式的原理是相一致的。 算法和数据结构常常被认为是一个程序的核心，它们是从程序中抽象出来的一般方法，而程序可以看作是算法与数据结构的具体化。比如快速排序算法大致就是将数据分割成两个小部分，并使得其中一个部分的所有数据比另一个部分都要小，然后对分割出的每堆不断进行这个操作，又比如队列这种数据结构就是对数据先进先出这种特征的抽象。这种抽象使得我们不必受编程中繁琐的具体内容所困，从而把握住程序的本质特征，进而能够对程序的具体行为和性能作出准确的分析。有了这些分析，我们也就有了程序设计的一些最基本的判据，甚至可以做一些简单程序的设计了。这一过程体现的正是马克思唯物辩证法中的抽象与具体的方法。 代码复用可以说是程序设计的一大核心主题，广义上的代码复用就是指对代码的重复利用。有效的代码复用可以极大地解放程序员的生产力，使得程序员不必将精力和体力耗费在枯燥繁琐的拷贝修改上，而将精力和智力花费在其它更有价值的地方。同时，代码复用本身也是一个具体到抽象的过程，它使我们可以从更高的角度看问题，例如我们前面提到的快速排序算法，我们显然不关心其中数据的具体类型是什么，只要它们是“具有序关系的”，我们就可以对它们使用快速排序算法，但对于一些强类型语言，你可能不得不为每一种“具有序关系的”类型提供一个实现，尽管它们之间可能只有微小的差异，而如果运用一些代码复用的手段，比如模版或者泛型，我们只需要提供一种实现代码即可达到目的。这样，我们不仅提高了生产力，而且提升了代码的抽象层次，使得代码的层次结构更为清晰，也有利于将来的维护。具体地，代码复用的常见实现手段有：泛型、模版、继承、多态、模块化，以及各种各样的设计模式等等。由于篇幅的限制，下面重点讲讲模块化与设计模式。 模块化也是程序设计中的一大主题，它虽然是代码复用的一种实现手段，但其意义不止于此。模块化是一个比较宽泛的概念，随着划分粒度的不同，大至一个程序库，小至一段函数，都可以称之为“模块”。“高内聚，低耦合”是我们常听到的模块设计的原则，所谓“内聚”是从功能角度度量模块内的联系程度，而“耦合”则是从数据访问的角度度量模块间的关联程度。高内聚的模块应当专心做好一件事，而低耦合的模块与模块间应该只通过少且简单的接口进行交互。这种原则使得程序的层次结构十分清晰，有利于程序的开发和维护，同时，模块充分的独立性也给程序后续的维护和升级带来便利。 可以看到，模块化进一步地解放了程序员的生产力。但另一方面，我们在实践中经常会遇到模块粒度的问题，显然，一个粗粒度的模块会包含许多细粒度的模块，那么粗粒度模块的高内聚，与细粒度模块间的低耦合就构成了一对矛盾。一种有效的解决策略是粗粒度的模块做抽象普遍的事，而细粒度的模块做具体特殊的事，例如一个图形界面库里面有一个对话框类，而对话框类里面有一个显示文本的方法。模块化的另一个矛盾是“高内聚，低耦合”虽然可以提高开发和维护的效率，但往往也会降低运行效率，而与之相对的“低内聚，高耦合”虽然加大了程序开发与维护的难度，但同时也换取了更高的运行效率。对于这个矛盾只能采取具体问题具体分析的方法，综合考虑程序具体的运行环境、硬件配置，以及程序本身的设计目标，进行合理的取舍。 所谓设计模式就是一系列程序设计中常见问题的通用解决方案，因而代码的可复用性也是其目标之一。以著名的MVC（模型-视图-控制器）模式为例，它将用户界面分离成三类对象，模型是应用对象，视图表达它在屏幕上的显示，控制器定义界面对用户输入的响应方式。对于一个用户输入，控制器获取它并将指令和数据传递给模型，由模型来更新数据库并通知视图刷新，最后由视图将结果返回给用户。它可以看作普遍联系观与否定之否定规律的运用，将现象与本质、内容与形式剥离开来，再重新建立起它们间的联系。这样，既克服了传统界面设计中数据、显示与业务逻辑高度耦合的混杂状态，又保持了数据、显示与业务逻辑之间的联系性与一致性。对于其它设计模式，这里就不再赘述了，只想用下面这幅图来展示普遍联系的观点是如何在设计模式中运用的（图中每一个方框都代表这一种设计模式，箭头表达了设计模式间是如何联系与转化的）。 （上图摘自《设计模式：可复用面向对象软件的基础》） 运用马克思主义基本原理，可以加深我们对软件设计的体会与理解。但“纸上得来终觉浅，绝知此事要躬行”，只有真正将马克思主义基本原理和程序设计贯彻到实践中去，才能让知识开花结果，制作出好的程序来。","categories":[{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miRoox.github.io/blog/categories/杂谈散记/"}],"tags":[{"name":"程序设计","slug":"程序设计","permalink":"http://miRoox.github.io/blog/tags/程序设计/"},{"name":"哲学","slug":"哲学","permalink":"http://miRoox.github.io/blog/tags/哲学/"},{"name":"马克思主义","slug":"马克思主义","permalink":"http://miRoox.github.io/blog/tags/马克思主义/"}]},{"title":"【翻译】代数数据类型的代数结构（上）","slug":"TheAlgebraOfADT-I","date":"2017-05-27T13:44:34.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2017/05/TheAlgebraOfADT-I/","link":"","permalink":"http://miRoox.github.io/blog/2017/05/TheAlgebraOfADT-I/","excerpt":"原文链接 我以此题目在2012年11月的伦敦Haskell会议上做了演讲。演讲的视频见 YouTube ，幻灯片见 GitHub 。 在本系列文章中，我将在不提及范畴论和高等数学的情况下解释Haskell的数据类型为什么被称为 代数的。","text":"原文链接 我以此题目在2012年11月的伦敦Haskell会议上做了演讲。演讲的视频见 YouTube ，幻灯片见 GitHub 。 在本系列文章中，我将在不提及范畴论和高等数学的情况下解释Haskell的数据类型为什么被称为 代数的。 你高中所学的代数始于数字（例如：1、2、3……）和运算符（例如：加法和乘法）。运算符给你一种组合数字并从中产生新数字的方法。例如：将1和2通过加法运算结合起来将得到一个新数字3，我们通常将这个事实表述为 1+2=31 + 2 = 3 1+2=3 当你稍微长大一点之后，你会学到能够代替数字的变量（例如： xxx 、 yyy 、 zzz ……）。在你更大一些之后，你会知道一些代数遵循的法则，诸如 0+x=x1⋅x=x\\begin{aligned} 0 + x &amp;= x \\\\ 1 \\cdot x &amp;= x \\end{aligned}0+x1⋅x​=x=x​ 它们对于 xxx 的任何值都成立。此外还有一些其它的规则来定义数字和运算的性质。 当数学家们谈论代数时，他们意味着的是比这更普遍的东西。一个数学上的代数包含三个部分： 对象 是代数的“事物”。对象的集合定义了我们要讨论的是什么。 运算 给出将旧事物结合成新事物的方法。 规则 是对象和操作间的关系。 在中学的代数中，数字是对象，而加法、乘法和友谊是运算。 Haskell类型的代数 在Haskell类型的代数中，对象是类型，例如 Bool 和 Int。运算符从已有的类型中产生新的类型。一个实例是类型构造子 Maybe 。它本身不是类型，但你可以使用它产生类型 —— 例如 Maybe Bool 和 Maybe Int，而它们是类型。另一个例子是 Either，它从两个旧有类型中产生新类型 —— 例如 Either Int Bool。 计数 通过对类型可能具有的 值 进行计数，我们可以看到它与我们熟悉的数字代数的联系。我们取 Bool 的定义为 1data Bool = False | True 一个类型为 Bool 的对象有两种可能的取值 —— 它要么是 False 要么是 True （技术上来讲，它还有可能会是 undefined ，但我会在后文中忽略这个事实）。不严谨地说，类型 Bool 就对应于数字代数中的“2”。 如果说 Bool 是2，那么什么是1呢？它应当是一个只有唯一取值的类型。在计算机科学文献中，这种类型通常称为 Unit 并有如下定义 1data Unit = Unit 在Haskell中已经存在一种只有唯一取值的类型了 —— 它是 () （读作“Unit”）。你不能自己定义它，但如果你可以，它大概长这样 1data () = () 使用这种计数方法类推，Int 对应于数字 2322^{32}232 ，这正是类型 Int 所具有的值的数目（至少在我的机器上是这样的）。 加法 原则上我们可以有对应于3、4、5等等的类型。有时我们可能真的需要这样做 —— 比如对应于7的类型可以用于编码一周的七天。但是，如果我们可以从旧的类型建立起新的类型岂不是更好。这就需要我们请出代数中的运算符 一个对应于加法的类型是 1data Add a b = AddL a | AddR b 也就是说，类型 a+ba+ba+b 是一个具有标签的联合体[1]，它可以是 aaa 或 bbb。要了解为什么这对应于加法，我们可以重新审视一下计数法。让我们假设 aaa 是 Bool 而 bbb 是 ()，那么 aaa 有2种取值而 bbb 有1种取值。至于类型 Add Bool () 有多少种取值呢？我们可以将他们列出一个表： 1addValues = [AddL False, AddL True, AddR ()] 这其中有三个值，而 3 = 2 + 1 。这通常被称为是一个 和类型。在Haskell中，和类型通常使用 Either，它的定义为 1data Either a b = Left a | Right b 但我坚持使用 Add。 乘法 一个对应于乘法的类型是 1data Mul a b = Mul a b 也就是说，类型 a⋅ba\\cdot ba⋅b 是一个容纳 aaa 和 bbb 的容器。通过计数法可以证明其与乘法间的对应关系 —— 如果我们把 aaa 和 bbb 都定为 Bool，那么类型 Mul Bool Bool 可能的值为 1mulValues = [Mul False False, Mul False True, Mul True False, Mul True True] 这其中有四个值，即 4=2×24 = 2 \\times 24=2×2。这通常被称为 积类型。在Haskell中乘积是序对类型： 1data (,) a b = (a, b) 但我坚持使用 Mul。 零 使用加法和乘法我们可以产生任何1以上的数字所对应的类型 —— 但是0呢？它应当是一个没有任何值的类型。这听起来很奇怪，但你可以定义这样的类型： 1data Void 注意到在数据的定义中没有构造子，因此无法构造 Void 类型的值 —— 它有零个值，这正是我们想要的！ Haskell类型的代数中的规则 我们前面定义的类型有什么规则？就如同数字代数里那样，有一道规则能够断言两个对象是否相等 —— 在我们这，对象就是指类型。 然而，当我谈论到 相等性 时，我的意思不是Haskell中函数 (==) 的意义下的相等，而是两种类型之间存在着一一对应的关系 —— 也就是说，当我说 aaa 和 bbb 两种类型相等时，我的意思是你可以写出两个函数 12from :: a -&gt; bto :: b -&gt; a 它将 aaa 的值与 bbb 的值配对，因此下面的等式总是成立的（这里的 == 是真正的Haskell式的相等） 12to (from a) == afrom (to b) == b 比如，我认为类型 Bool 与类型 Add () () 等价的。因为我可以通过如下的函数证明它们的等价性： 1234567to :: Bool -&gt; Add () ()to False = AddL ()to True = AddR ()from :: Add () () -&gt; Boolfrom (AddL _) = Falsefrom (AddR _) = True 后面，我会使用三等号，===，来表示类型之间的这种等价关系。 加和类型的运算法则 加法有两条运算规则： 1Add Void a === a 意即类型 Add Void a 与类型 a 具有相同数目的值，而 1Add a b === Add b a 意味着你求和是什么次序无关紧要。这可以两条法则写成你可能更为熟悉的算数代数的形式 0+x=xx+y=y+x\\begin{aligned} 0 + x &amp;= x \\\\ x + y &amp;= y +x \\end{aligned}0+xx+y​=x=y+x​ 假如你喜欢做练习，你可以在 Haskell 代数中证明上述法则的正确性 —— 无论是采用计数法，还是通过写出 from 和 to 函数。 乘积类型的运算法则 乘法有三个有用的法则： 1Mul Void a === Void 意味着任何类型与 Void 相乘，你都会得到 Void ， 1Mul () a === a 意即与 () 不改变任何东西，而 1Mul a b === Mul b a 意味着你做乘积是什么次序无关紧要。这些法则更让人熟悉的形式是 0⋅x=01⋅x=xx⋅y=y⋅x\\begin{aligned} 0 \\cdot x &amp;= 0 \\\\ 1 \\cdot x &amp;= x \\\\ x \\cdot y &amp;= y \\cdot x \\end{aligned}0⋅x1⋅xx⋅y​=0=x=y⋅x​ 两个小练习：（1）证明上述法则在 Haskell 代数中的有效性，（2）解释为什么我们不需要下面这样的法则 12Mul a Void === VoidMul a () === a 此外，我们还有一条联系加法和乘法运算的法则： 1Mul a (Add b c) === Add (Mul a b) (Mul a c) 这一条推理起来可能有点棘手，但写出对应的 from 和 to 函数并不太难。这条法则的算术版长得比较友好 a⋅(b+c)=a⋅b+a⋅ca \\cdot (b + c) = a \\cdot b + a \\cdot c a⋅(b+c)=a⋅b+a⋅c 它被称为 分配 律。 函数类型 除了像 Int 和 Bool 这样的实体类型，Haskell 中还有 函数 类型，如 Int -&gt; Bool 或 Double -&gt; String 。如何将它们也纳入到这种代数里面？ 为了解决这个问题，我们重新回到计数法。类型 a→ba\\rightarrow ba→b 包含多少种函数？ 让我们具体来看，把 aaa 和 bbb 都定为 Bool。值 False 可以映射到 True 或者 False，对于值 True 也是如此 —— 因此，有 2⋅2=22=42 \\cdot 2 = 2 ^{2} = 42⋅2=22=4 种可能的 Bool -&gt; Bool 函数。为了真正的明确它们，我们可以将其枚举如下 12345678910111213f1 :: Bool -&gt; Bool -- 等价于 'id'f1 True = Truef1 False = Falsef2 :: Bool -&gt; Bool -- 等价于 'const False'f2 _ = Falsef3 :: Bool -&gt; Bool -- 等价于 'const True'f3 _ = Truef4 :: Bool -&gt; Bool -- 等价于 'not'f4 True = Falsef4 False = True 如果 bbb 仍然是（只有两个值的）Bool 类型，而 aaa 是具有三个值的类型，如 1data Trio = First | Second | Third 那么每个 First 、Second 和 Third 可以映射到两个可能值，因而总共有 2⋅2⋅2=23=82 \\cdot 2 \\cdot 2 = 2^{3} = 82⋅2⋅2=23=8 种 Trio -&gt; Bool 类型的函数。 采用同样的方法可以得到一般的规律。如果 AAA 是类型 aaa 的值的个数， BBB 是类型 bbb 的值的个数，那么类型 a→ba\\rightarrow ba→b 值的个数为 BAB^{A} BA 这说明了使用 指数类型 作为函数类型的常用术语的理由。 函数的运算法则 这里有两条关于单位类型的函数类型的运算法则。它们是 1() -&gt; a === a 这意味着有和类型 a 的值一样多的函数 () -&gt; a ，以及 1a -&gt; () === () 这意味着只存在唯一的一个函数 a -&gt; () —— 特别地，它就是 const () 。这两条规则的算术形式是 a1=a1a=1\\begin{aligned} a^{1} &amp;= a \\\\ 1^{a} &amp;= 1 \\end{aligned}a11a​=a=1​ 还有允许提取出共同参数的法则： 1(a -&gt; b, a -&gt; c) === a -&gt; (b,c) 其算术形式为 ba⋅ca=(bc)ab^{a} \\cdot c^{a} = (bc)^{a} ba⋅ca=(bc)a 以及关于返回其它函数的函数 1a -&gt; (b -&gt; c) === (b,a) -&gt; c 其算术形式为 (cb)a=cb⋅a(c^{b})^{a} = c^{b \\cdot a} (cb)a=cb⋅a 当右侧部分的变量顺序切换，同时删除左侧的括号后，最后这条法则可能会变得更为令人熟悉 1a -&gt; b -&gt; c === (a,b) -&gt; c 这也就是我们所谓的柯里化和非柯里化的函数。再说一次，通过写出对应的 from 和 to 函数来证明所有的这些法则是一项有趣的练习。 下一篇 在下一篇文章中我将着眼于递归类型，比如列表和二叉树，并展示如何在以各种方式使用类型代数来推导出关于类型的有趣事实。 此处原文为 “… the type a + b is a tagged union …” 。具有标签的联合体（tagged union）这个翻译可能不是很准确，但网上也没找到其它合适的翻译，特此注明。 ↩︎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"},{"name":"翻译作品","slug":"翻译作品","permalink":"http://miRoox.github.io/blog/categories/翻译作品/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://miRoox.github.io/blog/tags/翻译/"},{"name":"科普","slug":"科普","permalink":"http://miRoox.github.io/blog/tags/科普/"},{"name":"Haskell","slug":"Haskell","permalink":"http://miRoox.github.io/blog/tags/Haskell/"}]},{"title":"西方著名哲学家 课程笔记","slug":"WesternPhilosopher","date":"2017-04-01T15:22:33.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2017/04/WesternPhilosopher/","link":"","permalink":"http://miRoox.github.io/blog/2017/04/WesternPhilosopher/","excerpt":"当时记录的基本就是一些关键词，所以可能不太通顺。","text":"当时记录的基本就是一些关键词，所以可能不太通顺。 0. 绪论 世界三大哲学传统的特点： 中国哲学与伦理学紧密联系； 印度哲学与宗教紧密联系； 西方哲学与科学紧密联系。 研究西方哲学家时应避免： 辉格史观 贴标签（如：唯心主义、不可知论等） 移时史观 [1] 1. 前苏格拉底时期 闲暇 惊异 自由 ——哲学产生和发展的三个条件 1.1 伊奥尼亚自然哲学家 1.1.1 米利都派 主要人物：泰勒斯、阿那克西曼德、阿那克西米尼 米利都派的始基： 水 -&gt; Aperion -&gt; 气 1.1.1.1 泰勒斯 世界是由水构成的 体现出抽象、还原的思想（当代科学的核心方法）。 1.1.1.2 阿那克西曼德 Aperion（indefinite） 那产生存在之物者，也就是遵照必然而毁灭的过程回归于它的东西，因为事物遵循着时间的秩序而相互付出它们的不义所造成的痛苦的代价并得到补偿 1.1.1.3 阿那克西米尼 气 我们的灵魂，因为它是空气，是使我们每个人结成一体的原则；同样，空气也包围着整个世界。 1.1.2 爱菲斯的赫拉克利特 事物永恒变化，但遵循 logos [2]。 这个有秩序的宇宙 [3] 对万物都是相同的它既不是神也不是人所创造的，它过去、现在和将来永远是一团永恒的活火，按一定尺度燃烧，一定尺度熄灭。 人不能两次踏入同一条河流 生与死，梦与醒，老与少，是同样的东西。后者变化，就成为前者，前者变回来，则称为后者。 战争对于以前都是共同的。斗争就是正义，世间万物都是通过斗争而产生和灭亡的。 1.2 存在论的诞生 1.2.1 毕达哥拉斯学派 主要人物：毕达哥拉斯 万物皆数。 存在的本质是形式（数）。 1.2.2 埃里亚学派 主要人物：色诺芬尼、巴门尼德、芝诺 1.2.2.1 色诺芬尼 神是抽象的、普遍的、不变的 假如牛、马和狮子有手，并且和人一样用手作画塑像，那么它们也会按照各自的模样，绘制出马形的神和狮形的神。 1.2.2.2 巴门尼德 有存在，不可能不存在，这是确定性的道路，因为它伴随着真理。另一条则是，有不存在，非有存在，这是条狭窄的小路，在这条路上，女神说：“没有什么东西照亮你的脚步”。 能被思维者和能存在者是同一个东西。 存在是永恒的，是一，连续不可分；存在是不动的，是真实的，可以被思想； 感性世界的具体事物是非存在，是假相，不能被思想。 1.2.2.3 芝诺 否认运动。 假设时空连续导致的悖论：阿喀琉斯追龟、二分法 假设时空不连续导致的悖论：飞矢不动、游行队伍 1.3 元素派自然哲学家 ① 恩培多克勒的四根说 水、火、土、气 ② 阿那克萨戈拉的种子说 种子的动力来自心智 1.4 原子论 古希腊自然哲学的巅峰。 “朴素唯物主义”[4] 主要人物：留基伯、德谟克利特 2. 古希腊三杰 古希腊哲学的特点：没有额外的目的。 （实质：思考哲学问题本身是贵族身份的象征。） 已有的关于世界本源的认识： 质料、始基、Arche 形式（数学） 逻辑 动力 -&gt; 心智（spirit） 2.0 智者运动 智者派（Sophists） 被诟病的原因： 有功利性 相对主义 诡辩 影响：使哲学从自然哲学走到人类社会。 主要人物：普罗泰戈拉 2.1 苏格拉底 ① 确定性的追求 与智者派相对 ② 自知无知 与 德行即知识 ③ 未经审视的人生不值得过 ④ 苏格拉底之死 2.2 柏拉图 ① 洞穴隐喻 ② 四线段比喻 ③ 理念论 流变世界 - 理念世界 知识是理念世界的实体 学习都是忆旧 ④ 理想的人和理想国 2.3 亚里士多德 分科法： 理论学科 实践学科 创制学科 to exist - 实体 - 单一物 一切存在的实体都只能是单一物，而不能是抽象物。 （用于反对柏拉图的理念论） 逻辑：演绎推理。 核心 - 三段论 关于世界的本源 （人工物）四因说：质料、形式、动力、目的 （自然物） 潜能-现实 宇宙：洋葱模型 3. 希腊化、罗马时期和中世纪的哲学与宗教 3.1 快乐主义 ① 昔勒尼派 ② 伊壁鸠鲁主义 伊壁鸠鲁的三种快乐： 自然而必要：朋友、自由、思想、食物、蔽风雨处、衣服 自然但不必要：广宅、私人浴室、宴饮、鱼、肉 不自然又不必要：名望、权势 ③ 快乐是唯一的善 3.2 德性主义 ① 犬儒主义 ② 斯多葛主义 ③ 德性是唯一的善 ④ 依照自然和理性生活 我们个人的本性都是普遍本性的一部分，因此主要的善就是以一种顺其自然的方式生活。也就是一个人自己的本性和顺从普遍的本性。这就是按照德性而生活。 愿意的人，命运领着走；不愿意的人，命运牵着走。 塞涅卡 我是必然要死的，但难道我就必须呻吟而死吗？我必然是被囚禁的，但难道我就必须哀怨吗？我是必然要遭流放的，但是难道因此就有任何人能阻止我，使我不能欢笑、勇敢而又镇定了吗？ “那么我把你锁起来”。你说什么？锁起我来？你可以锁住我的腿，但是我的意志是你锁不了的，连宙斯都无法驯服它。 爱比克泰德 3.3 怀疑主义 主要人物：皮浪、恩披里克 核心思想： 归纳都不是确定的 演绎都不能带来新知识 演绎的前提归根结底来源于归纳 不存在任何确定性的知识​​​。 3.4 基督教哲学 基督教面临的问题： 上帝存在的证明 神正论 3.4.1 奥古斯丁 上帝赋予人自由意志。 3.4.2 托马斯·阿奎纳 上帝存在的后天证明（相对于过去的本体论证明）： 因果链证明 生物层次证明 特创论 … 4. 近代哲学的兴起 背景： ① 文艺复兴与宗教改革 ② 资本主义与科学革命 ③ 教权与皇权相争 ④ 新柏拉图主义兴起 ​​​​ 特点： 研究方向由本体论转向了认识论 主体性原则 认识论的两个方面： 认识的来源 认识可靠性的评价标准 4.0 两大主要阵营 经验主义：培根、洛克、贝克莱、休谟 理性主义：笛卡尔、斯宾诺莎、莱布尼兹 4.1 培根 ① 四假象说 ② 伟大的复兴 ③ 新工具： 归纳法-相对于基督教所推崇的亚里士多德的演绎法 4.2 笛卡尔 认识的评价标准：理性 认识的来源：天赋 ① 笛卡尔的方法： 普遍怀疑法 分析综合法 ② 身心关系 ③ 天赋观念 4.3 斯宾诺莎 上帝是万物的动因，一切事物都在上帝之中。 认识的来源：（单一的）上帝 4.4 莱布尼兹 认识的来源：有无数个本源。单子论。 4.5 洛克 ① 批判天赋观念 ② 感觉和内省 ③ 白板说 ④ 两种性质说 4.6 贝克莱 存在就是被感知 物是观念的集合 4.7 休谟 ① 激进经验主义 ② 怀疑论 ③ 否定因果律 否定因果律，挖去了科学的根基。 另一方面，当时科学所表现出的机械论[5]，可以说是挖去了神学的根基。 5. 德国唯心主义 5.1 康德 有两种东西，我对它们的思考越是深沉和持久，他们在我心灵中唤起的赞叹和敬畏就会越来越历久弥新，一是我们头顶浩瀚灿烂的星空，一是我们心中的道德律。 康德区分两种不同的理性： 一种是在我们的日常生活中运用，称为实践理性；另一种是在探索真理时所用，称为纯粹理性。 康德的认识模型： 物自体（thing-in-itself） ———————————— 感官 现象 感性直观：时间 、空间 知性范畴：质、量、关系、样式 理性理念：上帝、灵魂、世界 二律背反： 一 正题：世界在时间和空间上是有限的 反题：世界在时间和空间上是无限的 二 正题：世界上一切都由单一、不可分的部分构成的 反题：世界上没有单一的东西，一切都是复杂可分的 三 正题：世界上存在着自由 反题：没有自由，一切都是必然的 四 正题：存在着世界的最初原因 反题：没有世界的最初原因 《纯粹理性批判》指出形而上学中研究的诸问题（如意志自由、灵魂不朽、上帝存在）是不可证明的， 而《实践理性批判》则指出一个社会想要正常运转需要将它们作为假设相信。 附注： 关于辉格史观和移时可以 见此 ↩︎ logos 一词经常被翻译成“道”，但它与中国哲学中的“道”是不同的。logos 可以称之为“普遍的理性”（或谓之“言辞”）。相对的，中国哲学中的“道”是意境的，不可言明的。 ↩︎ Cosmos 其对应的反义词是 Chaos。 ↩︎ “朴素”一词在哲学中的的含义：未证实的。 ↩︎ Mechanism ，当时哲学和科学的两大传统之一；另一个是 Organism（有机论）。 ↩︎","categories":[{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miRoox.github.io/blog/categories/杂谈散记/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://miRoox.github.io/blog/tags/哲学/"},{"name":"笔记","slug":"笔记","permalink":"http://miRoox.github.io/blog/tags/笔记/"}]},{"title":"旧作：【翻译】MIX 文件格式","slug":"MIXFormat","date":"2017-03-25T02:12:33.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2017/03/MIXFormat/","link":"","permalink":"http://miRoox.github.io/blog/2017/03/MIXFormat/","excerpt":"原文地址 XCC Homepage 中 Documents -&gt; MIX File format 。 MIX 文件格式 Copyright Copyright © 2000 Olaf van der Spek This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 介绍 作者：Olaf van der Spek。 本文解释了命令与征服：泰伯利亚黎明、红色警戒、泰伯利亚之日使用的MIX文件的格式 MIX文件用于存储其他文件，与ZIP文件相同，但没有压缩。我将在本文档中使用C++表示法。","text":"原文地址 XCC Homepage 中 Documents -&gt; MIX File format 。 MIX 文件格式 Copyright Copyright © 2000 Olaf van der Spek This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 介绍 作者：Olaf van der Spek。 本文解释了命令与征服：泰伯利亚黎明、红色警戒、泰伯利亚之日使用的MIX文件的格式 MIX文件用于存储其他文件，与ZIP文件相同，但没有压缩。我将在本文档中使用C++表示法。 123typedef unsigned char byte;typedef unsigned short word;typedef unsigned long dword; 首部(Header) 一个MIX文件由两部分组成：一个首部和一个主体。首部存储有关文件数，总文件大小和每个内部文件的ID，偏移量和大小的信息 泰伯利亚黎明的MIX文件没有做加密，而红色警戒和泰伯利亚之日的MIX文件可能对首部的一部分使用了Blowfish算法加密。我将首先介绍泰伯利亚黎明的MIX文件。 12345struct t_mix_header&#123; __int16 c_files; // 内部文件数目 __int32 size; // 主体的大小，不包括这个首部和索引&#125;; 紧接在其后的是内部文件的索引。该索引由具有以下结构的C语言文件条目组成。 123456struct t_mix_index_entry&#123; unsigned __int32 id; // ID，代替一个正常的文件名来标识文件 __int32 offset; // 相对主体开头的偏移量 __int32 size; // 这个内部文件的大小&#125;; 在这个索引之后是实际主体的开头。 现在来介绍泰伯利亚之日/红色警戒的MIX文件。它始于一个32位的标记(flag)，这个标记表明这个MIX文件是否有校验和(checksum)以及是否已经被加密。 12const int mix_checksum = 0x00010000;const int mix_encrypted = 0x00020000; 如果一个MIX文件有校验和，那么在主体之后20字节处会包含一个校验和。这个校验和可以被忽略或删除。 如果这个MIX文件被加密了，那么在被称为key_source的标记之后有一80字节的块。它可以用于计算Blowfish算法的密钥。如果MIX文件没被加密，那么这个标记之后将会是一个普通的首部。 好了，MIX文件的首部使56字节密钥的Blowfish算法加密。这意味着在key_source之后，存在许多需要解密的8字节块。你可以通过解密包含MIX首部的第一个区域来知道有多少个区域。然后查看这里有多少个内部文件并计算首部和索引的大小。 IDs ID用于标识每个文件。它们可以从原始的文件名中计算出来。这里有两个不同的版本来计算ID，一个用于泰伯利亚黎明和红色警戒而另一个用于泰伯利亚之日。我使用如下的代码来计算ID。 12345678910111213141516171819202122232425262728293031323334353637383940int Cmix_file::get_id(t_game game, string name)&#123; name = to_upper(name); // 转换为大写 if (game != game_ts) &#123; // 用于泰伯利亚黎明和红色警戒 int i = 0; unsigned int id = 0; int l = name.length(); // 文件名长度 while (i &lt; l) &#123; unsigned int a = 0; for (int j = 0; j &lt; 4; j++) &#123; a &gt;&gt;= 8; if (i &lt; l) a += static_cast&lt;unsigned int&gt;(name[i]) &lt;&lt; 24; i++; &#125; id = (id &lt;&lt; 1 | id &gt;&gt; 31) + a; &#125; return id; &#125; else &#123; // 用于泰伯利亚之日 const int l = name.length(); int a = l &gt;&gt; 2; if (l &amp; 3) &#123; name += static_cast&lt;char&gt;(l - (a &lt;&lt; 2)); int i = 3 - (l &amp; 3); while (i--) name += name[a &lt;&lt; 2]; &#125; Ccrc crc; // 使用普通的CRC(循环冗余校验?)函数 crc.init(); crc.do_block(name.c_str(), name.length()); return crc.get_crc(); &#125;&#125; 主体 主体包含未压缩和未加密格式的内部文件。 校验和 关于校验和，目前唯一知道的只有它有20字节长。只要你修改对应的标记，你就可以安全的删去它。 Blowfish算法 在MIX文件中，Blowfish算法用于加密和解密首部。你可以使用这个代码来加密/解密首部。首先，你需要用set_key来设置密钥。这不是80字节的key_source，所以你首先要用下面关于WS密钥计算的代码来计算密钥。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423typedef dword t_bf_p[18];typedef dword t_bf_s[4][256];class Cblowfish&#123;public: void set_key(const byte* key, int cb_key); void encipher(dword&amp; xl, dword&amp; xr) const; void encipher(const void* s, void* d, int size) const; void decipher(dword&amp; xl, dword&amp; xr) const; void decipher(const void* s, void* d, int size) const;private: inline dword Cblowfish::S(dword x, int i) const; inline dword Cblowfish::bf_f(dword x) const; inline void Cblowfish::ROUND(dword&amp; a, dword b, int n) const; t_bf_p m_p; t_bf_s m_s;&#125;;const t_bf_p p = &#123; 0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89, 0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 0x9216d5d9, 0x8979fb1b&#125;;const t_bf_s s = &#123; 0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e, 0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013, 0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e, 0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440, 0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a, 0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193, 0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032, 0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239, 0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0, 0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe, 0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d, 0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463, 0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09, 0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb, 0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8, 0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82, 0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573, 0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b, 0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4, 0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c, 0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1, 0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9, 0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf, 0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af, 0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915, 0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a, 0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266, 0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1, 0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1, 0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8, 0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd, 0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7, 0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331, 0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af, 0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87, 0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c, 0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd, 0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509, 0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a, 0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960, 0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28, 0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84, 0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf, 0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e, 0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281, 0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696, 0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73, 0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0, 0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105, 0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250, 0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285, 0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061, 0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc, 0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340, 0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7, 0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068, 0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840, 0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504, 0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb, 0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6, 0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b, 0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b, 0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c, 0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc, 0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564, 0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115, 0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728, 0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0, 0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e, 0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d, 0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b, 0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb, 0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c, 0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9, 0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe, 0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc, 0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9, 0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c, 0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169, 0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027, 0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62, 0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634, 0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76, 0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc, 0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c, 0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0, 0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe, 0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b, 0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6, 0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22, 0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59, 0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c, 0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28, 0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd, 0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319, 0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f, 0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166, 0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb, 0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47, 0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370, 0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048, 0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd, 0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f, 0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525, 0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e, 0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299, 0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc, 0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a, 0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b, 0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060, 0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f, 0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6&#125;;void Cblowfish::set_key(const byte* key, int cb_key)&#123; int i, j; dword datal, datar; memcpy(m_p, p, sizeof(t_bf_p)); memcpy(m_s, s, sizeof(t_bf_s)); j = 0; for (i = 0; i &lt; 18; i++) &#123; int a = key[j++]; j %= cb_key; int b = key[j++]; j %= cb_key; int c = key[j++]; j %= cb_key; int d = key[j++]; j %= cb_key; m_p[i] ^= a &lt;&lt; 24 | b &lt;&lt; 16 | c &lt;&lt; 8 | d; &#125; datal = datar = 0; for (i = 0; i &lt; 18;) &#123; encipher(datal, datar); m_p[i++] = datal; m_p[i++] = datar; &#125; for (i = 0; i &lt; 4; i++) &#123; for (j = 0; j &lt; 256;) &#123; encipher(datal, datar); m_s[i][j++] = datal; m_s[i][j++] = datar; &#125; &#125;&#125;inline dword Cblowfish::S(dword x, int i) const&#123; return m_s[i][(x &gt;&gt; ((3 - i) &lt;&lt; 3)) &amp; 0xff];&#125;inline dword Cblowfish::bf_f(dword x) const&#123; return ((S(x, 0) + S(x, 1)) ^ S(x, 2)) + S(x, 3);&#125;inline void Cblowfish::ROUND(dword&amp; a, dword b, int n) const&#123; a ^= bf_f(b) ^ m_p[n];&#125;void Cblowfish::encipher(dword&amp; xl, dword&amp; xr) const&#123; dword Xl = xl; dword Xr = xr; Xl ^= m_p[0]; ROUND (Xr, Xl, 1); ROUND (Xl, Xr, 2); ROUND (Xr, Xl, 3); ROUND (Xl, Xr, 4); ROUND (Xr, Xl, 5); ROUND (Xl, Xr, 6); ROUND (Xr, Xl, 7); ROUND (Xl, Xr, 8); ROUND (Xr, Xl, 9); ROUND (Xl, Xr, 10); ROUND (Xr, Xl, 11); ROUND (Xl, Xr, 12); ROUND (Xr, Xl, 13); ROUND (Xl, Xr, 14); ROUND (Xr, Xl, 15); ROUND (Xl, Xr, 16); Xr ^= m_p[17]; xr = Xl; xl = Xr;&#125;void Cblowfish::decipher(dword&amp; xl, dword&amp; xr) const&#123; dword Xl = xl; dword Xr = xr; Xl ^= m_p[17]; ROUND (Xr, Xl, 16); ROUND (Xl, Xr, 15); ROUND (Xr, Xl, 14); ROUND (Xl, Xr, 13); ROUND (Xr, Xl, 12); ROUND (Xl, Xr, 11); ROUND (Xr, Xl, 10); ROUND (Xl, Xr, 9); ROUND (Xr, Xl, 8); ROUND (Xl, Xr, 7); ROUND (Xr, Xl, 6); ROUND (Xl, Xr, 5); ROUND (Xr, Xl, 4); ROUND (Xl, Xr, 3); ROUND (Xr, Xl, 2); ROUND (Xl, Xr, 1); Xr ^= m_p[0]; xl = Xr; xr = Xl;&#125;static inline dword reverse(dword v)&#123; _asm &#123; mov eax, v xchg al, ah rol eax, 16 xchg al, ah mov v, eax &#125; return v;&#125;void Cblowfish::encipher(const void* s, void* d, int size) const&#123; const dword* r = reinterpret_cast&lt;const dword*&gt;(s); dword* w = reinterpret_cast&lt;dword*&gt;(d); size &gt;&gt;= 3; while (size--) &#123; dword a = reverse(*r++); dword b = reverse(*r++); encipher(a, b); *w++ = reverse(a); *w++ = reverse(b); &#125;&#125;void Cblowfish::decipher(const void* s, void* d, int size) const&#123; const dword* r = reinterpret_cast&lt;const dword*&gt;(s); dword* w = reinterpret_cast&lt;dword*&gt;(d); size &gt;&gt;= 3; while (size--) &#123; dword a = reverse(*r++); dword b = reverse(*r++); decipher(a, b); *w++ = reverse(a); *w++ = reverse(b); &#125;&#125; CRC 在MIX文件中，CRC用来计算一个文件的ID。你可以使用这个代码来计算一个文件名的ID，但你也能用它来计算其它东西的CRC，例如一个文件。这与ZIP文件使用的CRC相同。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Ccrc&#123;public: void do_block(const void* data, int size); void init() &#123; m_crc = 0; &#125; int get_crc() const &#123; return m_crc; &#125;private: unsigned int m_crc;&#125;;int crc_table[256] = &#123; 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d&#125;;void Ccrc::do_block(const void* data, int size)&#123; const unsigned char* r = reinterpret_cast&lt;const unsigned char*&gt;(data); m_crc = ~m_crc; while (size--) m_crc = (m_crc &gt;&gt; 8) ^ crc_table[*r++ ^ (m_crc &amp; 0xff)]; m_crc = ~m_crc;&#125; WS密钥计算 这部分涵盖了Westwood Studio的密钥计算。这是一个将80字节的key_source作为输入并输出56字节的密钥的函数。它使用一个非常大的整数算法。你需要调用的函数是void get_blowfish_key(const byte* s, byte* d)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423char *pubkey_str = \"AihRvNoIbTn85FZRYNZRcT+i6KpU+maCsEqr3Q5q+LDB5tH7Tz2qQ38V\";const static char char2num[] = &#123; -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1&#125;;typedef dword bignum4[4];typedef dword bignum[64];typedef dword bignum130[130];struct&#123; bignum key1; bignum key2; dword len;&#125; pubkey;bignum glob1;dword glob1_bitlen, glob1_len_x2;bignum130 glob2;bignum4 glob1_hi, glob1_hi_inv;dword glob1_hi_bitlen;dword glob1_hi_inv_lo, glob1_hi_inv_hi;static void init_bignum(bignum n, dword val, dword len)&#123; memset((void *)n, 0, len * 4); n[0] = val;&#125;static void move_key_to_big(bignum n, char *key, dword klen, dword blen)&#123; dword sign; int i; if (key[0] &amp; 0x80) sign = 0xff; else sign = 0; for (i = blen*4; i &gt; klen; i--) ((char *)n)[i-1] = sign; for (; i &gt; 0; i--) ((char *)n)[i-1] = key[klen-i];&#125;static void key_to_bignum(bignum n, char *key, dword len)&#123; dword keylen; int i; if (key[0] != 2) return; key++; if (key[0] &amp; 0x80) &#123; keylen = 0; for (i = 0; i &lt; (key[0] &amp; 0x7f); i++) keylen = (keylen &lt;&lt; 8) | key[i+1]; key += (key[0] &amp; 0x7f) + 1; &#125; else &#123; keylen = key[0]; key++; &#125; if (keylen &lt;= len*4) move_key_to_big(n, key, keylen, len);&#125;static dword len_bignum(bignum n, dword len)&#123; int i; i = len-1; while ((i &gt;= 0) &amp;&amp; (n[i] == 0)) i--; return i+1;&#125;static dword bitlen_bignum(bignum n, dword len)&#123; dword ddlen, bitlen, mask; ddlen = len_bignum(n, len); if (ddlen == 0) return 0; bitlen = ddlen * 32; mask = 0x80000000; while ((mask &amp; n[ddlen-1]) == 0) &#123; mask &gt;&gt;= 1; bitlen--; &#125; return bitlen;&#125;static void init_pubkey()&#123; dword i, i2, tmp; char keytmp[256]; init_bignum(pubkey.key2, 0x10001, 64); i = 0; i2 = 0; while (i &lt; strlen(pubkey_str)) &#123; tmp = char2num[pubkey_str[i++]]; tmp &lt;&lt;= 6; tmp |= char2num[pubkey_str[i++]]; tmp &lt;&lt;= 6; tmp |= char2num[pubkey_str[i++]]; tmp &lt;&lt;= 6; tmp |= char2num[pubkey_str[i++]]; keytmp[i2++] = (tmp &gt;&gt; 16) &amp; 0xff; keytmp[i2++] = (tmp &gt;&gt; 8) &amp; 0xff; keytmp[i2++] = tmp &amp; 0xff; &#125; key_to_bignum(pubkey.key1, keytmp, 64); pubkey.len = bitlen_bignum(pubkey.key1, 64) - 1;&#125;static dword len_predata()&#123; dword a = (pubkey.len - 1) / 8; return (55 / a + 1) * (a + 1);&#125;static long int cmp_bignum(bignum n1, bignum n2, dword len)&#123; n1 += len-1; n2 += len-1; while (len &gt; 0) &#123; if (*n1 &lt; *n2) return -1; if (*n1 &gt; *n2) return 1; n1--; n2--; len--; &#125; return 0;&#125;static void mov_bignum(bignum dest, bignum src, dword len)&#123; memmove(dest, src, len*4);&#125;static void shr_bignum(bignum n, dword bits, long int len)&#123; dword i, i2; i2 = bits / 32; if (i2 &gt; 0) &#123; for (i = 0; i &lt; len - i2; i++) n[i] = n[i + i2]; for (; i &lt; len; i++) n[i] = 0; bits = bits % 32; &#125; if (bits == 0) return; for (i = 0; i &lt; len - 1; i++) n[i] = (n[i] &gt;&gt; bits) | (n[i + 1] &lt;&lt; (32 -bits)); n[i] = n[i] &gt;&gt; bits;&#125;static void shl_bignum(bignum n, dword bits, dword len)&#123; dword i, i2; i2 = bits / 32; if (i2 &gt; 0) &#123; for (i = len - 1; i &gt; i2; i--) n[i] = n[i - i2]; for (; i &gt; 0; i--) n[i] = 0; bits = bits % 32; &#125; if (bits == 0) return; for (i = len - 1; i &gt; 0; i--) n[i] = (n[i] &lt;&lt; bits) | (n[i - 1] &gt;&gt; (32 -bits)); n[0] &lt;&lt;= bits;&#125;static dword sub_bignum(bignum dest, bignum src1, bignum src2, dword carry, dword len)&#123; dword i1, i2; len += len; while (--len != -1) &#123; i1 = *(word *)src1; i2 = *(word *)src2; *(word *)dest = i1 - i2 - carry; src1 = (dword *)(((word *)src1) + 1); src2 = (dword *)(((word *)src2) + 1); dest = (dword *)(((word *)dest) + 1); if ((i1 - i2 - carry) &amp; 0x10000) carry = 1; else carry = 0; &#125; return carry;&#125;static void inv_bignum(bignum n1, bignum n2, dword len)&#123; bignum n_tmp; dword n2_bytelen, bit; long int n2_bitlen; init_bignum(n_tmp, 0, len); init_bignum(n1, 0, len); n2_bitlen = bitlen_bignum(n2, len); bit = ((dword)1) &lt;&lt; (n2_bitlen % 32); n1 += ((n2_bitlen + 32) / 32) - 1; n2_bytelen = ((n2_bitlen - 1) / 32) * 4; n_tmp[n2_bytelen / 4] |= ((dword)1) &lt;&lt; ((n2_bitlen - 1) &amp; 0x1f); while (n2_bitlen &gt; 0) &#123; n2_bitlen--; shl_bignum(n_tmp, 1, len); if (cmp_bignum(n_tmp, n2, len) != -1) &#123; sub_bignum(n_tmp, n_tmp, n2, 0, len); *n1 |= bit; &#125; bit &gt;&gt;= 1; if (bit == 0) &#123; n1--; bit = 0x80000000; &#125; &#125; init_bignum(n_tmp, 0, len);&#125;static void inc_bignum(bignum n, dword len)&#123; while ((++*n == 0) &amp;&amp; (--len &gt; 0)) n++;&#125;static void init_two_dw(bignum n, dword len)&#123; mov_bignum(glob1, n, len); glob1_bitlen = bitlen_bignum(glob1, len); glob1_len_x2 = (glob1_bitlen + 15) / 16; mov_bignum(glob1_hi, glob1 + len_bignum(glob1, len) - 2, 2); glob1_hi_bitlen = bitlen_bignum(glob1_hi, 2) - 32; shr_bignum(glob1_hi, glob1_hi_bitlen, 2); inv_bignum(glob1_hi_inv, glob1_hi, 2); shr_bignum(glob1_hi_inv, 1, 2); glob1_hi_bitlen = (glob1_hi_bitlen + 15) % 16 + 1; inc_bignum(glob1_hi_inv, 2); if (bitlen_bignum(glob1_hi_inv, 2) &gt; 32) &#123; shr_bignum(glob1_hi_inv, 1, 2); glob1_hi_bitlen--; &#125; glob1_hi_inv_lo = *(word *)glob1_hi_inv; glob1_hi_inv_hi = *(((word *)glob1_hi_inv) + 1);&#125;static void mul_bignum_word(bignum n1, bignum n2, dword mul, dword len)&#123; dword i, tmp; tmp = 0; for (i = 0; i &lt; len; i++) &#123; tmp = mul * (*(word *)n2) + *(word *)n1 + tmp; *(word *)n1 = tmp; n1 = (dword *)(((word *)n1) + 1); n2 = (dword *)(((word *)n2) + 1); tmp &gt;&gt;= 16; &#125; *(word *)n1 += tmp;&#125;static void mul_bignum(bignum dest, bignum src1, bignum src2, dword len)&#123; dword i; init_bignum(dest, 0, len*2); for (i = 0; i &lt; len*2; i++) &#123; mul_bignum_word(dest, src1, *(word *)src2, len*2); src2 = (dword *)(((word *)src2) + 1); dest = (dword *)(((word *)dest) + 1); &#125;&#125;static void not_bignum(bignum n, dword len)&#123; dword i; for (i = 0; i &lt; len; i++) *(n++) = ~*n;&#125;static void neg_bignum(bignum n, dword len)&#123; not_bignum(n, len); inc_bignum(n, len);&#125;static dword get_mulword(bignum n)&#123; dword i; word *wn; wn = (word *)n; i = (((((((((*(wn-1) ^ 0xffff) &amp; 0xffff) * glob1_hi_inv_lo + 0x10000) &gt;&gt; 1) + (((*(wn-2) ^ 0xffff) * glob1_hi_inv_hi + glob1_hi_inv_hi) &gt;&gt; 1) + 1) &gt;&gt; 16) + ((((*(wn-1) ^ 0xffff) &amp; 0xffff) * glob1_hi_inv_hi) &gt;&gt; 1) + (((*wn ^ 0xffff) * glob1_hi_inv_lo) &gt;&gt; 1) + 1) &gt;&gt; 14) + glob1_hi_inv_hi * (*wn ^ 0xffff) * 2) &gt;&gt; glob1_hi_bitlen; if (i &gt; 0xffff) i = 0xffff; return i &amp; 0xffff;&#125;static void dec_bignum(bignum n, dword len)&#123; while ((--*n == 0xffffffff) &amp;&amp; (--len &gt; 0)) n++;&#125;static void calc_a_bignum(bignum n1, bignum n2, bignum n3, dword len)&#123; dword g2_len_x2, len_diff; word *esi, *edi; word tmp; mul_bignum(glob2, n2, n3, len); glob2[len*2] = 0; g2_len_x2 = len_bignum(glob2, len*2+1)*2; if (g2_len_x2 &gt;= glob1_len_x2) &#123; inc_bignum(glob2, len*2+1); neg_bignum(glob2, len*2+1); len_diff = g2_len_x2 + 1 - glob1_len_x2; esi = ((word *)glob2) + (1 + g2_len_x2 - glob1_len_x2); edi = ((word *)glob2) + (g2_len_x2 + 1); for (; len_diff != 0; len_diff--) &#123; edi--; tmp = get_mulword((dword *)edi); esi--; if (tmp &gt; 0) &#123; mul_bignum_word((dword *)esi, glob1, tmp, 2*len); if ((*edi &amp; 0x8000) == 0) &#123; if (sub_bignum((dword *)esi, (dword *)esi, glob1, 0, len)) (*edi)--; &#125; &#125; &#125; neg_bignum(glob2, len); dec_bignum(glob2, len); &#125; mov_bignum(n1, glob2, len);&#125;static void clear_tmp_vars(dword len)&#123; init_bignum(glob1, 0, len); init_bignum(glob2, 0, len); init_bignum(glob1_hi_inv, 0, 4); init_bignum(glob1_hi, 0, 4); glob1_bitlen = 0; glob1_hi_bitlen = 0; glob1_len_x2 = 0; glob1_hi_inv_lo = 0; glob1_hi_inv_hi = 0;&#125;static void calc_a_key(bignum n1, bignum n2, bignum n3, bignum n4, dword len)&#123; bignum n_tmp; dword n3_len, n4_len, n3_bitlen, bit_mask; init_bignum(n1, 1, len); n4_len = len_bignum(n4, len); init_two_dw(n4, n4_len); n3_bitlen = bitlen_bignum(n3, n4_len); n3_len = (n3_bitlen + 31) / 32; bit_mask = (((dword)1) &lt;&lt; ((n3_bitlen - 1) % 32)) &gt;&gt; 1; n3 += n3_len - 1; n3_bitlen--; mov_bignum(n1, n2, n4_len); while (--n3_bitlen != -1) &#123; if (bit_mask == 0) &#123; bit_mask = 0x80000000; n3--; &#125; calc_a_bignum(n_tmp, n1, n1, n4_len); if (*n3 &amp; bit_mask) calc_a_bignum(n1, n_tmp, n2, n4_len); else mov_bignum(n1, n_tmp, n4_len); bit_mask &gt;&gt;= 1; &#125; init_bignum(n_tmp, 0, n4_len); clear_tmp_vars(len);&#125;static void process_predata(const byte* pre, dword pre_len, byte *buf)&#123; bignum n2, n3; const dword a = (pubkey.len - 1) / 8; while (a + 1 &lt;= pre_len) &#123; init_bignum(n2, 0, 64); memmove(n2, pre, a + 1); calc_a_key(n3, n2, pubkey.key2, pubkey.key1, 64); memmove(buf, n3, a); pre_len -= a + 1; pre += a + 1; buf += a; &#125;&#125;void get_blowfish_key(const byte* s, byte* d)&#123; static public_key_initialized = false; if (!public_key_initialized) &#123; init_pubkey(); public_key_initialized = true; &#125; byte key[256]; process_predata(s, len_predata(), key); memcpy(d, key, 56);&#125; 链接 http://www.counterpane.com/blowfish.html","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"},{"name":"翻译作品","slug":"翻译作品","permalink":"http://miRoox.github.io/blog/categories/翻译作品/"}],"tags":[{"name":"红警","slug":"红警","permalink":"http://miRoox.github.io/blog/tags/红警/"},{"name":"翻译","slug":"翻译","permalink":"http://miRoox.github.io/blog/tags/翻译/"},{"name":"参考","slug":"参考","permalink":"http://miRoox.github.io/blog/tags/参考/"},{"name":"文件格式","slug":"文件格式","permalink":"http://miRoox.github.io/blog/tags/文件格式/"}]},{"title":"旧作：借助卷积定理证明中心极限定理","slug":"ProveCRTWithConvolution","date":"2016-12-10T01:49:11.000Z","updated":"2020-01-23T12:17:55.000Z","comments":true,"path":"2016/12/ProveCRTWithConvolution/","link":"","permalink":"http://miRoox.github.io/blog/2016/12/ProveCRTWithConvolution/","excerpt":"摘要 ：中心极限定理的研究在概率论具有重要地位，它揭示了大量独立同分布的的随机变量之和的极限趋势为正态分布，在统计学以及其它许多学科中都有重要的应用。但教材[1]中并没有给出其具体证明。本文将从傅里叶变换中的卷积定理的角度证明该定理。 关键词 ：中心极限定理, 傅里叶变换, 卷积定理","text":"摘要 ：中心极限定理的研究在概率论具有重要地位，它揭示了大量独立同分布的的随机变量之和的极限趋势为正态分布，在统计学以及其它许多学科中都有重要的应用。但教材[1]中并没有给出其具体证明。本文将从傅里叶变换中的卷积定理的角度证明该定理。 关键词 ：中心极限定理, 傅里叶变换, 卷积定理 引言 Everyone believes in it: experimentalists believing that it is a mathematical theorem, mathematicians believing that it is an empirical fact. [2] Henri Poincaré 对中心极限定理的研究实质上始于1733年棣莫弗（A. de Moirvre）对二项分布的极限分布的研究，并得到了拉普拉斯（P.-S. Laplace）、泊松（S.-D. Possion）、贝塞尔（A.L. Bessel）、柯西（A.-L. Cauchy）等人的进一步研究和推广。但总体上，由于当时概率论不太受数学家重视，中心极限定理在很长一段时间没有得到一个完整的严格证明，直到1901年李雅普诺夫（A.M. Lyapunov）借助特征函数的工具才有了一个条件较为宽松的严格证明。[3] 一个常用的中心极限定理如下：[1] 定理 1 （独立同分布的中心极限定理） 如果随机变量序列 X1,X2,⋯ ,Xn,⋯X_{1},X_{2},\\cdots ,X_{n},\\cdotsX1​,X2​,⋯,Xn​,⋯ 独立同分布，并且具有有限的数学期望和方差 E(Xi)=μ,D(Xi)=σ2&gt;0(i=1,2,3,⋯ )E(X_{i})=\\mu ,D(X_{i})=\\sigma ^{2}&gt;0 (i=1,2,3,\\cdots )E(Xi​)=μ,D(Xi​)=σ2&gt;0(i=1,2,3,⋯) ，则对一切 x∈Rx\\in {\\rm\\bf{R}}x∈R 有 lim⁡n→∞P(1nσ(∑i=1nXi−nμ)≤x)=∫−∞x12πe−t22dt\\lim_{n\\to\\infty} P\\left(\\frac{1}{\\sqrt{n}\\sigma}\\left(\\sum_{i=1}^{n}X_{i}-n\\mu \\right)\\le x\\right) = \\int_{-\\infty }^{x}\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^{2}}{2}}\\mathrm{d}t n→∞lim​P(n​σ1​(i=1∑n​Xi​−nμ)≤x)=∫−∞x​2π​1​e−2t2​dt 本文将以上述定理为例，从卷积定理的角度对其进行证明。 卷积定理及中心极限定理的证明 卷积、卷积与独立随机变量之和的关系 在傅里叶变换的语境下，卷积的概念如下：[4] 定义 1 （卷积） 给定定义在 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 上的函数 f1(t)f_{1}(t)f1​(t) 与 f2(t)f_{2}(t)f2​(t) ，称由含参变量 ttt 的广义积分所确定的函数 g(t)=∫−∞+∞f1(τ)f2(t−τ)dτg(t) = \\int_{-\\infty}^{+\\infty}f_{1}(\\tau)f_{2}(t-\\tau)\\mathrm{d}\\tau g(t)=∫−∞+∞​f1​(τ)f2​(t−τ)dτ 为函数 f1(t)f_{1}(t)f1​(t) 与 f2(t)f_{2}(t)f2​(t) 的卷积，记为 g(t)=f1(t)∗f2(t)g(t) = f_{1}(t) \\ast f_{2}(t) g(t)=f1​(t)∗f2​(t) 出于方便，我们只考虑连续型随机变量（离散型随机变量通常可以通过在连续型随机变量的概率密度函数中使用 Dirac δ 函数来表示）。我们注意到，对于独立随机变量 X1,X2X_{1},X_{2}X1​,X2​ ，其概率密度为 f1(x1),f2(x2)f_{1}(x_{1}),f_{2}(x_{2})f1​(x1​),f2​(x2​) ，那么对于任意的 Y∈RY\\in \\textbf{R}Y∈R ，都有 P(X1+X2≤Y)=∬x1+x2≤Yf1(x1)f2(x2)dx1dx2=∫−∞Y∫−∞+∞f1(x1)f2(y−x1)dx1dy=∫−∞Y(f1∗f2)(y)dy\\begin{aligned} P(X_{1}+X_{2}\\le Y) &amp;= \\iint_{x_{1}+x_{2}\\le Y}f_{1}(x_{1})f_{2}(x_{2})\\mathrm{d}x_{1}\\mathrm{d}x_{2} \\\\ &amp;= \\int_{-\\infty}^{Y}\\int_{-\\infty}^{+\\infty}f_{1}(x_{1})f_{2}(y-x_{1})\\mathrm{d}x_{1}\\mathrm{d}y \\\\ &amp;= \\int_{-\\infty}^{Y}(f_{1}\\ast f_{2})(y)\\mathrm{d}y \\end{aligned}P(X1​+X2​≤Y)​=∬x1​+x2​≤Y​f1​(x1​)f2​(x2​)dx1​dx2​=∫−∞Y​∫−∞+∞​f1​(x1​)f2​(y−x1​)dx1​dy=∫−∞Y​(f1​∗f2​)(y)dy​ 亦即，若记随机变量 Y=X1+X2Y=X_{1}+X_{2}Y=X1​+X2​，则其概率密度函数 fY(y)=(f1∗f2)(y)f_{Y}(y) = (f_{1}\\ast f_{2})(y) fY​(y)=(f1​∗f2​)(y) 归纳地，对于随机变量 Y=X1+X2+⋯+XnY=X_{1}+X_{2}+\\cdots+X_{n}Y=X1​+X2​+⋯+Xn​，其概率密度函数 fY(y)=(f1∗f2∗⋯∗fn)(y)f_{Y}(y) = (f_{1}\\ast f_{2} \\ast \\cdots \\ast f_{n})(y) fY​(y)=(f1​∗f2​∗⋯∗fn​)(y) 中心极限定理的证明 众所周知，傅里叶变换可以将函数的卷积变换为像函数的乘积，即所谓的卷积定理[5] 定理 2 （卷积定理） 给定两个函数f1(t),f2(t)f_{1}(t),f_{2}(t)f1​(t),f2​(t)，记F1(ω)=F[f1(t)],F2(ω)=F[f2(t)]F_{1}(\\omega)=\\mathscr{F} [f_{1}(t)],F_{2}(\\omega)=\\mathscr{F} [f_{2}(t)]F1​(ω)=F[f1​(t)],F2​(ω)=F[f2​(t)]，则 F[f1(t)∗f2(t)]=F1(ω)⋅F2(ω)\\mathscr{F} [f_{1}(t) \\ast f_{2}(t)] = F_{1}(\\omega)\\cdot F_{2}(\\omega) F[f1​(t)∗f2​(t)]=F1​(ω)⋅F2​(ω) 这样，独立的随机变量之和的概率密度函数的求解可以得到简化。 下面进行对定理 1 进行证明： 对于独立同分布的随机变量序列 X1,X2,⋯ ,Xn,⋯X_{1},X_{2},\\cdots ,X_{n},\\cdotsX1​,X2​,⋯,Xn​,⋯ ，具有相同的概率密度 f(x)f(x)f(x)，不妨取其期望 E(Xi)=0E(X_{i})=0E(Xi​)=0， 方差 D(Xi)=1D(X_{i})=1D(Xi​)=1（一般的，对于期望为 μ\\muμ，方差为 σ2\\sigma^{2}σ2 的随机变量 X′X&#x27;X′，总能通过变换 X=X′−μσX=\\frac{X&#x27;-\\mu}{\\sigma}X=σX′−μ​ 化为这种“标准”的形式）。另记随机变量 Yn=1n(∑i=1nXi)Y_{n} = \\frac{1}{\\sqrt{n}}\\left(\\sum_{i=1}^{n}X_{i} \\right) Yn​=n​1​(i=1∑n​Xi​) 其概率密度为 fn(y)=n(f∗⋯∗f⏟n)(ny)f_{n}(y) = \\sqrt{n}(\\underbrace{ f\\ast\\cdots\\ast f}_{n})(\\sqrt{n}y) fn​(y)=n​(nf∗⋯∗f​​)(n​y) 记 F[f(x)]=F(ω)\\mathscr{F}[f(x)]=F(\\omega)F[f(x)]=F(ω) ，对 fn(y)f_{n}(y)fn​(y) 做傅里叶变换 F[fn(y)]=F[n(f∗⋯∗f⏟n)(ny)]=nF[(f∗⋯∗f⏟n)(ny)]=(F(f∗⋯∗f⏟n))(ωn)=(F(ωn))n\\begin{aligned} \\mathscr{F} [f_{n}(y)] &amp;= \\mathscr{F} [\\sqrt{n}(\\underbrace{ f\\ast\\cdots\\ast f}_{n})(\\sqrt{n}y)] \\\\ &amp;= \\sqrt{n}\\mathscr{F} [(\\underbrace{ f\\ast\\cdots\\ast f}_{n})(\\sqrt{n}y)] \\\\ &amp;= (\\mathscr{F} (\\underbrace{ f\\ast\\cdots\\ast f}_{n}))\\left(\\frac{\\omega}{\\sqrt{n}}\\right) \\\\ &amp;= \\left(F\\left(\\frac{\\omega}{\\sqrt{n}}\\right)\\right)^{n} \\end{aligned}F[fn​(y)]​=F[n​(nf∗⋯∗f​​)(n​y)]=n​F[(nf∗⋯∗f​​)(n​y)]=(F(nf∗⋯∗f​​))(n​ω​)=(F(n​ω​))n​ 另一方面 F(ωn)=∫−∞+∞f(x)e−ıωnxdx(1)F\\left(\\frac{\\omega}{\\sqrt{n}}\\right) = \\int_{-\\infty}^{+\\infty}f(x)e^{-\\imath\\dfrac{\\omega}{\\sqrt{n}}x}\\mathrm{d}x \\tag{1} F(n​ω​)=∫−∞+∞​f(x)e−ın​ω​xdx(1) 注意到 ∣e−ıωnx∣=1\\left\\vert e^{-\\imath\\frac{\\omega}{\\sqrt{n}}x}\\right\\vert =1∣∣∣​e−ın​ω​x∣∣∣​=1，故上述积分绝对收敛。 对 e−ıωnxe^{-\\imath\\frac{\\omega}{\\sqrt{n}}x}e−ın​ω​x 做泰勒展开 F(ωn)=∫−∞+∞[1−ıωnx+12(ıωnx)2+Rn(x)]f(x)dx=∫−∞+∞f(x)dx−ıωn∫−∞+∞xf(x)dx−ω22n∫−∞+∞x2f(x)dx+∫−∞+∞Rn(x)f(x)dx=1−ω22n+∫−∞+∞Rn(x)f(x)dx\\begin{aligned} F\\left(\\frac{\\omega}{\\sqrt{n}}\\right) &amp;= \\int_{-\\infty}^{+\\infty} \\left[1 - \\imath\\dfrac{\\omega}{\\sqrt{n}}x + \\dfrac{1}{2}\\left(\\imath\\dfrac{\\omega}{\\sqrt{n}}x\\right)^{2} + R_{n}(x)\\right] f(x)\\mathrm{d}x \\\\ &amp;= \\int_{-\\infty}^{+\\infty}f(x)\\mathrm{d}x - \\imath\\dfrac{\\omega}{\\sqrt{n}}\\int_{-\\infty}^{+\\infty}xf(x)\\mathrm{d}x - \\dfrac{\\omega^{2}}{2n}\\int_{-\\infty}^{+\\infty}x^{2}f(x)\\mathrm{d}x + \\int_{-\\infty}^{+\\infty}R_{n}(x)f(x)\\mathrm{d}x \\\\ &amp;= 1-\\dfrac{\\omega^{2}}{2n} + \\int_{-\\infty}^{+\\infty}R_{n}(x)f(x)\\mathrm{d}x \\end{aligned}F(n​ω​)​=∫−∞+∞​[1−ın​ω​x+21​(ın​ω​x)2+Rn​(x)]f(x)dx=∫−∞+∞​f(x)dx−ın​ω​∫−∞+∞​xf(x)dx−2nω2​∫−∞+∞​x2f(x)dx+∫−∞+∞​Rn​(x)f(x)dx=1−2nω2​+∫−∞+∞​Rn​(x)f(x)dx​ 由于式(1)中的积分总是有限的，故上式中 ∫−∞+∞Rn(x)f(x)dx=o(1n),n→∞\\int_{-\\infty}^{+\\infty}R_{n}(x)f(x)\\mathrm{d}x=o\\left(\\frac{1}{n}\\right) \\qquad ,n\\to\\infty ∫−∞+∞​Rn​(x)f(x)dx=o(n1​),n→∞ 因而 lim⁡n→∞(F(ωn))n=lim⁡n→∞(1−ω22n+o(1n))n=e−ω22\\lim_{n\\to\\infty}\\left(F\\left(\\frac{\\omega}{\\sqrt{n}}\\right)\\right)^{n} = \\lim_{n\\to\\infty}\\left(1-\\frac{\\omega^{2}}{2n}+o\\left(\\frac{1}{n}\\right)\\right)^{n} = e^{-\\frac{\\omega^{2}}{2}}n→∞lim​(F(n​ω​))n=n→∞lim​(1−2nω2​+o(n1​))n=e−2ω2​ 对上式求傅里叶逆变换即可得 lim⁡n→∞fn(y)=F−1[e−ω22]=12πe−ω22\\lim_{n\\to\\infty}f_{n}(y) = \\mathscr{F}^{-1} \\left[e^{-\\frac{\\omega^{2}}{2}}\\right] = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{\\omega^{2}}{2}} n→∞lim​fn​(y)=F−1[e−2ω2​]=2π​1​e−2ω2​ 定理 1 得证。 类似地，只要将 YnY_{n}Yn​ 改写为 X1+X2+⋯+Xnn\\frac{X_{1}+X_{2}+\\cdots +X_{n}}{n}nX1​+X2​+⋯+Xn​​，按同样的方法不难得到大数定律。 结论 中心极限定理的研究曾在概率论中占据中心地位，而傅里叶变换对微分、积分、卷积等运算都具有简化的作用。将傅里叶变换运用到概率论中可以获得极大的便利，由于概率分布具有归一化的性质，因而对概率密度函数使用傅里叶变换总是可行的，实际上，概率论中的“特征函数”就是对概率密度函数的傅里叶变换，可以说，它的出现把概率理论的研究推上了一个新的台阶。 参考资料: [1]: 王勇主编 2014 大学数学. 概率论与数理统计 （北京：高等教育出版社） 第141页 [2]: JinZhihui 2013 正态分布的前世今生（下） http://cos.name/2013/01/story-of-normal-distribution-2/ [3]: 杨静, 邓明立 2013 中心极限定理的创立与发展 科学 Vol.65 No.5 [4]: 哈尔滨工业大学数学系组编；包革军，邢宇明，盖云英编 2013 复变函数与积分变换 （第三版） （北京：科学出版社） 第241页 [5]: 哈尔滨工业大学数学系组编；包革军，邢宇明，盖云英编 2013 复变函数与积分变换 （第三版） （北京：科学出版社） 第247页","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miRoox.github.io/blog/categories/数理科学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miRoox.github.io/blog/tags/数学/"},{"name":"概率论","slug":"概率论","permalink":"http://miRoox.github.io/blog/tags/概率论/"},{"name":"傅里叶变换","slug":"傅里叶变换","permalink":"http://miRoox.github.io/blog/tags/傅里叶变换/"}]},{"title":"旧作：【翻译】CSF文件格式","slug":"CSFFileFormat","date":"2016-12-07T16:24:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2016/12/CSFFileFormat/","link":"","permalink":"http://miRoox.github.io/blog/2016/12/CSFFileFormat/","excerpt":"原文链接 CSF文件格式 CSF文件存储了红色警戒2/尤里的复仇（也有将军/绝命时刻和其它可能）的字符串表。","text":"原文链接 CSF文件格式 CSF文件存储了红色警戒2/尤里的复仇（也有将军/绝命时刻和其它可能）的字符串表。 标头(The Header) CSF文件的标头有0x18个字节长。 它以如下方式构成 偏移量 类型 描述 0x00 char[4] “FSC” CSF文件的头部标识符。 如果这里不是“FSC”，游戏将不会加载这个文件。 0x04 DWORD CSF版本 CSF格式的版本号。 红警2、尤里的复仇、将军、绝命时刻以及BFME系列使用版本3。 救世传说(NOx)使用版本2。 这些版本间实际有什么差别是未知的。 感谢Siberian GRemlin提供了这些信息。 见此 0x08 DWORD 标签数 这个字符串表中全部标签的数目。 0x0C DWORD 字符串数 这个字符串表中全部字符串对的数目。 （一个字符串对由一个Unicode编码的Value和一个ASCII编码的ExtraValue组成，一个标签可以包含不止一个这样的字符串对，但实际上只有第一个字符串对的Value会被游戏所使用。） 0x10 DWORD （未使用） 这个部分不会被游戏所使用，这意味着它是没有用的。 如果需要，你可以在其中存储一个额外的信息标记，来让你的程序使用它（假如你想写一个程序来读取CSF文件）。 0x14 DWORD 语言 这个字符串表使用的语言。 参见下面的列表 语言 语言（DWORD类型）可以具有以下值（其他值将被识别为“未知”）： 0 = 美国（英语） * 1 = 英国（英语） 2 = 德语 * 3 = 法语 * 4 = 西班牙语 5 = 意大利语 6 = 日语 7 = 无意义(Jabberwockie) 8 = 韩语 * 9 = 汉语 * &gt;9 = 未知 * 红警2/尤里的复仇已经用这些语言发布。 标签(Labels) 在标头之后，跟着标签数据。 标签可以视为字符串表中的条目（例如：“GUI:OK”是一个标签）。 每个标签有一个 name （ASCII编码的字符串，例如“NAME:MTNK”）以及零或若干个字符串对。正如前面提到的，一个字符串对由一个Unicode编码的Value（例如：“灰熊坦克”）和一个ASCII编码的ExtraValue（在原版的ra2.csf/ra2md.csf中没有例子，也不会被游戏所使用）。 现在让我们来看看数据是如何在CSF文件中储存的： 标签标头(Label header) 标签的数据始于一个标签标头，它以如下方式构成： 偏移量 类型 描述 0x00 char[4] “LBL” 标签标识符 如果这里不是“LBL”，游戏将无法将后面的数据识别为标签数据，并且会读取后面的4字节。 0x04 DWORD 字符串对的数目 这是与这个标签关联的字符串对的数目。通常为1。 0x08 DWORD 标签长度(LabelNameLength) 此值保存后面的标签名称的大小。 0x0C char[LabelNameLength] 标签名 一个长度为偏移量为0x08的DWORD的 非 '\\0’终止的字符串。如果长度超过的话，剩下部分的会被截去。 ra2md.csf中的第一个标签可以在0x18处找到。 注：空格、制表符、换行符会从标签名中格式化出去，因此他们不能被使用。 值(Values) 其数据（字符串对）直接接在标签标头的后面。 这是它构成的方式： 偏移量 类型 描述 0x00 char[4] “RTS” 或 “WRTS” 标识符 “RTS”意味着这个标签 没有 ExtraValue。 “WRTS”意味着在Value数据后还跟着ExtraValue的数据（见下）。 其它任何数据都是无效的。 0x04 DWORD 值长度(ValueLength) 它保存后面的Unicode字符串（Value）的长度。 0x08 byte[ValueLength*2] 值(Value) 它保存 编码后的 标签的值(Value)。 注意它有ValueLength*2字节长，因为值是一个Unicode字符串，即每个字符是一个字(word)而不是一个字节(byte)。 将这里的数据解码成Unicode字符串时，注意 不是 每个字节都是值的数据（或者用0xFF减它，参见下面的示例）。 0x8+ValueLength*2 DWORD 额外值长度(ExtraValueLength) 这里保存了后面跟着的额外数据(ExtraValue)字符串的长度。 只有标识符为“WRTS”而不是“RTS”时，它以及后面的数据才会存在。 0x8+ValueLength*2+0x4 char[ExtraValueLength] 额外值(ExtraValue) 与标签名相似，这是一个长度为ExtraValueLength的非’\\0’终止的字符串。如果长度超过的话，剩下部分的会被截去。 将value解码 将value解码成Unicode字符串时，注意不是每个字节都是值的数据（或者用0xFF减它）。 一个C++的示例： 1234int ValueDataLength = ValueLength &lt;&lt; 1;for(int i = 0; i &lt; ValueDataLength; ++i) &#123; ValueData[i] = ~ValueData[i];&#125;","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"},{"name":"翻译作品","slug":"翻译作品","permalink":"http://miRoox.github.io/blog/categories/翻译作品/"}],"tags":[{"name":"红警","slug":"红警","permalink":"http://miRoox.github.io/blog/tags/红警/"},{"name":"翻译","slug":"翻译","permalink":"http://miRoox.github.io/blog/tags/翻译/"},{"name":"参考","slug":"参考","permalink":"http://miRoox.github.io/blog/tags/参考/"},{"name":"文件格式","slug":"文件格式","permalink":"http://miRoox.github.io/blog/tags/文件格式/"}]},{"title":"旧作：低观点下的线性微分方程的解法","slug":"LODESolutionUnderLowViewpoint","date":"2016-12-05T15:16:23.000Z","updated":"2020-01-25T03:16:52.000Z","comments":true,"path":"2016/12/LODESolutionUnderLowViewpoint/","link":"","permalink":"http://miRoox.github.io/blog/2016/12/LODESolutionUnderLowViewpoint/","excerpt":"低观点的话，就只能上技巧了吧？ 摘要 ：一种不涉及线性微分方程解的结构的方法。","text":"低观点的话，就只能上技巧了吧？ 摘要 ：一种不涉及线性微分方程解的结构的方法。 一阶常系数线性非齐次微分方程的另解 对于非齐次方程 y′=p(x)y+q(x)xxxx其中，q(x)≠0(1)y&#x27;=p(x)y+q(x)\\phantom{xxxx} \\text{其中，} q(x)\\neq 0 \\tag{1} y′=p(x)y+q(x)xxxx其中，q(x)​=0(1) 即 y′−p(x)y=q(x)y&#x27;-p(x)y=q(x) y′−p(x)y=q(x) 为了在上式左边得到导数乘法公式的形式 (f⋅g)′=f′⋅g+f⋅g′(2)(f\\cdot g)&#x27;=f&#x27;\\cdot g+f\\cdot g&#x27; \\tag{2} (f⋅g)′=f′⋅g+f⋅g′(2) 等式两边同乘 f(x)f(x)f(x) ，即 y′⋅f(x)−p(x)y⋅f(x)=q(x)f(x)(3)y&#x27;\\cdot f(x)-p(x)y\\cdot f(x)=q(x)f(x) \\tag{3} y′⋅f(x)−p(x)y⋅f(x)=q(x)f(x)(3) 比对公式(2)，f(x)f(x)f(x) 应满足 f′(x)=−p(x)f(x)f&#x27;(x)=-p(x)f(x)f′(x)=−p(x)f(x) 容易解得 f(x)=e−∫p(x)dx(4)f(x)=\\mathrm{e}^{-\\int p(x)dx} \\tag{4} f(x)=e−∫p(x)dx(4) （任意常数显然没有必要） 则(3)式可以化成 (y⋅f(x))′=q(x)f(x)(y\\cdot f(x))&#x27;=q(x)f(x)(y⋅f(x))′=q(x)f(x)，解得 y=1f(x)(C+∫q(x)f(x)dx)y=\\frac{1}{f(x)}(C+\\int q(x)f(x)dx) y=f(x)1​(C+∫q(x)f(x)dx) 再带入(4)，即有 y=e∫p(x)dx(C+∫q(x)e−∫p(x)dxdx)(5)y=\\mathrm{e}^{\\int p(x)dx}(C+\\int q(x)\\mathrm{e}^{-\\int p(x)dx}dx) \\tag{5} y=e∫p(x)dx(C+∫q(x)e−∫p(x)dxdx)(5) 本方法的核心在于凑出导数乘法公式形式，相当于再解一个齐次微分方程，思路比常数变易法要显然，因此也不必记忆公式，知道凑乘法的思路即可，而且容易推广到其它问题上（比如中值定理凑函数的问题，以及下面的高阶线性微分方程等）。 二阶常系数线性齐次方程 y′′+py′+qy=0y&#x27;&#x27;+py&#x27;+qy=0 y′′+py′+qy=0 令 p=−(r1+r2)p=-(r_{1}+r_{2})p=−(r1​+r2​), q=r1r2q=r_{1}r_{2}q=r1​r2​，即 r1,r2r_{1}, r_{2}r1​,r2​ 是 x2+px+q=0x^{2}+px+q=0x2+px+q=0 的根，显然存在。则 y′′−(r1+r2)y′+r1r2y=0 ⟹ (y′′−r1y′)−r2(y′−r1y)=0 ⟹ (y′−r1y)′−r2(y′−r1y)=0\\begin{aligned} y&#x27;&#x27;-(r_{1}+r_{2})y&#x27;+r_{1}r_{2}y&amp;=0 \\\\ \\implies (y&#x27;&#x27;-r_{1}y&#x27;)-r_{2}(y&#x27;-r_{1}y)&amp;=0 \\\\ \\implies (y&#x27;-r_{1}y)&#x27;-r_{2}(y&#x27;-r_{1}y)&amp;=0 \\end{aligned}y′′−(r1​+r2​)y′+r1​r2​y⟹(y′′−r1​y′)−r2​(y′−r1​y)⟹(y′−r1​y)′−r2​(y′−r1​y)​=0=0=0​ 可得 y′−r1y=C0er2x(6)y&#x27;-r_{1}y=C_{0}\\mathrm{e}^{r_{2}x} \\tag{6} y′−r1​y=C0​er2​x(6) 若 r1≠r2r_{1}\\neq r_{2}r1​​=r2​ ： 对(6)式两边同时乘 e−r1x\\mathrm{e}^{-r_{1}x}e−r1​x ，则有 e−r1xy′−r1e−r1xy=C0e(r2−r1)x ⟹ (e−r1xy)′=C0e(r2−r1)x ⟹ y=C0r2−r1er2x+C1er1x(7)\\begin{aligned} \\mathrm{e}^{-r_{1}x}y&#x27;-r_{1}\\mathrm{e}^{-r_{1}x}y&amp;=C_{0}\\mathrm{e}^{(r_{2}-r_{1})x} \\\\ \\implies (\\mathrm{e}^{-r_{1}x}y)&#x27;&amp;=C_{0}\\mathrm{e}^{(r_{2}-r_{1})x} \\\\ \\implies y&amp;=\\frac{C_{0}}{r_{2}-r_{1}}\\mathrm{e}^{r_{2}x}+C_{1}\\mathrm{e}^{r_{1}x} \\tag{7} \\end{aligned}e−r1​xy′−r1​e−r1​xy⟹(e−r1​xy)′⟹y​=C0​e(r2​−r1​)x=C0​e(r2​−r1​)x=r2​−r1​C0​​er2​x+C1​er1​x​(7) 不妨记 C2=C0r2−r1C_{2}=\\frac{C_{0}}{r_{2}-r_{1}}C2​=r2​−r1​C0​​ ，即 y=C2er2x+C1er1xy=C_{2}\\mathrm{e}^{r_{2}x}+C_{1}\\mathrm{e}^{r_{1}x} y=C2​er2​x+C1​er1​x 若 r1=r2r_{1}=r_{2}r1​=r2​ ，记作rrr ： 对(6)式两边同时乘 e−rx\\mathrm{e}^{-rx}e−rx ，则 e−rxy′−re−rxy=C0⇒(e−rxy)′=C0⇒y=C0xerx+C1erx(8)\\begin{aligned} \\mathrm{e}^{-rx}y&#x27;-r\\mathrm{e}^{-rx}y&amp;=C_{0} \\\\ \\Rightarrow (\\mathrm{e}^{-rx}y)&#x27;&amp;=C_{0} \\\\ \\Rightarrow y&amp;=C_{0}x\\mathrm{e}^{rx}+C_{1}\\mathrm{e}^{rx} \\tag{8} \\end{aligned}e−rxy′−re−rxy⇒(e−rxy)′⇒y​=C0​=C0​=C0​xerx+C1​erx​(8) 事实上，对(7)式取极限 r2→r1=rr_{2}\\rightarrow r_{1}=rr2​→r1​=r 亦可得到(8)式。 二阶常系数线性非齐次方程一般形式 y′′+py′+qy=f(x)y&#x27;&#x27;+py&#x27;+qy=f(x) y′′+py′+qy=f(x) 与齐次方程类似处理，(y′−r1y)′−r2(y′−r1y)=f(x)(y&#x27;-r_{1}y)&#x27;-r_{2}(y&#x27;-r_{1}y)=f(x)(y′−r1​y)′−r2​(y′−r1​y)=f(x) 实质上，这等价于两个一阶线性非齐次方程： u′−r2u=f(x)y′−r1y=u(x)\\begin{aligned} u&#x27;-r_{2}u&amp;=f(x) \\\\ y&#x27;-r_{1}y&amp;=u(x) \\end{aligned}u′−r2​uy′−r1​y​=f(x)=u(x)​ 利用之前一阶线性非齐次方程中方法即可解出yyy 一般地，对 nnn 阶常系数线性微分方程 y(n)+a1y(n−1)+⋯+any=f(x)y^{(n)}+a_{1}y^{(n-1)}+\\cdots +a_{n}y=f(x)y(n)+a1​y(n−1)+⋯+an​y=f(x) 等价于求解 nnn 个一阶非齐次微分方程： un′−rnun=f(x)un−1′−rn−1un−1=un(x)⋮u2′−r2u2=u3(x)y′−r1y=u2\\begin{aligned} u_{n}&#x27;-r_{n}u_{n}&amp;=f(x) \\\\ u_{n-1}&#x27;-r_{n-1}u_{n-1}&amp;=u_{n}(x) \\\\ &amp;\\vdots \\\\ u_{2}&#x27;-r_{2}u_{2}&amp;=u_{3}(x) \\\\ y&#x27;-r_{1}y&amp;=u_{2} \\end{aligned}un′​−rn​un​un−1′​−rn−1​un−1​u2′​−r2​u2​y′−r1​y​=f(x)=un​(x)⋮=u3​(x)=u2​​ （其中，r1,r2,⋯ ,rnr_{1},r_{2},\\cdots ,r_{n}r1​,r2​,⋯,rn​ 是代数方程 xn+a1xn−1+⋯+an=0x^{n}+a_{1}x^{n-1}+\\cdots +a_{n}=0xn+a1​xn−1+⋯+an​=0 的根） 二阶常系数线性非齐次方程特殊形式 y′′+py′+qy=eαx[P(x)cos⁡βx+Q(x)sin⁡βx](9)y&#x27;&#x27;+py&#x27;+qy=\\mathrm{e}^{\\alpha x} [ P(x)\\cos \\beta x+Q(x)\\sin \\beta x ] \\tag{9} y′′+py′+qy=eαx[P(x)cosβx+Q(x)sinβx](9) （其中 P(x),Q(x)P(x),Q(x)P(x),Q(x) 是 nnn 次多项式） 这是前面一般形式的一种特殊的情况，只需要注意如下两个事实： ①由欧拉恒等式 eıx=cos⁡x+ısin⁡x\\mathrm{e}^{\\imath x}=\\cos x+\\imath \\sin xeıx=cosx+ısinx，知上式右边可化为 S(x)eλxS(x)\\mathrm{e}^{\\lambda x} S(x)eλx 其中，λ=α+ıβ\\lambda =\\alpha +\\imath \\betaλ=α+ıβ，S(x)S(x)S(x)是适当的 nnn 次多项式； ②对于 nnn 次多项式 S(x)S(x)S(x)，若 λ≠0\\lambda \\neq 0λ​=0，则 ∫S(x)eλx=T(x)eλx+C\\int S(x)\\mathrm{e}^{\\lambda x}=T(x)\\mathrm{e}^{\\lambda x}+C ∫S(x)eλx=T(x)eλx+C 其中，T(x)T(x)T(x) 也是 nnn 次多项式。 由此不难得到，对式(9) 若 α+ıβ\\alpha +\\imath \\betaα+ıβ是方程x2+px+q=0x^{2}+px+q=0x2+px+q=0 的二重根 则 y=x2eαx[R(x)cos⁡βx+S(x)sin⁡βx]+C1xerx+C2erxy=x^{2}\\mathrm{e}^{\\alpha x} [ R(x)\\cos \\beta x+S(x)\\sin \\beta x ] +C_{1}x\\mathrm{e}^{rx}+C_{2}\\mathrm{e}^{rx}y=x2eαx[R(x)cosβx+S(x)sinβx]+C1​xerx+C2​erx 若 α+ıβ\\alpha +\\imath \\betaα+ıβ是方程x2+px+q=0x^{2}+px+q=0x2+px+q=0 的某个单根 则 y=xeαx[R(x)cos⁡βx+S(x)sin⁡βx]+C1er1x+C2er2xy=x\\mathrm{e}^{\\alpha x} [ R(x)\\cos \\beta x+S(x)\\sin \\beta x ] +C_{1}\\mathrm{e}^{r_{1}x}+C_{2}\\mathrm{e}^{r_{2}x}y=xeαx[R(x)cosβx+S(x)sinβx]+C1​er1​x+C2​er2​x 若 α+ıβ\\alpha +\\imath \\betaα+ıβ不是是方程x2+px+q=0x^{2}+px+q=0x2+px+q=0 的根 则 y=eαx[R(x)cos⁡βx+S(x)sin⁡βx]+C1er1x+C2er2xy=\\mathrm{e}^{\\alpha x} [ R(x)\\cos \\beta x+S(x)\\sin \\beta x ] +C_{1}\\mathrm{e}^{r_{1}x}+C_{2}\\mathrm{e}^{r_{2}x}y=eαx[R(x)cosβx+S(x)sinβx]+C1​er1​x+C2​er2​x 其中 R(x),S(x)R(x),S(x)R(x),S(x) 是待定的 nnn 次多项式，r1,r2r_{1},r_{2}r1​,r2​（或 rrr）是方程 x2+px+q=0x^{2}+px+q=0x2+px+q=0 的根（或重根）。 欧拉方程 xny(n)+a1xn−1y(n−1)+⋯+any=f(x)x^{n}y^{(n)}+a_{1}x^{n-1}y^{(n-1)}+\\cdots +a_{n}y=f(x) xny(n)+a1​xn−1y(n−1)+⋯+an​y=f(x) 令 x=etx=\\mathrm{e}^{t}x=et，有 xky(k)=ddt((ddt−1)((ddt−2)(⋯(ddt−(k−1))y⋯ )))x^{k}y^{(k)}=\\frac{d}{dt} \\left( \\left(\\frac{d}{dt}-1\\right) \\left( \\left(\\frac{d}{dt}-2\\right) \\left( \\cdots \\left(\\frac{d}{dt}-(k-1)\\right)y \\cdots \\right) \\right) \\right) xky(k)=dtd​((dtd​−1)((dtd​−2)(⋯(dtd​−(k−1))y⋯))) 则方程化为关于 ttt 的常系数线性微分方程，可按前面nnn阶常系数线性微分方程的方法求解。","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miRoox.github.io/blog/categories/数理科学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miRoox.github.io/blog/tags/数学/"},{"name":"微积分","slug":"微积分","permalink":"http://miRoox.github.io/blog/tags/微积分/"}]},{"title":"旧作：一点小思辨","slug":"LogicAndExperience","date":"2016-04-18T04:08:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2016/04/LogicAndExperience/","link":"","permalink":"http://miRoox.github.io/blog/2016/04/LogicAndExperience/","excerpt":"","text":"西方哲学导论课的老师举过一个例子：“一个方的三角形是圆的”，想以此来说明“逻辑的对象应当是可经验的”。 如果直接当一个原子命题处理的话看起来似乎是不满足排中律或者背反律，但我考虑了一下，觉得下面这种形式化才是适当的[1]： 论域：平面上所有三角形组成的集合。 Rx：x是方的。 Ox：x是圆的。 则前述命题：∀x(Rx ∧ Ox) 显然为假。 其否定：∃x(﹁Rx ∨ ﹁Ox) 显然为真。 这样看，背反律和排中律并没有出问题。 至于前面那种错误应该是因为论域“所有方的三角形组成的集合”本身是空集，而空集没有任何元素，自然无法讨论属于它的个体词构成的命题。[2] 但如果我们进一步考察“‘所有方的三角形组成的集合’本身是空集”的理由时，我们不得不重新思考“三角形”和“方的”这些从具体事物中抽象出来的理想化的一般结构的概念，很显然，下面的定义是符合我们直观的认识的： 三角形：一个图形是三角形，当且仅当这个图形是三个不在同一直线上的点由直线（线段）两两连接构成。 方的：一个图形是方的，当且仅当这个图形是凸多边形[3]且每个顶角都是直角。 不难证明，在平面上“…是三角形”和“…是方的”是一对互斥的性质，这样，“所有方的三角形组成的集合”即“所有既是三角形又是方的图形组成的集合”是空集。 但如果不是在平面上呢？ 当然，不是平面就不会有直线了，因而我们考虑直线更本质的特征，可以发现“直线（段）是连接连接平面上两点的所有曲线中最短的”，即所谓的“测地线”。 这样，我们给出“三角形”更一般的定义：一个图形是三角形，当且仅当这个图形是三个不在同一测地线上的点由测地线（线段）两两连接构成。 一般的多边形类似。 现在让我们考虑一个简单的特例——球面几何。 球面的测地线即球的大圆，我们发现很容易找到一个既是“三角形”又是“方的”图形（在球面上标注经纬线，两个相距90°的经线和赤道围成的图形，每个顶角都是直角，也是凸多边形（包围区域是个凸集），而且也是是三个不在同一大圆上的点由大圆（弧）两两连接构成），而圆是“其上所有点到某定点的距离相等的点”这在球面几何上也没有必要更改。 这样，作为一个原子命题的原命题“一个方的三角形是圆的”为假是显然的了，而其否定“一个方的三角形不是圆的”则为真。 而我们知道，球面几何的一切规则都是内蕴的[4]，一个人完全可以在不清楚球面几何的直观模型下只基于公理得出同样的结论。这样来看，逻辑似乎可以对那些非经验的，逻辑自身衍生出来的对象做出一些有意义的处理。[5] 上面这个论证可以说是漏洞百出，我重看的时候简直不堪卒读，我虽然多次让自己警惕论证的“言辞陷阱”，却还是掉了进去QAQ。那些论证看似在摆脱概念，但实际上又完全陷入了概念的泥淖。 最大的问题是概念的同一性，虽然关于“三角形”和“方的”的第二种概念与第一种概念以及我们的俗常观念是相容的，但这绝不意味着第二种概念与我们原始命题“一个方的三角形是圆的”里相应的概念是等同的。 这里的问题在于“一个方的三角形”不与任何我们经验的概念对应，这时，言辞成了纯粹的形式，“一个方的三角形”本身无法在我们的常俗语境中确定，因而是“无意义”的，我们的讨论陷入了一个困境——语境缺失。 为了解决这个问题，我重新考察了这些概念（分解后）在常俗语境下的定义。[6]值得注意的是，这种考察本身已经脱离了我们的常俗语境，重构出了新的语境，在这个语境下，我们使用了一些原本语境中不存在的语词来分析，“三角形”等概念虽然由于恰当定义的原因还没有发生畸变，却已经具有充分的广延性，这时，“规范滑坡”[7]已经发生了。而后借助重定义推广“三角形”等词的概念，一番波折后，居然把全新语境下的概念套用到了原始命题上，完全脱离了命题原本的含义，只留下一个形式的壳被我翻来覆去地套在不同的内涵上。 出现这种情况的原因在于，这些语境都有公共的语词，如“三角形”等，为了将他们联系起来，我预设了一个更宽泛的公共语境，而这个而这个超经验的公共语境的合理性是我们无法证明的，于是出现了泛化的“无边界讨论”。 论述的谬误澄清了之后，让我们再回到原本的问题：“逻辑的对象是否应该是可经验的？” 这个问题的困难在于，对于不可经验的对象，我们不能保证正确地把握它，而我们似乎已经找到了这样的命题，让我们的逻辑律出现了悖谬。另一方面，来自数学的证言似乎又给我们一线生机，它所基于的演绎系统似乎完全是超经验的，却又无比正确。好，简单地考察一下，两句话的两个“正确”的判定标准显然不同，前者是符合经验，后者是符合逻辑。也就是说，这些不过是同义反复罢了，再一次落入了语词的陷阱。 但这也给我们指出了一条明路，我们将考察一些预设。对于“逻辑的对象是否应该是可经验的”的判断总是无法避免地需要引入“正确”或者类似的概念，而判定的标准本身总归会涉及“经验的”或者“逻辑的”，在各个不同的范式中，同义反复似乎是不可避免的。我们或许可以按照证伪主义的要求，给这个问题处以死刑——“无意义”。 尽管如此，证伪主义本身也在哲学批判的范围之内，更深入的讨论依旧是可能的。 钱鍾书在《说“回家”》中讲过：“思想家的危险就是给比喻诱惑得忘记了被比喻的原物，把比喻上生发出来的理论认为适用于被比喻的原物。”而我大概是被形式诱惑得忘记了问题的实质吧。虽然说了一大堆好像又绕回了原点，但在“回家”的路上收获的思考和方法才是这短暂旅途中最重要的吧。 注释（或是反思）： “……是适当的”其实并没有解决任何问题，不过是退而求其次的折衷。 ↩︎ ↩︎ 这里有两个问题：一是为什么论域不能为空，上面的理由看起来非常有理，但其实和“逻辑的对象应当是可经验的”是同义反复的。二是这里讲的还是关于谓词逻辑的，却没有解释命题逻辑的原子命题p为何出现了不符合背反律的情况（命题逻辑里没有个体词和论域的概念），我目前只能认为命题逻辑有着不可避免的缺陷。 ↩︎ ↩︎ 凸多边形排除了诸如“凹”字形、“凸”字形的可能。 ↩︎ 即使说，我们完全可以脱离三维欧式空间里的球面这个模型，而基于球面几何公理来认识球面几何。（这里应该还要存疑，虽然我觉得球面几何也可以像平面几何那样仅基于公理地建立，但我并没有查到相关的资料-_-!） ↩︎ 这一块问题实在太多了QAQ。这句的一个主要问题是，逻辑本身和它的衍生都不过是一些形式，而意义则要在人赋予给这些形式时才会有。 ↩︎ 这里和后面讲的都是第二部分（用重定义的方法来讨论），对于第一部分（用谓词逻辑来讨论）的反省参见[1:1][2:1]。 ↩︎ 当一个范式超越了个体语言的控制时，为了求得一个规范而得到一个脆弱的公共语境，但对于这个公共语境，当我们嫁接了方法论后，可能涉及到这个公共语境不存在的语词来进行分析，而新引进的语词所实践的意义本身被用来表述范式本身，使得原有的范式失效了，或者说被人无意识地扩大了。这个过程即所谓的“规范滑坡”。 ↩︎","categories":[{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miRoox.github.io/blog/categories/杂谈散记/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://miRoox.github.io/blog/tags/哲学/"},{"name":"逻辑","slug":"逻辑","permalink":"http://miRoox.github.io/blog/tags/逻辑/"}]},{"title":"旧作：陈天权 数学分析讲义 部分习题答案（第二弹）","slug":"ChengTianQuan-02","date":"2016-02-02T06:28:00.000Z","updated":"2020-01-25T03:16:52.000Z","comments":true,"path":"2016/02/ChengTianQuan-02/","link":"","permalink":"http://miRoox.github.io/blog/2016/02/ChengTianQuan-02/","excerpt":"说明：这里的答案全部是我自己写的，不保证完全正确。题目不抄了，只标题号，书没有就没办法了。题目都是选我感兴趣且会做的。","text":"说明：这里的答案全部是我自己写的，不保证完全正确。题目不抄了，只标题号，书没有就没办法了。题目都是选我感兴趣且会做的。 2.3.1 (i) 注意每个 bmb_mbm​ 都是序列 ana_nan​ 的上界，由确界公理知 sup⁡n∈Nan\\sup_{n\\in\\N}a_nsupn∈N​an​存在且比每个 bmb_mbm​ 都小。 (ii) 与(i)同理，显然 (iii) 由(i)知 ∀m∈N,sup⁡n∈Nan&lt;bm\\forall m\\in\\N,\\sup_{n\\in\\N}a_n&lt; b_m∀m∈N,supn∈N​an​&lt;bm​，结合(ii)，显然 sup⁡n∈Nan&lt;inf⁡n∈Nbn\\sup_{n\\in\\N}a_n&lt; \\inf_{n\\in\\N}b_nsupn∈N​an​&lt;infn∈N​bn​ (iv) 由(iii)显然 ⋂n∈N[an,bn]⊇[sup⁡n∈Nan,inf⁡n∈Nbn]\\bigcap_{n\\in\\N}\\left[a_n,b_n\\right]\\supseteq\\left[\\sup_{n\\in\\N}a_n,\\inf_{n\\in\\N}b_n \\right] n∈N⋂​[an​,bn​]⊇[n∈Nsup​an​,n∈Ninf​bn​] 又 ∀x&lt;sup⁡n∈Nan,∃m∈N,am&gt;x, 即x∉⋂n∈N[an,bn]\\forall x&lt; \\sup_{n\\in\\N}a_n,\\exist m\\in\\N,a_m&gt;x,\\,\\text{即} x\\notin\\bigcap_{n\\in\\N}\\left[a_n,b_n\\right] ∀x&lt;n∈Nsup​an​,∃m∈N,am​&gt;x,即x∈/​n∈N⋂​[an​,bn​] 以及 ∀y&gt;inf⁡n∈Nbn,∃m∈N,bm&lt;x\\forall y&gt; \\inf_{n\\in\\N}b_n,\\exist m\\in\\N,b_m&lt; x ∀y&gt;n∈Ninf​bn​,∃m∈N,bm​&lt;x 可知 ⋂n∈N[an,bn]=[sup⁡n∈Nan,inf⁡n∈Nbn]\\bigcap_{n\\in\\N}\\left[a_n,b_n\\right]=\\left[\\sup_{n\\in\\N}a_n,\\inf_{n\\in\\N}b_n \\right] n∈N⋂​[an​,bn​]=[n∈Nsup​an​,n∈Ninf​bn​] 2.3.2 (i) 若 r∉[k,l]r\\notin[k,l]r∈/​[k,l]，则令 g=2k+l3,h=k+2l3g=\\frac{2k+l}{3},h=\\frac{k+2l}{3}g=32k+l​,h=3k+2l​，显然 [g,h]⊂[k,l][g,h]\\subset[k,l][g,h]⊂[k,l] 若 r∈[k,l]r\\in[k,l]r∈[k,l]，则令 g=2r+l3,h=r+2l3g=\\frac{2r+l}{3},h=\\frac{r+2l}{3}g=32r+l​,h=3r+2l​，有 r∉[g,h]⊂[k,l]r\\notin[g,h]\\subset[k,l]r∈/​[g,h]⊂[k,l] (ii) 与(i)相同的构造方式，易得。 (iii) 与(i)相同，只要令 {cn+1=2cn+dn3,dn+1=cn+2dn3an+1∉[cn,dn]cn+1=2an+1+dn3,dn+1=an+1+2dn3an+1∈[cn,dn]\\begin{cases} c_{n+1}=\\frac{2c_n+d_n}{3},d_{n+1}=\\frac{c_n+2d_n}{3} &amp; a_{n+1}\\notin[c_n,d_n]\\\\ c_{n+1}=\\frac{2a_{n+1}+d_n}{3},d_{n+1}=\\frac{a_{n+1}+2d_n}{3} &amp; a_{n+1}\\in[c_n,d_n] \\end{cases}{cn+1​=32cn​+dn​​,dn+1​=3cn​+2dn​​cn+1​=32an+1​+dn​​,dn+1​=3an+1​+2dn​​​an+1​∈/​[cn​,dn​]an+1​∈[cn​,dn​]​ (iv) 由2.3.1结论（闭区间套定理）， ⋂n=1[cn,dn]≠∅\\bigcap_{n=1}[c_n,d_n]\\ne\\empty⋂n=1​[cn​,dn​]​=∅ 由数学归纳法 ∀x∈D,x∉⋂n=1[cn,dn]\\forall x\\in D,x\\notin\\bigcap_{n=1}[c_n,d_n] ∀x∈D,x∈/​n=1⋂​[cn​,dn​] (v) ∀n∈N,[cn,dn]⊂[c,d]\\forall n\\in\\N,[c_n,d_n]\\subset[c,d] ∀n∈N,[cn​,dn​]⊂[c,d] 归纳地， ⋂n=1[cn,dn]⊂[c,d]\\bigcap_{n=1}[c_n,d_n]\\subset[c,d] n=1⋂​[cn​,dn​]⊂[c,d] 故 ∃x∈⋂n=1[cn,dn]⊂[c,d],x∉D\\exist x\\in\\bigcap_{n=1}[c_n,d_n]\\subset[c,d],x\\notin D ∃x∈n=1⋂​[cn​,dn​]⊂[c,d],x∈/​D (vi) 对于任何一个 φ:N↦R\\varphi:\\N\\mapsto\\Rφ:N↦R，记 an=φ(n)a_n=\\varphi(n)an​=φ(n) 由(v)中结论知，总 ∃x∈[c,d],x∉φ(N)\\exist x\\in[c,d],x\\notin\\varphi(\\N)∃x∈[c,d],x∈/​φ(N)，即 [c,d][c,d][c,d] 不可数。 2.3.3 (i) 显然 a∈Ka\\in Ka∈K (ii) 显然 bbb 是 KKK 的一个上界，有确界公理知 M=sup⁡KM=\\sup KM=supK 存在。 (iii) 显然 (iv) 由确界公理以及确界的性质知 ∀ε&gt;0,(M−ε,M]∩K≠∅\\forall\\varepsilon&gt;0,(M-\\varepsilon,M]\\cap K\\ne\\empty ∀ε&gt;0,(M−ε,M]∩K​=∅ 即存在 c∈K,c&gt;M−εc\\in K,c&gt;M-\\varepsilonc∈K,c&gt;M−ε，使 [a,c][a,c][a,c] 能被 {Iα:α∈J}\\{I_\\alpha:\\alpha\\in J\\}{Iα​:α∈J} 的某个有限子族覆盖 故 [a,M−ε]⊂[a,c][a,M-\\varepsilon]\\subset[a,c][a,M−ε]⊂[a,c] 能被开区间族 {Iα:α∈J}\\{I_\\alpha:\\alpha\\in J\\}{Iα​:α∈J} 的某个有限子族覆盖 (v) 因为开区间族 {Iα:α∈J}\\{I_\\alpha:\\alpha\\in J\\}{Iα​:α∈J} 覆盖了 [a,b][a,b][a,b]，故 ∃α∈J,M∈Iα\\exist\\alpha\\in J,M\\in I_\\alpha∃α∈J,M∈Iα​ 又因 IαI_\\alphaIα​ 是开区间，故 ∃ε&gt;0,[M−ε,M]⊂Iα\\exist\\varepsilon&gt;0,[M-\\varepsilon,M]\\subset I_\\alpha∃ε&gt;0,[M−ε,M]⊂Iα​ 注意到(iv)中 ε\\varepsilonε 的任意性 显然 [a,M][a,M][a,M] 也能被 {Iα:α∈J}\\{I_\\alpha:\\alpha\\in J\\}{Iα​:α∈J} 的某个有限子族覆盖。 (vi) 假若 M&lt;bM&lt; bM&lt;b，由于(v)中的 IαI_\\alphaIα​ 是开区间，故 ∃0&lt;δ&lt;b−M,M+δ∈Iα\\exist 0&lt; \\delta&lt; b-M,M+\\delta\\in I_\\alpha ∃0&lt;δ&lt;b−M,M+δ∈Iα​ 则 [a,M+δ][a,M+\\delta][a,M+δ] 也可被 {Iα:α∈J}\\{I_\\alpha:\\alpha\\in J\\}{Iα​:α∈J} 的某个有限子族覆盖，这与 MMM 是 KKK 的上确界矛盾。 (vii) 由(v)和(vi)，显然。 (viii) 假若 N\\NN 有上界 MMM，则 [1,M]⊂⋃x∈[1,M](x−13,x+13)[1,M]\\subset\\bigcup_{\\mathclap{x\\in[1,M]} }\\left(x-\\frac{1}{3},x+\\frac{1}{3} \\right) [1,M]⊂x∈[1,M]​⋃​(x−31​,x+31​) 由(vii)中结论（有限覆盖定理） [1,M][1,M][1,M] 可以被 ⋃x∈[1,M](x−13,x+13)\\bigcup_{x\\in[1,M] }\\left(x-\\frac{1}{3},x+\\frac{1}{3} \\right)⋃x∈[1,M]​(x−31​,x+31​) 的某个有限子族覆盖 注意到其每个区间 (x−13,x+13)\\left(x-\\frac{1}{3},x+\\frac{1}{3} \\right)(x−31​,x+31​) 长度为 23&lt;1\\frac{2}{3}&lt; 132​&lt;1 故每个区间 (x−13,x+13)\\left(x-\\frac{1}{3},x+\\frac{1}{3} \\right)(x−31​,x+31​) 至多只包含一个自然数 又 [1,M][1,M][1,M] 可以被 ⋃x∈[1,M](x−13,x+13)\\bigcup_{x\\in[1,M] }\\left(x-\\frac{1}{3},x+\\frac{1}{3} \\right)⋃x∈[1,M]​(x−31​,x+31​) 的某个有限子族覆盖 故 [1,M][1,M][1,M] 中只包含有限个整数，这与 N\\NN 是无限集矛盾，故 N\\NN 无上界。 (ix) 考虑如 2.3.1 的闭区间套 [a1,b1]⊃[a2,b2]⊃⋯⊃[an,bn]⊃⋯[a_1,b_1]\\supset[a_2,b_2]\\supset\\cdots\\supset[a_n,b_n]\\supset\\cdots [a1​,b1​]⊃[a2​,b2​]⊃⋯⊃[an​,bn​]⊃⋯ 以 U=(a1,b1+1)U=(a_1,b_1+1)U=(a1​,b1​+1) 为空间，显然 ∀k∈N,[ak,bk]⊂U\\forall k\\in\\N,[a_k,b_k]\\subset U ∀k∈N,[ak​,bk​]⊂U 任何一个闭区间的余集 [an,bn]C=(a1−1,an)∪(bn,b1+1)[a_n,b_n]^C=(a_1-1,a_n)\\cup(b_n,b_1+1)[an​,bn​]C=(a1​−1,an​)∪(bn​,b1​+1) 是两个开区间之并 假若 ⋂n=1∞[an,bn]=∅\\bigcap_{n=1}^\\infty [a_n,b_n]=\\empty n=1⋂∞​[an​,bn​]=∅ 则 ⋃n=1∞[an,bn]C=U⊃(a1,b1)\\bigcup_{n=1}^\\infty [a_n,b_n]^C=U\\supset(a_1,b_1) n=1⋃∞​[an​,bn​]C=U⊃(a1​,b1​) 由(vii)中结论（有限覆盖定理） 存在 ⋃n=1∞[an,bn]C\\bigcup_{n=1}^\\infty [a_n,b_n]^C⋃n=1∞​[an​,bn​]C 的某个有限子族可以将 [a1,b1][a_1,b_1][a1​,b1​] 覆盖 而 ⋃n=1∞[an,bn]C\\bigcup_{n=1}^\\infty [a_n,b_n]^C⋃n=1∞​[an​,bn​]C 的开子区间可以表示为 (a1−1,am)(a_1-1,a_m)(a1​−1,am​) 或 (bk,b1+1)(b_k,b_1+1)(bk​,b1​+1) 考虑在某个有限子族中这些开区间里标号（mmm 或 kkk）最大的一个，其标号为 lll，注意到闭区间套的性质，则 [al+1,bl+1]⊂[a1,b1][a_{l+1},b_{l+1}]\\subset[a_1,b_1][al+1​,bl+1​]⊂[a1​,b1​] 无法被覆盖，导出矛盾，故 ⋂n=1∞[an,bn]≠∅\\bigcap_{n=1}^\\infty [a_n,b_n]\\ne\\empty n=1⋂∞​[an​,bn​]​=∅ 2.3.4 (i) 由 [a,b]⊂⋃j=1n(cj,dj)[a,b]\\subset\\bigcup_{j=1}^n (c_j,d_j)[a,b]⊂⋃j=1n​(cj​,dj​) 必存在开区间 (k,l)(k,l)(k,l) 使 [a,b]⊂(k,l)=⋃j∈G(cj,dj)[a,b]\\subset(k,l)=\\bigcup_{j\\in G}(c_j,d_j)[a,b]⊂(k,l)=⋃j∈G​(cj​,dj​)（其中 G⊂{1,2,…,n}G\\subset\\{1,2,\\dots,n\\}G⊂{1,2,…,n}） （否则 ∃x∈[a,b],x∉⋃j=1n(cj,dj)\\exist x\\in[a,b],x\\notin\\bigcup_{j=1}^n (c_j,d_j)∃x∈[a,b],x∈/​⋃j=1n​(cj​,dj​) 与题设矛盾） 由数学归纳法和开区间的简单性质易证 l−k&lt;∑j∈G(dj−cj)l-k&lt; \\sum_{j\\in G}(d_j-c_j)l−k&lt;∑j∈G​(dj​−cj​) 因而 b−a&lt;l−k&lt;∑j∈G(dj−cj)&lt;∑j=1n(dj−cj)b-a&lt; l-k&lt; \\sum_{j\\in G}(d_j-c_j)&lt; \\sum_{j=1}^n(d_j-c_j) b−a&lt;l−k&lt;j∈G∑​(dj​−cj​)&lt;j=1∑n​(dj​−cj​) (ii) 由 2.3.3(vii) 的有限覆盖定理，必存在某个有限集 F⊂JF\\subset JF⊂J 使得 [a,b]⊂⋃α∈FIα[a,b]\\subset\\bigcup_{\\alpha\\in F}I_\\alpha[a,b]⊂⋃α∈F​Iα​ 又由(i)，即有 b−a&lt;∑α∈F∣Iα∣≤sup⁡有限集F⊂J∑α∈F∣Iα∣b-a&lt; \\sum_{\\alpha\\in F}|I_\\alpha|\\le\\sup_{\\text{有限集}F\\subset J }\\sum_{\\alpha\\in F}|I_\\alpha| b−a&lt;α∈F∑​∣Iα​∣≤有限集F⊂Jsup​α∈F∑​∣Iα​∣ (iii) 任意给定 ε&gt;0\\varepsilon&gt;0ε&gt;0，记 D={a1,a2,…,an,… }D=\\{a_1,a_2,\\dots,a_n,\\dots \\}D={a1​,a2​,…,an​,…}，并取 In=(an−2−n−2ε,an+2−n−2ε)I_n=\\left(a_n-2^{-n-2}\\varepsilon,a_n+2^{-n-2}\\varepsilon \\right)In​=(an​−2−n−2ε,an​+2−n−2ε) 显然 D=⋃n=1∞InD=\\bigcup_{n=1}^\\infty I_nD=⋃n=1∞​In​，且 ∑n=1∞∣In∣=ε2&lt;ε\\sum_{n=1}^\\infty |I_n|=\\frac{\\varepsilon}{2}&lt; \\varepsilon∑n=1∞​∣In​∣=2ε​&lt;ε。 (iv) 假若 [a,b][a,b][a,b] 是可数集，由(ii)知 [a,b][a,b][a,b] 必定能被某个开区间族 {Iα:α∈J}\\{I_\\alpha :\\alpha\\in J \\}{Iα​:α∈J} 覆盖，且 b−a&lt;sup⁡有限集F⊂J∑α∈F∣Iα∣b-a&lt; \\sup_{\\text{有限集}F\\subset J }\\sum_{\\alpha\\in F}|I_\\alpha| b−a&lt;有限集F⊂Jsup​α∈F∑​∣Iα​∣ 取开区间族 {Iα:α∈J}\\{I_\\alpha :\\alpha\\in J \\}{Iα​:α∈J} 中蕴含了 {Ii:i∈F}\\{I_i :i\\in F \\}{Ii​:i∈F} 的某个可数子族 {In:n∈E}\\{I_n :n\\in E \\}{In​:n∈E}，显然 ∑n∈E∣In∣&gt;sup⁡有限集F⊂J∑α∈F∣Iα∣\\sum_{n\\in E}|I_n|&gt;\\sup_{\\text{有限集}F\\subset J }\\sum_{\\alpha\\in F}|I_\\alpha| n∈E∑​∣In​∣&gt;有限集F⊂Jsup​α∈F∑​∣Iα​∣ 又由(iii)，取 ε=b−a2\\varepsilon=\\frac{b-a}{2}ε=2b−a​，则有 b−a&lt;sup⁡有限集F⊂J∑α∈F∣Iα∣&lt;∑n∈E∣In∣&lt;b−a2b-a&lt; \\sup_{\\text{有限集}F\\subset J }\\sum_{\\alpha\\in F}|I_\\alpha|&lt; \\sum_{n\\in E}|I_n|&lt; \\frac{b-a}{2} b−a&lt;有限集F⊂Jsup​α∈F∑​∣Iα​∣&lt;n∈E∑​∣In​∣&lt;2b−a​ 导出矛盾，故 [a,b][a,b][a,b] 是不可数集。 2.3.5 (i) 将 SSS 中的点按大小排序 a0&lt;a1&lt;⋯&lt;ana_0&lt; a_1&lt; \\cdots&lt; a_na0​&lt;a1​&lt;⋯&lt;an​ 显然只要某个 Iα⊂[x,y]I_\\alpha\\subset[x,y]Iα​⊂[x,y]，就有 S∩[x,y]=∅S\\cap[x,y]=\\emptyS∩[x,y]=∅ 假设有某个 ai∈[x,y]a_i\\in[x,y]ai​∈[x,y]，由 λ\\lambdaλ 的选取，必有 ai−1&lt;x,ai+1&gt;ya_{i-1}&lt; x,a_{i+1}&gt;yai−1​&lt;x,ai+1​&gt;y 故 [x,y][x,y][x,y] 中最多含有 SSS 的一个点。 (ii) x∈Iα=(kα,lα)x\\in I_\\alpha=(k_\\alpha,l_\\alpha) x∈Iα​=(kα​,lα​) 显然 yyy 只可能满足 kα&lt;x&lt;y&lt;lαk_\\alpha&lt; x&lt; y&lt; l_\\alphakα​&lt;x&lt;y&lt;lα​ 或者 y≥lαy\\ge l_\\alphay≥lα​ 其中之一， 而后者显然使 lα∈[x,y]l_\\alpha\\in[x,y]lα​∈[x,y]，与题设矛盾，故 y∈(kα,lα)y\\in(k_\\alpha,l_\\alpha)y∈(kα​,lα​) (iii) [x,y]∩S={h}[x,y]\\cap S=\\{h\\} [x,y]∩S={h} 以 hhh 为端点的开区间不会盖住 hhh 对于任何一个盖住 hhh 的开区间 Iβ=(kβ,lβ)I_\\beta=(k_\\beta,l_\\beta)Iβ​=(kβ​,lβ​)，必有 [x,y]⊂Iβ[x,y]\\subset I_\\beta[x,y]⊂Iβ​， 否则 [x,y]∩S={h,kβ}⊻[x,y]∩S={h,lβ}[x,y]\\cap S=\\{h,k_\\beta\\}\\veebar [x,y]\\cap S=\\{h,l_\\beta\\}[x,y]∩S={h,kβ​}⊻[x,y]∩S={h,lβ​} 为真，与(i)中结论矛盾，故 [x,y]⊂Iβ[x,y]\\subset I_\\beta[x,y]⊂Iβ​ (iv) 由(i)的结论和(ii),(iii)的讨论，综述易得。 2.3.6 由 2.3.3(vii) 的有限覆盖定理 ∃有限集F⊂J,[a,b]⊂⋃α∈FIα\\exist\\text{有限集}F\\subset J,[a,b]\\subset\\bigcup_{\\alpha\\in F}I_\\alpha ∃有限集F⊂J,[a,b]⊂α∈F⋃​Iα​ 又由 2.3.5(iv) 的结论，综述易得。 2.3.7 (i) 必要性显然； 充分性： 假若 ∃ε0&gt;0,E∩(l−ε0,l+ε0)\\exist\\varepsilon_0&gt;0,E\\cap(l-\\varepsilon_0,l+\\varepsilon_0)∃ε0​&gt;0,E∩(l−ε0​,l+ε0​)是有限集，记为 {a1,a2,…,an}\\{a_1,a_2,\\dots,a_n\\}{a1​,a2​,…,an​} 取 \\varepsilon=\\min_{\\substack{1\\le i\\le n\\\\ a_i\\ne l} }\\left|a_i-l\\right| 则 (E∖{l})∩(l−ε,l+ε)=∅(E\\setminus\\{l\\})\\cap(l-\\varepsilon,l+\\varepsilon)=\\empty(E∖{l})∩(l−ε,l+ε)=∅，矛盾，故充分性得证。 (ii) 根据否定命题的原则，显然。 (iii) 取 [a,b]⊃E[a,b]\\supset E[a,b]⊃E，若 EEE 无聚点，则 ∀x∈E,∃εx&gt;0,E∩(x−εx,x+εx)\\forall x\\in E,\\exist \\varepsilon_x&gt;0, E\\cap(x-\\varepsilon_x,x+\\varepsilon_x)∀x∈E,∃εx​&gt;0,E∩(x−εx​,x+εx​)是有限集 由 2.3.3(vii) 的有限覆盖定理 ∃{x1,x2,…,xn}⊂[a,b],[a,b]⊂⋃j=1n(xj−εxj,xj+εxj)\\exist\\{x_1,x_2,\\dots,x_n \\}\\subset[a,b], [a,b]\\subset\\bigcup_{j=1}^n\\left(x_j-\\varepsilon_{x_j},x_j+\\varepsilon_{x_j} \\right) ∃{x1​,x2​,…,xn​}⊂[a,b],[a,b]⊂j=1⋃n​(xj​−εxj​​,xj​+εxj​​) 而 E=E∩[a,b]⊂⋃j=1nE∩(xj−εxj,xj+εxj)E=E\\cap[a,b]\\subset\\bigcup_{j=1}^nE\\cap\\left(x_j-\\varepsilon_{x_j},x_j+\\varepsilon_{x_j} \\right) E=E∩[a,b]⊂j=1⋃n​E∩(xj​−εxj​​,xj​+εxj​​) （有限个有限集之并） 故 EEE 是有限集。 (iv) 若 Z\\ZZ 有上界，则 Z+\\Z_{+}Z+​ 亦有上界，而 Z+\\Z_{+}Z+​ 以 111 为下界，故 Z+\\Z_{+}Z+​ 有界 由 (iii) 的聚点存在定理， Z+\\Z_{+}Z+​ 有聚点，记为 lll 则 (l−13,l+13)∩Z+\\left(l-\\frac{1}{3},l+\\frac{1}{3} \\right)\\cap\\Z_{+}(l−31​,l+31​)∩Z+​ 应为无限集，但 (l−13,l+13)\\left(l-\\frac{1}{3},l+\\frac{1}{3} \\right)(l−31​,l+31​) 中至多包含一个整数，与 lll 是聚点矛盾，故 Z+\\Z_{+}Z+​ 无上界，Z\\ZZ 亦无上界。 同理易证 Z\\ZZ 无下界。 (v) 由 (iv) Z\\ZZ 无界易得。 (vi) 假若 ∃ε0&gt;0,∀N∈N,n−mN≥ε0\\exist\\varepsilon_0&gt;0,\\forall N\\in\\N,\\frac{n-m}{N}\\ge\\varepsilon_0∃ε0​&gt;0,∀N∈N,Nn−m​≥ε0​， 则 ∀N∈N,N≤n−mε0\\forall N\\in\\N,N\\le\\frac{n-m}{\\varepsilon_0}∀N∈N,N≤ε0​n−m​ 与 N\\NN 无上界矛盾，得证。 (vii) 任意给定 ε&gt;0\\varepsilon&gt;0ε&gt;0，对 ∀x∈[a,b]\\forall x\\in[a,b]∀x∈[a,b]， 由 (v) 知 ∀N∈N,∃m,n∈Z,m&lt;Na&lt;Nb&lt;n\\forall N\\in\\N,\\exist m,n\\in\\Z, m&lt; Na&lt; Nb&lt; n∀N∈N,∃m,n∈Z,m&lt;Na&lt;Nb&lt;n，即有 mN&lt;a≤x≤b&lt;nN\\frac{m}{N}&lt; a\\le x\\le b&lt; \\frac{n}{N}Nm​&lt;a≤x≤b&lt;Nn​ 又由 (vi) 知 ∀ε&gt;0,∃N∈N,n−mN&lt;ε\\forall\\varepsilon&gt;0,\\exist N\\in\\N,\\frac{n-m}{N}&lt; \\varepsilon∀ε&gt;0,∃N∈N,Nn−m​&lt;ε 故 ∀ε&gt;0,(Q∩[a,b]∖{x})∩(x−ε,x+ε)≠∅\\forall\\varepsilon&gt;0,(\\mathbb{Q}\\cap[a,b]\\setminus\\{x\\})\\cap(x-\\varepsilon,x+\\varepsilon)\\ne\\empty ∀ε&gt;0,(Q∩[a,b]∖{x})∩(x−ε,x+ε)​=∅ 即 xxx 是 Q∩[a,b]\\mathbb{Q}\\cap[a,b]Q∩[a,b] 的聚点。 2.3.8 (i) 显然。 (ii) 取 [a,b][a,b][a,b] 使 ∀n∈N,xn∈[a,b]\\forall n\\in\\N,x_n\\in[a,b]∀n∈N,xn​∈[a,b]，记 [a1,b1]=[a,b][a_1,b_1]=[a,b][a1​,b1​]=[a,b] 将 [a1,b1][a_1,b_1][a1​,b1​] 二等分，则至少有一边包含 {xn}\\{x_n\\}{xn​} 的无穷多项，记为 [a2,b2][a_2,b_2][a2​,b2​]， 类似地，将 [a2,b2][a_2,b_2][a2​,b2​] 二等分，取包含 {xn}\\{x_n\\}{xn​} 无穷多项的一边 [a3,b3][a_3,b_3][a3​,b3​]， …… 以此类推得到闭区间套 [an,bn][a_n,b_n][an​,bn​]，且 ∀n∈N\\forall n\\in\\N∀n∈N，[an,bn][a_n,b_n][an​,bn​] 包含 {xn}\\{x_n\\}{xn​} 的无穷多项 由 2.3.1 的闭区间套定理，并注意到 bn−an=b−a2n−1→0b_n-a_n=\\frac{b-a}{2^{n-1} }\\to0bn​−an​=2n−1b−a​→0 ∃l,⋂n=1∞[an,bn]={l}而∀ε&gt;0,∃n∈N,(l−ε,l+ε)⊃[an,bn]\\exist l,\\bigcap_{n=1}^{\\infty}[a_n,b_n]=\\{l\\}\\text{而}\\forall\\varepsilon&gt;0,\\exist n\\in\\N,(l-\\varepsilon,l+\\varepsilon)\\supset[a_n,b_n] ∃l,n=1⋂∞​[an​,bn​]={l}而∀ε&gt;0,∃n∈N,(l−ε,l+ε)⊃[an​,bn​] 故 lll 是 {xn}\\{x_n\\}{xn​} 的聚点。 2.3.9 不妨设 b∈Bb\\in Bb∈B，取 x=sup⁡Ax=\\sup Ax=supA 显然 ∀ε&gt;0,A∩(x−ε,x+ε)≠∅\\forall\\varepsilon&gt;0,A\\cap(x-\\varepsilon,x+\\varepsilon)\\ne\\empty∀ε&gt;0,A∩(x−ε,x+ε)​=∅，而 x≤bx\\le bx≤b 若 x=bx=bx=b，显然 B∩(x−ε,x+ε)∋bB\\cap(x-\\varepsilon,x+\\varepsilon)\\ni bB∩(x−ε,x+ε)∋b 若 x&lt;bx&lt; bx&lt;b，∀ε&gt;0,∀y∈A,x+ε&gt;y\\forall\\varepsilon&gt;0,\\forall y\\in A,x+\\varepsilon&gt;y∀ε&gt;0,∀y∈A,x+ε&gt;y，而 [a,b]=A∪B[a,b]=A\\cup B[a,b]=A∪B 故 0&lt;ε&lt;b−x,x+ε∈B0&lt; \\varepsilon&lt; b-x, x+\\varepsilon\\in B0&lt;ε&lt;b−x,x+ε∈B，得证。 2.3.10 (i) 考察 n+1n+1n+1 个实数 lα−⌊lα⌋l\\alpha-\\lfloor l\\alpha\\rfloorlα−⌊lα⌋（其中 l∈{1,2,…,n+1}l\\in\\{1,2,\\dots,n+1\\}l∈{1,2,…,n+1}） 注意 ∀l∈{1,2,…,n+1},lα−⌊lα⌋&lt;1\\forall l\\in\\{1,2,\\dots,n+1\\}, l\\alpha-\\lfloor l\\alpha\\rfloor&lt; 1∀l∈{1,2,…,n+1},lα−⌊lα⌋&lt;1 故在这组数中至少有两个数满足 ∣(l2α−⌊l2α⌋)−(l1α−⌊l1α⌋)∣&lt;1n,1&lt;l1&lt;l2&lt;n+1\\left|(l_2\\alpha-\\lfloor l_2\\alpha\\rfloor)-(l_1\\alpha-\\lfloor l_1\\alpha\\rfloor) \\right|&lt; \\frac{1}{n},\\quad 1&lt; l_1&lt; l_2&lt; n+1 ∣(l2​α−⌊l2​α⌋)−(l1​α−⌊l1​α⌋)∣&lt;n1​,1&lt;l1​&lt;l2​&lt;n+1 现取 k=l2−l1≤n,m=⌊l2α⌋−⌊l1α⌋k=l_2-l_1\\le n, m=\\lfloor l_2\\alpha\\rfloor-\\lfloor l_1\\alpha\\rfloork=l2​−l1​≤n,m=⌊l2​α⌋−⌊l1​α⌋，则 kα−m&lt;1nk\\alpha-m&lt; \\frac{1}{n}kα−m&lt;n1​ 即有 ∣α−mk∣&lt;1kn\\left|\\alpha-\\frac{m}{k} \\right|&lt; \\frac{1}{kn} ∣∣∣​α−km​∣∣∣​&lt;kn1​ (ii) 假若只有有限个这样的有理数 mini\\frac{m_i}{n_i}ni​mi​​，满足 ∣α−mini∣&lt;1ni2\\left|\\alpha-\\frac{m_i}{n_i} \\right|&lt; \\frac{1}{n_i^2}∣∣∣​α−ni​mi​​∣∣∣​&lt;ni2​1​（i∈{1,2,…,p}i\\in\\{1,2,\\dots,p\\}i∈{1,2,…,p}） 令 δ=min⁡1≤i≤p∣α−mini∣\\delta=\\min_{1\\le i\\le p}\\left|\\alpha-\\frac{m_i}{n_i} \\right| δ=1≤i≤pmin​∣∣∣∣​α−ni​mi​​∣∣∣∣​ 取 N&gt;1δN&gt;\\frac{1}{\\delta}N&gt;δ1​，并取 m,n∈N,(0&lt;n&lt;N)m,n\\in\\N,(0&lt; n&lt; N)m,n∈N,(0&lt;n&lt;N) 使得 ∣α−mn∣&lt;1nN&lt;1n2\\left|\\alpha-\\frac{m}{n} \\right|&lt; \\frac{1}{nN}&lt; \\frac{1}{n^2} ∣∣∣​α−nm​∣∣∣​&lt;nN1​&lt;n21​ 即 m,nm,nm,n 满足题意 同时注意到 ∣α−mn∣&lt;1nN&lt;δn&lt;δ\\left|\\alpha-\\frac{m}{n} \\right|&lt; \\frac{1}{nN}&lt; \\frac{\\delta}{n}&lt; \\delta ∣∣∣​α−nm​∣∣∣​&lt;nN1​&lt;nδ​&lt;δ 即 mn∉{mini:1≤i≤p}\\frac{m}{n}\\notin\\left\\{\\frac{m_i}{n_i}:1\\le i\\le p \\right\\}nm​∈/​{ni​mi​​:1≤i≤p}，导出矛盾 故满足 ∣α−mn∣&lt;1n2\\left|\\alpha-\\frac{m}{n}\\right|&lt; \\frac{1}{n^2}∣∣​α−nm​∣∣​&lt;n21​ 的有理数 mn\\frac{m}{n}nm​ 有无限个。","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miRoox.github.io/blog/categories/数理科学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miRoox.github.io/blog/tags/数学/"},{"name":"题解","slug":"题解","permalink":"http://miRoox.github.io/blog/tags/题解/"},{"name":"微积分","slug":"微积分","permalink":"http://miRoox.github.io/blog/tags/微积分/"}]},{"title":"旧作：【翻译】如何编写PKT文件","slug":"PKTFile","date":"2015-12-19T13:50:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2015/12/PKTFile/","link":"","permalink":"http://miRoox.github.io/blog/2015/12/PKTFile/","excerpt":"来自PPM （只翻关键部分） 作者：Dark Templar X 简单来说，它是控制当有扩展地图包时，什么地图将出现在遭遇战的各种模式中。当然，MPR和YRM格式的地图没必要有它。 不管怎样，其基本的设置类似于rules文件中的载具列表，里面有地图的列表以及各个地图的细节内容。","text":"来自PPM （只翻关键部分） 作者：Dark Templar X 简单来说，它是控制当有扩展地图包时，什么地图将出现在遭遇战的各种模式中。当然，MPR和YRM格式的地图没必要有它。 不管怎样，其基本的设置类似于rules文件中的载具列表，里面有地图的列表以及各个地图的细节内容。 PKT文件创建起来非常容易：新建一个文本文档并重命名为modname.pkt 即可。名字并不重要，但它有助于分辨文件的来源。 首先是[MultiMaps]部分。 例如： 12345[MultiMaps] 1=SOMEMAP1 2=SOMEMAP2 3=SOMEMAP3 …… 然后是对地图的定义。 例如： 123456[SOMEMAP1] Description=DESC:SOMEMAP1 CD=0,1,2 MinPlayers=2 MaxPlayers=2 GameMode=standard, meatgrind [SOMEMAP1]是地图文件的名字。 Description=是CSF中对应的“类型:项目”名。 CD=指定哪个盘需要在地图里播放。 注： 在例举中我把所有的三个都用上了，建议你也这么做。 （译注：这条应该是废弃了，参见后面的补充） MinPlayers=决定这个地图的最少玩家数。（译注：不应小于2） MaxPlayers=决定这个地图的最多玩家数，不能大于8。 GameMode=决定可以使用的游戏模式，模式参考mpmodes(md).ini。 补充： Allied General 的回复： 据我所知，PKT文件只在遭遇战开发者套装里的文件中有所提及。 CD=我认为它实际上已经废弃了，因为在assault.pkt中CD=0 是默认的使用方法，而且我也没有因它遇见过任何问题。 GameMode=是PKT中最有用的部分，因为它可以使你能够定义一些有可用地图的特殊模式。 例如在你的mpmodes(md).ini中有 =GUI:FFAAssault, STT:ModeFFAAssault,MPFreeForAllMD.ini, assault, false 那么任何有GameMode=assault的地图将会使用MPFreeForAllMD.ini里的设置，或者你也可以特别为它做一个，比如MPCaptureOnlyMD.ini。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"},{"name":"翻译作品","slug":"翻译作品","permalink":"http://miRoox.github.io/blog/categories/翻译作品/"}],"tags":[{"name":"红警","slug":"红警","permalink":"http://miRoox.github.io/blog/tags/红警/"},{"name":"翻译","slug":"翻译","permalink":"http://miRoox.github.io/blog/tags/翻译/"},{"name":"参考","slug":"参考","permalink":"http://miRoox.github.io/blog/tags/参考/"}]},{"title":"旧作：陈天权 数学分析讲义 部分习题答案（第一弹）","slug":"ChengTianQuan-01","date":"2015-12-13T13:08:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2015/12/ChengTianQuan-01/","link":"","permalink":"http://miRoox.github.io/blog/2015/12/ChengTianQuan-01/","excerpt":"说明：这里的答案全部是我自己写的，不保证完全正确。题目不抄了，只标题号，书没有就没办法了。题目都是选我感兴趣且会做的。","text":"说明：这里的答案全部是我自己写的，不保证完全正确。题目不抄了，只标题号，书没有就没办法了。题目都是选我感兴趣且会做的。 4.1.1 (i) 由 f(0)=f(0)+f(0)f(0)=f(0)+f(0)f(0)=f(0)+f(0) 知 f(0)=0f(0)=0f(0)=0 n=1n=1n=1 时显然成立，而 ∀x∈R,∀n∈N+,f((n+1)x)=f(x)+f(nx)\\forall x\\in\\R,\\forall n\\in\\N_{+},f((n+1)x)=f(x)+f(nx) ∀x∈R,∀n∈N+​,f((n+1)x)=f(x)+f(nx) 由归纳原理知 ∀x∈R,∀n∈N+,f(nx)=f(x)n(1)\\forall x\\in\\R,\\forall n\\in\\N_{+},f(nx)=f(x)n \\tag{1} ∀x∈R,∀n∈N+​,f(nx)=f(x)n(1) 带入 x=1x=1x=1，即 ∀n∈N+,f(n)=f(1)n(2)\\forall n\\in\\N_{+},f(n)=f(1)n \\tag{2} ∀n∈N+​,f(n)=f(1)n(2) 又 ∀n∈N,f(n)+f(−n)=f(0)=0\\forall n\\in\\N, f(n)+f(-n)=f(0)=0 ∀n∈N,f(n)+f(−n)=f(0)=0 即f(−n)=−f(n)=f(1)⋅(−1)f(-n)=-f(n)=f(1)\\cdot(-1)f(−n)=−f(n)=f(1)⋅(−1) 故 ∀m∈Z,f(m)=f(1)m(3)\\forall m\\in\\Z,f(m)=f(1)m \\tag{3} ∀m∈Z,f(m)=f(1)m(3) 带入 x=mnx=\\frac{m}{n}x=nm​ 于(1)式， ∀m∈Z,∀n∈N+,f(m)=f(mn)n\\forall m\\in\\Z,\\forall n\\in\\N_{+},f(m)=f\\left(\\frac{m}{n}\\right)n ∀m∈Z,∀n∈N+​,f(m)=f(nm​)n 又由(3)式知 ∀m∈Z,∀n∈N+,f(mn)=1nf(m)=mnf(1)\\forall m\\in\\Z,\\forall n\\in\\N_{+},f\\left(\\frac{m}{n}\\right)=\\frac{1}{n}f(m)=\\frac{m}{n}f(1) ∀m∈Z,∀n∈N+​,f(nm​)=n1​f(m)=nm​f(1) 即 ∀p∈Q,f(p)=f(1)p(4)\\forall p\\in\\mathbb{Q},f(p)=f(1)p \\tag{4} ∀p∈Q,f(p)=f(1)p(4) 又因 ∀x∈R,∃pn∈Q,lim⁡n→∞pn=x\\forall x\\in\\R,\\exist p_n\\in\\mathbb{Q},\\lim_{n\\to\\infty}p_n=x ∀x∈R,∃pn​∈Q,n→∞lim​pn​=x 结合 f(x)f(x)f(x) 的连续性可得 ∀x∈R,f(x)=f(1)x\\forall x\\in\\R,f(x)=f(1)x ∀x∈R,f(x)=f(1)x (ii) 令 g(x)=log⁡f(1)f(x)g(x)=\\log_{f(1)}{f(x)}g(x)=logf(1)​f(x)，则 g(x+y)=log⁡f(1)f(x+y)=log⁡f(1)f(x)+log⁡f(1)f(y)=g(x)+g(y)g(x+y)=\\log_{f(1)}{f(x+y)}=\\log_{f(1)}{f(x)}+\\log_{f(1)}{f(y)}=g(x)+g(y) g(x+y)=logf(1)​f(x+y)=logf(1)​f(x)+logf(1)​f(y)=g(x)+g(y) 由(i)中结论知 g(x)=g(1)x=xg(x)=g(1)x=xg(x)=g(1)x=x，则 f(x)=f(1)g(x)=f(1)xf(x)=f(1)^{g(x)}=f(1)^xf(x)=f(1)g(x)=f(1)x (iii) 令 g(x)=f(ex)g(x)=f\\left(\\mathrm{e}^x\\right)g(x)=f(ex)，则 g(x+y)=f(ex⋅ey)=f(ex)⋅f(ey)=g(x)⋅g(y)g(x+y)=f\\left(\\mathrm{e}^x\\cdot\\mathrm{e}^y\\right)=f(\\mathrm{e}^x)\\cdot f(\\mathrm{e}^y)=g(x)\\cdot g(y) g(x+y)=f(ex⋅ey)=f(ex)⋅f(ey)=g(x)⋅g(y) 由(ii)可知 g(x)=g(1)x=f(e)xg(x)=g(1)^x=f(e)^xg(x)=g(1)x=f(e)x，故 f(x)=g(ln⁡x)=f(e)ln⁡x=xln⁡f(e)f(x)=g(\\ln x)=f(e)^{\\ln x}=x^{\\ln f(e)}f(x)=g(lnx)=f(e)lnx=xlnf(e) (iv) 令 g(x)=f(ex)g(x)=f\\left(\\mathrm{e}^x\\right)g(x)=f(ex)，则 g(x+y)=f(ex⋅ey)=f(ex)+f(ey)=g(x)+g(y)g(x+y)=f\\left(\\mathrm{e}^x\\cdot\\mathrm{e}^y\\right)=f(\\mathrm{e}^x)+f(\\mathrm{e}^y)=g(x)+g(y) g(x+y)=f(ex⋅ey)=f(ex)+f(ey)=g(x)+g(y) 由(i)知 g(x)=g(1)x=f(e)xg(x)=g(1)x=f(e)xg(x)=g(1)x=f(e)x，故 f(x)=g(ln⁡x)=f(e)ln⁡xf(x)=g(\\ln x)=f(e)\\ln xf(x)=g(lnx)=f(e)lnx 4.1.3 考虑 (0,1]∖Q\\left(0,1\\right]\\setminus\\mathbb{Q}(0,1]∖Q： 由 Archimedes 原理， ∀ε&gt;0,∃N∈N+,∀n≥N,1n&lt;ε\\forall\\varepsilon&gt;0,\\exist N\\in\\N_{+},\\forall n\\ge N,\\frac{1}{n}&lt; \\varepsilon ∀ε&gt;0,∃N∈N+​,∀n≥N,n1​&lt;ε 另一方面，在区间 (0,1]\\left(0,1\\right](0,1] 上，分母小于 NNN 的有理数不会超过 N2−N2\\frac{N^2-N}{2}2N2−N​ 个， 因此，必定 ∃δ&gt;0,∃p∈(x−δ,x+δ)∩Q,∣R(p)−R(x)∣≤1N&lt;ε\\exist\\delta&gt;0,\\exist p\\in(x-\\delta,x+\\delta)\\cap\\mathbb{Q},|R(p)-R(x)|\\le\\frac{1}{N}&lt;\\varepsilon ∃δ&gt;0,∃p∈(x−δ,x+δ)∩Q,∣R(p)−R(x)∣≤N1​&lt;ε 即 RRR 在 xxx 处连续。 再考虑 (0,1]∩Q\\left(0,1\\right]\\cap\\mathbb{Q}(0,1]∩Q： ∀δ&gt;0,∃q∈(x−δ,x+δ),q∈R∩Q\\forall\\delta&gt;0,\\exist q\\in(x-\\delta,x+\\delta),q\\in\\R\\cap\\mathbb{Q} ∀δ&gt;0,∃q∈(x−δ,x+δ),q∈R∩Q 显然，只要取 ϵ=R(x)2\\epsilon=\\frac{R(x)}{2}ϵ=2R(x)​，就不可能找到一个 δ&gt;0\\delta&gt;0δ&gt;0 使得 ∀y∈(x−δ,x+δ),∣R(y)−R(x)∣&lt;ε\\forall y\\in(x-\\delta,x+\\delta),|R(y)-R(x)|&lt; \\varepsilon∀y∈(x−δ,x+δ),∣R(y)−R(x)∣&lt;ε，故 RRR 在 xxx处不连续。","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miRoox.github.io/blog/categories/数理科学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miRoox.github.io/blog/tags/数学/"},{"name":"题解","slug":"题解","permalink":"http://miRoox.github.io/blog/tags/题解/"},{"name":"微积分","slug":"微积分","permalink":"http://miRoox.github.io/blog/tags/微积分/"}]},{"title":"旧作：泰矿模拟研究","slug":"Tiberium","date":"2015-10-11T12:48:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2015/10/Tiberium/","link":"","permalink":"http://miRoox.github.io/blog/2015/10/Tiberium/","excerpt":"","text":"本文综合了 PPM Forum 上 Allied General 大神的教程以及 RA2DIY 上 kenosis 大神的教程，并经本人实践调试总结而成。 Allied General 的教程 kenosis 的教程 总体思路 一、泰矿对步兵的毒害：用矿石闪光动画刷出粒子从而伤害。（kenosis使用动画刷碎片的方法，但我在实践时失败了） 二、（蓝色）泰矿爆炸：给宝石加上Explodes=yes并用爆炸动画刷出碎片从而引发连锁反应。 （当然，你或许需要泰伯利亚矿石的模型。自己想办法找吧。） 具体代码 Tiberium Damage 12345678910111213141516171819202122232425262728293031323334;******* in RULSEMD.INI *******[AudioVisual](......)OreTwinkleChance=1;30 ; At map startup, there is 1 chance in N that a cell with ore will get a twinkle anim.;I alter this value to make the damage continous(......)[Particles](......)XX=OreGasPart ; \"XX\" is an ordinal[Warheads](......)YY=OreWH ; \"YY\" is an ordinal[OreGasPart]Image=none ; its invisible MaxDC=15 ; how many frames before damage occur, keep it small so damage occurs quickly MaxEC=60 ; how many frames this last for, keep it small to reduce lag Damage=15 ; how much it hurts, this damage ignores tags such as ImmuneToPoison even if the attached warhead is Poison=yes Warhead=OreWH ; the scissors, paper, rock of the damage StartFrame=0 ; best not to mess with this EndStateAI=20 ; best not to mess with this WindEffect=1 ; determines how far this particle moves from its starting position (defaults to 0) BehavesLike=Gas ; best not to mess with this StateAIAdvance=4 ;; best not to mess with this [OreWH]CellSpread=1 ; area effect damage PercentAtMax=1 ; keep damage high Verses=100%,100%,100%,1%,0%,1%,0%,0%,0%,0%,0% ; maybe you should change the armor of your SLAV to spcial_1 ProneDamage=300% ; multipler to apply to damage when infantry use prone sequence in art. InfDeath=8 ; virusdie 12345678910;******* in ARTMD.INI ********[TWNK1]LoopCount=-1 ; this animation plays forever RandomLoopDelay=120,300 ; this gives a delay on the anim playing DetailLevel=2 ;I don't know what's this, best not to mess with this HideIfNoOre=true ; dont play this anim if no ore present ;Trailer=TWNK2 ;I tried and failed;SpawnDelay=1 ;sorry, the Great kenosisSpawnsParticle=OreGasPartNumParticles=1 ; the number to spawn, keep this low to minimise lag Tiberium BOOM! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778;******** in RULSEMD.INI *********[General](......)BarrelExplode=EXPLOLRGX;EXPLOLRG ; exploding crates animation;I convert it because many warheads use EXPLOLRG as its AnimList, and I need distinguish from it.(......)[CombatDamage]AmmoCrateDamage=200 ; damage generated from exploding ammo crate overlay;Tiberium explosion damamge, but you'd better not to mess with this (......)C4Warhead=Super ;gs HE ;gs What? C4 sets a timer that forces the destruction of a building. This warhead is used throughout the code to mean \"Absolute damage\" ; this is the warhead that C4 uses to damage buildings;Tiberium explosion warhead, DON'T alter this!!!(......)[Animations](......)WWWW=EXPLOLRGX ; \"WWWW\" is an ordinalZZZZ=GEMDBR ; as above[GEM01]Name=GemsTiberium=yesLegalTarget=falseRadarInvisible=falseRadarColor=140,0,140;Land=Rock;ChainReaction=no;CellAnim=BIGBLUE;Image=GEM01;NoUseTileLandType=true;DrawFlat=falseExplodes=yes[GEM02](......) ;leave outExplodes=yes[GEM03](......) ;leave outExplodes=yes[GEM04](......) ;leave outExplodes=yes[GEM05](......) ;leave outExplodes=yes[GEM06](......) ;leave outExplodes=yes[GEM07](......) ;leave outExplodes=yes[GEM08](......) ;leave outExplodes=yes[GEM09](......) ;leave outExplodes=yes[GEM10](......) ;leave outExplodes=yes[GEM11](......) ;leave outExplodes=yes[GEM12](......) ;leave outExplodes=yes 123456789101112131415161718192021222324252627282930;******** in ARTMD.INI *******[EXPLOLRGX]Image=EXPLOLRGTranslucent=yesUseNormalLight=yesReport=Explosion09Crater=yesScorch=yesTrailerAnim=GEMDBRTrailerSeperation=1[GEMDBR] ; maybe you need a shp with only ONE pixelElasticity=0.0MinZVel=12.0MaxXYVel=10.0ExpireAnim=TWLT026Damage=20DamageRadius=100Warhead=HE IsTiberium=trueLoopStart=0LoopEnd=8LoopCount=-1Rate=500;DetailLevel=0RandomRate=220,500Bouncer=yesTiberiumRadius=1TiberiumSpawnType=TIB01 ; GEM to ORE :)","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miRoox.github.io/blog/categories/代码编程/"}],"tags":[{"name":"红警","slug":"红警","permalink":"http://miRoox.github.io/blog/tags/红警/"},{"name":"功能模拟","slug":"功能模拟","permalink":"http://miRoox.github.io/blog/tags/功能模拟/"}]},{"title":"旧作：七三一纪行","slug":"731","date":"2015-09-20T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2015/09/731/","link":"","permalink":"http://miRoox.github.io/blog/2015/09/731/","excerpt":"","text":"Who controls the past controls the future; who controls the present controls the past. George OrwellNineteen Eighty-four 初到平房，现代风格的第一展区首先给了我以极大的震撼。金燦的斜阳撒在魆黑的方形外壳上，仿若一座未来的要塞堡垒从地面突兀耸起，又如一尊异域的猛兽蛰伏着却溢放辉芒。时代确竟是不同了，昔日的废土上也生长起了这样伟岸的前卫建筑，可它却是拿来纪念历史的——历史又一次走在了我们的前面吗？ 进入展馆前，要通过一道安检。安检，本质上是一种过滤、防御系统，再加上门前站岗的警员，更加强了我对它那种要塞堡垒的印象——或许它确实是个堡垒，想将时间凝结在这个历史的黑匣子里，保护起来，收藏起来，乃至供奉起来。这确实是人类的记忆啊，无怪是要保护起来的。 穿越滤门，进入了第一个展厅。映入眼帘的是由中文、英文、日文、韩文、俄文分别书写的“反人类暴行”几个大字，明耀的灯光打在字上，与幽暗的空间鲜明的对比，仿佛在向世界昭示日军的罪证暴行。可黑暗毕竟是更多的，是否暗示着更多的历史依旧笼罩在摩耶之幕下呢？ 随后是一些日军生化部队的布置介绍，基本上是一些纲要树图，也没有多少文物资料。有意思的是，除了731部队，还有诸如644部队之类的其它生化部队，可为什么只有731部队闻名呢？ 再往后走，看见的大抵不过是一些复原的模型、复制的资料以及一些残破不堪的日军遗物。这些东西，作为证据，感觉并不充分有力。作为外行，它们即使全是赝作，我们又能看出什么端倪呢？研究辨别它们，本是历史学家的工作。可如今，对历史学家的存真去伪似乎却愈发困难咯。 当然，也不是真的那么无物可看。导游带领着，浮光掠影地扫过大部分资料，讲述着老生常谈的论调，这样的行程未免太过无趣。因此我亦步亦趋地随着大部队，用自己的双眼寻找spot。 有两张有趣的照片，拍摄了七三一部队的拔河比赛和盂兰盆节，他们雀跃着，欢歌着，洋溢着幸福，可他们将要成为什么？传说“恶魔都有两副面孔”，或许是再贴切不过了。 在一个展厅里，陈列着大量诸如“A报告”、“Q报告”之类的“topsecret”的复件，确实像是最详实的资料了。“美国人成了历史的记录者，因为他们有比中国人更客观的立场和更翔实的资料。”可他们真的有立场吗？可他们真的可信赖吗？作为罪行的掩盖者，这莫非又是某个庞大计划的一环？ 还有日本人的，他们大都是口述史或回忆录式的，这本应成为最有力的证据吧？可西方人似乎并不这么看。这些内容更像是在中国共产党的“洗脑”下诞生的。“日本是一个多么文明有礼的国家啊，又怎么会做出如此残忍的虐杀呢？”“所谓坦白视频里的老兵哭的太过头，表现地太激动，简直像个疯子。共产党是洗脑的高手，毫无疑问这是他们阴谋。” 展厅里也有艺术。染血的手术台、十字架的刑场，还有用光影在墙上绘成的囚窗和掌印……鬼气森森的艺作给历史带上了一层阴森神秘之感。和历史一样，艺术毕竟也是一项主观的、充满创造力的行为啊。 离开第一展区前，有一个不小的商店，陈列着各式的纪念品和书籍。“这是历史的商品化？抑或是历史的资本价值得以发挥？”无论如何，我都不曾购买一份纪念。它正淌过我的指尖。 离开第一展区要通过一个宽敞的隧道，沿途没有警卫也没有安检，成为了一个堡垒的巨大破绽，仿佛将宝脉的“气”都放了出去。安全性的失却，令它那超现实的神秘感削弱了大半，却又像回归了历史。 第二展区在开阔的室外，这是要参观真正的历史了。可就是在七三一本部的旧址旁，团簇着大量的鸽子。和平也被战争的过往吸引着啊。 而后来到一处破败的铁架房前，据说这里曾经是炼狱。可炼狱也被时间摧残得辨认不出了，又有多少亡魂在这里徘徊？ 在锅炉房面前，我们明确地知道了什么缺失了。那些消失的钢筋暗示着历史的连续，时间并未在此定格。而令钢筋消失的，不同样也是不能忘记的历史吗？ 冷冻实验室旁有一片树林，人们称它们“历史的见证者”，可它们从未听从我们的呼唤。它们真的见证了什么吗？我不知道。 而后我看见了一方凝固的时间。匿身地下的小动物饲养室完好的保存下来，这是值得庆幸的。可作为暴行的证据，它似乎有些太弱了。这也是谋划好的吗？ “謝罪と不戦平和の誓い”据说这是日本唯一在中国明确表达谢罪之意的纪念碑。感觉却像是“为了忘却的纪念”。 最后离开之时，我回顾这片残垣，却想起了哈尔滨的烟霾弥漫，不得不回忆起刘宇昆的《纪录片：终结历史之人》。 这是一部几乎没有剧情的小说。或者，对于一部纪录片，本身也不需要什么剧情。身为著名美籍华裔科幻作家的刘宇昆带来了一个简单的故事：为了向世人还原731部队的暴行，美籍华裔历史学家埃文•魏与妻子美籍日裔物理学家桐野明美一起制作了一台可以将参与者带回过去亲眼目睹历史事件的机器，但正如“人不能两次踏入同一条河流”，这种回顾只有一次机会，而由此引发的一系列纷争则远远超出了他们的意料与控制。可他丰富地展现了不同国家不同立场的不同人的态度与观点，让真实与赝品纠缠。这正是我们难以做到的。 “我是在报纸上看到这条新闻的。报纸上说魏博士不是中国人，而是美国人。中国人都知道731部队，所以这对我们来说不算什么新闻。我实在懒得搭理这种事。那些无知的年轻人们成天叫嚣着抵制日货，然后一转头就迫不及待地去买下一期漫画。干嘛要听他们瞎扯？他们只会空口煽动民众，自己什么都不做。” “我接下来说的话一定会引起公愤，但是事实就是事实。在主席执政期间所发生的三年自然灾害和随之而来的文化大革命中，死去的人也是不计其数。战争是痛苦的，但是这不过是中国人所经历的众多痛苦中的其中一个而已。在中国，无人哀悼的悲惨往事多了去。那个魏博士真是没事找事的蠢货。历史能当饭吃，能当水喝，能当衣服穿吗？” “但是按照埃文的观点——我认为他这么想是完全合理的——一旦他接受了中国政府的任何资助，监控，或依附于中国政府，那么他的工作在西方人的眼里就毫无可信性了。因此埃文拒绝了中国给予的所有帮助，甚至请来美国外交官加以干涉。这一举动引发了中国人的众怒和排斥。最后，中国政府迫于滚滚而来的负面舆论，叫停了埃文的项目。对此几乎没有一个中国人起来为他辩护，因为他们觉得埃文和明美给中国历史及其子民非但没有带来福音，反而使其遭受了更多的损害——甚至也许是处心积虑的行为。” “日本侵略在中国造成一千六百多万人死亡。数目虽然庞大，却并不是发生在像平房区这样的死亡工厂或南京的屠杀竞技场等这些抢占报纸头条，夺人眼球的地方。相反，他们是在无数个僻静的小村庄，城镇和偏远的山区惨遭屠杀，强奸，然后再屠杀，他们的尖叫声随着刺骨的寒风渐渐消失，甚至于他们的名字也都渐渐被人遗忘。但是这些人也应该受到人们的怀念。” “虽然隔着一片狭窄的海域，中国和日本对二战暴行的态度却不谋而合：一些人要求以‘和平’和‘社会主义’的共同愿望遗忘历史；一些人将战争回忆牵扯上爱国之心；一些人把受害者和犯罪者同时打造成服务国家需要的标志。由此看来，中国的这些零碎的，不完整的回忆片段和日本的沉默不过是一枚硬币的正反面而已。” “魏博士的观点核心在于，他认为没有真实的回忆，就没有真正的和解。正是因为没有真实的回忆，各国的国民才无法感受和体会并牢记受难者的苦痛。只有每个人都能以自己的方式讲述出那段历史，我们才能够挣脱历史的束缚。” “他的方法存在很多问题。我们有大量的心理案例以及法律法规可质疑这些目击证词的可靠性。而且对于‘桐野技术’所具有的一次性特点，我们也深感忧虑。‘桐野技术’似乎会毁灭它所研究的对象，消除被见证的历史。通俗地说，就是你再也不可能回到其他目击者已经经历的那一时刻——因为经历之后它就随之消失。既然每一个目击证人的证词没有其它证词可以验证，那么我们怎么能依靠这样一种手段去寻找真相呢？” “我们生活的时代非常推崇个人化的真实记录，比如自传这种形式。目击者的叙述所具有的直接性和现实性给人一种强烈的可信感，在我们看来他们所传达的信息比任何小说都要真实。但是，矛盾的是，我们又总是迫不及待想在这些故事里找到任何一个与事实相悖和不符之处，然后宣布整个故事不过是虚构而已。我们的心理就是具有这样一种极端的阴郁特性。可是话说回来，我们从一开始就应该认清这种叙述本身就带着不可克服的主观性，不过那并不意味他们就没有传达真相。” 由于篇幅的关系，我不再继续列举更多的内容了。刘宇昆在小说中探讨的早已不只是七三一的暴行揭露了，更是对历史虚无主义探讨，是对人与历史关系的研究。引用约翰•H•阿诺德在《历史之源》结尾中的一段话： 确定一种记载优于另外一种的危险在于，它是为了把“历史”浇铸成一个单一的真实故事。主观的历史学家（具有他们自己的成见、阶级利益和性别政治）试图将他们的事件版本作为唯一可能的版本呈现出来。然而，认为历史中存在单一的真实故事，这一观念仍然具有极大的吸引力，因而也具有极大的危险性。报纸每天谈论“历史”会如何对政治家或事件做出评判，政治家在“历史向我们表明”的基础上为外交政策辩护，全球的战争集团以“他们的历史”为基础证明其杀戮的正当性。这是省略了人的历史——不管过去发生了什么，也不管现在它被用作何意，都要取决于人，取决于人的选择、判断、行为和观念。给过去的真实故事贴上“历史”的标签，是为了让它们看起来是独立于人的参与和作用而发生的。 毕竟是人书写的历史啊。 你觉得呢？","categories":[{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miRoox.github.io/blog/categories/杂谈散记/"}],"tags":[{"name":"作文","slug":"作文","permalink":"http://miRoox.github.io/blog/tags/作文/"},{"name":"散记","slug":"散记","permalink":"http://miRoox.github.io/blog/tags/散记/"}]},{"title":"旧作：从芝诺悖论到无穷小分析","slug":"ZenoParadoxAndCalculus","date":"2015-07-19T09:17:45.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2015/07/ZenoParadoxAndCalculus/","link":"","permalink":"http://miRoox.github.io/blog/2015/07/ZenoParadoxAndCalculus/","excerpt":"（高中毕业的暑假写的） 百度文库版 前言： 这是本人第一次写科普，解释可能并不很形象。建议知识水平在初中以上的读者阅读（高中水平以下的建议先阅读后面的注释[1]）。本人水平有限，如有错误，欢迎各位指正。","text":"（高中毕业的暑假写的） 百度文库版 前言： 这是本人第一次写科普，解释可能并不很形象。建议知识水平在初中以上的读者阅读（高中水平以下的建议先阅读后面的注释[1]）。本人水平有限，如有错误，欢迎各位指正。 一、“可望不可即”——芝诺之惑 一只运动速度为10米每秒的兔子与一只运动速度1米每秒的乌龟同向而行。开始时，乌龟在兔子前方9米处。问：何时兔子追上乌龟？[2] 这道题即使是小学四五年级的学生应该也能立即答出“一秒”的答案来的。然而，我们“聪明的”古希腊哲学家芝诺却为这个问题头疼不已。他在脑中模拟，想：兔子在追上乌龟之前，先要抵达两者原距离的一半处，而此时乌龟已经向前走了一段距离，接下来，兔子又要先到两者第二次距离的一半处，这时乌龟又向前走了一段，如此往复，兔子永远也无法追上乌龟。[3] 芝诺的做法似乎无可非议，可问题在哪呢？ 有人认为，时空并非无限可分，存在某种最小单元[4]，因此，他的“如此往复”，必将终止于某一阶段。那么，假如我们暂时抛却这个瑕疵，假设时空是 无限可分的 ，芝诺的推理就对了吗？ 聪明的读者也许很快就会注意到：无穷的过程是否需要无限的时间？这便是这个问题的关键。[5] [6]为了避免文章中出现许多公式与符号，我们将这个问题简化成另一个等价的问题上： “永远无法抵达的终点”：当乌龟正为自己的秘术沾沾自喜时，却发现自己永远也抵达不了一米前的终点。他首先要抵达终点的一半处，然后要抵达剩余路程的一半处，如此往复，自己永远也到达不了终点的地方。再强化一点，将终点无限移近，那他甚至无法起动。[7] 果真如此吗？ 答案当然是否定的。 对于每一段，乌龟所花的时间分别是 12,14,18,116,⋯\\frac{1}{2},\\frac{1}{4},\\frac{1}{8},\\frac{1}{16},\\cdots21​,41​,81​,161​,⋯ 乌龟所花的总时间 t=12+14+18+116+⋯t=\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\frac{1}{16}+\\cdotst=21​+41​+81​+161​+⋯ 有一点级数知识的读者当然知道求解，但我这里要提供一个小学生也能看懂的办法[8]： 12+14+18+116+⋯=12+12(12+14+18+116+⋯ )⇒12(12+14+18+⋯ )=12⇒12+14+18+⋯=1\\begin{aligned} \\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\frac{1}{16}+\\cdots &amp;= \\frac{1}{2}+\\frac{1}{2}(\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\frac{1}{16}+\\cdots) \\\\ \\Rightarrow \\frac{1}{2}(\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\cdots) &amp;= \\frac{1}{2} \\\\ \\Rightarrow \\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\cdots &amp;= 1 \\end{aligned}21​+41​+81​+161​+⋯⇒21​(21​+41​+81​+⋯)⇒21​+41​+81​+⋯​=21​+21​(21​+41​+81​+161​+⋯)=21​=1​ 当然，更聪明的读者也许会说：在空间上， 12,14,18,116,⋯\\frac{1}{2},\\frac{1}{4},\\frac{1}{8},\\frac{1}{16},\\cdots21​,41​,81​,161​,⋯ 这些距离都是从111m中分割出来的，而且除此之外也 没有剩下的 [9]，那它们的总和自然也是111。 显然， 无限的过程并不对应着无限的时间 。而且，这样算出的时间与一般方法并无二致。芝诺的错误，在于 人为的 将连续统进行了无限的划分，并错误的认为无限的任务必定不能在有限的时间内完成。 不过，我们的数学家又怎会止步于此，他们在此基础上提出了一种思想实验——“超级计算机”：这种计算机启动后0.5秒输出圆周率小数点后的第一位数，然后过0.25秒输出第二位数，之后再0.125秒输出第三位数，以此类推，那么一秒后我们可以得到圆周率的最后一位数。（尽管我们知道它没有最后一位）[10] 当然，在现实世界中，由于种种原因，这样的机器是不可能实现的，但这并不妨碍数学家们的想象它的运作。它从某个侧面揭示了数学的一种反常识现象。[11]但如果从实证的角度，这种“超级任务”不可完成，恰恰证明了芝诺这种将时间进行 人为划分 是无效的。[12] 芝诺的谬误，在现在看来是可笑的。但是在这条通往正确的荆棘之路上，第奥根尼、亚里士多德、黑格尔……大量的数学家哲学家或是误入歧途，或是倒在了求索之路上。与此同时，伴随着流数、级数等运算的深入研究，“无限”这个既抽象又形象的概念，也就需要一个逻辑上更切实的定义。 二、“瞬时是不是零？”——牛顿的尴尬 上节提到的芝诺其实是一个相当“高产”的哲学家，他一生曾巧妙地构建了四十多个悖论，其中，为了捍卫他老师巴门尼德关于“存在”不动、是“一”的学说[13]所提出的有关运动的四个悖论最为著名，上节讲的“追击悖论”便是当中的一个。而另一个著名悖论“飞矢不动”则更加凶猛，时日至今仍争论不断。 “飞矢不动”： 芝诺问他的学生：“一支射出的箭是动的还是不动的？” “那还用说，当然是动的。” “确实是这样，在每个人的眼里它都是动的。可是，这支箭在每一个瞬间里都有它的位置吗？” “有的，老师。” “在这一瞬间里，它占据的空间和它的体积一样吗？” “有确定的位置，又占据着和自身体积一样大小的空间。” “那么，在这一瞬间里，这支箭是动的，还是不动的？” “不动的，老师” “这一瞬间是不动的，那么其他瞬间呢？” “也是不动的，老师” “所以，射出去的箭是不动的？” 芝诺的论证中，有许多十分可疑的概念，而最可疑的是他对“ 不动 ”的阐述： 有确定的位置，又占据着和自身体积一样大小的空间 。表述十分拗口，而且仔细观察，这是有关运动的概念，却完全没有涉及时间。现在我们知道，在 运动 这个概念中时间是 必不可少的 。[14]很显然，如果失去时间，运动自然也就不复存在。而对任何一个瞬间，仅凭这一瞬间的空间状态其运动与否是无法判断的，只有这一瞬间 前后 物体的空间状态明晰了，我们才能判断它的运动状态。 然而，“瞬时速度”的横空出现让我们上面的说法又变得尴尬起来。原则上，我们只要知道某一刻的瞬时速度，它在这一刻的运动状态就几乎完全确定下来。[15]而瞬时速度是 瞬时的 ，它所讲的应该是 这一时刻 ，而非时间。因此，时间对运动状态判断的影响似乎又不那么重要了。 瞬时速度，这个概念也许诞生于伽利略对匀变速直线运动的研究，或者在更早的时候就有了雏形，但真正普适的计算方法，却是伴随着微积分的诞生与发展而产生的。 说起微积分，大家可能会想起牛顿与莱布尼兹的微积分创始人之争。事实上，微积分既非开始于他们，也非完成于他们。积分的概念上可追溯到古希腊的阿基米德，而导数（微分）的计算也在他们半个世纪前的开普勒时代就出现了。到17世纪，一批继承了伽利略和开普勒工作的科学家，关心着两个问题：①求切线的问题；②求曲线长度、曲面面积以及不规则物体体积的问题。而牛顿和莱布尼兹的伟大之处就在于指出了这两个问题的重要联系，即我们今天所说的牛顿-莱布尼兹公式。牛顿出于动力学研究的需要，在他的老师巴罗的工作的影响下，得到了这个重要的结果，但这个结果的广泛使用相当程度上应归功于莱布尼兹出色的形式符号。其实，巴罗在几何学的研究中已经揭示出了上面两个问题的联系，但他并未提出一般的导数与积分的概念，因而完全没有涉及运动学与动力学领域。而到了牛顿，他虽先于莱布尼兹得到这个结果，但却没有立即发表。之后，莱布尼兹在与物理学家惠更斯为一件外交事务交往时，在一个短的惊人的时间内学到了微分和积分这种新的数学概念，不久，他便独立于牛顿获得了这一结果，并立即发表了它。事后，崇拜牛顿的人与莱布尼兹的朋友发生了激烈的争执，前者毫无根据地指责莱布尼兹剽窃。随后，卷入这场争执的人越来越多，甚至发展成了一场英国科学家与欧洲大陆科学家之间历时两百多年的争执。这样的争执对科学发展是毫无意义的。特别，使用比较繁琐的牛顿的符号，并蔑视欧洲大陆莱布尼兹学派的工作，竟成为英国数学家爱国与忠于信仰的表现。这种陈腐的思想使得到了18世纪，欧洲大陆出现了伯努利、欧拉、拉格朗日以及拉普拉斯这样的数学大家时，英吉利海峡北面的不列颠岛上竟没有一个人的才华可以与他们相提并论的。事实上，不同的人从不同的问题出发，经历不同的思路，得到同一个重要的结果，这种“殊途同归”的现象在人类文明史上是屡见不鲜的。而那种追名逐利的做法却会给科学带来巨大伤害。 再回到瞬时速度，假如我们直接套用平均速度的算法显然是行不通的，因为一瞬间，时间是0，物体的位移也是0，而 00\\frac{0}{0}00​ 是无意义的。那么牛顿他们是怎么做的？[16] 我们知道，对于自由落体运动，其位移 sss 与时间 ttt 的关系满足： s=12gt2s=\\frac{1}{2}gt^{2}s=21​gt2 给时间ttt一个极小的增量 Δt\\Delta tΔt，显然从 ttt 到 t+Δtt+\\Delta tt+Δt 这段时间的平均速度为 v=ΔsΔt=12g(t+Δt)2−12g(t)2Δt=12g(2t+Δt)v=\\frac{\\Delta s}{\\Delta t}=\\frac{\\frac{1}{2}g(t+\\Delta t)^{2}-\\frac{1}{2}g(t)^{2}}{\\Delta t}=\\frac{1}{2}g(2t+\\Delta t) v=ΔtΔs​=Δt21​g(t+Δt)2−21​g(t)2​=21​g(2t+Δt) 略去 Δt\\Delta tΔt，即瞬时速度 v=gtv=gtv=gt 这也就是我们说自由落体是匀加速直线运动（速度随时间线性增加）的原因。 在这里，我们注意到一个重要的步骤： 略去 Δt\\Delta tΔt 。略去它，从本质上是令它 等于零 。牛顿对此解释称其为无限小增量，是一种 静止 的无穷小量，而莱布尼兹则认为它是高阶无穷小的误差，应当忽略。 很显然，这样的推理是不严密的， Δt\\Delta tΔt 一会儿不是零，一会儿又是零。另一方面，直觉和经验告诉人们运动的物体每一刻都有一个相对应的瞬时速度，而牛顿和莱布尼兹的做法确实可以求出相应的瞬时速度来，许多数学家和物理学家因而也承认了这种做法的有效性。 好景不长，1734年英国的哲学家神学家贝克莱发表了一本针对微积分基础的小册子《分析学家》，引起了数学界的轩然大波，诱发了我们所谓的“第二次数学危机”。这本小册子只有104页，却对微积分的基本概念，基本方法等全部内容提出了全面批评。 一方面，他批评了微积分当中许多基本概念如流数、瞬[17]、无穷小增量、初生量、消失量[18]等的模糊性。在他看来，这些重要的概念都是“隐晦的神秘物”，是“混乱与模糊”、“无理与荒谬”。对于瞬时速度，贝克莱的观点似乎与现在思想异曲同工——既然速度不能离开时间和空间，那么根本不能想象一个时间为零的瞬时速度。 另一方面，他指出了微积分基本方法的缺陷。称牛顿首先给xxx一个增量，之后又令它“消失”（等于零），显然违背了背反律，所得流数实际上不过是0/0。对于消失量，他讥讽的诘问：“这些消失的增量究竟是什么呢？它们既不是有限量，又不是无限小，也不是零，难道我们不应该称它们为消失的鬼魂吗？”同时，他也攻击莱布尼兹的微分法，认为莱布尼兹依靠“忽略高级无穷小的误差”的做法，不过是“从错误的原理出发，通过错误的抵消，得出的不科学但是正确的结论。” “在每一门其他科学中，人们用他们的原理证明他们的结论，而不是用结论来证明他们的原理。” 贝克莱主教的诘难，无疑是犀利的。他一针见血地指出了早期微积分发展时种种逻辑上的弊病，使微积分的基础问题得到了更大的重视。尽管如此，整个18世纪众多数学家弥补微积分漏洞的尝试都没能获得圆满的结果。分析学（微积分是其基础）就在这种浑浑噩噩的状态下不断发展。直至19世纪，柯西迈出了微积分走向严格化的关键一步，并由德国数学家魏尔斯特拉斯提出了完善的“ε-δ定义”，将微积分与实数紧密结合起来，最终实现“分析算术化”，使微积分建立在一个严谨的逻辑基础上，第二次数学危机也就此圆满解决。 三、“ ε-δ 的无穷小分析”——魏尔斯特拉斯的解释 在讲魏尔斯特拉斯的解释之前，我们先来谈谈两个数学的逻辑符号的意义： 逻辑算子“∀\\forall∀”“∃\\exists∃”。它们往往放在命题的前面，用于约束命题中的变量。 “∀\\forall∀”是全称量词，读作“对任意的……”，但它的意义应当是“对任意 给定的 ……”。比如一个命题，“∀x∈U，p(x)\\forall x\\in U，p(x)∀x∈U，p(x)”，其中， xxx 是 UUU 中的任一元素。但同时，在判定 p(x)p(x)p(x) 之前， xxx 必须确定下来。此时，单独研究 p(x)p(x)p(x) 所用的是之前给定的 xxx ，不能再更改。 “∃\\exists∃”是特称量词，读作“存在……”，它的意义比“∀\\forall∀”要显然一些。但有一点值得注意：特称量词既不能确定满足条件的变量的个数，更无法得到满足条件的解。如果说全称命题是先给定 xxx ，再考虑 p(x)p(x)p(x) 的话；对特称命题的判定则应先看 p(x)p(x)p(x) ，再考虑是否存在满足的 xxx。 从这里，可以看出，全称量词下的变量乍看之下是“运动”的，却也有静止的时候；特称量词下的变量，看起来固定，却又有些随意。这种辩证的关系贯穿着整个数学，尤其是数学分析。认识了这一点，才能正确的理解微积分的内涵。 有了之前的铺垫，下面便开始讲魏尔斯特拉斯的阐释。 首先，来看他关于函数极限的几条看起来比较吓人的定义[19]： 1.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (a−A,a)∪(a,a+A)(a-A,a)\\cup (a,a+A)(a−A,a)∪(a,a+A) 的集合（其中 AAA 是某个允许的正数）。若 ∀ε&gt;0,∃0&lt;δ≤A,∀x∈(a−δ,a)∪(a,a+δ),∣f(x)−α∣&lt;ε\\forall \\varepsilon&gt;0, \\exists 0&lt; \\delta\\le A, \\forall x\\in (a-\\delta,a)\\cup (a,a+\\delta), \\vert f(x)-\\alpha\\vert &lt; \\varepsilon ∀ε&gt;0,∃0&lt;δ≤A,∀x∈(a−δ,a)∪(a,a+δ),∣f(x)−α∣&lt;ε 则称函数 f(x)f(x)f(x) 当 x→ax\\to ax→a 时 趋于 （或 收敛于 ）极限 α\\alphaα。 也称函数 f(x)f(x)f(x) 当 x→ax\\to ax→a 时 有极限 α\\alphaα，记作 lim⁡x→af(x)=α\\lim_{x\\to a}{f(x)}=\\alphalimx→a​f(x)=α 。 2.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (a−A,a)(a-A,a)(a−A,a) 的集合（其中 AAA 是某个允许的正数）。若 ∀ε&gt;0,∃0&lt;δ≤A,∀x∈(a−δ,a),∣f(x)−α∣&lt;ε\\forall \\varepsilon&gt;0, \\exists 0&lt; \\delta\\le A, \\forall x\\in (a-\\delta,a), \\vert f(x)-\\alpha\\vert &lt; \\varepsilon ∀ε&gt;0,∃0&lt;δ≤A,∀x∈(a−δ,a),∣f(x)−α∣&lt;ε 则称函数 f(x)f(x)f(x) 当 x→a−x\\to a_{-}x→a−​ 时 趋于 （或 收敛于 ）极限 α\\alphaα。 也称函数 f(x)f(x)f(x) 当 x→ax\\to ax→a 时 有左极限 α\\alphaα，记作 lim⁡x→a−f(x)=α\\lim_{x\\to a_{-}}{f(x)}=\\alphalimx→a−​​f(x)=α 。 3.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (a,a+A)(a,a+A)(a,a+A) 的集合（其中 AAA 是某个允许的正数）。若 ∀ε&gt;0,∃0&lt;δ≤A,∀x∈(a,a+δ),∣f(x)−α∣&lt;ε\\forall \\varepsilon&gt;0, \\exists 0&lt; \\delta\\le A, \\forall x\\in (a,a+\\delta), \\vert f(x)-\\alpha\\vert &lt; \\varepsilon ∀ε&gt;0,∃0&lt;δ≤A,∀x∈(a,a+δ),∣f(x)−α∣&lt;ε 则称函数 f(x)f(x)f(x) 当 x→a+x\\to a_{+}x→a+​ 时 趋于 （或 收敛于 ）极限 α\\alphaα。 也称函数 f(x)f(x)f(x) 当 x→ax\\to ax→a 时 有右极限 α\\alphaα，记作 lim⁡x→a+f(x)=α\\lim_{x\\to a_{+}}{f(x)}=\\alphalimx→a+​​f(x)=α 。 4.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (a−A,a)(a-A,a)(a−A,a) 的集合（其中 AAA 是某个允许的正数）。若 ∀M∈R,∃0&lt;δ≤A,∀x∈(a−δ,a),f(x)&gt;M\\forall M \\in\\mathbb{R}, \\exists 0&lt; \\delta\\le A, \\forall x\\in (a-\\delta,a), f(x)&gt;M ∀M∈R,∃0&lt;δ≤A,∀x∈(a−δ,a),f(x)&gt;M 则称函数 f(x)f(x)f(x) 当 x→a−x\\to a_{-}x→a−​ 时 趋于 （或 发散于 ）∞\\infty∞。 也称函数 f(x)f(x)f(x) 当 x→ax\\to ax→a 时 有左极限是无穷大，记作 lim⁡x→a−f(x)=∞\\lim_{x\\to a_{-}}{f(x)}=\\inftylimx→a−​​f(x)=∞ 。 类似的，还有 右极限是无穷大 的 5.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (a−A,a)(a-A,a)(a−A,a) 的集合（其中 AAA 是某个允许的正数）。若 ∀M∈R,∃0&lt;δ≤A,∀x∈(a−δ,a),f(x)&lt;M\\forall M \\in\\mathbb{R}, \\exists 0&lt; \\delta\\le A, \\forall x\\in (a-\\delta,a), f(x)&lt; M ∀M∈R,∃0&lt;δ≤A,∀x∈(a−δ,a),f(x)&lt;M 则称函数 f(x)f(x)f(x) 当 x→a−x\\to a_{-}x→a−​ 时 趋于 （或 发散于 ）−∞-\\infty−∞。 也称函数 f(x)f(x)f(x) 当 x→ax\\to ax→a 时 有左极限是负无穷大，记作 lim⁡x→a−f(x)=−∞\\lim_{x\\to a_{-}}{f(x)}=-\\inftylimx→a−​​f(x)=−∞ 。 类似的，还有 右极限是负无穷大 的 6.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (A,+∞)(A,+\\infty )(A,+∞) 的集合（其中 AAA 是某个允许的正数）。若 ∀ε&gt;0,∃M≥A,∀x&gt;M,∣f(x)−α∣&lt;ε\\forall \\varepsilon&gt;0, \\exists M\\ge A, \\forall x&gt;M , \\vert f(x)-\\alpha\\vert &lt; \\varepsilon ∀ε&gt;0,∃M≥A,∀x&gt;M,∣f(x)−α∣&lt;ε 则称函数 f(x)f(x)f(x) 当 x→+∞x\\to +\\inftyx→+∞ 时 趋于 （或 发散于 ）极限 α\\alphaα。 也称函数 f(x)f(x)f(x) 当 x→+∞x\\to +\\inftyx→+∞ 时 有极限 α\\alphaα，记作 lim⁡x→+∞f(x)=α\\lim_{x\\to +\\infty}{f(x)}=\\alphalimx→+∞​f(x)=α 。 类似的，还有当 x→−∞x\\to -\\inftyx→−∞ 时 有极限 α\\alphaα的 7.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (A,+∞)(A,+\\infty)(A,+∞) 的集合（其中 AAA 是某个允许的正数）。若 ∀M∈R,∃L≥A,∀x&gt;L,f(x)&gt;M\\forall M \\in\\mathbb{R}, \\exists L\\ge A, \\forall x&gt;L , f(x)&gt;M ∀M∈R,∃L≥A,∀x&gt;L,f(x)&gt;M 则称函数 f(x)f(x)f(x) 当 x→+∞x\\to +\\inftyx→+∞ 时 趋于 （或 发散于 ）∞\\infty∞。 也称函数 f(x)f(x)f(x) 当 x→+∞x\\to +\\inftyx→+∞ 时 有极限 ∞\\infty∞，记作 lim⁡x→+∞f(x)=∞\\lim_{x\\to +\\infty}{f(x)}=\\inftylimx→+∞​f(x)=∞ 。 类似的，还有当 x→−∞x\\to -\\inftyx→−∞ 时 有极限 ∞\\infty∞ 的，当 x→+∞x\\to +\\inftyx→+∞ 时 有极限 −∞-\\infty−∞ 的，当 x→−∞x\\to -\\inftyx→−∞ 时 有极限 −∞-\\infty−∞ 的 8.除此之外，还有当 xxx 趋于某个值或无穷时函数 f(x)f(x)f(x) 没有极限的情况。 上面的概念看似复杂而且数目繁多，但其理念都是相似的。其中， 1 是最具有普遍性，也最利于我们加以阐明的。为了使论述更加形象，我们从一个具体的例子开始。 考虑函数 f(x)=x3+xxf(x)=\\frac{x^{3}+x}{x}f(x)=xx3+x​ 显然，函数f(x)f(x)f(x)在x=0x=0x=0处没有定义，但 ∀x≠0,f(x)=x2+1\\forall x\\ne 0, f(x)=x^{2}+1∀x​=0,f(x)=x2+1 。即 f(x)−1=x2f(x)-1=x^{2}f(x)−1=x2 。这样，我们只需把 xxx 限制在0的 充分小的邻域内 ，这个差就可以小到 任何我们所希望的程度 。比如， x=±110f(x)=1100x=±1100f(x)=110000\\begin{aligned} x&amp;=\\pm\\frac{1}{10} &amp;{} f(x)&amp;=\\frac{1}{100}\\\\ x&amp;=\\pm\\frac{1}{100} &amp;{} f(x)&amp;=\\frac{1}{10000} \\end{aligned}xx​=±101​=±1001​​f(x)f(x)​=1001​=100001​​ 等等。一般地，对于任何一个确定的正数 ε\\varepsilonε，无论它有多么小，只要我们控制xxx与0的差小于 δ=ε\\delta =\\sqrt{\\varepsilon}δ=ε​ 的话，那么 f(x)f(x)f(x) 与1之间的差将小于 ε\\varepsilonε。因为 ∣x∣&lt;ε⇒∣f(x)−1∣=∣x2∣&lt;ε\\vert x\\vert &lt; \\sqrt{\\varepsilon} \\Rightarrow \\vert f(x)-1\\vert =\\vert x^{2}\\vert &lt; \\varepsilon ∣x∣&lt;ε​⇒∣f(x)−1∣=∣x2∣&lt;ε 此时我们就称 lim⁡x→0x3+xx=1\\lim_{x\\to 0}{\\frac{x^{3}+x}{x}}=1limx→0​xx3+x​=1 再让我们回到极限概念 1 ，第一句话实际是为了让求x=ax=ax=a处的极限成为可能—— f(x)f(x)f(x) 要在 aaa 的附近有定义。这个“附近”应当与 aaa 无限的“近” [20]，而它的半径 AAA 可以任意的小。注意这个定义是挖去了“心” x=ax=ax=a 的，但它并没有要求 f(x)f(x)f(x) 在 aaa 处没有定义。 事实上， f(a)f(a)f(a) 是否存在以及其值是多少对 f(x)f(x)f(x) 在该点的极限都没有影响。只有 f(x)f(x)f(x) 在该点附近的“趋势”才决定它的极限。 第二句话也就是定义的关键。首先，是“对于任意的正数ε\\varepsilonε”。注意，在这一步后， ε\\varepsilonε 必须给定，无论是100还是1/100或是别的什么，固定下来进入下一步后就不能改变。 然后，为了方便理解，我们先跳过“存在……”这个部分，因为 δ\\deltaδ 要根据后面来确定[21]。先看“对任意包含于 (a−δ,a)∪(a,a+δ)(a-\\delta ,a)\\cup (a,a+\\delta )(a−δ,a)∪(a,a+δ) 的 xxx”，当然，这里的 xxx 同样要给定。但由于我们的 δ\\deltaδ 还“未定”，因此，我们更要留意 xxx 的遍历性，即 xxx 是可以 取遍 条件内的任何值的。 再到最后一个部分，即 f(x)f(x)f(x) 与某定值 α\\alphaα 之间的差可以小于之前给定的 ε\\varepsilonε。这时再往回看，如果定值 α\\alphaα 真是 f(x)f(x)f(x) 在 aaa 处的极限，那么我们总能找到一个合适的 δ\\deltaδ，使得任何一个包含于 (a−δ,a)∪(a,a+δ)(a-\\delta ,a)\\cup (a,a+\\delta)(a−δ,a)∪(a,a+δ) 的 xxx ，都能使最后一部分的论断成立。 最后，我们再考虑 ε\\varepsilonε 的任意性，你可以不断缩小 ε\\varepsilonε，但上述的论断始终成立。这样，定值 α\\alphaα 便是 f(x)f(x)f(x) 在 aaa 处的极限，否则，就不是。 需要注意的是，定值 α\\alphaα 的确定是先于这里面所有的步骤的，极限的定义实际上是一种判定定理，但如何求出它则有赖于我们的数学技巧。 还有一点，我们虽然通常把求极限的过程称为“趋于……”，但在 ε−δ\\varepsilon-\\deltaε−δ 定义中，自变量的范围是被动的[22]，它不以任何物理或几何意义去“趋于”一个极限 aaa。然而这个词以及符号 →\\to→ 我们仍然保留，而且没有任何一个科学家需要或打算忽视这种表达所具有的启示性直观感受。 但当我们要验证或判定一个极限时，我们仍需应用 ε−δ\\varepsilon-\\deltaε−δ 定义。至于这个定义是否很好的符合我们直观“动态”的趋近的观念，正如几何公理并不完美地提供了空间直观观念的描述[23]，它的表述丢掉了一些直观认为是真实的东西，却让这些概念有了更合适更逻辑化的数学结构。 最后，我们再梳理一遍定义 1 的文字表述（省去前面有关函数定义域的要求）：对于任意小的正数 ε\\varepsilonε，我们总能找到一个正数 δ\\deltaδ，使得任何在 (a−δ,a)∪(a,a+δ)(a-\\delta ,a)\\cup (a,a+\\delta )(a−δ,a)∪(a,a+δ) 内的 xxx，都能让 f(x)f(x)f(x) 与某定值 α\\alphaα 之间的差可以小于之前给定的 ε\\varepsilonε。 阐明了最关键的定义 1 ，我们再来看看其它几个概念中需要注意的地方。 左极限与右极限实际上是极限的弱化，它们使求区间边界处的极限成为可能。但另一方面，在某点有左极限、右极限并不意味着一定有极限，只有该点左右极限相等时才有极限。 另外一个重要概念的就是我们分析中的“无穷”。通常，分析中的“无穷”不是一个 实在的 概念[24]，而且往往要与其它成分结合起来使用。比如我们可以把极限的概念说成当自变量与 aaa 相差一个无穷小量时，因变量与 α\\alphaα 的差也是一个无穷小量。这里，我们要注意前后两个“无穷小量”的意义是 不同的 。 当然，这种说法十分粗略，正如前面所说，牢记极限的标准概念才是研究科学应有的谨严态度（尽管如此，许多物理学家和工程师都喜欢用“无穷小量”、“微元”之类的表述）。 类似的，所谓“无穷大”在不同的地方意义也不同。用于自变量时是“存在某个值，当 xxx 大于它，……”；用于因变量时是“对于任意某个给定值，（某条件下）， f(x)f(x)f(x) 都比它大”。 同样，也有人把它简单地理解成“一个比任何其他数都要大的数”。显然，照这样理解，一个有限的数无论如何也加不到无限，这大概也是芝诺追龟问题的理由吧。[25] 理清了极限的概念，在谈导数之前，我们先来讲一下“连续”。 有了前面的极限的铺垫，连续也就很好定义了。 先说 f(x)f(x)f(x) 在（不在边界的）某一点 aaa（附近）的连续性[26]： 函数值 f(a)f(a)f(a) 存在； 极限 lim⁡x→af(x)\\lim_{x\\to a}{f(x)}limx→a​f(x) 存在； f(a)=lim⁡x→af(x)f(a)=\\lim_{x\\to a}{f(x)}f(a)=limx→a​f(x) 以上三点都成立的话，我们就称f(x)f(x)f(x)在aaa处连续。 如果函数的定义域连通[27]且函数在定义域内的每一点连续，我们则称函数f(x)f(x)f(x)连续。 了解了前面极限的几何意义，我们很容易看出，连续的定义也符合我们直观上对连续的认识。而如果我们从连续的角度看的话，极限在很多时候是把一些不连续的函数扩张成一个连续的函数，譬如之前例举的函数 f(x)=x3+xxf(x)=\\frac{x^{3}+x}{x}f(x)=xx3+x​ ，如果我们令一个新函数 f‾(x)={f(x),if x≠01,if x=0\\overline{f}(x)= \\begin{cases} f(x),&amp; \\text{if}\\ x\\neq 0 \\\\ 1, &amp; \\text{if}\\ x=0 \\end{cases}f​(x)={f(x),1,​if x​=0if x=0​ 那么新函数在原来函数的定义域内与原来的函数完全是相同的。但与原来函数不同的是，它成了 R\\mathbb{R}R 上的一个连续函数。这个过程我们叫“保证函数连续性的延拓”[28]，它合理地将函数的范围扩大了，同时函数原有的部分也没有改变。只要我们承认函数的连续性，这样的延拓就是有意义的。 最后，我们再来谈谈分析中最基础的，也是曾困扰了数学界许多年的导数（微分）。 在抛弃了无穷小量的现在[29]，借助极限，我们很容易将导数的概念建立在一个严谨的逻辑基础上面。 函数 f(x)f(x)f(x) 在某点 aaa 处的导数定义为[30] f′(a)=lim⁡Δx→0f(a+Δx)−f(a)Δxf&#x27;(a)=\\lim_{\\Delta x\\to 0}{\\frac{f(a+\\Delta x)-f(a)}{\\Delta x}} f′(a)=Δx→0lim​Δxf(a+Δx)−f(a)​ 至于所谓的瞬时速度不过是位移对时间的导数 v⃗=lim⁡Δt→0Δs→Δt\\vec v =\\lim_{\\Delta t\\to 0}{\\frac{\\overrightarrow{\\Delta s}}{\\Delta t}}v=limΔt→0​ΔtΔs​ ，由极限的定义我们知道瞬时速度绝不是单属于某一 时刻 的性质，而与这一时刻 前后 的状态息息相关。 那么瞬时速度本身的涵义，则是 ttt 到 t+Δtt+\\Delta tt+Δt（或 t+Δtt+\\Delta tt+Δt 到 ttt 当 Δt&lt;0\\Delta t&lt;0Δt&lt;0 时）的平均速度 v(Δt)v(\\Delta t)v(Δt) 在 Δt=0\\Delta t=0Δt=0 处进行延拓的结果，而只要我们相信时空的连续性[31]，瞬时速度的内涵也无可置疑。 有了瞬时速度，配合我们所谓的“无穷小分析”，大量的动力学问题也才有了解决的可能。 在现代科学中，“无穷小分析”已经渗透到各个领域，几乎无所不在。本文主要介绍的不过是无穷小分析中基础中的基础——极限与导数，而关于它们的认识却困扰了数学界百余年。一切正如马克思所说：“在科学上没有平坦的大道，只有不畏劳苦沿着陡峭山路攀登的人，才有希望达到光辉的顶点！” 参考资料： [1]【美】莫里斯·克莱因. 古今数学思想.第1册. 张理京，张锦炎，江泽涵译. 上海：上海科学技术出版社. 2002 [2]【美】莫里斯·克莱因. 古今数学思想.第2册. 朱学贤等译. 上海：上海科学技术出版社. 2002 [3]【美】莫里斯·克莱因. 古今数学思想.第4册. 邓东皋等译. 上海：上海科学技术出版社. 2002 [4] 韩雪涛. 从惊讶到思考：数学悖论奇景. 长沙：湖南科学技术出版社. 2007 [5] 陈天权. 数学分析讲义·第一册. 北京：北京大学出版社. 2009 [6]【美】R·柯朗，H·罗宾. 什么是数学：对思想和方法的基本研究. I·斯图尔特修订. 左平，张饴慈译. 上海：复旦大学出版社. 2011 （部分图片来自网络） 这些主要是给知识水平在高中以下的读者参考的： 集合 ： 朴素地， 集合 就是一些东西的总体（这些东西中不应有重复（ 内涵 与 外延 都相同），比如： {1,1}\\{1,1\\}{1,1} 这种记法是错误的，但 {(1,0),1}\\{(1,0),1\\}{(1,0),1} 是合法的）。总体中的东西被称为这个集合的 元素 （如：“xxx 是集合 AAA 中的元素”，记作“x∈Ax\\in Ax∈A”）。若两个集合的每个元素都相同，则这两个集合 相等 。如果一个集合的全部元素都属于另一个集合，则该集合称之为这另一个集合的 子集 （如：集 AAA 是集 BBB 的子集，记作“A⊆BA\\subseteq BA⊆B”）。两个集合的 交集 ，即两个集合公共元素组成的集合（如：集 AAA 与集 BBB 的交集，记作“A∩BA\\cap BA∩B”）。两个集合的 并集 ，即这两个集合所有元素组成的集合（如：集 AAA 与集 BBB 的并集，记作“A∪BA\\cup BA∪B”）。元素都是数的集合叫 数集 ，本文中出现的集合都是数集。本文出现了的几个数集符号：自然数集 N\\mathbb{N}N、正整数集 N+\\mathbb{N}_{+}N+​、实数集 R\\mathbb{R}R。 区间 ：集合的一种表现形式，都是实数集 R\\mathbb{R}R 的子集。(a,b)(a,b)(a,b) 表示满足 a&lt;x&lt;ba&lt; x&lt; ba&lt;x&lt;b 的所有 xxx 组成的集合；[a,b)[a,b)[a,b) 表示满足 a≤x&lt;ba≤ x&lt; ba≤x&lt;b的所有 xxx 组成的集合；(a,b](a,b](a,b] 表示满足 a&lt;x≤ba&lt; x≤ ba&lt;x≤b 的所有 xxx 组成的集合；[a,b][a,b][a,b] 表示满足 a≤x≤ba≤ x≤ ba≤x≤b 的所有 xxx 组成的集合。 函数 ：在本文中是指两个 数集 之间的对应关系，它使得其中一个数集的任何一个元素在另一个数集中都有 唯一确定 的一个元素与之对应。比如一个集 AAA 到集 BBB 的函数 f:A→Bf:A\\to Bf:A→B 是使得任何 x∈Ax\\in Ax∈A，都存在 y∈By\\in By∈B，满足 y=f(x)y=f(x)y=f(x) 的对应关系，这里，我们称集 AAA 为 定义域 ，集 BBB 为 值域 ， xxx 为 自变量 ， yyy 为 因变量 。 分析：与几何、代数等并列的数学主要分支之一。微积分是其基础。 矢量：区别于标量（数量），它既有大小，又有方向，加减运算遵循平行四边形定则。 ↩︎ 芝诺原始的悖论讲的是阿喀琉斯追龟（阿喀琉斯是古希腊善跑的勇士），但问题的实质是一样的。另外，实际生活中的兔子要更快，乌龟要更慢。 ↩︎ 这个问题的数学解答： 按芝诺的分法，记第 nnn 次兔子走过的路程为 ana_{n}an​ (m)，所花的时间为 tnt_{n}tn​ (s)，同时乌龟走过的路程为 bnb_{n}bn​ (m)，并记nnn次兔子走过的总距离 An=∑k=1nakA_{n}=\\sum_{k=1}^{n} a_{k}An​=∑k=1n​ak​ (m)，所花的总时间 Tn=∑k=1ntkT_{n}=\\sum_{k=1}^{n} t_{k}Tn​=∑k=1n​tk​ ，这段时间乌龟走过的总路程 Bn=∑k=1nbkB_{n}=\\sum_{k=1}^{n} b_{k}Bn​=∑k=1n​bk​ 。 由题设， a1=92a_{1}=\\dfrac{9}{2}a1​=29​ ， tn=an10t_{n}=\\frac{a_{n}}{10}tn​=10an​​ ， bn=tnb_{n}=t_{n}bn​=tn​ ，即bn=an10b_{n}=\\frac{a_{n}}{10}bn​=10an​​ 并且， an+1=Bn−An+92a_{n+1}=\\frac{B_{n}-A_{n}+9}{2}an+1​=2Bn​−An​+9​ 又bn=an10b_{n}=\\frac{a_{n}}{10}bn​=10an​​ ，故Bn=An10B_{n}=\\frac{A_{n}}{10}Bn​=10An​​ ，因而， an+1=92−9An20a_{n+1}=\\frac{9}{2}-\\frac{9 A_{n}}{20}an+1​=29​−209An​​ ……① 同理， an+2=92−9An+120a_{n+2}=\\frac{9}{2}-\\frac{9 A_{n+1}}{20}an+2​=29​−209An+1​​ ……② ②-①，得 an+2=1120an+1,(n≥1)a_{n+2}=\\frac{11}{20}a_{n+1} ,(n\\ge 1)an+2​=2011​an+1​,(n≥1) 又由①， a2=92−9a120=92⋅1120a_{2}=\\frac{9}{2}-\\frac{9 a_{1}}{20}=\\frac{9}{2}\\cdot\\frac{11}{20}a2​=29​−209a1​​=29​⋅2011​ 故an=92(1120)n−1a_{n}=\\frac{9}{2}(\\frac{11}{20})^{n-1}an​=29​(2011​)n−1 ， bn=920(1120)n−1b_{n}=\\frac{9}{20}(\\frac{11}{20})^{n-1}bn​=209​(2011​)n−1 ， tn=920(1120)n−1t_{n}=\\frac{9}{20}(\\frac{11}{20})^{n-1}tn​=209​(2011​)n−1 则An=10(1−(1120)n)A_{n}=10(1-(\\frac{11}{20})^{n})An​=10(1−(2011​)n) ， Bn=1−(1120)nB_{n}=1-(\\frac{11}{20})^{n}Bn​=1−(2011​)n ， Tn=1−(1120)nT_{n}=1-(\\frac{11}{20})^{n}Tn​=1−(2011​)n 龟兔间距离 dn=Bn−An+9=(1120)nd_{n}=B_{n}-A_{n}+9=(\\frac{11}{20})^{n}dn​=Bn​−An​+9=(2011​)n ，当n→∞n\\to \\inftyn→∞ ， dn→0d_{n}\\to 0dn​→0 故追击时间 T=lim⁡n→∞Tn=1T=\\lim_{n\\to \\infty}{T_{n}}=1T=limn→∞​Tn​=1 ↩︎ 这种说法并不准确。事实上，目前的量子力学、量子宇宙学都并没有否认时空的连续性，只是认为小于一定尺度（普朗克长度/普朗克时间）内发生的物理过程 没有意义 。 ↩︎ ↩︎ 后文中我们会知道，无限在分析中并不是一个 实在 的量，定义上无限即 不可达到 ，这大概就是芝诺认为追及是不可能的的原因。（可参见[25:1]。） ↩︎ 事实上，这个问题更准确的认识应当是芝诺 人为划分 的 芝诺时 与我们实际中的 固有时 之间转化的差异。在这里，芝诺时的全部只对应于固有时的[0,1)[0,1)[0,1)（单位：秒）这个区间。因此，芝诺所说的“不可达到”，实际上是芝诺时的 划分意义 上的不可达到，因为他的时间“永远”也走不到1秒。 ↩︎ ↩︎ ↩︎ ↩︎ 这个问题实际上是芝诺的另一个经典悖论——“二分法悖论”。但两者的解决办法相同。 ↩︎ 直接这样处理并不严谨，因为在各种级数中，只有绝对收敛的级数才满足加法结合律。 ↩︎ “没有剩下”即默认了乌龟能够抵达目的地，这可能是有违芝诺本意的。 ↩︎ 这个问题也可以套用[6:1]中的解决办法，即“超级计算机”的输出也是按芝诺时来度量的，电脑的输出规则实际是一个关于时间的函数，但它的定义域只在 [0,1)[0,1)[0,1) （单位：秒）这个区间内， t=1st=1st=1s 时的情况对它来说是 未定义的 。 ↩︎ ↩︎ ↩︎ “反常识现象”是指超穷基数的大小比较。详情见下一篇《“潜无限”与“实无限”》。 ↩︎ “无效”的原因如[6:2]与[10:1]中所述。 ↩︎ 巴门尼德的学说认为存在是永恒的，是一，连续不可分，可以被思想，以及感性世界的具体事物是非存在，是假象，等等。 ↩︎ 现在，物理学界更多认为有运动（尤其是周期运动）才有时间（或者时间的度量），完全静态的宇宙中不存在时间。 ↩︎ “几乎完全”是因为瞬时速度为零时，如果加速度不为零，物体也不处于静止状态。 ↩︎ 严格来说，这是当时一些数学家的做法，牛顿的方法形式上更复杂，但并没有本质的差别。 ↩︎ “瞬”是牛顿早期使用的不可分增量，而“流数”则是在处理连续变量时使用的。 ↩︎ “初生量”的概念确实不清不楚，大概是自变量与因变量的增量 Δt\\Delta tΔt 以及 Δs\\Delta sΔs；而“消失量”是指它们两个正在“消失”时的量（牛顿的解释）。 ↩︎ 这个定义最早是由柯西与1820年左右提出的，但准确的数学符号表示还是由魏尔斯特拉斯给出的。 ↩︎ 任意地 给定误差，范围内总有点与 aaa 的距离小于该误差。 ↩︎ 从整体上看，如果 α\\alphaα 是极限的话，应当有一个适当的函数 g(x)g(x)g(x) 使得 δ\\deltaδ 最大不超过 g(ε)g(\\varepsilon)g(ε) 即可，就像例函数中的 δ=ε\\delta =\\sqrt{\\varepsilon}δ=ε​ 一样。从这个意义上讲， δ\\deltaδ 也算是“确定”的。 ↩︎ 极限概念的一个关键点是，我们是靠控制因变量的范围来控制自变量的。这和我们平时的认知可能有些不一样。而且，误差 ε\\varepsilonε 虽然是任意给定的，但给定多少是没有先后的，既不是从大到小，也不是从小到大，甚至没有任何顺序可言。给定 ε\\varepsilonε 的值这一步是非时间的，我们可以想象成有无数个并列的进程，所有进程的第一步都给定了一个正数，每个进程给出的正数各不相同，且所有进程给出的正数将每一个正数都覆盖到了，然后，它们各自再走向下一步。这一点与我们直观上的“趋于”确实相差很大。 ↩︎ 没有大小的点、没有宽度的线、无限延伸的直线……这些概念在现实中都是不存在的，是从现实事物中抽象出的理想元素，但对于我们研究现实确实起到了很大的作用。 ↩︎ 尽管如此，在勒贝格积分中我们引入了包含无穷大元素 ±∞{\\pm\\infty }±∞ 的扩张了的实数集 R‾\\overline{\\mathbb{R}}R，在非标准分析中我们引入了含有无穷小数和无穷大数的超实数系 R∗\\mathbb{R}*R∗，在集论中我们甚至有可以比较大小的“无限”——超穷基数。它们都是有明确数学意义的概念。 ↩︎ ↩︎ 事实上，极限也不能直接帮我们解决这个问题。虽然，无穷级数 ∑k=1∞12k=1\\sum_{k=1}^{\\infty}\\frac{1}{2^{k}}=1∑k=1∞​2k1​=1 。但根据极限的定义，这个级数的真正含义应当是 ∀ε&gt;0,∃N∈N+,∀n≥N,∣∑k=1n12k−1∣&lt;ε\\forall \\varepsilon&gt;0, \\exists N \\in \\mathbb{N}_{+}, \\forall n\\ge N, \\vert \\sum _{k=1}^{n} \\frac{1}{2^{k}} -1 \\vert &lt; \\varepsilon∀ε&gt;0,∃N∈N+​,∀n≥N,∣∑k=1n​2k1​−1∣&lt;ε ，并不允许“真正的”无限出现。这似乎让我们第一节中的解决办法难以在逻辑上站住脚。另一方面，这解释了[6:3]和[10:2]中的全部“芝诺时”只对应与我们固有时的[0,1)[0,1)[0,1) （单位：秒）的原因。 ↩︎ ↩︎ 在边界时，我们有左连续与右连续，分别对应于左极限与右极限的情况。 ↩︎ 这个条件简单的说就是函数的定义域应该可以表示成一个区间。连通性，比较形象的说法是集合中的任何两点可以用一条每一点都属于该集合的线连接起来（这实际上是道路连通，在这里没有太多差别）。 ↩︎ 事实上，这只是延拓的一种方法，只适用于有限个可去间断点的情况。更复杂的情况我们需要限制更多条件（可微、光滑之类的），而且延拓的结果可能不止一种。 ↩︎ 如[24:1]所述，于1960年左右发展起来的非标准分析用完美的逻辑使曾经不光彩“无穷小”重新焕发生机。唯一的缺陷是它所使用的数理逻辑方法太过艰深，以致难以普及。 ↩︎ 在现代分析中，导数（微分）不再是一个数，而是一个线性映射，是对原有函数的线性近似。 ↩︎ 见[4:1]。 ↩︎","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miRoox.github.io/blog/categories/数理科学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miRoox.github.io/blog/tags/数学/"},{"name":"微积分","slug":"微积分","permalink":"http://miRoox.github.io/blog/tags/微积分/"},{"name":"科普","slug":"科普","permalink":"http://miRoox.github.io/blog/tags/科普/"}]},{"title":"旧作：Idea","slug":"Idea","date":"2015-07-09T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2015/07/Idea/","link":"","permalink":"http://miRoox.github.io/blog/2015/07/Idea/","excerpt":"(不怎么科幻的科幻小说，曾投稿至科幻星云网举办的第四届幻想类征文比赛)","text":"(不怎么科幻的科幻小说，曾投稿至科幻星云网举办的第四届幻想类征文比赛) Idea [1] 大自然到底能否究诘呢？ 歌德 一切都明亮起来。 视野的中央有一道轮廓，比周围的色彩更暗淡一些。 轮廓的最上部圆中带方，经由一段短轴似的结构与下面的主体——“躯干”——平滑相连。“躯干”又连接着上下共四个分支——“肢”。“上肢”在结点处自然弯曲，并在其末端散出更多细小的分支——“指”。 分支是灵活的，只要他想。 “肢”可以按他的意愿绕关节灵活转动。 “指”可以按他的意愿弯曲扭动。 活动视野却不能让“躯干”从中脱离。 「自我」 他如是认为。 “有意思的开头。”埃尔温博士自语着，将页面收藏后，关闭了IdeaReader的视窗。 “是时候干正事了。” 埃尔温博士有晨读的习惯，劳逸结合的同时还常常能给他带来好的灵感。而现在正是准备博士论文的时候。 事实上，论文的内容已经在他的心中酝酿许久了。虽然其中的创见早已被他人提到过，但没有一个人的模型像他这样完备自洽。 “多美妙啊！”想着，埃尔温博士不由地兴奋起来，轻盈的手指在键盘上跃动颤抖。 大部分的时间里，理论物理的研究非常枯燥无味。除了大量的运算和繁琐的检查，常常还不得不研读许多晦涩抽象的数学文献以寻找理论研究的突破口。高强度的工作让埃尔温博士早生华发，甚至有了些绝顶的趋势。天天在书房里研究的埃尔温长年不修边幅，脏兮兮的衣服，蓬乱的头发，胡子拉碴的脸上还有浓重的黑眼圈，怎么看都是一副屌丝(loser)的样子，以至于他的许多老同学讥讽地称他为“埃尔温大学士(Bachelor Erwin)”。[2] “好呀，你们这群以貌取人的家伙。”埃尔温醉醺醺地摆动着手指，摇头晃脑，绯红的面庞闪亮着油光，“看我下次聚会的时候把缇娜带来～” “哇哦！大伙听到了没，埃尔温说他下次要把他的充气玩偶带来呢！” “该不会是最近挺流行的那个什么‘虚拟偶像’吧？想想我们的‘埃尔温大学士(Bachelor Erwin)’整天对着掌机甜言蜜语……天哪！我要笑破肚皮了。哈哈哈……” “啊哈哈哈……” “……” “呵——欠～” “有些累了。”感觉屏幕上的字变得有些模糊，埃尔温博士推了推他的金丝眼镜，“或许我应该休息一下，转换一下心情。” 保存好论文的草稿，埃尔温博士从收藏中打开今晨读的那段开头，微笑着，饶有兴趣地，继续读了下去。 睁开眼。 「我」依旧在视野中央。 周围散布着一些奇异的团块，有些地方有棱角，有些地方又很圆滑，不时地，还会发生一些形变。它们在空中，时而飘移，时而碰撞，有时竟还会对穿而去。 “无法解释的现象。”他认为。 这时，一个较大的团块从右侧向他飞来。几乎本能地，他伸展弯曲的“上肢”将团块拨开，却突然发现几乎所有团块都变向右移去。 “这些团块，虽然没有直接连接在一起，但有一种无形的联系将它们‘超距’地合为一个整体。” 他思考着，左侧又有团块向他扑来。自然，他想用“上肢”将其推开。出人意料的是，他毫不费力地穿了过去，只不过叠合的地方色彩更深了一些。这使他能够区分「自己」与团块。 “这个团块”他沉思了一会儿，“有着和我不一样的「成分」，因而我们彼此之间没有任何作用，呈现「孤立」状态……” …… “孤立子！”从事多年物理研究的埃尔温博士立马想到了这个名词，眼里仿佛冒出了金光。 “不过，‘他’就没有考虑过‘视野在身体之外’这个问题吗？如果从这个角度考虑的话……是‘平面国人奇遇记’？不，这应当是柏拉图古老的‘洞穴寓言’吧。”埃尔温博士漫无目的地发散着奇思异想，思绪如脱缰的野马自由奔腾。 “这就是我们物理学的现状与终结吧。” 如同靡菲斯特的低语，梦魇般的念头将埃尔温博士牢牢抓住。 他摇摇头，仿佛要将这个念头逐出脑海，却又如水手结般越扯越紧。几乎无意识地，埃尔温博士在保存之前便关闭了IdeaReader的窗口。 孤独的空气中弥漫起了焦躁的氛围。 “也许。” 埃尔温博士在扶椅上闭目静思了一会儿。 “至少我希望这篇论文能够成为解答。” 「众所周知，由于“宇宙监督假设”，几乎所有的奇点都被安全地隐藏与事件视界之内。正因如此，我们能够使用一些熟悉的物理定律来描述和预测我们所能观测到的世界，而免于裸奇点所带来的糟糕影响。」 「然而，当我们试图追溯宇宙之初时，大爆炸奇点似乎是一个纯粹的裸奇点，它使我们的一切物理法则在大爆炸开始时失效。」 「通常，裸奇点的出现意味着某一理论的局限性。因而，奇点的解析研究便成为了宇宙学中早期宇宙研究的活跃领域。」 「注意到事件视界所带来的便利性，我们猜想：大爆炸奇点是否也会被一个事件视界所包裹？」 「我们知道，三维空间中的黑洞其视界是二维的。但我们感知的这个宇宙有三个空间维度，因而遮蔽大爆炸奇点的事件视界应当也是三维的。」 「借助DGP模型的方法，我们成功诱导出了宇宙的膜世界表达——宇宙像一个在五维（包含时间）史瓦西黑洞上的球形三维膜一样产生。」 「遮蔽大爆炸奇点的三维事件视界，应该是四维宇宙中巨大恒星坍缩产生的。」 「暗物质的星际锁链也许来源与四维星体。」 「宇宙膨胀本质上其实是黑洞事件视界的扩大。」 「坍缩前的四维恒星质量越大，其黑洞的三维视界就越平坦。我们宇宙的平坦性源于巨大的四维恒星。」 「由于四维宇宙可能存在了无限久，空间已趋于光滑，因而三维宇宙也继承了这种光滑性。」 「……」[3] “一个合理的理论模型——光滑性和平坦性、暗物质与暗能量……诸多难题都可以解释，剩下的就是更加精确的天文观测来检验了。” 夜已深暝，埃尔温博士最后审读了一遍他的论文。 “该睡觉了。” 简单洗漱后，埃尔温博士来到床边，踌躇地望着床头那个名为IdeaReader的枕状仪器。​ 「“IdeaReader 睡眠版”产品使用说明书： （捕捉思想的每一点灵光…） 产品概述： 失眠者和聪明人的福音！本机是一款前卫实用的精神保健仪器，适用于床榻、扶椅等休憩之处。枕上它，您不仅会告别失眠的烦恼，还可以保留住梦中的灵光一闪，让您在工作中创新的源泉不竭。 功能特点： 【催眠脉冲】按个人特征滤调后的电磁脉冲，无害剂量，促进睡眠，告别失眠烦恼。 【梦境捕捉】与脑波调谐，放大信号，活化潜意识里的创造力，读取梦中信息。 【梦境重构】重现梦境，输出图像文本，把握睡梦中闪念的灵光。 ………… 」 “不会的吧……不会的。”埃尔温博士坐在床边喃喃自语，“我很清醒认识到了本质……恶魔不会到来。” 躺下，IdeaReader像感应到猎物的猫类一样亮起了侧灯的光。积累了一天的疲怠如潮水般很快将埃尔温的意识吞没，带他沉入梦乡。 “视野在躯体之外，这意味着什么？” 他明白了，宛如醍醐灌顶。 “所见之「我」，不过是投射在壁面上的光影假象。实在之我，则应存在于更高层次的空间中。” 一切简单明了。 “异常之‘形变’不过是旋转导致的投影面变化；奇诡之‘对穿’本是不同层物体投影的邂逅；莫名的‘超距’作用实则‘我’被推行移动。‘成分’、‘孤子’……冗余的的解释变得毫无必要。新的视野下，不同的现象获得了简洁的统一。这是事物认知的新纪元！” 突然，一个与众不同的物件从他眼前飘过。 “抓住它。”他想着，“手”第一次在视野中展现出它真正的构造。 抓住的一瞬间，如神谕般的信息向他的思想奔流。 一把匕首。 “生存游戏么？”他能感受到嘴角扬起的弧线。 他摇荡双腿，如鱼儿般游动起来，在壁面上划出一道优美的弧。​ “来了。” 猎物就在眼前，毫无察觉地将要害暴露。 光线昏暗，他将手中的利刃向前刺去。​ 匕首从背部穿入对方的身体，刺向心脏的位置。这是他的胜利。 “嗯？” 被刺中的对手没有任何反应，只看见对方的匕首插在了空中。 “痛！” 可他的胸口却传来剧痛。 浑身失力，视野模糊。感到天旋地转的他看见了对方的恶魔之影——那匕首插入了“空”，可它的“影”却穿入一团心形的暗影之中。 如将灭之烛光，他的思维前所未有的活跃起来，无数的猜想像走马灯般闪过，似蛛网般交织缠结，企图寻找一个答案。 “全息……” 他如蒙神启。​ ​ 参考资料： 【1】理想国/（古希腊）柏拉图著；郭斌和，张竹明译.—北京：商务印书馆，1986.8 【2】超越时空：通过平行宇宙、时间卷曲和第十维度的科学之旅/（美）加来道雄（Kaku，M.）著；刘玉玺，曹志良译.—上海：上海科技教育出版社，2009.6 【3】越弱越暗越美丽/李淼著.—南京：江苏文艺出版社，2013.4 【4】Out of the White Hole: A Holographic Origin for the Big Bang. Razieh Pourhasan, Niayesh Afshordi and Robert B. Mann in Journal of Cosmology and Astroparticle Physics, Vol. 2014, Article No. JCAP04(2014)005;April 2014. 注释： [1]: “idea”一词有“主意”、“想法”、“表象”、“信念”等译意。 [2]: “bachelor”有“学士”的意思，也有“单身汉”之意。 [3]: 关于论文的那一段：真正的论文大概不会这么写，其中部分内容参考了 参考资料【4】的摘要。","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miRoox.github.io/blog/categories/小说文艺/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miRoox.github.io/blog/tags/小说/"},{"name":"科幻","slug":"科幻","permalink":"http://miRoox.github.io/blog/tags/科幻/"}]},{"title":"旧作：关于函数列 x,x²+x,x³+3x²+x,x⁴+6x³+7x²+x,……","slug":"BellPolynomial","date":"2015-06-27T09:33:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2015/06/BellPolynomial/","link":"","permalink":"http://miRoox.github.io/blog/2015/06/BellPolynomial/","excerpt":"x,x2+x,x3+3x2+x,x4+6x3+7x2+x,…x,x^2+x,x^3+3x^2+x,x^4+6x^3+7x^2+x,\\dots x,x2+x,x3+3x2+x,x4+6x3+7x2+x,… 这是对前一篇文章的一个补充和推广。","text":"x,x2+x,x3+3x2+x,x4+6x3+7x2+x,…x,x^2+x,x^3+3x^2+x,x^4+6x^3+7x^2+x,\\dots x,x2+x,x3+3x2+x,x4+6x3+7x2+x,… 这是对前一篇文章的一个补充和推广。 显然，令其中的 x=1x=1x=1 ,函数列就成为数列 1,2,5,15,…1,2,5,15,\\dots1,2,5,15,…。 事实上，这一函数列来自原数列问题的推广 fn(x)=∑k=0+∞knk!xkf_n(x)=\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!}x^k fn​(x)=k=0∑+∞​k!kn​xk 而前几项 f1(x)=xexf2(x)=(x+x2)exf3(x)=(x3+3x2+x)exf4(x)=(x4+6x3+7x2+x)ex\\begin{aligned} f_1(x)&amp;=x\\mathrm{e}^x\\\\ f_2(x)&amp;=(x+x^2)\\mathrm{e}^x\\\\ f_3(x)&amp;=(x^3+3x^2+x)\\mathrm{e}^x\\\\ f_4(x)&amp;=(x^4+6x^3+7x^2+x)\\mathrm{e}^x\\\\ \\end{aligned}f1​(x)f2​(x)f3​(x)f4​(x)​=xex=(x+x2)ex=(x3+3x2+x)ex=(x4+6x3+7x2+x)ex​ 显然，原数列只是其特例 an=∑k=0+∞knk!=fn(1)a_n=\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!}=f_n(1) an​=k=0∑+∞​k!kn​=fn​(1) 受此影响，我开始采用的是与之前一样的做法： f1(x)=∑k=0+∞kk!xk=x∑k=1+∞1(k−1)!xk−1=xexfn(x)=∑k=0+∞knk!xk=∑k=1+∞kn−1(k−1)!xk=∑k=1+∞(k−1)n−1(k−1)!xk+∑j=1n−1[(−1)j+1Cn−1j∑k=1+∞kn−j−1(k−1)!xk]=x∑k=1+∞kn−1k!xk+∑j=1n−1[(−1)j+1Cn−1j∑k=1+∞kn−jk!xk]=xfn−1(x)+∑j=1n−1[(−1)j+1Cn−1jfn−j(x)]\\begin{aligned} f_1(x)&amp;=\\sum_{k=0}^{+\\infty}\\frac{k}{k!}x^k=x\\sum_{k=1}^{+\\infty}\\frac{1}{(k-1)!}x^{k-1}=x\\mathrm{e}^x\\\\ f_n(x)&amp;=\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!}x^k\\\\ &amp;=\\sum_{k=1}^{+\\infty}\\frac{k^{n-1}}{(k-1)!}x^k\\\\ &amp;=\\sum_{k=1}^{+\\infty}\\frac{(k-1)^{n-1}}{(k-1)!}x^k+\\sum_{j=1}^{n-1}\\left[(-1)^{j+1}C_{n-1}^j\\sum_{k=1}^{+\\infty}\\frac{k^{n-j-1}}{(k-1)!}x^k \\right]\\\\ &amp;=x\\sum_{k=1}^{+\\infty}\\frac{k^{n-1}}{k!}x^k+\\sum_{j=1}^{n-1}\\left[(-1)^{j+1}C_{n-1}^j\\sum_{k=1}^{+\\infty}\\frac{k^{n-j}}{k!}x^k \\right]\\\\ &amp;=xf_{n-1}(x)+\\sum_{j=1}^{n-1}\\left[(-1)^{j+1}C_{n-1}^jf_{n-j}(x) \\right] \\end{aligned}f1​(x)fn​(x)​=k=0∑+∞​k!k​xk=xk=1∑+∞​(k−1)!1​xk−1=xex=k=0∑+∞​k!kn​xk=k=1∑+∞​(k−1)!kn−1​xk=k=1∑+∞​(k−1)!(k−1)n−1​xk+j=1∑n−1​[(−1)j+1Cn−1j​k=1∑+∞​(k−1)!kn−j−1​xk]=xk=1∑+∞​k!kn−1​xk+j=1∑n−1​[(−1)j+1Cn−1j​k=1∑+∞​k!kn−j​xk]=xfn−1​(x)+j=1∑n−1​[(−1)j+1Cn−1j​fn−j​(x)]​ 这样，我们原则上可以获得这一函数列的任意项（虽然很难算）。 然而，很快我就发现了另一种简便许多的办法： fn+1(x)=∑k=0+∞kn+1k!xk=x∑k=0+∞kn+1k!xk−1=xddx(∑k=0+∞knk!xk)=xfn′(x)f_{n+1}(x)=\\sum_{k=0}^{+\\infty}\\frac{k^{n+1}}{k!}x^k=x\\sum_{k=0}^{+\\infty}\\frac{k^{n+1}}{k!}x^{k-1}=x\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!}x^k\\right)=xf&#x27;_n(x) fn+1​(x)=k=0∑+∞​k!kn+1​xk=xk=0∑+∞​k!kn+1​xk−1=xdxd​(k=0∑+∞​k!kn​xk)=xfn′​(x) 这一递推式同样能得到这一函数列的任意项，而且计算上要简便许多。 而在此基础上，，我们求原数列 an=fn(1)a_n=f_n(1)an​=fn​(1) 也比原来简便。这无疑是所谓“创造者悖论”（越宏大的计划,越有机会获得成功,多个问题也许要比一个问题容易回答,较全面的定理可能更容易证明,较普遍的题目可能更容易解答。）的一个例证。也正印证了华罗庚教授的一句话：“解题时先足够地退，退到我们最容易看清楚问题的地方，认透了，钻深了，然后再上去。” 附： {fn(x)ex}\\{\\frac{f_n(x)}{\\mathrm{e}^x}\\}{exfn​(x)​} 的前几项： xx2+xx3+3x2+xx4+6x3+7x2+xx5+10x4+25x3+15x2+xx6+15x5+65x4+90x3+31x2+xx7+21x6+140x5+350x4+301x3+63x2+xx8+28x7+266x6+1050x5+1701x4+966x3+127x2+x⋮\\begin{gathered} x \\\\ x^2+x \\\\ x^3+3x^2+x \\\\ x^4+6x^3+7x^2+x \\\\ x^5+10 x^4+25 x^3+15 x^2+x \\\\ x^6+15 x^5+65 x^4+90 x^3+31 x^2+x \\\\ x^7+21 x^6+140 x^5+350 x^4+301 x^3+63 x^2+x \\\\ x^8+28 x^7+266 x^6+1050 x^5+1701 x^4+966 x^3+127 x^2+x\\\\ \\vdots \\end{gathered}xx2+xx3+3x2+xx4+6x3+7x2+xx5+10x4+25x3+15x2+xx6+15x5+65x4+90x3+31x2+xx7+21x6+140x5+350x4+301x3+63x2+xx8+28x7+266x6+1050x5+1701x4+966x3+127x2+x⋮​ 2020年1月18日补记： 在前一篇的补记中提到，用Mathematica发现了名为BellB的函数。实际上，这个函数的完全体是 Bell 多项式，即这篇文章前面阐述的这个多项式序列。 它是函数 h(t)=exp⁡[(exp⁡(t)−1)x]h(t)=\\exp[(\\exp(t)-1)x ]h(t)=exp[(exp(t)−1)x] 的生成函数。 甚至这个多项式的系数序列也有专门的名称，叫第二类Stirling数。这组数跟组合理论有深刻的联系。 另参见： Bell Polynomial - Wolfram MathWorld Bell polynomial - Encyclopedia of Mathematics OEIS A106800","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miRoox.github.io/blog/categories/数理科学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miRoox.github.io/blog/tags/数学/"},{"name":"数列","slug":"数列","permalink":"http://miRoox.github.io/blog/tags/数列/"}]},{"title":"旧作：关于数列 1,2,5,15,……","slug":"BellNumber","date":"2015-06-10T02:52:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2015/06/BellNumber/","link":"","permalink":"http://miRoox.github.io/blog/2015/06/BellNumber/","excerpt":"考虑序列 an=∑k=0+∞knk!a_n=\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!} an​=k=0∑+∞​k!kn​","text":"考虑序列 an=∑k=0+∞knk!a_n=\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!} an​=k=0∑+∞​k!kn​ 我用计算器随便试了下发现 a1/e=1a2/e=2a3/e=5a4/e=15 ⋮\\begin{aligned} a_1/\\mathrm{e}&amp;=1\\\\ a_2/\\mathrm{e}&amp;=2\\\\ a_3/\\mathrm{e}&amp;=5\\\\ a_4/\\mathrm{e}&amp;=15\\\\ &amp;\\ \\ \\vdots \\end{aligned}a1​/ea2​/ea3​/ea4​/e​=1=2=5=15 ⋮​ 它们竟都是 e\\mathrm{e}e 的整数倍，这种规律性显然不平凡。于是我便开始思索其中的计算方法。这当中， a1a_1a1​ 的计算给予了我关键的启发： a1=∑k=0+∞kk!=∑k=1+∞1(k−1)!=ea_1=\\sum_{k=0}^{+\\infty}\\frac{k}{k!}=\\sum_{k=1}^{+\\infty}\\frac{1}{(k-1)!}=\\mathrm{e} a1​=k=0∑+∞​k!k​=k=1∑+∞​(k−1)!1​=e 依循这个思路，就会有 an=∑k=0+∞knk!=∑k=1+∞kn−1(k−1)!=∑k=1+∞(k−1)n−1(k−1)!+∑k=1+∞Cn−11kn−2(k−1)!−∑k=1+∞Cn−12kn−3(k−1)!+⋯+(−1)n∑k=1+∞Cn−1n−11(k−1)!=∑k=1+∞(k−1)n−1(k−1)!+∑j=1n−1[(−1)j+1Cn−1j∑k=1+∞kn−j−1(k−1)!]=an−1+∑j=1n−1[(−1)j+1Cn−1jan−j]\\begin{aligned} a_n&amp;=\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!}\\\\ &amp;=\\sum_{k=1}^{+\\infty}\\frac{k^{n-1}}{(k-1)!}\\\\ &amp;=\\sum_{k=1}^{+\\infty}\\frac{(k-1)^{n-1}}{(k-1)!}+\\sum_{k=1}^{+\\infty}C_{n-1}^1\\frac{k^{n-2}}{(k-1)!}-\\sum_{k=1}^{+\\infty}C_{n-1}^2\\frac{k^{n-3}}{(k-1)!}+\\cdots+(-1)^n\\sum_{k=1}^{+\\infty}C_{n-1}^{n-1}\\frac{1}{(k-1)!}\\\\ &amp;=\\sum_{k=1}^{+\\infty}\\frac{(k-1)^{n-1}}{(k-1)!}+\\sum_{j=1}^{n-1}\\left[(-1)^{j+1}C_{n-1}^j\\sum_{k=1}^{+\\infty}\\frac{k^{n-j-1}}{(k-1)!} \\right]\\\\ &amp;=a_{n-1}+\\sum_{j=1}^{n-1}\\left[(-1)^{j+1}C_{n-1}^ja_{n-j} \\right] \\end{aligned}an​​=k=0∑+∞​k!kn​=k=1∑+∞​(k−1)!kn−1​=k=1∑+∞​(k−1)!(k−1)n−1​+k=1∑+∞​Cn−11​(k−1)!kn−2​−k=1∑+∞​Cn−12​(k−1)!kn−3​+⋯+(−1)nk=1∑+∞​Cn−1n−1​(k−1)!1​=k=1∑+∞​(k−1)!(k−1)n−1​+j=1∑n−1​[(−1)j+1Cn−1j​k=1∑+∞​(k−1)!kn−j−1​]=an−1​+j=1∑n−1​[(−1)j+1Cn−1j​an−j​]​ 根据这个地推公式，我们可以算出任意 nnn 对应 ana_nan​ 的值。 显然，所有 ana_nan​ 都会是 a1a_1a1​ 也就是 e\\mathrm{e}e 的整数倍。 2020年1月18日补记： 拿Mathematica的找规律函数FindSequenceFunction随便尝试了一下，居然发现了一个这样的内置函数BellB 12FindSequenceFunction[&#123;1, 2, 5, 15&#125;](*Out[ ]=BellB*) 在BellB的文档里也能看到完全一样的结果： 看来当初的奇妙发现也不过是发掘一些别人玩剩下的。尽管按照Mathematica文档里的背景描述，其出发点不完全相同，可见下一篇的补记。","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miRoox.github.io/blog/categories/数理科学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miRoox.github.io/blog/tags/数学/"},{"name":"数列","slug":"数列","permalink":"http://miRoox.github.io/blog/tags/数列/"}]},{"title":"旧作：有钱任性？没钱率性？","slug":"YouQianRenXingMeiQianShuaiXing","date":"2015-05-31T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2015/05/YouQianRenXingMeiQianShuaiXing/","link":"","permalink":"http://miRoox.github.io/blog/2015/05/YouQianRenXingMeiQianShuaiXing/","excerpt":"","text":"【率性】②形：由着性子，任性。 《现代汉语词典》 Α.有钱就是任性 经济基础决定上层建筑。 马克思 “七万了。”他想。 “这应该是伙骗子。”他自语，“找了这么多理由，弄了这么多附加产品，诓了我这么多钱，想来是骗子没跑了。只是……” “哔！有您的新信息。” 他打开手机，瞄了一眼短信内容。 “……只有这一点钱，警察不见得会管。不如干脆把事弄大一点，顺带试试他们的口才。” 想着，他随手从桌边拣起一张金色的银行卡，向门外走去。 α.没钱也要率性 世界是我的表象；世界是我的意志。 叔本华 他是一位思想者，一名艺术家。 他的房间里只有一张木桌和一个书架。崭新的书本在破旧的书架里显得格格不入。这些书花去了他几乎全部的积蓄但他十分满意。 不同于网上那些注水文学，他一天只写六百字，其余时间用来读书，感受生活，释放思想。他要以他毕生的精力来完成这部巨著，就在这个房间里。而他的思维已经延伸到了时空尽头。 “即使被关在果壳之中，我仍自以为是无限宇宙之王。”他如是自诩。 他放下笔。窗户的破口外，一抽翠嫩的新芽蕴生着几点绿意。 Β.有钱就是任性 在现代社会中，资本是独立的并有其性格， 而一个活着的人是非独立的且没有性格的。 马克思 很奇怪。 要说为什么。这次对方竟要求用寄支票的方式来付款，简直是匪夷所思。要不是十万的诱惑力，他本是打算放弃这桩生意的。 “该不会……”他想。 “报告老大！没有发现条子。” “是吗？那就好，东西呢？” “在这里。” “好，很好。” 他接过包裹，扯出被裹得小心翼翼的支票。 “好！十万！”他拿着支票，翻来覆去的看，在金额上反复摩挲。突然，他的手停下了，眼角有些濡湿。 “老大，您……” 支票的背面，赫然写着四个字： 回·头·是·岸 β.没钱也要率性 人虽然能够做他想要做的，但不能要他所想要的。 叔本华 “还剩多少米？”父亲问。 “一两半。恐怕难熬过今天。”母亲叹了口气，望着里面紧闭的房门，“这孩子……” “不行，我得找他谈谈。” “算了吧！谈又有什么用，他那么犟，可别把你气坏了。” “……” 一阵寒风扫过，屋子也不由得打了个冷战。窗户映照着皑皑的冰雪世界，不知能否再见明年的春天。","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miRoox.github.io/blog/categories/小说文艺/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miRoox.github.io/blog/tags/小说/"},{"name":"作文","slug":"作文","permalink":"http://miRoox.github.io/blog/tags/作文/"}]},{"title":"旧作：筑基工，筑梦人","slug":"ZhuJiGongZhuMengRen","date":"2015-04-30T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2015/04/ZhuJiGongZhuMengRen/","link":"","permalink":"http://miRoox.github.io/blog/2015/04/ZhuJiGongZhuMengRen/","excerpt":"","text":"“我仰望星空，感到一阵惊恐/如果地球失去引力，我就会变成流星，无依无附在天宇飘行/哦，不能/为了拒绝这种‘自由’，我愿变成一段树根，深深地扎进地层。” 阖上书，指尖在粗糙的纸面上轻轻滑过。橘黄的灯光映照出封页上的书名——《忧天——顾城诗选集》[1]。他提上桶走出屋门，书本被搁在了床边。 外面的天空一片黑暗，依稀有几点闪烁的星光。但工地上的灯火常亮。他左转右拐，一路上不时碰到一些工友，也打个招呼，唠嗑一阵。许久，终于来到工地外沿的一排水龙头前。打上一桶半浊不清的水，再返回工舍。 回工舍，小小的板房里住着七八个人。大家都很累了，便没什么人聊天，只想干完活早点睡觉。他呢？他把桶里的水倒一些在盆里，将脚缓缓伸下。淤泥在水中扩散开来，沁凉的水温令他清醒不少。他顺手从桌上抽来一份报纸，消磨洗脚间的无聊时光 “……上世纪80年代后，广东、浙江、山东等沿海地区城市化建设提速，一批“快餐式”楼房密集建成。按照我国《民用建筑设计通则》的规定，一般性建筑的耐久年限为50年到100年。然而，现实生活中，很多建筑的实际寿命与设计通则的要求有相当大的距离。如今，许多楼房的建设年龄已经陆续达到20年、30年。由于先天不足，后天装修过频、维护不够等原因，良莠不齐的建筑进入‘质量报复周期’……”[2] 周围渐渐暗了下来，报纸上的小字在昏黄的灯光下显得格外模糊。他揉揉眼，轻轻阖上报纸，拿起自己的日记本，打开。他在床头写下： “X年X月晴 今天没有那么累了，打地基的工作已经基本完成。这是一幢大楼的基础，也是重中之重。地基不深、基础不牢，就容易形成‘豆腐渣’。我们这次把地基打到了三十米下，这样高楼大厦也会牢靠些……” “呵——” 有些倦了。他停下笔，周围的一些工友已经起了鼾声。他拉上灯，躺在榻上，一天的疲惫很快将他的意识吞没，带他沉入梦乡： “我看见，我看见一座擎天的大厦，矗立在神州大地上。它是那么得高大，我看不见它的顶峰。可它脚下踩着我们筑建的基石；我看到，我看到神州大地上亿万的人民化作无数的光点。汇聚着，凝聚成了巡天的巨龙，盘绕在那大厦之颠……天边升起无尽的光芒，我知道，这是梦的颜色。” 夜已深暝，天空中的星辰却愈发璀璨。 注： [1]: 并没有这本书。 [2]: 文段节选自《1个月5起房屋垮塌 楼盘“质量报复期”来了该咋办？》","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miRoox.github.io/blog/categories/小说文艺/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miRoox.github.io/blog/tags/小说/"},{"name":"作文","slug":"作文","permalink":"http://miRoox.github.io/blog/tags/作文/"}]},{"title":"旧作：污点","slug":"Stain","date":"2015-03-31T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2015/03/Stain/","link":"","permalink":"http://miRoox.github.io/blog/2015/03/Stain/","excerpt":"","text":"一张白纸。一张白纸摊开在面前 “写些什么呢？” 他不知道。手中的笔悬在半空中，他自言自语： “一开始，那个纯洁的婴儿呱呱坠地，所有亲友都说：‘多么纯净的孩子啊，就像一张白纸。’‘清澈的眸子里透着对善的渴望。’亲友中的一位诗人如是说。于是这个刚刚降生的小生命被赋予了‘元善’的名字。‘‘人之初，性本善’嘛’人们纷纷应和。” “小家伙很懂事，不到一岁就学会了喊‘妈妈’。之后，在父母的悉心教导下，小家伙成长为了一个知书达礼，乐于助人，惹人怜爱的好孩子。” “孩子上了中学，成绩优秀，也常帮助那些成绩不好的同学，因而很受爱戴。然而有一天……” “啪！” 一记响亮的耳光，全班人的目光都集中过来。他的脸火辣辣的。他不解地望向对方，对方却回以一个轻蔑的眼神。“为什么？为什么不听我的话？我是在帮他啊！”他不明白，一股无名火却已燃上心头。 “呸！没骨头的家伙。” 他理智的弦终于绷断。顺手拿起窗沿上的一个花盆，向前重重砸去…… “嗒。” 一滴墨水滴在纸上。 他有些慌乱，急急忙忙想用胶布粘去，却让墨迹扩散开来。费了九牛二虎之力，总算去除了墨迹，却发现纸张已经被他撕破了。 “换一张好了。” 可他没有动，他根本无纸可换。无奈，将手托在腮上，继续他的回想。 “……孩子受到了处分。但在父母的恳求下，校方还是将其撤消了。如父母所愿，孩子一路顺风地毕业、升学、直至工作……” “一次工作聚餐，已经不再是孩子的他喝了酒。酩酊的他在听到一句玩笑话后想起童年不快的回忆，竟大打出手，击翻的火锅还让一名严重烧伤。” “嗒。” 墨水滴下，他的手微微颤抖。 “监狱的日子可不好过，因此他努力改造，成功削减了一大半的刑期，可是……” “您的简历不合格。” “对不起，本司不录用有前科的人” “……” 无数次的应聘失意后，他开始混迹于酒吧、赌场、各种传销场所。几经淘洗下他已是负债累累，连老父亲也被他气得一病不起…… 他有些哽咽，泪水将眼角濡湿，沿着他的脸颊滑落。 纸面早已被浸染成了墨色，只有上方“被告人证词”的字样依旧鲜红。","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miRoox.github.io/blog/categories/小说文艺/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miRoox.github.io/blog/tags/小说/"},{"name":"作文","slug":"作文","permalink":"http://miRoox.github.io/blog/tags/作文/"}]},{"title":"旧作：微","slug":"Wei","date":"2015-02-28T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2015/02/Wei/","link":"","permalink":"http://miRoox.github.io/blog/2015/02/Wei/","excerpt":"","text":"“……微分方程通常的解法是将……” 台上的导师慷慨激昂地讲述晦涩难懂的知识，台下的他却是早已听得厌烦。上课未值十分钟，百无聊赖的他便拿起手机在抽屉里刷微博。 “既然在上微积分的课，不如扯一些有关的段子吧。”想着，他的指尖在屏幕上飞速的敲击： “小明买东西攒积分，求原函数。” “是不是太冷了？”想着刚才的微博，他有些不满意。眼睛漫无目的地在“信息碎片”的海洋中飘荡。突然，一段微博抓住了他的视线—— “高数毫无意义，未必买菜还要微积分？” “嘛～虽然也是很老的说法了……”他自语着，正准备给这句话点个赞。蓦地，他的手又停在了空中，转念一想：“我这样做岂不跟那些‘跟风狗’别无二致。不行，不行，我要独辟蹊径。”他左手端着手机，右手托住下巴，咬牙苦思起来。 微茫、遐远的的声音传来，在我静若止水的精神世界里激起了一道涟漪。 “唔……”我的躯骸稍稍起了一点反应。 “起床了！起床了……” 会是谁在唤醒我，让我自黑暗的沉眠中觉醒？是我那清丽可爱的青梅竹马？抑或是我那妖娆动人的女仆人？ 意识从水面下浮起。 否定！Both are not。我既没有清丽可爱的青梅竹马，也并无妖娆动人的女仆人。有的只是和我一样五大三粗的室友将我从睡梦中唤起。 但那残念，却向识海的深渊坠下。 揉着惺忪的睡眼，在这个不足二十平米的狭小空间里，我迅速掏出手机，一边漱口，一边浏览要问国事。 “这些事可以与我无关，但我决不能不管。我要表达我自己的观点。” 可是，表达观点是需要时间的。对于一刻也不能停的我而言，我不得不一边行走着享用“营养丰富”的面包，一边低头飞速的用掌中的“利器”进行吐槽。就这样，在幸运地避开了所有的障碍物后，我缓缓步入了教室。 微言大义，不是你一向奉行的“微时代”的基本准则吗？ 可笑！高数无用论又重出江湖。 可叹！“百年前躺着吸鸦片；百年后卧着玩手机”却不能使你警醒。 试问：你为何自甘堕落于尘俗碎片之间？ 你不答，却在微信中写下： “微斯人，吾谁与归？” 夜色渐暗 魆黑的卧室里，灯影忽微……","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miRoox.github.io/blog/categories/小说文艺/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miRoox.github.io/blog/tags/小说/"},{"name":"作文","slug":"作文","permalink":"http://miRoox.github.io/blog/tags/作文/"}]},{"title":"旧作：师表","slug":"ShiBiao","date":"2015-02-21T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2015/02/ShiBiao/","link":"","permalink":"http://miRoox.github.io/blog/2015/02/ShiBiao/","excerpt":"","text":"“师者，所以传道授业解惑也。” ——《师说》 一 “呼哧、呼哧、呼哧……” 嘴里叼着包子的少年，正卖力地在操场上奔跑。 “来不及了！来不及了！要迟到了！”少年边跑边想。 的确，他已经来不及了。他转上走廊，看见老师在远处冷冷地望着他。 “你又迟到了！”老师嫌恶地看着他。 “老师，我……”他刚想说话，可立马就被老师打断: “迟到可没什么理由，你拖沓的生活习惯必定会影响你的学习效率……” 老师在门口滔滔不绝地讲着，教室里读书的同学也不时望向他。他只是低着头，一言不发。 二 “嗯……这个字是……就没有什么人查字典吗？以后人手要有一本字典！”老师在讲台上大声喝叱。 “……” 台下一片沉默。 “叮铃铃——” 下课铃响起。 “好！今天就到这里。下课！” 说罢，老师飞快地走出教室。 “老师！老师！等一下！我问个问题！”他冲出教室及时拦下了老师。 “嗯……这种题目，我也不可能马上答出来，先让我看一下。” 两人沉默无语，都盯着那道题目。 “……” “叮铃铃——” 上课铃响起。 老师突然一转头，说道: “你先去上课，这题我再看一下。”老师顿了顿，“不要再迟到了。” 说罢，便转身走向办公室。他望着老师离开的方向，怅然若失。 三 又拖堂了。 他望着在讲台上涛涛不绝的老师，在心里叹息。 “所以说……喂！你们说我刚才讲了哪几点问题？”老师看台下的同学们似乎都在各行其事，忍不住发了问。 “……” 沉默，台下一片沉默。 “都给我停下手中的笔！”老师似乎生气了，用方言接道，“哪个晓得我刚才讲了么咂东西啊？” “……” 沉默，依旧沉默。只有陆陆续续把笔放下的声音。 沉默呵！沉默呵！不在沉默中爆发，就在沉默中灭亡。 突然，另外一位老师站在门外冲着老师招手。正要爆发的老师脸色骤变，微笑地向门外走去。 教室里的同学不约而门同地松了一口气，而后又纷纷拿起笔做起作业来。但他没有动，只是望着窗外，心里玩味着那句“拖沓的生活习惯只会影响你的学习效率。” 须臾，老师从教室外回来，看见同学们都在埋头苦干，心中感到十分欣慰。老师拿起记事本，忽然一愣: “我刚才讲到哪儿了？” “………”","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miRoox.github.io/blog/categories/小说文艺/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miRoox.github.io/blog/tags/小说/"},{"name":"作文","slug":"作文","permalink":"http://miRoox.github.io/blog/tags/作文/"}]},{"title":"旧作：《琵琶行》心理描写","slug":"PiPaXin","date":"2014-04-30T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2014/04/PiPaXin/","link":"","permalink":"http://miRoox.github.io/blog/2014/04/PiPaXin/","excerpt":"","text":"嗟乎！余闻此音曾几何？帝京丝竹如梦隔。昔我直言犯圣怒，左迁谪卧江州戍。余意本图兴，年且少狂轻。逆耳难得君意，未料圣恶言新。宦海浮沉十余载，吾志未达道已尽。身若陷囹圄，心似无所依。凄然寻欢今日，喜闻佳音忽至。行如高山流水，动若天籁仙音。大音希声，大象无形。凄迷婉转，似诉哀心。吾感此乐忆今昔，喟然欲叹涕先行。","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miRoox.github.io/blog/categories/小说文艺/"}],"tags":[{"name":"作文","slug":"作文","permalink":"http://miRoox.github.io/blog/tags/作文/"},{"name":"文言文","slug":"文言文","permalink":"http://miRoox.github.io/blog/tags/文言文/"}]},{"title":"旧作：求和公式Σk·a_k","slug":"KTimesSum","date":"2014-03-31T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2014/03/KTimesSum/","link":"","permalink":"http://miRoox.github.io/blog/2014/03/KTimesSum/","excerpt":"高二做题时发现的，非常trivial，但可以避开错位相减法繁琐方法。 ∑k=1nk⋅ak=∑k=1n∑j=knaj\\sum_{k=1}^nk\\cdot a_k=\\sum_{k=1}^n\\sum_{j=k}^na_j k=1∑n​k⋅ak​=k=1∑n​j=k∑n​aj​","text":"高二做题时发现的，非常trivial，但可以避开错位相减法繁琐方法。 ∑k=1nk⋅ak=∑k=1n∑j=knaj\\sum_{k=1}^nk\\cdot a_k=\\sum_{k=1}^n\\sum_{j=k}^na_j k=1∑n​k⋅ak​=k=1∑n​j=k∑n​aj​ 证明： ∑k=1nk⋅ak ⇓1⋅a1⇒∑a1 +⇒∑+2⋅a2⇒∑a2+∑a2 +⇒∑++∑+ ⋮ ⇒ ∑⋮+ ∑⋮⋱n⋅an⇒∑an+∑an+⋯+∑an ⇒ ∑⇓+∑⇓+⋯+ ∑⇓∑k=1n∑j=knaj⇐∑j=1naj+∑j=2naj+⋯+∑j=nnaj\\begin{aligned} \\sum_{k=1}^nk\\cdot a_k\\\\ \\ \\Downarrow\\quad\\\\ 1\\cdot a_1 &amp;\\Rightarrow\\phantom{\\sum} a_1\\\\ \\ +\\quad&amp;\\phantom{\\Rightarrow}\\phantom{\\sum} + \\\\ 2\\cdot a_2 &amp;\\Rightarrow\\phantom{\\sum} a_2 +\\phantom{\\sum} a_2\\\\ \\ +\\quad&amp;\\phantom{\\Rightarrow\\phantom{\\sum}} +\\phantom{+}\\phantom{\\sum} + \\\\ \\ \\vdots\\ \\quad&amp;\\phantom{\\Rightarrow}\\ \\phantom{\\sum}\\vdots\\phantom{+}\\ \\ \\phantom{\\sum}\\vdots\\qquad\\qquad \\ddots \\\\ n\\cdot a_n &amp;\\Rightarrow \\phantom{\\sum}a_n + \\phantom{\\sum}a_n +\\cdots+\\phantom{\\sum}a_n\\\\ \\ &amp;\\phantom{\\Rightarrow}\\ \\phantom{\\sum}\\Downarrow\\phantom{+} \\phantom{\\sum}\\Downarrow \\phantom{+\\cdots+}\\ \\ \\phantom{\\sum}\\Downarrow\\\\ \\sum_{k=1}^n\\sum_{j=k}^na_j&amp;\\Leftarrow\\sum_{j=1}^na_j+\\sum_{j=2}^na_j+\\cdots+\\sum_{j=n}^na_j \\end{aligned}k=1∑n​k⋅ak​ ⇓1⋅a1​ +2⋅a2​ + ⋮ n⋅an​ k=1∑n​j=k∑n​aj​​⇒∑a1​⇒∑+⇒∑a2​+∑a2​⇒∑++∑+⇒ ∑⋮+ ∑⋮⋱⇒∑an​+∑an​+⋯+∑an​⇒ ∑⇓+∑⇓+⋯+ ∑⇓⇐j=1∑n​aj​+j=2∑n​aj​+⋯+j=n∑n​aj​​ 证毕。 例一： ∑k=1nk2k=∑k=1n∑j=kn12j=∑k=1n(12⋅1−12n−k+11−12)=∑k=1n(12k−1−12n)=2−n+22n\\sum_{k=1}^n\\frac{k}{2^k}=\\sum_{k=1}^n\\sum_{j=k}^n\\frac{1}{2^j}=\\sum_{k=1}^n\\left(\\frac{1}{2}\\cdot\\frac{1-\\frac{1}{2^{n-k+1}}}{1-\\frac{1}{2}}\\right)=\\sum_{k=1}^n\\left(\\frac{1}{2^{k-1}}-\\frac{1}{2^n}\\right)=2-\\frac{n+2}{2^n} k=1∑n​2kk​=k=1∑n​j=k∑n​2j1​=k=1∑n​(21​⋅1−21​1−2n−k+11​​)=k=1∑n​(2k−11​−2n1​)=2−2nn+2​ 例二： ∑k=1nk2=∑k=1n∑j=knj=∑k=1n(k+n)(n−k+1)2=12∑k=1nk2+12∑k=1n(k+n+n2) ⟹ 32∑k=1nk2=12[(n+1)n2+n2(n+1)] ⟹ ∑k=1nk2=n(n+1)(2n+1)6\\begin{aligned} &amp;{}\\sum_{k=1}^nk^2=\\sum_{k=1}^n\\sum_{j=k}^nj=\\sum_{k=1}^n\\frac{(k+n)(n-k+1)}{2}=\\frac{1}{2}\\sum_{k=1}^nk^2+\\frac{1}{2}\\sum_{k=1}^n\\left(k+n+n^2\\right)\\\\ \\implies&amp;{}\\frac{3}{2}\\sum_{k=1}^nk^2=\\frac{1}{2}\\left[\\frac{(n+1)n}{2}+n^2(n+1) \\right]\\\\ \\implies&amp;{}\\sum_{k=1}^nk^2=\\frac{n(n+1)(2n+1)}{6} \\end{aligned}⟹⟹​k=1∑n​k2=k=1∑n​j=k∑n​j=k=1∑n​2(k+n)(n−k+1)​=21​k=1∑n​k2+21​k=1∑n​(k+n+n2)23​k=1∑n​k2=21​[2(n+1)n​+n2(n+1)]k=1∑n​k2=6n(n+1)(2n+1)​​","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miRoox.github.io/blog/categories/数理科学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miRoox.github.io/blog/tags/数学/"},{"name":"数列","slug":"数列","permalink":"http://miRoox.github.io/blog/tags/数列/"}]},{"title":"旧作：爱迪生于21世纪日记","slug":"EdisonIn21Century","date":"2013-07-31T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2013/07/EdisonIn21Century/","link":"","permalink":"http://miRoox.github.io/blog/2013/07/EdisonIn21Century/","excerpt":"","text":"引言 在发明了电灯之后，爱迪生在睡梦中偶然来到了21世纪，下面便是他“七日之游”的日记记录： 201X年某月某日（第一天） 睁开双眼，呼吸着那不同于我过去浑浊而清新的空气，抬头望见鳞次栉比的高楼大厦，道路上奔流不息的机械车辆，路边的行人不仅衣着古怪，还个个手里捧着一块发亮的“方砖”，这莫不是用来砸人的？天空的光芒似乎特别璀璨，炫得我难以直视。难道说这里就是天堂？可我并没有见到插着翅膀的美丽天使出来迎接我啊。不！我还不能死，我可是要成为“发明大王”的男人，怎么能在这里死掉！ 201X年某月某日（第二天） 经过一天的研究调查，大致明白了这里不是天堂（天堂怎么会有黑夜），而是一个拥有高度发达科技的世界。我至今还记得我说我是爱迪生时，旁边的路人一副见鬼了的样子，还害得我差点被送进精神疗养院去，真是太危险了。此外，我还发现人人手里所捧着的“方砖”，其实是一种名为“手机”的远程通讯工具，似乎有着类似古代神话中“千里传音”般的作用，但具体还有待明天的实地调查。 201X年某月某日（第三天） 今天外面似乎格外的热，而我却来到了一个十分凉爽的房间里。没错，我来顶哦啊了一个叫“手机商店”的地方，这里有一种叫“air-condition”的机器可以用来调节温度。我本想拆开研究一下这所谓的“air-condition”，但我今天的目的毕竟不是这个。我在柜台上随手拿了一台“iPhone试用机”便操作起来。可我无奈地发现上面的按键好少，而且我按了半天居然没有什么变化，起的我几乎要把它摔在地上。好在服务员把我拉住，才避免了惨剧的发生。感情这个闪闪发光的玻璃（屏幕）也可以触摸来操作啊！最后，在服务员的悉心教导下，我终于能够使用最基本的功能了。 201X年某月某日（第四天） 今天依然来到这个“手机商店”享受人生，这种名为“手机”的机器实在是太奇妙了，宛如古代炼金术师们传说的“贤者之石”一般无所不能。除了简单的音频沟通之外，还有视频、文字等种种交流方式，即使相距万里，也能方便的交流对话，真是妙不可言啊！ 201X年某月某日（第五天） 今天继续在店里享受人生。尽管店员们看我已经有点不耐烦了，但我对手机的热情没有丝毫退却。这还真是一部伟大的发明，看来我“发明大王”也要“退位让贤”了！ 201X年某月某日（第六天） 我今天终究是被赶了出去。看着他们那厌恶的眼神，我已经没有了丝毫的感觉。在这几天里我已经做到了“足不出户，知天下事”。于是我就在城市各处的同类商店里“打游击”，继续沉溺在手机的世界里。 201X年某月某日（最后一天） 今天我在网上看见有新闻说有人玩手机玩到眼瞎，玩电脑玩到猝死。我突然明白我最近为什么迷迷糊糊的了，别说发明了，就连探求欲都没有。“我的生命正在浪费，而我对此一无所知。”于是我愤怒了，将手里的机器当着所有人的面狠狠摔下！ 然后呢？ 然后，就没有然后了。","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miRoox.github.io/blog/categories/小说文艺/"}],"tags":[{"name":"作文","slug":"作文","permalink":"http://miRoox.github.io/blog/tags/作文/"}]},{"title":"旧作：沙的狂想","slug":"RhapsodyOfSand","date":"2013-07-31T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2013/07/RhapsodyOfSand/","link":"","permalink":"http://miRoox.github.io/blog/2013/07/RhapsodyOfSand/","excerpt":"","text":"曾几何时，我希冀着这样或那样的未来而来到了这个社会。然而这社会究竟不是我们所想象的那样。我们无法选择社会，但我们仍有选择权。我们可以选择改变自我，让社会来选择。 一 这是一片沙地，一片本只有沙子的沙地。在沙子们的社会里，个个互相承认、互相尊重。他们不在乎自己的渺小，因为这里每个成员都如此；他们不在乎别人的卑微，毕竟自己也好不到哪里去。但他们也不会互相帮助，他们是一盘散沙，只为各自的目标而奋斗。也有斗争，但很难有大规模的混乱。他们终究是散的，散漫而自由。 二 但是，世间毕竟没有不变之物。当一颗珍珠莫名来到这片沙地，一切，都改变了。 没有哪粒沙子知道那珍珠是何时出现又从何而来的。但他的出现，确确实实引发了一场大混乱，以及——变革。 人们总是本能地趋利避害，而当中最直接的表现，就是趋炎附势。珍珠的出现让沙子们明白了自己的卑微与渺小。他们怀着无限的崇拜与敬仰想去巴结珍珠，颗珍珠又怎么会理他们。随着越来越多的沙子只认可和尊重珍珠，有一批沙子却已经无法忍受珍珠的这股傲气。于是，出现了这样的一批沙子：他们拉帮结派，互相尊重，互相认可，他们认为珍珠掠夺了他们曾受过的尊重与认可，他们是要将失去的一切给夺回来。像这样的组织与矛盾出现后，一种名为“阶级”的事物在这片沙地上诞生了。 三 “我要向流星祈愿：我愿不择手段，成为一颗璀璨的明珠，受世人敬仰。” 一将功成万骨枯。在这茫茫沙海之中，诞生了一个传奇：他用自己的努力与奋斗，在牺牲了数百名同胞之后，成就了万众瞩目的珍珠。成为珍珠的他仿佛忘记了身为沙子时往昔的一切。成就珍珠时，周围无数沙子的祝贺与谩骂他都视而不见。曾有一名他还是沙子时的老友迎着他笑道：“好久不见。”得来的却是冰冷的一句：“你是谁啊？别乱搭讪！”逼得对方讪讪离开。此时的他，只尊重另一颗与之对等的“原始”珍珠。他们俩有如统治这片沙地的君王，高傲地盘踞在无数沙子的头上。 四 于是，一场浩浩荡荡的“珍珠养成计划”就这样展开了。毕竟，贪婪是万灵的本性。谁不想成为君王？谁不想受万人景仰？什么“要将失去的一切给夺回来”，什么“沙子们互相认可、尊重”，统统都是痴人说梦罢了。为此，沙子们开始不断残害同胞，作为成就珍珠的“祭品”。整片沙地上陷入了一片血雨腥风之中。自私、贪婪、趋炎附势……所有本性恶劣之处统统爆发出来，到处都是混乱、混乱、混乱…… 五 在这乱世之中，却有一粒独立特行的沙子，他似乎有着过人的先见之明。他决定远离纷争，藏身于大量“已成就”珍珠的缝隙之中。他抱有着这样的想法：“珍珠之所以高贵是因为物以稀为贵，等他们全部变成了珍珠，那我就是‘唯一’仅剩的沙子，岂不是最高贵的啦。”因此，他认为只要躲得远远的，自己便能坐享其成。于是他等着，等着，望见沙子们越来也少，珍珠们越来越多，心里便喜逐颜开。 然而有一天，他发现自己渺小的身躯被无尽的珍珠所掩埋。他看不见光亮，也看不见明天。 六 纷争结束了，曾经的沙地上，现在只看得见珍珠。珍珠的巨头们开始商议停战协议。没有人听见，在无数珍珠掩埋下那小小沙粒无声的呐喊……","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miRoox.github.io/blog/categories/小说文艺/"}],"tags":[{"name":"作文","slug":"作文","permalink":"http://miRoox.github.io/blog/tags/作文/"}]},{"title":"旧作：怯","slug":"Qie","date":"2013-07-31T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2013/07/Qie/","link":"","permalink":"http://miRoox.github.io/blog/2013/07/Qie/","excerpt":"","text":"老人面前是一块钻石，一块蛋黄大的钻石。 这是前几天一个商人朋友送来的。这样一块价值不菲的钻石却偏生得一道裂缝，若能顺着裂纹切开，那将升值数倍。然而，此下若是失败，便是不可估量的损失。因此，许多切割师都不愿动手。可这商人又和他是老友，他在这一带也是小有名气，又怎能不帮这个忙呢？但在他稀里糊涂地答应下这桩生意后，却有些不知所措。 老匠人面对钻石，从旁边拿起工具，举在空中，对准那道裂缝，仿佛就要切下去。可他的手却在微微颤抖。倏的，老人将手里的工具放下，伸出他那满布老茧的粗糙的手，轻抚那钻石上那道细细的裂纹。 夜渐渐深了。老人躺在床上，辗转难眠。他一闭眼，那破碎的钻石仿佛就在眼前。可他终还是抵不住困意，沉沉地睡去了。睡梦里，他准备了无数次精密的测量，只差那关键的一刀了。他暗暗运气，切下了这凌厉的一刀。那一刹那，他如同猛虎，又好似雄鹰，岁月的痕迹仿佛已经消失，这跨越时空的一刀，五十年前与五十年后，他的勇猛，从未改变。 刀落。 “！” 静谧的夜晚，安静得只有老人微微喘息的声音。 五十年前。 五十年前，当老匠人还只是个学徒的时候。他的父亲，也是他的师傅，交给了他这样的一个任务： “切开它，切开这个钻石，让他从裂缝中完美地被切开。那么你就出师了。”他是这样说的。 可他失败了。那如猛虎般凌厉的一刀让钻石碎开了。只留下一脸惊愕的众人。 “调整呼吸，盯紧目标，不要想它有多贵重，你只要想着那一刀而已。”父亲曾这样教导。 “可为什么我失败了呢？”他不明白，他以为自己只是在想那一刀。然而，他还未来得及问出口，巨大的变动已经席卷了他的家庭。那样的一块钻石，足以令他们倾家荡产。一家人过上了颠沛流离的生活。而他，不得不在父亲死后为了归还债务而继续做切割师。直到如今，他依旧有笔债务未能还清。 第二天早晨，老匠人迷茫地坐在床边，面前放着那块蛋黄大的钻石。 “五十年前……”老人这么想着，忽然笑着说：“五十年前的那块，恐怕只有这个的一半大。”而后他又低低地说，“那个老滑头……”突然，老人从床上立起，心中已有了决断。 他找来了徒弟，说：“今天将是你最后一次在我这里做工了。”他拿出了一些稿纸，继续道：“按这上面的方案，把那玩意剖开。”他指了指墙角的钻石，“无论成败如何，你都可以出师了。”“……要是成功了，把工钱全部给你。”但他没有说出口。 “这……”徒弟惊疑不定地望着老人。 “没事，去吧！”老人笑着对徒弟说，“一个赝品而已，用不着那么紧张，就当留个纪念。” 于是，徒弟分毫不差地按老人的方案布置执行了。在徒弟的一声大吼中，钻石完美的分成两半。 “老了，真的老了啊！”在学徒的大吼声下，老人发出一道微不可闻的叹息。 在晚霞的微风中，老匠人依旧做着他的切割师，只为还清那欠了五十年的债……","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miRoox.github.io/blog/categories/小说文艺/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miRoox.github.io/blog/tags/小说/"},{"name":"作文","slug":"作文","permalink":"http://miRoox.github.io/blog/tags/作文/"}]},{"title":"旧作：奋斗","slug":"FenDou","date":"2013-07-31T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2013/07/FenDou/","link":"","permalink":"http://miRoox.github.io/blog/2013/07/FenDou/","excerpt":"","text":"一、山中老人 老人每天起来，挑水劈柴、浇花种菜、打打太极，时不时还吼上一两嗓子的山歌，吓得林里的鸟儿全都飞窜开去。就这样，日复一日，年复一年，过着平平淡淡又有如世外桃源般宁静闲适、悠然自得的生活。 二、店家小二 小二，其实也就是服务生。在这样的小餐馆里，“小二”的称呼仍然保留着。这名年轻人在店里当服务生也有一两年了。他读的书并不多，但也知道国内外许多成功人士都是从洗碗端盘开始的。因此，他坚信，只要自己努力奋斗，终有一天可以成为一名大老板、大企业家。他端盘、送水，用业务性的完美微笑欢迎每一位来客。他是所有员工中最勤快认真的一个，虽然没有得到立即提拔，但他相信那一天终会来临。 三、从伍军人 军人，神圣的职业。而他们，则是当中最为重要的长驻边疆的边防战士。他们是最伟大、最无私的一群人。在许多人眼里，他们是“疯子”。他们常驻于环境恶劣的边地哨岗上，数年也难回一次家。但他们坚定在自己的岗位上，“舍小家，保大家”的信念早已将他们包围。然而，他们心中仍有迷惘：他们不希望在此碌碌终身，因而他们会渴望战争；但他们也不想自己的家园被破坏，因而他们又憎恶战争。 然而。 “报告：不明空军将进入我国领海上空。” 硝烟已把战火点燃，他们也将义无反顾…… 四、校内学生 “教室里书声朗朗，操场上汗水飞扬。我们怀揣着不同的梦想，走进学习的殿堂。我们遨游知识的海洋，却发现前途一片迷茫。但我们坚定心中的信仰，要相信希望就在彼方。” 这样一群有志青年，他们做着各自认为重要的事，他们朝着自己的目标而奋斗，但没有人能说得清他们的未来。未来的纸上一片空白，期待他们填上绚丽的色彩。 五、错误 曾几何时，我希冀着这样或那样的未来而来到了这个社会。然而这社会究竟不是我们所想象的那样。我们无法选择社会，但我们仍有选择权。我们也许做过许许多多的错事，但我们绝不是错误的人。 六、征兆·征召 “听说要打仗了？”墙角的一个青年说道。 “那菜价肯定又要上涨了。”一旁的大妈道。 “诶？那我们是不是要挖个洞藏起来比较好？”另一边的胖青年一本正经道。 “笨啊！…” “欸！对不起，让一让。上菜啦！”年轻服务生保持着他那一贯的业务性微笑，对着闲谈的众人说，“嗯……血战沙场。” “这是什么古怪名字。”胖青年嘟囔。 “这是……”年轻服务生正欲说明。 “好了好啦！”另一个瘦小的青年不耐烦地挥挥手。 那服务生到也识趣，讪笑的走开了。此时门前走来两个人，他便急忙迎过去。 “……最讨厌那张臭脸，真想踩两脚……”那瘦青年用微不可闻的声音道。 年轻服务生快步走到门前，继续保持业务性微笑，轻轻鞠了一躬：“欢迎光临，请问……” 他突然说不下去了。他隐约听见老板娘在说“怎么不说了，继续啊！”，但那也许已经不重要了。快步进来的两人，身着军装，似乎还挂有军衔。两人无视了他，径直走到了一块空白的墙壁前，服务生抬头上前，想看一看他们在干什么。只见两人飞快地贴上了一张布告后便离开了，留下在一旁发愣的年轻服务生。 “征…兵……”青年口中喃喃。 宪法规定：公民应履行服兵役的义务。 大学的校园里，人头攒动。一大批学生围在一张巨大的告示前，或大声喧嚷，或窃窃私语，还有一批热血青年凭着满腔的激情争先恐后地报名——参军。从高处看，应征的人群有如黑压压的蝗虫过境，整个报名的现场混沌不堪。 “真是……”老人摇摇头，望着下山的方向，手里攥着一块木牌，“都什么年代了，还玩这种鬼把戏。” “爷爷，怎么了？”扯着老人的衣角，一个虎头虎脑的小孩问道。 “不……没你的事，乖乖的在屋里呆着。” “哦，知道了。” “知道，你又知道些什么呢。”老人望着孙子离去的背影，攥着木牌的手已经有些泛白。 木牌上，两个朱红色的大字：征兵。 “唉！”老人叹了口气，转身回屋里去了。只留下青草地里，一块崭新的木牌。 “征兵啊……”年轻服务生左思右想。突然，他哼了一口气，自语道：“保家卫国什么的，有我没我又有什么区别呢？还是先干出一笔事业，再把父母……” “……父母！”他好像突然想起什么似的，立马从椅子上弹起，急匆匆的奔到柜台前，对老板说： “那个，对不起，请问我能请几天假回去不？我想安顿一下家里人。” “嗯……”老板沉吟片刻，点点头，“不过要尽早回来，店里还有一大堆事……” “好！我尽量在两天之内赶回来！”说罢，就开始脱下工作服。 “……等你回来我就提拔你当……” 老板话没能说完，青年已经一溜烟跑走了。 “……还是年轻好啊！”老板望着他离去的背影，感叹道。 七、战争 战争终究还是打响了。 战场上难免会有伤亡，但学生毕竟是整个社会所关注、保护的对象，因而他们能得到最迅速、最安全的撤离。在炮声与烽火中，细密的撤离队伍，却有歌声回响： “和平年代的朗朗书声一去不返/我们背离故乡/我们奔走流亡……” 歌声如同灌入了魔力一般，一传十，十传百，很快就传到了前线的军队中，又有歌曰： “战争时代的硝烟炮响连绵不断/我们背井离乡/我们奔赴战场……” 混沌的战场上，歌声、雨声、枪炮声，全都混杂在一起，纷乱、迷离…… 八、战后 一面断墙，一片废墟。 青年愣愣地站在这个自己曾经工作、奋斗的地方前。周围许多人看着他，欲言又止。 “升薪、升职，还当大老板！？”青年突然出声，周围的人都不由地退了一步。他惨笑着，跪倒在了废墟上，“啊哈哈！我要笑破肚皮了！” “别开玩笑了！”他忽的又站起来，状若疯魔，“保家卫国？嘿嘿！血战沙场？呵呵！” “我为什么没有应征？”他的声音倏尔又放低。 “那我又凭什么能应征？”他的声音突然高亢起来，“连这里都保不住的人，又谈什么保家卫国啊！” “全是些疯子、傻子，又有谁在保家，又有谁在卫国呐！”青年脸上没有一丝血色，惨笑着倒在了雨中。 战场上回来的人，有活人，亲人却死在了战争里；有死人，那是白发人送黑发人。他们互相搀扶着，依偎着，只为眼前那微不足道的希望。 有人哭天喊地、怨声载道；也有人调整心态、直面未来。但他们毕竟是活着的。活着的，便是胜利者，不是吗？ 那个曾经翠绿的山林也染上了一抹灰色，刺鼻的硝烟污浊了曾经新鲜的空气。山林深处，老人微微抬头，望着远处天空中弥漫的浓烟，战火并未来到这里。他长叹一声：“生有何乐，死又何哀。故人去矣，魂兮归来。” 九、歌 和平年代的朗朗书声一去不返 我们背离故乡 我们奔走流亡 我们对前路一片迷惘 找不到方向 我们有如无垠苦海上争渡的小船 踏着战士们的尸骨启航 我们何尝不想 收帆返乡 可战场毕竟是战场 没有希望 只有死亡 但待硝烟尽散 我们期望 能回乡 战争时代的硝烟炮响连绵不断 我们背井离乡 我们奔赴战场 我们怀着坚定的信仰 梦想在前方 我们好似北方草原上凶恶的白狼 把敌人的血肉当作食粮 我们挥洒血汗 斗志昂扬 那黑暗中仍有光芒 就是希望 就是彼方 纵使血流漂橹 埋骨他乡 又何妨","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miRoox.github.io/blog/categories/小说文艺/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miRoox.github.io/blog/tags/小说/"},{"name":"作文","slug":"作文","permalink":"http://miRoox.github.io/blog/tags/作文/"}]},{"title":"旧作：石·人","slug":"Stone-Man","date":"2011-07-31T16:00:00.000Z","updated":"2020-01-22T14:41:40.000Z","comments":true,"path":"2011/07/Stone-Man/","link":"","permalink":"http://miRoox.github.io/blog/2011/07/Stone-Man/","excerpt":"","text":"鸟儿冲破了鸟笼，因为它渴望自由。 序 老鸟对小鸟说：“从前啊，有一块石头……” “石头？”小鸟疑问道。 “对啊。”老鸟接着说，“可突然有一天，石头炸裂，里面出来一个人。” “人？可为什么是人呢？”小鸟问。 老鸟：“对啊，为什么是人呢？” 一 他抬起头，迷茫地看着这个世界。 眼前的世界是那么的迷茫，有所那么真切。 他，大概是第一次来到这个世界吧。 周围的人看着他，指指点点，议论纷纷。 “这家伙长得好丑。”一个女生说。 “妈妈！妈妈！”一个小女孩问道，“这个人怎么不穿衣服啊！” “这就是那个传说中从石头里蹦出来的家伙。”一个小男孩两眼冒金星，“可是，它为什么是人，而不是猴子呢？” …… 这，会是他所希冀的光明世界吗？对于这个思维能力尚比昆虫还低的生物而言，显然无法对这个问题自行解答。于是，他选择了“搁置”。 二 这是一个偏远的小山村。 高高耸立的山崖上，一块黑色的大石孤零零地摆在杂草堆中。 每天，都会有一只百灵鸟，站在山崖边的树上歌唱，讲她的奇闻趣事，述她的自由翱翔。 也就是那时， 原来空无一物的石头多了一丝执念，有了一颗心。虽然它听不见、看不到，但它却能从歌声中感受到那一丝欢愉。于是，它便有了想法：“祂要挣脱这黑暗，逃离这束缚，祂要进入那光明的世界。” 这是一丝执念，但随着时间的流转却没有丝毫被磨灭，反而愈发壮大起来。 终于有一天，伴随着一声惊天巨响，“他”诞生了。 三 他终于还是被关入囚笼里，即将要送出村去展览。这一次，连武装警卫也出动了。引来了大批的记者，以及所谓的“学术专家”。 “这下应该万无一失了吧。”人们如是想。 突然，人群中冲出一个小女孩，手中还有一件破破烂烂的小衣裳： “大哥哥，天这么冷，我要送一件……” 几乎所有人都低下了头，不愿意目睹血淋淋的惨剧在眼前发生。 “嘭！” 一声枪响，惊得所有人都不由地抬起头——一旁的警卫开了枪——小女孩踏过了警戒线。 “衣……服……” 鲜血洒向空中，小女孩如断线的风筝般倒下。 他，首先是茫然，然后表情逐渐转为愤怒。 “怪物”真真切切地暴走了！ 四 人类，果真如蝗虫一般的一种生物，总有无畏者在冲锋陷阵。纵使你是是最强，纵使你无敌于天下，在面对涌动着的无穷无尽的“蝗虫”大军时，无休止的战斗压地他无从喘息。那么，战斗还要继续吗？ 于是，他屈服了。 人们自以为是最先进的武器将他震慑住时，他只不过是厌倦了一边倒的屠杀而已。 人们将他关押到更为坚固的铁笼中，施加了更加致命的高压电流……直到人们认为他们的囚徒不再有机会逃脱时，才中止了无谓的浪费。 而他，只是日复一日地在囚笼中等待，等待永不到来的“戈多”，等着梦醒时分的到来。 就这样，春去冬来，时光荏苒。 直到有一天…… 五 直到有一天，他的惊鸿一瞥。 在前来参观的游人中，他瞥见了一名二十来岁的女子。虽然只是侧颜，但他立马笃定——就是当初那个小女孩！ 他从未有像此刻一般渴望自由，甚至远胜在石中度过的漫漫时光。 万无一失的囚笼对他而言不过是个笑话，从未有什么可以阻止他。 “啊！” 伴随着惊慌的尖叫，游客们四散奔逃。 如魔似神的存在，在硝烟的迷蒙中缓缓显现。不远处，那名女子并没有逃走，只是在那原地，静静地站着。 突然，有机灵的警卫将枪口指向那名女子。于是，“怪物”再度爆发出神秘的伟力，一个箭步蹿到女子的面前挡下这一枪。 “嘭！” 枪声，来自后方。 所向无敌的“怪物”不可思议地看着自己胸膛开的血洞，喃喃道： “为甚……么？” “长官，你看，我又立功了。”女人没有理他，自顾走向一旁的警官前炫耀。 “最脆弱的地方，是心。” 这是她给出的答案。 那倒下的尸体被被炸药引起的大火所吞噬。硝烟散尽，留下的，只有一块烧得漆黑的石头。 “这个石头给我们带回去研究吧。”赶来的学者说，“它说不定能破解生命的奥秘。” “不”她坚持道，“这还是放回原处好。” 六 老鸟对小鸟说：“从前呐，有一个人……” “人？”小鸟疑问道。 “对啊！”老鸟接着道，“可终于有一天，那人心死了，变成了石头……”","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miRoox.github.io/blog/categories/小说文艺/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miRoox.github.io/blog/tags/小说/"},{"name":"作文","slug":"作文","permalink":"http://miRoox.github.io/blog/tags/作文/"}]}]}