{"meta":{"title":"miRoox的博客","subtitle":"我唯一知道的就是我一无所知 ——苏格拉底","description":"现役研究生","author":"miRoox","url":"http://miRoox.github.io/blog","root":"/blog/"},"pages":[{"title":"404 Not Found","date":"2021-10-31T15:58:59.601Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"404.html","permalink":"http://miroox.github.io/blog/404.html","excerpt":"","text":"404 Not Found很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2021-10-31T15:58:59.621Z","updated":"2021-01-01T08:27:59.000Z","comments":true,"path":"about/index.html","permalink":"http://miroox.github.io/blog/about/index.html","excerpt":"","text":"Stats Intro偏理的工科生，字面意义的死宅。感兴趣的领域包括但不限于：编程、动漫、科幻小说、数学、科学哲学…好像什么都会一点，又好像什么都不懂。本质上是个theorist 。爱抽象的人很难爱上具体的人。目前科研方向主要是计算光学成像。常用社交帐号: twitter、微博、Bangumi、GitHub社交废人，通常承受不了2人以上的社交环境。不谈政治，少谈时事。动画、漫画、轻小说都看，不过后两者相对看得少。国产动画、漫画挑着看一些，欧美的基本不看。对动画的评价标准不确定，好评的重要一点是电波对的上（如《人类衰退之后》），某一方面很优秀的作品也会给好评（如《永生之酒》），差评的作品基本上是我很难看下去的。典型的对我电波的作品有《人类衰退之后》，《物语》系列，《四叠半神话大系》。魔禁是入宅作。不混圈，不是很懂你们二刺猿。没打过原作的伪东方厨。不打Gal，也不玩各类手游。游戏基本只玩红警2及其Mod。时代变了，Win10对红警兼容性太差，也不再玩了。不过依然只玩单机游戏。喜欢科幻小说，自己也尝试着写过一些，虽然写得不怎么样。目前最喜欢的科幻作家是特德·姜，如果限于国内的话，则是韩松。刘慈欣的作品也很喜欢，但韩松的更对电波一些。九州非忠实粉丝，不分南北。西方文学作品看得少，其主要原因是记不住人名。时常觉得文学作品中的所用的手法比所讲的内容更重要。万物皆可后现代。曾自称红警Modder，但其实从未做出过一个完成品。编程从C语言入门，目前主要使用C++、Wolfram Language （Mathematica）和Julia。C++是一门包罗万象的语言，也因此是门糟糕的语言。希望Rust早日干爆C++之流。吹一波Mathematica，吊打MatLab。现在改吹Julia了，吊打前面两位。还要吹一波Qt，至少人家支持的平台多。算法和数据结构都只是略有接触，不怎么用，也不怎么会用。价值上的相对主义者，认识上的怀疑主义者。哲学理念以康德哲学为核心，认为理性分为纯粹理性与实践理性。纯粹理性的认识论基于康德的“物自体-现象”模型；实践理性以马克思的辩证唯物主义为主，但对历史唯物主义偏向于否定。形式（几乎）是数学的全部内容。有关科学哲学方面的想法比较多，以后专门撰文来说。坑放得太久，都已经忘了。更多信息请见个人知识库维基"},{"title":"所有分类","date":"2021-10-31T15:58:59.621Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"categories/index.html","permalink":"http://miroox.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-10-31T15:58:59.621Z","updated":"2020-08-30T09:13:41.000Z","comments":true,"path":"friends/index.html","permalink":"http://miroox.github.io/blog/friends/index.html","excerpt":"","text":"友链交换示例：名称： miRoox头像： https://miroox.github.io/blog/images/avatar.jpg网址： https://miroox.github.io/blog/标签： 编程 吹水"},{"title":"所有标签","date":"2021-10-31T15:58:59.621Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"tags/index.html","permalink":"http://miroox.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在Julia中实现一个简单的不求值表达式类型获取","slug":"Julia-unevaltypeof","date":"2021-10-31T15:58:08.000Z","updated":"2021-10-31T15:58:09.000Z","comments":true,"path":"2021/10/Julia-unevaltypeof/","link":"","permalink":"http://miroox.github.io/blog/2021/10/Julia-unevaltypeof/","excerpt":"","text":"在Julia中，typeof 可以获取对象类型，但和C++中的 decltype 不同，它获取的是对象的运行时类型，需要对表达式完成求值才能得到。然而有时我们可能希望不求值就得到表达式的类型，这在Julia中并没有直接提供内置方法来实现。但是，我们注意到 Tests.@inferred 可以对推导出的类型和实际的运行时类型进行比较。显然，Julia其实提供了相应的方法获取推导的类型的。阅读其代码不难发现 Base.return_types 方法是推导类型的关键所在。这一方法在文档中并没有具体介绍，仅在手册中介绍方法分派的输出类型计算时作为一个反面例子出现。根据文档中的简单用例以及 @inferred 中的实现推断，可以知道它的签名类似1Base.return_types(f, types::Tuple&#123;Vararg&#123;DataType&#125;&#125;)即根据函数 f 以及给定参数类型的元组 types 来得到可能的返回值类型。注意这个函数会返回一个类型数组，分别对应于可能匹配到方法的不同实例的返回类型。例如123456789&gt; f(x::Int) &#x3D; x^2&gt; f(x::Integer) &#x3D; x&gt; Base.return_types(f, (Int,))1-element Vector&#123;Any&#125;: Int64&gt; Base.return_types(f, (Integer,))2-element Vector&#123;Any&#125;: Int64 Integer不过 Base.return_types 的调用方式显然不太直观，毕竟Julia不能直接改变方法调用的求值顺序。但我们可以通过宏来对其“转译”一下，将普通的函数调用表达式转换成满足参数格式要求的结构。一个粗浅的想法是直接照搬 @inferred 的实现，但由于 @inferred 的应用目标相对较窄，只处理了恰好是单个函数调用的情况，而对于内部的参数依然还是会进行求值。如果要进行推广，最简单的方式是递归地插入获取类型的代码。然而 Base.return_types 返回值是一个数组，需要将结果进行合并，则还要 typejoin 和 reduce 完成类型的合并，使调用即类似于1reduce(typejoin, Base.return_types(f, types))而对于非函数调用的叶子（参数）节点，通常的 typeof 固然可以，但是考虑到存在类似 parse 的类型选择器，typeof 为每个类型都返回 DataType 就显得有些模糊。因此，不妨自己定义一个更精确的 typeof：12exacttypeof(::T) where &#123;T&#125; = Texacttypeof(::Type&#123;T&#125;) where &#123;T&#125; = Type&#123;T&#125;在此基础上，加上简单的封装和宏展开基本就大功告成了123456789101112131415function uneval_typeof_impl(expr) if expr isa Expr if expr.head == :call eargs = map(uneval_typeof_impl, expr.args[2:end]) :(reduce(typejoin, Base.return_types($(esc(expr.args[1])), tuple($(eargs...))))) else error(\"invalid syntax: @uneval_typeof must be used with a expression.\") end else # leaf :(exacttypeof($(esc(expr)))) endendmacro uneval_typeof(expr) uneval_typeof_impl(macroexpand(@__MODULE__, expr))end简单试一下：123456789101112131415&gt; @uneval_typeof 1+2*3Int64&gt; @uneval_typeof 1&#x2F;&#x2F;2+3.0*0x45Float64&gt; @uneval_typeof parse(Int, &quot;123&quot;)Int64&gt; function f(x) println(x) 2x end&gt; x&#x3D;5;&gt; @uneval_typeof f(x)Int64&gt; @uneval_typeof f(x+f(1&#x2F;&#x2F;2))Rational&#123;Int64&#125;不过这个方法只适用于简单的函数调用表达式，对于包含表达式块或者生成器等不能简单表示为单个函数调用组合的情况则会出错。而且，Base.return_types 也不适用于内置的函数（例如，===、Core.sizeof等），因此也无法处理包含这些函数的表达式。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"元编程","slug":"元编程","permalink":"http://miroox.github.io/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"},{"name":"Julia","slug":"Julia","permalink":"http://miroox.github.io/blog/tags/Julia/"}]},{"title":"关于C#9中仅初始化的属性设置器","slug":"Initonly-Setter-CSharp","date":"2021-05-01T12:46:12.000Z","updated":"2021-10-25T15:18:25.000Z","comments":true,"path":"2021/05/Initonly-Setter-CSharp/","link":"","permalink":"http://miroox.github.io/blog/2021/05/Initonly-Setter-CSharp/","excerpt":"C# 9 引入了仅初始化的属性设置器，这使我们可以定义一个只能在构造函数或者初始化设定项中进行设置的属性：","text":"C# 9 引入了仅初始化的属性设置器，这使我们可以定义一个只能在构造函数或者初始化设定项中进行设置的属性：1234567891011121314public class Sample&#123; public string InitOnlyProperty &#123; get; init; &#125;&#125;static void Main(string[] args)&#123; var sample = new Sample &#123; InitOnlyProperty = \"init\", &#125;; //// 编译错误：只能在对象初始值设定项中或在实例构造函数或 \"init\" 访问器中的 \"this\" 或 \"base\" 上分配 init-only 属性或索引器 \"Program.Sample.InitOnlyProperty\"。 // sample.InitOnlyProperty = \"modified\";&#125;这既能保证属性的不可变性，又能避免出现需要定义具有大量参数的构造函数的情况。C# 9 还进一步地引入了记录类型和 with 表达式来简化不可变引用类型的构造。而这一语法糖的实现方式同样基于仅初始化的设置器。然而，在低于 .NET 5 的目标框架下，我们没法直接使用这一语言特性。哪怕指定了 C# 9 作为编译语言版本，依然会产生如下编译错误：预定义类型“System.Runtime.CompilerServices.IsExternalInit”未定义或导入当然，基于缺啥补啥的原则，我们直接看 .NET 的源码中System.Runtime.CompilerServices.IsExternalInit的部分，加上编译条件，照抄一份到我们的项目中：1234567891011121314#if NET5_0_OR_GREATER#elseusing System.ComponentModel;namespace System.Runtime.CompilerServices&#123; /// &lt;summary&gt; /// Reserved to be used by the compiler for tracking metadata. This class should not be used by developers in source code. /// &lt;/summary&gt; [EditorBrowsable(EditorBrowsableState.Never)] public sealed class IsExternalInit &#123; &#125;&#125;#endif就可以解决了。不过，我们本着知其然也要知其所以然的学习态度，不妨试试（用ildasm）对前面的代码反编译一下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647.class auto ansi nested public beforefieldinit Sample extends [System.Runtime]System.Object&#123; .field private initonly string '&lt;InitOnlyProperty&gt;k__BackingField' .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) .custom instance void [System.Runtime]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [System.Runtime]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) .method public hidebysig specialname instance string get_InitOnlyProperty() cil managed &#123; .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) // 代码大小 7 (0x7) .maxstack 8 IL_0000: ldarg.0 IL_0001: ldfld string InitOnlyProperty.Program/Sample::'&lt;InitOnlyProperty&gt;k__BackingField' IL_0006: ret &#125; // end of method Sample::get_InitOnlyProperty .method public hidebysig specialname instance void modreq([System.Runtime]System.Runtime.CompilerServices.IsExternalInit) set_InitOnlyProperty(string 'value') cil managed &#123; .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) // 代码大小 8 (0x8) .maxstack 8 IL_0000: ldarg.0 IL_0001: ldarg.1 IL_0002: stfld string InitOnlyProperty.Program/Sample::'&lt;InitOnlyProperty&gt;k__BackingField' IL_0007: ret &#125; // end of method Sample::set_InitOnlyProperty .method public hidebysig specialname rtspecialname instance void .ctor() cil managed &#123; // 代码大小 8 (0x8) .maxstack 8 IL_0000: ldarg.0 IL_0001: call instance void [System.Runtime]System.Object::.ctor() IL_0006: nop IL_0007: ret &#125; // end of method Sample::.ctor .property instance string InitOnlyProperty() &#123; .get instance string InitOnlyProperty.Program/Sample::get_InitOnlyProperty() .set instance void modreq([System.Runtime]System.Runtime.CompilerServices.IsExternalInit) InitOnlyProperty.Program/Sample::set_InitOnlyProperty(string) &#125; // end of property Sample::InitOnlyProperty&#125; // end of class Sample可以看到 InitOnlyProperty 的设置访问器 set_InitOnlyProperty(string) 被 modreq([System.Runtime]System.Runtime.CompilerServices.IsExternalInit) 所修饰，那么缺少所需的自定义修饰符类型 System.Runtime.CompilerServices.IsExternalInit 自然会导致编译无法通过。事实上，在规范建议的设计文档里，包含 Modreqs 与属性一节，阐述了 init 属性访问器的生成策略中为何选取了必需修饰符（modreq）而不是属性作为元数据进行标记。简而言之，由于 modreq 的必需性，无法理解 init 的编译器（如较早版本的编译器）应当会直接忽略对应的对应的属性设置访问器，从而可以避免将属性当成是可写的。尽管如此，这种保护也不是完全安全的。文档中指出了三种不会保护的情况：对（公共）成员的反射使用 dynamic不识别 modreq 的编译器文档后面还讨论了其它几种设计和它们的利弊，这里就不多加赘述了。不过，借助这一生成策略，我们也可以自己编写函数，通过反射来确认一个属性是否是仅初始化的：1234567891011121314151617181920using System.Linq;using System.Reflection;public static class PropertyExtensions&#123; /// &lt;summary&gt; /// 检查属性是否是仅初始化的。 /// &lt;/summary&gt; /// &lt;param name=\"property\"&gt;要检查的属性元信息。&lt;/param&gt; /// &lt;returns&gt;若该属性的设置访问器是仅初始化的，则为&lt;see langword=\"true\"/&gt;；否则，为&lt;see langword=\"false\"/&gt;。&lt;/returns&gt; public static bool IsInitOnly(this PropertyInfo property) &#123; MethodInfo? setMethod = property.SetMethod; if (setMethod == null) return false; return setMethod.ReturnParameter .GetRequiredCustomModifiers() .Contains(typeof(System.Runtime.CompilerServices.IsExternalInit)); &#125;&#125;","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"元编程","slug":"元编程","permalink":"http://miroox.github.io/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"},{"name":"C#","slug":"C","permalink":"http://miroox.github.io/blog/tags/C/"},{"name":".NET","slug":"NET","permalink":"http://miroox.github.io/blog/tags/NET/"}]},{"title":"在MSBuild中构建LaTeX文档","slug":"MSBuild-LaTeXDoc","date":"2021-01-28T12:12:12.000Z","updated":"2021-10-25T15:18:25.000Z","comments":true,"path":"2021/01/MSBuild-LaTeXDoc/","link":"","permalink":"http://miroox.github.io/blog/2021/01/MSBuild-LaTeXDoc/","excerpt":"众所周知，LaTeX 便于实现专业级的排版效果，而且内容与样式分离的设计也使文档格式易于调整修改；同时，其源文件作为一种纯文本格式的文件，对于 git 这类版本控制系统也更为友好，利于开发过程中的协作工作。因此，LaTeX 相比 Word 更适合用于制作软件的用户手册。","text":"众所周知，LaTeX 便于实现专业级的排版效果，而且内容与样式分离的设计也使文档格式易于调整修改；同时，其源文件作为一种纯文本格式的文件，对于 git 这类版本控制系统也更为友好，利于开发过程中的协作工作。因此，LaTeX 相比 Word 更适合用于制作软件的用户手册。Visual Studio 本身当然没有提供 LaTeX 的构建工具，但作为其构建系统的 MSBuild 提供了自定义目标和任务的方式。而我们在编写 LaTeX 文档时，也常常会使用 LaTeX 自己的构建工具（如：latexmk、Arara）。方便起见，我们直接用 Exec 任务调用 latexmk 构建 LaTeX 文档，已避免处理交叉引用等问题面临的多次编译排版的麻烦。这里就略过 LaTeX 文档本身如何编写了，只讲 MSBuild 的配置。首先，在文本编辑器下打开项目文件，通过属性设置好文档的目录和文档的文件名：1234&lt;PropertyGroup&gt; &lt;ManualFile&gt;manual.pdf&lt;/ManualFile&gt; &lt;ManualDir&gt;$(SolutionDir)doc/manual/&lt;/ManualDir&gt;&lt;/PropertyGroup&gt;这里，我们要生成的手册文档所在的路径是相对于解决方案路径的 doc/manual，而排版输出的 PDF 文档其文件名是 manual.pdf。然后添加构建文档的目标：1234567&lt;Target Name=\"BuildManual\" AfterTargets=\"PostBuildEvent\"&gt; &lt;Exec Command=\"latexmk\" WorkingDirectory=\"$(ManualDir)\" /&gt; &lt;Copy SourceFiles=\"$(ManualDir)$(ManualFile)\" DestinationFolder=\"$(OutDir)\" /&gt;&lt;/Target&gt;&lt;Target Name=\"PublishManual\" AfterTargets=\"Publish\"&gt; &lt;Copy SourceFiles=\"$(ManualDir)$(ManualFile)\" DestinationFolder=\"$(PublishDir)\" /&gt;&lt;/Target&gt;需要注意的是，latexmk 想要正常工作的话，要将工作目录和 LaTeX 源文件设置为同一个，尤其是在设置了 latexmkrc 来调整 latexmk 的行为的情况下。另外，除了在构建时需要将输出的 PDF 文档复制到软件的输出目录下之外，不要忘记发布时同样需要将其复制到发布目录下。然而，如果设置了多种 TargetFrameworks 时，上面这种组织目标的方式可能就不太合适，因为构建时几种目标框架会同时进行构建，很可能导致 latexmk 在同一时间段调用多次，而其所需的文件资源互相抢占，最终构建失败。当然，这样的问题总有前人踩过类似的坑，比如 SO 上的 How to make an MSBuild Target that only runs once instead of once, before Targets that run once per framework in the TargetFrameworks tag?，告诉我们可以使用 BeforeTargets=&quot;DispatchToInnerBuilds&quot; 在进入目标框架构建之前执行目标，于是我们的文档构建-输出-发布可以改写成：123456789&lt;Target Name=\"BuildManual\" BeforeTargets=\"DispatchToInnerBuilds\"&gt; &lt;Exec Command=\"latexmk\" WorkingDirectory=\"$(ManualSource)\" /&gt;&lt;/Target&gt;&lt;Target Name=\"CopyManual\" DependsOnTargets=\"BuildManual\" AfterTargets=\"PostBuildEvent\"&gt; &lt;Copy SourceFiles=\"$(ManualSource)$(ManualFile)\" DestinationFolder=\"$(OutDir)\" /&gt;&lt;/Target&gt;&lt;Target Name=\"PublishManual\" DependsOnTargets=\"BuildManual\" AfterTargets=\"Publish\"&gt; &lt;Copy SourceFiles=\"$(ManualSource)$(ManualFile)\" DestinationFolder=\"$(PublishDir)\" /&gt;&lt;/Target&gt;最后，为了方便重新构建，也不要忘记在清理目标时同时清理 LaTeX 文档：1234&lt;Target Name=\"CleanManual\" AfterTargets=\"Clean\"&gt; &lt;Exec Command=\"latexmk -c\" WorkingDirectory=\"$(ManualDir)\" /&gt; &lt;Delete Files=\"$(OutDir)$(ManualFile)\" /&gt;&lt;/Target&gt;","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"LaTeX","slug":"LaTeX","permalink":"http://miroox.github.io/blog/tags/LaTeX/"},{"name":"MSBuild","slug":"MSBuild","permalink":"http://miroox.github.io/blog/tags/MSBuild/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://miroox.github.io/blog/tags/Visual-Studio/"}]},{"title":"2020年终总结","slug":"Summary2020","date":"2020-12-31T15:32:13.000Z","updated":"2020-12-31T15:32:13.000Z","comments":true,"path":"2020/12/Summary2020/","link":"","permalink":"http://miroox.github.io/blog/2020/12/Summary2020/","excerpt":"今年大概是我第一次写年终总结。不得不说，2020 年是充满变数的一年，开年席卷而来的新冠病毒肺炎打破了大多数人的正常生活，我当然也不例外。","text":"今年大概是我第一次写年终总结。不得不说，2020 年是充满变数的一年，开年席卷而来的新冠病毒肺炎打破了大多数人的正常生活，我当然也不例外。封锁刚开始的时候还是比较闲的，毕竟作为一个真正的死宅，在家里待着比到处去走亲访友要愉快多了。而在闲着的时候找点事干也算是我为数不多的长处之一了，除了日常补补动画漫画之外，还把博客逐渐迁移到 Hexo 上，然后又开了一些新坑，例如：Wolfram 语言的视频教程、Wolfram 语言实现的惰性列表以及一个轻量的 Wolfram 语言解释器。然而这几个坑挖了也都没能好好填上：视频教程开了个引言就一直鸽着；惰性列表算是完成度比较高的一个，也留着大量基础设施在 TODO list 里；解释器就更惨了，以我这三脚猫的编译原理基础，折腾了一个月连词法分析都没弄对，也就没好意思拿出来开源。不过，空闲的日子并没有持续多久。寒假还没结束，导师就把所里的项目拉来让我们做，而且这项目还是紧跟热点的“新冠病毒核酸自动化快速检测平台”。虽然名字起得高大上，但实质上我们课题组负责的也就是一个自动数据处理报表的软件，作为“新冠病毒核酸快速检测一体化设备与试剂”的中间环节。或许是为了减轻其它同学的开发学习负担，导师让我们使用 C# 进行开发。而我这个初学者只好边学边做，却没想到借着其它语言的基础，轻松碾压咱这帮纯业余的师兄师姐们，一跃成为项目的唯一主力开发。另一方面，因为紧跟时事，项目的进程自然也催得很紧，需求变化也很快，程序也就翻来覆去地改。整个春季的多数时间都消磨在这个项目上了，甚至还因此不小心错过了春季学期的选课。期间又有各种事情，断断续续到八月份交了一个不甚完善的版本才算暂且告一段落。不过，项目拖着拖着没过一段时间就不怎么催了。到五月份后，除了上上网课，敲敲代码，闲暇的生活又再次回归了。然后，怀抱着ドキドキ的心情，我久违地(?)尝试了女装，体验意外地还不错`(*&gt;﹏&lt;*)′，顺带也让我蹭了一下 15K+ star 的传说级 repo。伴随着哈工大百年校庆的接近，美国政府加大了对中国的制裁打击。其结果不仅让我们学校告别了正版 MATLAB，也让我加入 Wolfram 学生大使为简历充门面的计划成功泡汤了。很快到了七月返校的时间。因为在学校时常连不上 GitHub 而一怒之下买了 v2ray 的节点，顺便注册了个 twitter。于是在种种机缘巧合下认识了 Raptazure，并受邀加入了 h1trust。不过手里没有一个拿得出手的 Rust 项目的话感觉还是受之有愧，于是又开了一个新坑——用于 Rust 的 Wolfram LibraryLink 接口。差不多同一时间段，看到了张小飞大佬在招募社区成员翻译 Qt 文档，作为一个 Qt 的老用户，我也凑热闹翻译了其中的几篇。随着正式开学的逐渐迫近，读博还是工作的选择也愈发紧迫起来。曾经我以为这件事上并没有多少变数，毕竟当初选择导师的时候我就答应了要去读博，本着诚实守信的原则，原本想着最多也就是换一个地方读博。不过，一年多的科研时光让我多少产生了一些犹豫，答应导师要写的论文已经鸽了一年了（嗯，现在还鸽着），做的东西感觉也不过是在生产学术垃圾。而咨询了一些师兄师姐之后，他们也都劝我要三思，毕竟真陷进去的话想要再出来就很困难了。再三考虑下，我意识到读博多半恐怕无法实现我理想中的那种“纯粹的科研”。为了不浪费国家的科研经费，也为了不让自己顶着可能肄业的压力和风险，我最终决定去当民科找工作。毫无疑问，到八月这个时间点才开始准备找工作，在各个层面上都非常不利。不过既然决定了也就不能瞻前顾后，八月底到整个九月，我的精力都放在了找工作和毕业论文开题上。然而准备不足加上我这个阴郁的性格，结果基本是不停碰壁。而到了十月，从天而降的拼接仪（准确说叫“焦面像元几何精度精密标定设备”）项目又让我再次陷入泥淖。就像之前吐槽的那样，这玩意纯粹是一个坑，508 所去年就已经拿着一个空壳子去验收过一次了，到今年实在等不及了才催着做实际的验收。该吐的槽之前的文章基本也吐过了，好在这会儿我有了 C# 基础和之前的经验，东拼西凑最后还是在十一月中旬弄得差不多交去验收了。同样在十月期间，终于有公司肯收留我了。由于留给我考虑时间并不宽裕，而多数公司都杳无音讯，只好选择了一个其貌不扬的苏州同元软控。他们号称要做国产 Simulink/MATLAB，在这个中美贸易战的背景下，大概能拿不少国家的补贴；而且他们的软件开发也很大程度上基于 Qt，并且想做 Julia 语言的互操作，和我现有的技术栈也勉强算合得来。于是在十月底完成了三方签约。时间转到十一月，出乎我意料的是，没隔几周，金山办公和 Intel 陆续给我发了 offer，于是难得地体验了一把左右横跳。这么跳来跳去感觉还是非常愧对前面两个公司的，不过还是架不住 Intel 传说中的性价比。Intel 录我的是系统软件工程部，然而我对系统软件这个领域我基本是一无所知，想着抽空大致学一下，于是开始照着 Writing an OS in Rust 学着写写一个简单的操作系统。十一月意味着一学期已经过去一半了，想着也该把课题捡起来做一做了。作为一个 MATLAB 黑，很多科研需要的基础设施都只能自己造，于是就先撸了一个衍射计算的 Julia 程序包，顺带还开了相位恢复和叠成成像程序包的坑。然而课题还没有多少进展，十二月初，核酸检测软件又需要交付使用了。在看完现在的版本后，生命学院那边还提出了若干个新需求，一下把软件的自由度和扩展性提升了好几倍。我寻思着这下重构还不如重写了，于是换到 .NET Core 从头进行开发，就这么一直做到现在。也不知道这次做完能不能赶上第二波疫情反弹。2020 年是充满变数的一年，或者用我党的惯用说法可以称之为机遇与挑战并存的一年。在这一年，我放弃了人生的一条道路，开始尝试走向另一条道路；在这一年，我付出了许多额外的辛劳，也收获了不少意外之喜；在这一年，我似乎更清楚地认识了自己，又似乎依旧在原地踏步。我只知道这大概是我人生中重要的一年，当然，也可能意外地不那么重要。毕竟，谁也不知道未来是怎样。不过，在现在，在此时此刻，我们也许只需要鼓起勇气，平和地迈向新的一年。","categories":[{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miroox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"http://miroox.github.io/blog/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"}]},{"title":"Julia包开发基本指南","slug":"JuliaPkgGuide","date":"2020-11-30T15:58:23.000Z","updated":"2020-12-02T10:27:35.000Z","comments":true,"path":"2020/11/JuliaPkgGuide/","link":"","permalink":"http://miroox.github.io/blog/2020/11/JuliaPkgGuide/","excerpt":"近期试着做了一些 Julia 的程序包，并注册到了官方的 General Registry 上。不得不说，Julia 程序包功能完善，而开发的流程也不复杂。这里简单记录一下，以飨后人。","text":"近期试着做了一些 Julia 的程序包，并注册到了官方的 General Registry 上。不得不说，Julia 程序包功能完善，而开发的流程也不复杂。这里简单记录一下，以飨后人。 包的基本结构在Juia中，一个完整的程序包除了有项目本身的程序之外，往往还包含测试、文档等部分。因此，在开始讲程序包开发之前，先看一下一个典型程序包的基本结构：1234567891011121314151617181920MyPackage|-- docs| |-- src| | |-- index.md| | &#96;-- ...| |-- Manifest.toml| |-- Project.toml| &#96;-- make.jl|-- src| |-- MyPackage.jl| &#96;-- ...|-- test| |-- Manifest.toml| |-- Project.toml| |-- runtests.jl| &#96;-- ...|-- LICENSE|-- Project.toml|-- README.md&#96;-- ...可以看到，这里有三个文件夹 docs、src、test 分别对应文档、项目源码、测试代码。根据用途的不同，有时也会包含存放示例的 example、存放模板的 templates 等文件夹。这里，最不可或缺的就是项目源码 src/MyPackage.jl，当我们使用 using MyPackage 或者 import MyPackage 时，加载的就是这个文件。当然，同样不可或缺的还有项目文件 Project.toml，它包含了项目的名称、UUID、作者、依赖等元数据。通常，一个项目还会包含一个 Manifest.toml 的清单文件，用来描述完整的依赖关系图、每个包的确切版本以及项目使用的库。但对于一个需要发布的包而言，我们通常会在版本控制系统中将其忽略（如添加在 .gitignore 中），因为我们一般不会希望完全固定一个包的依赖版本，而是指示一个兼容的范围（这可以在 Project.toml 中通过 [compat] 指定）来允许更自由的安装依赖。此外，代码测试也非常重要，是否有良好的代码测试显著影响着代码的质量，因而 Julia 在标准库中内置了对代码测试的支持，在包管理器下执行 test 则会运行 test/runtests.jl。值得注意的是，在 test 目录下，我们还有一个 Project.toml 和一个 Manifest.toml，这意味着，test 其实是另一个项目，清单文件的存在，保证了测试所处环境的一致性，从而更能保证测试的可复现性。不过这个机制在 Julia 1.2 之前是通过 [extras] 和 [targets] 实现的，因此如果要兼容早期版本，需要使用之前的机制，见 Test-specific dependencies in Julia 1.0 and 1.1。另一个重要的内容则是文档，完善的文档让程序包更易理解和使用。除了将内置的 docstring 作为文档之外，我们也可能希望发布的程序包附带一份内容更完善的在线部署文档。docs 中的内容就是为了实现这一目的而准备的，它依托 Documenter.jl 进行文档生成与发布部署。同样，文档目录也是独立的项目，使整个文档生成工作在独立的环境中，不干扰源项目本身。 包开发在包开发的过程中，首先要进行的是包的命名。需要注意的是，待注册的包应当遵循 Julia 包命名方针：尽量避免缩写，除非是广为人知的缩写；避免使用 Ju 开头；主要功能是关于特定类型的话，应该使用复数；使用清晰的命名，哪怕这会让名字看起来长了点；用于某个领域的不同实现方式之一的包，可能适合不太系统的名字；包装了外部库或程序的包应该命名为对应的库或程序。在前一节，我们看到，Julia 包的结构还是有些复杂的，但格式基本相对固定。为了避免在开发初期被繁琐的配置困扰，社区已经有大佬开发了 PkgTemplates.jl，提供了自动化和可定制的包生成机制。下面是一个模板配置的例子：123456789101112Template( julia=v\"1.2.0\", plugins=[ Tests(; project=true), Git(; ssh=true), CompatHelper(), TagBot(), GitHubActions(), Codecov(), Documenter&#123;GitHubActions&#125;(), ])可以看到除了前一节提到的部分，还有基于 GitHub Actions 的持续集成，Codecov 覆盖率监测、CompatHelper、TagBot 等一系列附加工具。详情还是去看 PkgTemplates.jl 的文档吧。另外，Documenter 在部署文档时，需要在托管环境中配置 SSH 部署密钥，而为了生成密钥，还需要 DocumenterTools.jl，然后分别将公钥和私钥放在 GitHub 具有仓库写权限的 deploy key 和名为 DOCUMENTER_KEY 的环境变量中。这部分详见 Authentication: SSH Deploy Keys。 包注册包注册其实非常简单。不过注册前还需要检查一下注册需要满足的条件，包括是否有开源许可协议，是否所有依赖都有有限区间的 [compat] 入口，以及前面提过的命名要求等。这些条件详见 Registering a package in General。至于注册，只需要在更新了项目文件中的 version 后，在对应的提交下评论1@JuliaRegistrator register即可发出注册请求，它会自动在 JuliaRegistries/General 中创建一个对应的 pull request。对于新注册的包，会公示三天，如果没有问题，则会自动合并；对于已存在的包的新版本，等待5分钟就会自动合并。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Julia","slug":"Julia","permalink":"http://miroox.github.io/blog/tags/Julia/"}]},{"title":"吐槽：这些天在拼接仪项目上踩的坑","slug":"TrapInSplicerProject","date":"2020-10-31T14:56:23.000Z","updated":"2020-10-31T14:56:13.000Z","comments":true,"path":"2020/10/TrapInSplicerProject/","link":"","permalink":"http://miroox.github.io/blog/2020/10/TrapInSplicerProject/","excerpt":"本文以倒苦水为主。","text":"本文以倒苦水为主。那是一个平和的中午，我刚吃完午饭，正准备回寝室休息。然而，一个突如其来的微信消息打破了宁静的一天……嗯，就是导师突然拉上我们组好几个人来开会，讨论如何在甲方要求的验收时间——国庆节后——之前把这个项目的软件部分给做出来。然而，这个项目虽然启动已经有至少三年之久了，可之前基本没啥进展，硬件那边不知道为啥一直没完成，咱们软件也就没好好做，并且之前负责这个项目的两个师兄都已经毕业了。最终，这颗定时炸弹轮到咱们手里终于还是炸了。不过，更离谱的是我们没人明白这个东西到底要做成啥样。手头只有一份上一代留下来的不清不楚的说明书。而导师的核心指示就是要把界面做得和原来一样，至于里面的功能，很大程度上只能自己去猜了。整个项目粗浅的理解就是在一个多自由度的位移台上放了一个红外相机，软件则要控制位移台的运动以及相机的拍摄，并可以运用自动聚焦的方式寻找焦面的最佳位置。你要问我这里哪里体现了“拼接仪”，我也说不清，只能说和我们软件部分的工作无关。 位移台控制最初给我分配的任务就是位移台控制。在这里，位移台是通过 PMAC 驱动的。PMAC (Programmable Multi-Axis Controller) 可编程多轴运动控制器，是美国 Delta Tau Data System 公司推出的PC机平台上的运动控制器。不过，想要用 PMAC 实现上位机编程控制，首先还需要安装 PMAC EXECUTIVE PRO2 SUITE，然后通过它的互操作库 Interop.PCOMMSERVERLib 来调用命令，实现对电机的控制。然而，我们一上手就遇到了一个难题，Interop.PCOMMSERVERLib 似乎是基于 .NET Framework 3.x 开发的，将它引入引用后，如果目标框架是 .NET Framework 3.5 就没有问题，而如果用 .NET Framework 4 及以上，就会出现诸如“无法嵌入互操作类型 “PmacDeviceClass”，请改用合适的接口”的问题。然而，Windows.Forms.DataVisualization 又是 .NET Framework 4 才引入的，没用它的话，要绘制自动聚焦评价函数的曲线又显得麻烦起来。几经波折，总算在公司的官方论坛上找到了一个解决方法。按照他的指示，将引用属性里的“嵌入互操作类型”的值改为 false，就可以避免出现编译错误了。按我的理解，这避开了编译时对 COM 类型的解析。而另一方面，得益于 COM 组件强大的兼容性，这么做在运行时似乎并不会有问题。除此之外，还有各种其它问题到工厂里调试才逐渐凸显，于是项目的开发毫无疑问的超期了，变成了一场漫长而琐碎拉锯战。 相机控制相机用的是 FLIR 的工业相机，为了通过编程控制，需要使用 FlyCapture2 套件进行开发。事实上，这部分之前的一个师兄应该已经尝试过了，然而，他在移交代码的时候并没有找全所有依赖，导致移交的程序虽然能通过编译，但一旦启动就会发生 FileNotFoundException。不过好在开发套件中还包含一些demo的源码，那就编译跑跑试试？幸运的是，demo在我的机器上可以跑起来。既然如此，那就好办了，找到输出目录，把里面的东西一股脑的都复制过来……额，好像有点多。那就先用暴力排除法，在程序启动的时候试着把路径里的文件一个个删掉，没有操作权限的文件就是必要的依赖。不过后来想想这个方法还是太笨太低效了，于是又去找查找依赖项的工具，得到了 Dependencies，不过这是后话了。既然找到依赖了，最好还能在构建的时候一把梭把依赖全部自动复制到输出目录。在研究了一下demo的项目文件后，又根据目标平台和配置写了一个PostBuildEvent脚本，中间还顺带学习了一下 PowerShell，一晃就到了凌晨三点半。结果第二天师兄跟我说在他那儿还是会触发 BadImageFormatException，不过此时我已经备好了 Dependencies 作为武器。分析一下 Dependencies 给出缺失的库，基本都 api-ms-win- 开头，d 结尾的一些动态库，这就意识到估计跟 Debug 模式有关，而且是微软官方的 VC++ 运行时库。于是先让师兄换成 Release，成功跑起来。再让他给 Visual Studio 安装 C++ 桌面开发的相关组件，才解决。然而还有漫长的痛苦发生在去工厂调试之后。我们的目标工控机跑的是古老的 Windows XP 32位系统，然而我们用的这个库是64位（其实有32位的，不过32位的好像缺依赖，在我自己的机器上都跑不了demo）。好在机器的硬件是64位的，于是又抱着主机到有网的地方重装一个64位系统。除了系统之外，还有各种 VC 运行时库、.NET Framework 要安装。好不容易搞定了基本环境，启动后却检测不到相机。看设备管理器里的提示，似乎跟驱动程序的证书有关，可找遍各种资料也没明白应该怎么修复，找相机售后也没得出个所以然来。不过这段时间我正好有一些工作面试之类的，也没太管。事后，听说师兄们祭出了终极绝招360管家，把所有系统漏洞都修复了就好使了……而问题的准确原因也就成了一个谜。 总结做这么一个项目的过程中虽然踩了不少坑，碰了不少壁，不过“凡不能毁灭我的，必使我强大”，要说收获，可能也不少。不过项目虽然已经进入后期，但踩坑之路还没有断绝。到了现在，看这项目最大的隐患可能就是各个精度指标提的有些离谱，什么自动聚焦图像采集间隔 10μm，用拟合得到的最佳焦面位置判定精度却要达到1μm之类的，实在是过于奇幻了。","categories":[{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miroox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C#","slug":"C","permalink":"http://miroox.github.io/blog/tags/C/"},{"name":"PMAC","slug":"PMAC","permalink":"http://miroox.github.io/blog/tags/PMAC/"},{"name":"FlyCapture2","slug":"FlyCapture2","permalink":"http://miroox.github.io/blog/tags/FlyCapture2/"}]},{"title":"部署一个简单的缩略 URL 的表单","slug":"WolframURLShortenForm","date":"2020-08-30T13:33:21.000Z","updated":"2020-08-31T06:56:39.000Z","comments":true,"path":"2020/08/WolframURLShortenForm/","link":"","permalink":"http://miroox.github.io/blog/2020/08/WolframURLShortenForm/","excerpt":"最近微博好像把 github.io 下的域名屏蔽了，导致博客完全无法分享，就考虑通过短链接跳转绕开这一限制。考虑到 Mathematica 有现成的函数 URLShorten，直接使用即可。不过闲着无聊，就顺便部署了一个简单的缩略 URL 的表单: https://www.wolframcloud.com/obj/miroox/url-shorten。","text":"最近微博好像把 github.io 下的域名屏蔽了，导致博客完全无法分享，就考虑通过短链接跳转绕开这一限制。考虑到 Mathematica 有现成的函数 URLShorten，直接使用即可。不过闲着无聊，就顺便部署了一个简单的缩略 URL 的表单: https://www.wolframcloud.com/obj/miroox/url-shorten。本来想支持复制按钮的，然而 CopyToClipboard 在网页上不起作用，自己写 js 支持又出乎意料的麻烦，遂放弃。部署用的代码：1234567891011121314CloudDeploy[ FormPage[ &#123;\"url\", \"URL:\"&#125; -&gt; &lt;| \"Interpreter\" -&gt; \"URL\", \"Hint\" -&gt; \"Enter the URL to be shortened\" |&gt;, Row@&#123;\"Short URL: \", Hyperlink@ URLShorten[#url]&#125; &amp;, AppearanceRules -&gt; &lt;| \"Title\" -&gt; \"Shorten your URL\" |&gt; ], \"url-shorten\", Permissions -&gt; \"Public\" ]","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"},{"name":"Cloud","slug":"Cloud","permalink":"http://miroox.github.io/blog/tags/Cloud/"}]},{"title":"【新坑】wll-rs: 用于 Rust 的 Wolfram LibraryLink 接口","slug":"wll-rs-design","date":"2020-08-29T15:40:21.000Z","updated":"2021-10-25T15:18:25.000Z","comments":true,"path":"2020/08/wll-rs-design/","link":"","permalink":"http://miroox.github.io/blog/2020/08/wll-rs-design/","excerpt":"苦于 Wolfram LibraryLink 原本的接口使用起来过于繁琐，又受 wll-interface 的启发，近期开了一个新坑，尝试为 Wolfram LibraryLink 封装一套 Rust 的接口 wll-rs。阅读本文需要一定 Rust 以及 Wolfram LibraryLink 的基础。","text":"苦于 Wolfram LibraryLink 原本的接口使用起来过于繁琐，又受 wll-interface 的启发，近期开了一个新坑，尝试为 Wolfram LibraryLink 封装一套 Rust 的接口 wll-rs。阅读本文需要一定 Rust 以及 Wolfram LibraryLink 的基础。 目标和基本结构既然用上 Rust 这种高级抽象的语言，自然不可能只是做一些简单的绑定。至少要能做到两件事：提供安全便利的类型和接口封装自动生成满足 LibraryLink 规范的导出函数格式为了让不熟悉 Wolfram LibraryLink 的读者也能了解到它使用起来有多麻烦，下面截一段官方示例中的源码：1234567891011121314151617181920212223242526272829// demo.c/* Include required header */#include \"WolframLibrary.h\"/* Return the version of Library Link */DLLEXPORT mint WolframLibrary_getVersion( ) &#123; return WolframLibraryVersion;&#125;/* Initialize Library */DLLEXPORT int WolframLibrary_initialize( WolframLibraryData libData) &#123; return LIBRARY_NO_ERROR;&#125;/* Uninitialize Library */DLLEXPORT void WolframLibrary_uninitialize( WolframLibraryData libData) &#123; return;&#125;/* Adds one to the input, returning the result */DLLEXPORT int demo_I_I( WolframLibraryData libData, mint Argc, MArgument *Args, MArgument Res) &#123; mint I0; mint I1; I0 = MArgument_getInteger(Args[0]); I1 = I0 + 1; MArgument_setInteger(Res, I1); return LIBRARY_NO_ERROR;&#125;除了加载库和卸载库时所需要的初始化和反初始化函数外，函数本身的传参形式也非常奇妙，LibraryFunction 的实参通过 MArgument 的指针（数组）传入，实际的返回结果也在参数列表中，而函数所返回的 int 值则表示一个错误码。作为目标，我们期望在 wll-rs 中实现的等效形式：12345678910111213// demo.rsuse wll::Result;#[wll::setup]fn init() &#123;&#125;#[wll::teardown]fn uninit() &#123;&#125;#[wll::export(demo_I_I)]fn add_one(n: isize) -&gt; Result&lt;isize&gt; &#123; Ok(n + 1)&#125;即通过 wll::Result 表示返回值和结果状态，通过类属性宏标记函数来自动生成满足 LibraryLink 规范的导出函数。有了基本的目标，那么大致的框架也可以确定了：wll-sys 底层接口绑定wll-macros 提供类属性过程宏（受Rust本身的限制，过程宏必须由单独的包提供）wll 整合封装给用户使用的包 底层接口绑定底层接口绑定是一件很无聊的事，不过好在我们有 bindgen 可以从头文件中生成对应的 Rust 文件，大大减轻了我们的工作量。具体操作流程就不再赘述了，直接看官方的文档教程即可。稍微值得一提的是，bindgen 生成的文件可能不能满足我们对类型的预期，比如头文件中的宏定义和匿名枚举项，本身不具有类型描述。例如来自宏定义的 True 的类型并不会是 mbool。为了能手动转换复写它们，这里将 bindgen 生成的代码包含在一个 mod 中，再 pub use 导出全部符号，这时，在外部复写也不会导致符号重名的错误了。1234567891011// sys/src/lib.rs 节选mod bindings &#123; include!(concat!(env!(\"OUT_DIR\"), \"/bindings.rs\"));&#125;pub use bindings::*;pub const True: mbool = bindings::True as mbool;pub const False: mbool = bindings::False as mbool;// ……另外 Wolfram LibraryLink 的接口设计某种意义上是不需要链接的，几乎所有类型都是指针，用来回调的函数也是 WolframLibraryData 的成员函数指针。事实上，在目前的测试中，哪怕没有链接到 WolframRTL，编译得到的 C ABI 动态库（cdylib）只要满足 LibraryLink 的接口规范，一样能正常使用。 参数类型适配底层接口绑定完成后，就可以开始进行用户层参数的适配了。首先考虑错误处理。这里将错误码封装成更具 Rust 风格的 Result 和 Error 对象，以及和错误码之间的相互转换。而为了更友好地向用户表征错误类型，也提供了 ErrorKind 枚举类型，以及其到 Error 类型的转换（见 errors.rs）。在 LibraryLink 的接口中，所有类型的参数都通过 MArgument 来传递，这是一个（untagged）联合体，包含了 LibraryLink 中的各种类型。而我们的用户既不应该直接处理 MArgument，也通常不用直接面对 LibraryLink 的底层类型，而是使用封装后的 Rust 类型。如图所示，为了支持函数的输入输出，需要有“Rust 类型 - LibraryLink 类型 - MArgument”的双向转换。这里，LibraryLink 类型是可枚举的，因此，它和 MArgument 之间的转换也是可枚举的，同时，从设计上看，这部分转换也是无需暴露给用户的。而对于可能的 Rust 类型，为了给予用户可扩展性，允许用户自定义 Rust 类型和 LibraryLink 类型之间的转换。并且，一旦用户自定义了 Rust 类型和 LibraryLink 类型之间的转换，那么对应的 Rust 类型和 MArgument 之间的转换也应该自动被实现。而为了保证最终转换的唯一性，一个 Rust 类型至多只能对应于一个 LibraryLink 类型（反之则不然）。小结一下需求：LibraryLink 类型和 MArgument 之间的转换预先固定且不暴露给用户；Rust 类型和 LibraryLink 类型之间的转换可以由用户自行扩展，但一个 Rust 类型至多只能对应于一个 LibraryLink 类型；Rust 类型和 LibraryLink 类型之间的转换 → Rust 类型和 MArgument 之间的转换。一个非常平凡的想法是将所有 LibraryLink 类型包到一个 enum 中，毕竟 Rust 的 enum 也就是一种 tagged union，这样也很容易满足一个 Rust 类型至多只对应于一个 LibraryLink 类型。但问题在于这使 MArgument 到 LibraryLink 类型，以及更进一步的，从 MArgument 到 Rust 类型的转换变得困难了起来。虽然 enum 带有标签，但从编译时蕴含的信息上看，它和 union 一样，都抹平了不同类型之间的差异。当从它向 MArgument 转换时，由于它具有的运行时信息更丰富，因此可以实现。然而，反之则不然，如果不向这一过程注入更多类型信息的话，那么实现起来完全无从下手。可是，如果不使用 enum 的话，这些信息本身就存在，再额外注入不仅画蛇添足，似乎也不太符合分离耦合的思想。在 Rust 中，我们有两种逻辑委派方法，其中一种是 enum，而另一种是 trait 对象[1]。enum 是封闭类型，看上去更符合我们这里的情况，但由于上述原因，并不适合使用；而 trait 对象是开放类型，似乎也没法用在这里。当然，我们这里不需要动态性，所以只需要 trait 而非 trait 对象，但这也为我们提供了另一种可能的思路。事实上，sealed trait 模式[2]让我们能将 trait 的实现限制在我们的模块内而无法被外部实现。简而言之，就是让我们的公开 trait 将一个不公开的占位 trait 作为父 trait，从而使外部实现无法满足约束，从而封闭了可能的类型。123456789101112131415161718192021222324// adaptor.rs 节选mod private &#123; pub trait Sealed &#123;&#125;&#125;pub trait MType: private::Sealed + Sized &#123;&#125;macro_rules! impl_mtypes &#123; ($($t:ty),+) =&gt; &#123; $( impl private::Sealed for $t &#123;&#125; impl MType for $t &#123;&#125; )+ &#125;;&#125;impl_mtypes!( mbool, mint, mreal, mcomplex, // ……);在这里，我们将所有的 LibraryLink 类型都实现为 MType trait。这只是一个开端，我们还需要提供它们的适配关系接口。1234567891011pub trait InputAdaptor: Sized &#123; type Input: MType; fn mtype_try_from(input: Self::Input) -&gt; Result&lt;Self&gt;;&#125;pub trait OutputAdaptor: Sized &#123; type Output: MType; fn try_into_mtype(self) -&gt; Result&lt;Self::Output&gt;;&#125;考虑到一个 Rust 类型至多只对应于一个 LibraryLink 类型。将对应的 LibraryLink 类型作为适配 trait 的关联类型显然是比较合适的。而为了自动实现 Rust 类型和 MArgument 之间的转换，可以采用所谓的 blanket implementations[3] 来传递这种转换关系。然而，不同 LibraryLink 类型对应 MArgument 的字段不同，需要 ad-hoc 实现，而同一个 trait 的 blanket implementations 不能区分具有不同关联类型的同种 trait。因此 MArgument 的转换 trait 必须是具有泛型类型参数的 trait，通过完全特化的实现来满足这种对应关系。123456789101112131415161718192021222324252627282930313233343536#[doc(hidden)]pub trait MArgumentGetter&lt;T: MType&gt;: Sized &#123; fn try_get_arg(arg: MArgument) -&gt; Result&lt;Self&gt;;&#125;#[doc(hidden)]pub trait MArgumentSetter&lt;T: MTypeOrVoid&gt;: Sized &#123; fn try_set_arg(self, arg: &amp;MArgument) -&gt; Result&lt;()&gt;;&#125;impl&lt;T: InputAdaptor&lt;Input = mbool&gt;&gt; MArgumentGetter&lt;mbool&gt; for T &#123; #[inline] fn try_get_arg(arg: MArgument) -&gt; Result&lt;Self&gt; &#123; unsafe &#123; let ptr = arg.boolean; if ptr.is_null() &#123; return Err(Error::from(ErrorKind::TypeError)); &#125; T::mtype_try_from(std::ptr::read(ptr)) &#125; &#125;&#125;impl&lt;T: OutputAdaptor&lt;Output = mbool&gt;&gt; MArgumentSetter&lt;mbool&gt; for T &#123; #[inline] fn try_set_arg(self, arg: &amp;MArgument) -&gt; Result&lt;()&gt; &#123; unsafe &#123; let ptr = arg.boolean; if ptr.is_null() &#123; return Err(Error::from(ErrorKind::TypeError)); &#125; std::ptr::write(ptr, self.try_into_mtype()?); &#125; Ok(()) &#125;&#125;// ……#[doc(hidden)] 表明这部分不应被用户直接使用。实际的实现代码为了避免繁琐易错的复制粘贴，是通过宏完成的（见 adaptor.rs）。最终的类型适配关系如图所示： 访问 WolframLibraryData由于 LibraryLink 的所有函数都是回调式的，各种函数的调用都免不了要访问当前的 WolframLibraryData。然而我们显然是不会希望各个函数都要带着一个 WolframLibraryData 的参数到处跑的，因此，一种直观的方式是使用一个全局静态对象，并在适时处设置它以实现别的函数对它的访问。不过这部分的设计尚未完全确定，在此也不多费口舌了。 类属性过程宏为了便利地从 Rust 函数中创建满足 LibraryLink 的接口规范的导出函数，可以通过类属性过程宏来解决这一麻烦。这部分实现在 wll-macros，并在 wll 设置了 macros feature 时会重新导出其中的宏（似乎由于 Rust 本身的限制，过程宏的重导出必须这么做）。其中setup 会将它标记的函数放到 WolframLibrary_initialize 中调用，并补上 WolframLibrary_getVersion；teardown 会将它标记的函数放到 WolframLibrary_uninitialize 中调用；export 有两种形式：当它不包含参数时，会给原本的函数名前面加上 wll_ 并按 LibraryLink 的接口规范导出函数；当它包含参数时，则按参数名作为导出函数的名称，同样按 LibraryLink 的接口规范导出。过程宏在官方资料中描述不多，但本身又非常繁琐，因此在这里就不多赘述了，推荐观看视频进行学习。这里给出前述 demo.rs 进行宏展开后的结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// cargo expand demo.rsuse wll::Result;#[inline(always)]fn init() &#123;&#125;#[no_mangle]pub extern \"C\" fn WolframLibrary_initialize( data: ::wll::sys::WolframLibraryData,) -&gt; ::wll::sys::errcode_t &#123; if let ::std::result::Result::Err(e) = ::wll::global::initialize_lib_data(data) &#123; e.to_raw_error() &#125; else &#123; init(); ::wll::sys::LIBRARY_NO_ERROR &#125;&#125;#[no_mangle]pub extern \"C\" fn WolframLibrary_getVersion() -&gt; ::wll::sys::mint &#123; ::wll::sys::WolframLibraryVersion&#125;#[inline(always)]fn uninit() &#123;&#125;#[no_mangle]pub extern \"C\" fn WolframLibrary_uninitialize(_: ::wll::sys::WolframLibraryData) &#123; uninit();&#125;#[inline]fn add_one(n: isize) -&gt; Result&lt;isize&gt; &#123; Ok(n + 1)&#125;#[no_mangle]pub unsafe extern \"C\" fn demo_I_I( lib_data: ::wll::sys::WolframLibraryData, argc: ::wll::sys::mint, args: *const ::wll::sys::MArgument, res: ::wll::sys::MArgument,) -&gt; ::wll::sys::errcode_t &#123; use ::wll::adaptor::&#123;MArgumentGetter, MArgumentSetter&#125;; let _lib_data = ::wll::global::LibDataLocalizer::new(lib_data); if argc != 1 &#123; return ::wll::sys::LIBRARY_TYPE_ERROR; &#125; let arg0 = match &lt;isize&gt;::try_get_arg(args.add(0usize).read()) &#123; ::std::result::Result::Ok(val) =&gt; val, ::std::result::Result::Err(err) =&gt; return err.to_raw_error(), &#125;; let ret = match add_one(arg0) &#123; ::std::result::Result::Ok(val) =&gt; val, ::std::result::Result::Err(err) =&gt; return err.to_raw_error(), &#125;; match ret.try_set_arg(&amp;res) &#123; ::std::result::Result::Ok(()) =&gt; ::wll::sys::LIBRARY_NO_ERROR, ::std::result::Result::Err(err) =&gt; err.to_raw_error(), &#125;&#125; 总结文章简单介绍了一下 wll 的基本设计和目前的进展。通过这个项目我也熟悉了Rust 的 bindgen、过程宏以及 trait 的各种高级用法。顺便 LibraryLink 的接口规范虽然繁琐，但也不失为一种具有灵活性和强兼容性的接口设计方案。不过 wll 还处于相当早期的开放阶段，虽然提供了简单的 Complex&lt;T&gt; 复数类型，但功能并不完整。而像 MTensor, MNumericArray 等类型对应的 Rust 高级类型和适配都尚未开始，开发完善的路途依旧漫长。Enum or Trait Object ↩︎Rust API Guidelines: C-SEALED ↩︎Traits: Defining Shared Behavior ↩︎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"},{"name":"元编程","slug":"元编程","permalink":"http://miroox.github.io/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"},{"name":"Rust","slug":"Rust","permalink":"http://miroox.github.io/blog/tags/Rust/"},{"name":"LibraryLink","slug":"LibraryLink","permalink":"http://miroox.github.io/blog/tags/LibraryLink/"}]},{"title":"预览在 GitHub 上的 Wolfram 笔记本","slug":"WolframGitHubViewer","date":"2020-07-31T13:29:21.000Z","updated":"2020-08-01T14:44:38.000Z","comments":true,"path":"2020/07/WolframGitHubViewer/","link":"","permalink":"http://miroox.github.io/blog/2020/07/WolframGitHubViewer/","excerpt":"","text":"不知道啥时候，Wolfram 官方偷偷上线了一个在线预览 GitHub 仓库中的笔记本的网页应用。有了这个，大家就不用花自己的 Cloud Credits 来部署笔记本，而只要把笔记本同步到 GitHub 上就可以从浏览器访问云上的笔记本了。以 @wjxway 大佬的黑洞吸积盘模拟为例，按表单的提示输入即可：输入 GitHub 用户名输入要预览的 GitHub 仓库名和分支，分支默认为 master得到一个Markdown格式的徽章链接代码 复制徽章代码到 Markdown 文件（通常是 README.md），在预览中点击徽章即可打开笔记本目前的坑：文件名中不能包含中文Cloud 访问可能比较慢补记：关于在 git 和 GitHub 上的笔记本的编写保存写笔记本的时候建议使用 ResourceFunction[&quot;SaveReadableNotebook&quot;] 或者 mathematica-notebook-filter 得到干净的笔记本文件，避免提交一些乱七八糟的cache到git中：小文件推荐使用 ResourceFunction[&quot;SaveReadableNotebook&quot;]，也推荐使用我的 MirooxUtils 包附带的一个面板来一键快速保存为可读笔记本。大文件，尤其是包含大量图片或者动态的文件，还是推荐使用 mathematica-notebook-filter（但要注意它还会滤掉输出单元），否则文件大小可能回膨胀地非常大，并且 ResourceFunction[&quot;SaveReadableNotebook&quot;] 对动态的处理存在一定Bug，可能导致文件损坏。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"},{"name":"GitHub","slug":"GitHub","permalink":"http://miroox.github.io/blog/tags/GitHub/"}]},{"title":"一个适用于 Wolfram 语言的 GitHub Action","slug":"GitHubActionForWolframLanguage","date":"2020-01-30T14:23:21.000Z","updated":"2020-08-28T12:01:39.000Z","comments":true,"path":"2020/01/GitHubActionForWolframLanguage/","link":"","permalink":"http://miroox.github.io/blog/2020/01/GitHubActionForWolframLanguage/","excerpt":"去年 GitHub 推出了 Actions，以提供内置的持续集成能力。同样是在去年，Wolfram Research 也推出了免费的开发者 Wolfram 引擎，让我们有机会免费运行 Wolfram 语言代码。那么，两件快乐事情重合在一起。而这两份快乐，又给我带来多的快乐。得到的……没错，就是我们期待已久的对 Wolfram 语言程序的持续集成。","text":"去年 GitHub 推出了 Actions，以提供内置的持续集成能力。同样是在去年，Wolfram Research 也推出了免费的开发者 Wolfram 引擎，让我们有机会免费运行 Wolfram 语言代码。那么，两件快乐事情重合在一起。而这两份快乐，又给我带来多的快乐。得到的……没错，就是我们期待已久的对 Wolfram 语言程序的持续集成。 配置经历（趟过的坑）当然，天下代码一大抄，照猫画虎首先也需要一个参考对象。这里参照的是 xu-cheng/latex-action，因为这是一个基于 Docker 容器的 Actions。而现成的 Wolfram 引擎的 Docker 配置早已经出现的 DockerHub 上了，直接拿来用就可以了。由于缺乏经验，还是先按照 Creating a Docker container action 的文档过了一遍基本的流程，了解了一下 Docker 的基本用法。基本思路是继承 arnoudbuzing/wolframengine 的 Docker 容器，然后通过入口点脚本 entrypoint.sh 认证激活 Wolfram 引擎，再运行输入的 Wolfram 脚本。在这里遇到的最大的困难大概还是认证激活。首先，认证需要对应的 Wolfram ID 账号密码登录。显然，账号密码不能要用户直接写在 Action 的配置里。GitHub 提供了 Secrets 机制来避免加密内容直接出现在配置文件中，但如果直接通过参数将账号密码传递给 Docker，仍不能避免让密码内容在日志中以明文出现。参考了 sliteteam/github-action-git-crypt-unlock 后，尝试得知环境变量在传递过程中不会在日志中直接输出其内容。因此，账号密码在使用时都应以环境变量的方式传递。另一方面，Wolfram 引擎通常的激活流程是初次启动时手动在 prompt 下依序键入账号密码，文档里并没有提供利用 wolframscript 自动化这一激活流程的办法，还是在我几经失败踩坑后才探索出一种合适的办法：12/usr/bin/wolframscript -authenticate $WOLFRAM_ID $WOLFRAM_PASS/usr/bin/wolframscript -activate解决了认证激活的问题，剩下的基本就也没什么难度了。对参数缺失以及不合法的报错处理直接按 xu-cheng/latex-action 照搬。其它配置也基本大同小异。最后，将 Action 发布到了市场上，见 GitHub action for Wolfram language。有什么用我也不清楚，大概可以方便推广？ 食用方法使用时将下面的内容复制到 .github/workflow/main.yml （或者其它名字的）配置文件里1234567- name: Run Wolfram script uses: miRoox/wolfram-action@master with: file: script.wl env: WOLFRAM_ID: $&#123;&#123; secrets.WolframID &#125;&#125; WOLFRAM_PASS: $&#123;&#123; secrets.WolframPW &#125;&#125;这里，script.wl 即你要运行的 Wolfram 语言脚本；secrets.WolframID 和 secrets.WolframPW 分别对应你的 Wolfram 账号 ID 和密码，你需要在仓库中建立对应名称的 Secrets，操作流程见 Creating and using encrypted secrets。下面是一个完整的配置文件的例子：123456789101112131415on: [push]jobs: run_wolfram: name: Run Wolfram language code runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v1 - name: Run Wolfram script uses: miRoox/wolfram-action@master with: file: script.wl env: WOLFRAM_ID: $&#123;&#123; secrets.WolframID &#125;&#125; WOLFRAM_PASS: $&#123;&#123; secrets.WolframPW &#125;&#125; 附录关于 Wolfram 引擎的许可证：根据 FAQ 里的 “我可以在开源项目中使用免费引擎吗？”：您可以使用免费引擎开发项目，以及演示和测试。但是，免费引擎许可证不允许终端用户使用，除非此用途用于进一步开发。对于终端用户使用，用户必须拥有 Wolfram 引擎的单独许可证。如果您拥有 Wolfram 产品（如 Wolfram|One 或 Mathematica），或者您所在的组织拥有 Wolfram 站点许可证，则您可能已拥有相应的许可证。开源项目可以申请特殊的 Wolfram 引擎许可证，允许终端用户自由使用免费引擎作为他们项目用途的一部分。由于持续集成服务本身是“用于进一步开发”的用途，而且终端用户使用时也确实不能免除 Wolfram 引擎的单独许可证，我认为在许可上应该时没有什么风险的。关于许可证的使用次数。经测试，对于同一个 Docker image，重复使用是不会消耗许可证的。而在进行了新 build 的 image 中使用才会消耗许可证。这也是这个 action 相对于直接在 workflow 中使用 wget 下载 Wolfram Engine 再激活的一个优势。2020.08.28 补记：最近发现 Wolfram Engine 的许可证好像可以随便用了，这个项目的意义顿时变得微妙了起来。现在在 GitHub Action 中可以直接在 Ubuntu 环境下运行：123wget https://account.wolfram.com/download/public/wolfram-engine/desktop/LINUXsudo bash LINUX -- -auto -verboserm LINUX安装 Wolfram Engine ，然后采用前述同样的命令激活。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"},{"name":"GitHub","slug":"GitHub","permalink":"http://miroox.github.io/blog/tags/GitHub/"},{"name":"持续集成","slug":"持续集成","permalink":"http://miroox.github.io/blog/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"}]},{"title":"利用 GitHub Actions 自动化构建和发布 Qt 程序的一点经验","slug":"AboutGitHubActionsCIQt","date":"2019-12-10T14:24:54.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2019/12/AboutGitHubActionsCIQt/","link":"","permalink":"http://miroox.github.io/blog/2019/12/AboutGitHubActionsCIQt/","excerpt":"前一阵子 GitHub 正式发布了 Actions 功能来提供内置的持续集成和持续发布。而我正好最近在利用 Qt 写数字图像处理的作业，就想利用这个机会尝试一下基于 GitHub Actions 的持续集成。","text":"前一阵子 GitHub 正式发布了 Actions 功能来提供内置的持续集成和持续发布。而我正好最近在利用 Qt 写数字图像处理的作业，就想利用这个机会尝试一下基于 GitHub Actions 的持续集成。当然，有问题首先是找轮子。很快我就找到了 jaredtao/HelloActions-Qt，以及相关的几篇博客文章[1] [2]。照猫画虎很快就把各个平台下的自动构建弄成了。但那篇关于自动发行的文章[2:1]对多配置下 create-release 重复执行导致失败这一问题的解决方案不太令我满意，总觉得太繁琐了，而且我对其中所用的 PowerShell 也不熟。不过这个问题显然不是特殊情况，想必也曾有人就此提出了问题，而也许已经有别人回答了更好的解决方案也不一定。果不其然，早就有人在 create-release 的仓库下的 issues 中提出过这个问题，并且这个 issue 尚未关闭，也就是并没有一个非常令人满意的解答。不过，其中有一个回答[3]给我一点启发，它将使用多种配置的发布任务与创建 release 的任务分开，而通过 upload-artifact 和 download-artifact 来传递 release URL。另一个关联的仓库也有人给出了类似的思路[4]：123456789build(mac) build(linux) build(win) │ │ │ └──────────────────┼─────────────────┘ │ create_release() │ ┌──────────────────┼─────────────────┐ │ │ │upload(mac) upload(linux) upload(win)不过这种任务结构让构建和上传两个阶段的文件对应变得麻烦起来。受此启发，我想到了另一种可能——create_release()真的一定要在build(...)完成之后才能进行吗？因为我们需要创建 release 的时候一定是在发布 tag 的时候，这时我们通常已经在 commit 时检验过一遍是否通过构建/测试了，因此不妨将create_release()提前，于是有1234567 create_release()* │ ┌──────────────────┼─────────────────┐ │ │ │ build(mac) build(linux) build(win) &amp; &amp; &amp;upload(mac)* upload(linux)* upload(win)**表示只在发布 tag 的时候才会进行这个步骤。这里将build(...)和upload(...)两个阶段合在同一个job中，便于传递文件。最终配置如 .github/workflows/build.yml 所示。Qt使用github-Actions自动化编译 ↩︎Qt使用github-Actions自动化发行 ↩︎ ↩︎How to prevent creating multiple releases when using a build matrix? ↩︎Support matrix build ↩︎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://miroox.github.io/blog/tags/GitHub/"},{"name":"Qt","slug":"Qt","permalink":"http://miroox.github.io/blog/tags/Qt/"},{"name":"持续集成","slug":"持续集成","permalink":"http://miroox.github.io/blog/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"}]},{"title":"为什么我们需要术语——兼谈科普的危害性","slug":"TerminologyAndPopularScience","date":"2019-11-05T13:03:42.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2019/11/TerminologyAndPopularScience/","link":"","permalink":"http://miroox.github.io/blog/2019/11/TerminologyAndPopularScience/","excerpt":"写下这篇文章的起源是在知乎上看到的一个回答[1]：很简单，就是硬抬杠。举个例子，我说偶数跟正整数一样多，你就说怎么可能，正整数包含奇数和偶数，所以肯定正整数多。我解释说偶数跟正整数存在一个一一映射，并且都含有无穷多元素，所以一样多。你就说我听不懂什么一一映射，我只知道我是你的两倍，所以肯定比你多。那我解释，1对应2，2对应4，3对应6，一直这样下去，每个正整数都对应一个偶数。他就是不同意，说你说话就在放屁，我给你一百块，你给我两百块，一直这样我们看看最后谁的钱多？我说这在有限的情况下是对的，但是无穷的情况下就不一定了。你就说无穷不就是特别大的数嘛，那我大一你倍不是大你更多？我说wdnmd吧，你就说你怎么骂人呢？在这个回答里，作者似乎把对于无法将无穷集合的等势理解成“一样多”的普通人思维当作抬杠。但这件事就真的只是抬杠这么肤浅吗？","text":"写下这篇文章的起源是在知乎上看到的一个回答[1]：很简单，就是硬抬杠。举个例子，我说偶数跟正整数一样多，你就说怎么可能，正整数包含奇数和偶数，所以肯定正整数多。我解释说偶数跟正整数存在一个一一映射，并且都含有无穷多元素，所以一样多。你就说我听不懂什么一一映射，我只知道我是你的两倍，所以肯定比你多。那我解释，1对应2，2对应4，3对应6，一直这样下去，每个正整数都对应一个偶数。他就是不同意，说你说话就在放屁，我给你一百块，你给我两百块，一直这样我们看看最后谁的钱多？我说这在有限的情况下是对的，但是无穷的情况下就不一定了。你就说无穷不就是特别大的数嘛，那我大一你倍不是大你更多？我说wdnmd吧，你就说你怎么骂人呢？在这个回答里，作者似乎把对于无法将无穷集合的等势理解成“一样多”的普通人思维当作抬杠。但这件事就真的只是抬杠这么肤浅吗？需要明确的是，“一样多”是自然语言的提法，不是一个严格的数学术语。基于基数的比较方式可以在有限的时候和我们平时说的一样多是一致的，因此我们将其推广到无穷意义下的一样多。但这个对应不是唯一的，我们可以构造另一个比较方式依然满足有限意义的“一样多”，却在无限集的比较晚得到不同的结果。比如：不妨定义区间 [−a,a][-a,a][−a,a] 与集合 AAA 的交集的元素个数为 NA(a)N_A(a)NA​(a) ，然后定义集合 AAA 和集合 BBB 的“元素比值”为p(A,B)=lim⁡a→∞NA(a)NB(a)p(A,B)=\\lim_{a\\to\\infty}\\frac{N_A(a)}{N_B(a)}p(A,B)=a→∞lim​NB​(a)NA​(a)​当“元素比值” p(A,B)=1p(A,B)=1p(A,B)=1 时，则称集合 AAA 和 BBB 的元素“一样多”。显然，这个定义在集合有限时和我们的认知依然是一致的，因此也可以作为“一样多”的一个推广。但如果拿来比较整数和偶数，结果则不会是“一样多”，而前者对后者的“元素比值”为2，似乎更符合我们的直观认识。当然，上面这个定义显然不会是我们的数学所想要的。因为这个定义过于平凡了，以至于即使在面对像有理数集这样的可数集时也会无法定义，这与数学所追求最广泛意义上的一致性是相违背的。因而，“势”依然是对任意集合的大小进行度量的最佳方式，也是我们在数学中普遍采用的。但这一概念如果反过来作为日常用语中的“一样多”的替代，则无疑是术语的滥觞，只会令人更加迷惑，无益于辨清问题的边界。也许一个来自数学自身的例子更能展现这种概念拓展的不唯一性：维数——我们有线性空间的维数（自由度）、拓扑维数乃至各式各样的分形维数，它们最初都来自我们日常对空间方位的直观认知。但它们都是在各自领域中抽象出来的概念，并不能简单地断言谁是一般意义上最佳的定义。不过，概念的推广与取代在学术界内部确实广为存在，每一次取代本身可以认为是对概念更深刻的理解。虽说如此，明辨问题的边界和语境对业内人士同样重要，至少应该采取明确的上下文或者精准唯一的术语来进行描述。如果说概念的泛化推广是抽象和发散思维的体现，那么划定专有术语和明晰边界则是具体和确定性的追求。这两点对于研究者而言都具有程度相当的重要性。如何在两者间取得平衡，对科研人员也并非易事，更遑论科普读物和它们的读者了。能把握住这当中的微妙的，大概《物理学咬文嚼字》尚且能算一个比较好的例子吧。针对科普作品，19世纪伟大的物理学家麦克斯韦曾写下这样的忠告[2]：In the popular treatise, whatever shreds of the science are allowed to appear, are exhibited in an exceedingly diffuse and attenuated form, apparently with the hope that the mental faculties of the reader, though they would reject any stronger food, may insensibly become saturated with scientific phraseology, provided it is diluted with a sufncient quantity of more familiar language. In this way, by simple reading, the student may become possessed of the phrases of the science without having been put to the trouble of thinking a single thought about it. The loss implied in such an acquisition can be estimated only by those who have been compelled to unlearn a science that they might at length begin to learn it.The technical treatises do less harm, for no one ever reads them except under compulsion. From the establishment of the general equations to the end of the book, every page is full of symbols with indices and suffixes, so that there is not a paragraph of plain English on which the eye may rest.确实，科普读物对专业术语的稀释一定程度上也是对读者深入思维能力的一种伤害。进一步地，这种对术语的浅薄化，对业已进入专业行列的“原读者”乃至科普作者自身的辨析能力也会造成不经意的伤害；而这种伤害又反过来进一步拉大了科学概念与一般人之间的距离，令人以为这些被“通俗化”所粉饰的概念就一定能为大众所理解，构成现代科学版的“何不食肉糜”，不得不令人扼腕。当然，科普工作也不尽然都是坏的。哪怕是稀释过的概念知识，倘若能抓住精要，不会因为注水过多而浅尝辄止，那么从科普中浸润的少量知识反而更能让人甘之如饴，激发探索深入的兴趣。只是，倘若能在科普中就更好的明辨当中的概念和术语，大概会减少那些因模糊的粉饰而对长远的研究道路所造成的伤害吧。如何激怒一位数学爱好者？ - 孙泰英的回答 - 知乎 ↩︎MAXWELL J C. Tait’s “Thermodynamics”[J]. Nature, 1878, 17(431): 257–259. ↩︎","categories":[{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miroox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://miroox.github.io/blog/tags/%E6%9D%82%E8%B0%88/"},{"name":"科普","slug":"科普","permalink":"http://miroox.github.io/blog/tags/%E7%A7%91%E6%99%AE/"}]},{"title":"如何提交函数到 Wolfram Function Repository","slug":"SubmitFunctionToWFR","date":"2019-10-12T07:23:32.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2019/10/SubmitFunctionToWFR/","link":"","permalink":"http://miroox.github.io/blog/2019/10/SubmitFunctionToWFR/","excerpt":"首先，你需要一个 Wolfram 账户。","text":"首先，你需要一个 Wolfram 账户。然后，你需要申请一个 Publisher ID，这点在许多讲述提交函数到WFR的文章中都没提到。大致的申请流程可以在参考文档里找到。然后在 Mathematica 中新建一个函数知识库项。按风格指南编写函数代码和文档。提交前要检查 Mathematica 有没有登录到你的 Wolfram 账户，可以根据 $WolframID 的值确认。而且应该将 $PublisherID 的值设置为你申请到的 Publisher ID。当然，提交之前还应该用菜单中的“Check”按钮检查格式无误后再提交。最后点击“Submit to Repository”，接下来就等邮件吧。无论 review 有没有通过一般都会发邮件进行通知。没有通过的话往往还会附上 review comments 指导你改进，并且可以完善后再提交更新。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"}]},{"title":"尝试用TiddlyWiki搭建个人维基知识库","slug":"PersonalWiki","date":"2019-10-10T12:44:23.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2019/10/PersonalWiki/","link":"","permalink":"http://miroox.github.io/blog/2019/10/PersonalWiki/","excerpt":"搭建一个个人维基用来整理知识的想法早已有之，但具体该使用什么方案却迟迟没能定下来。在最初的想法里，我希望满足下面的几项需求：内容与表现分离自动化构建可以使用自己定制的模板词条的分类灵活，以适应知识体系的逐渐完善方便建立知识点（词条）间的联系需要用笔记时能快速提取LaTeX\\LaTeXLATE​X 公式输入代码块语法高亮","text":"搭建一个个人维基用来整理知识的想法早已有之，但具体该使用什么方案却迟迟没能定下来。在最初的想法里，我希望满足下面的几项需求：内容与表现分离自动化构建可以使用自己定制的模板词条的分类灵活，以适应知识体系的逐渐完善方便建立知识点（词条）间的联系需要用笔记时能快速提取LaTeX\\LaTeXLATE​X 公式输入代码块语法高亮作为参考，见过别人用 Dokuwiki 的，也有直接拿 Hexo 的 Wikitte 主题搭建的，等等。当然，我自己也做过一些尝试，比如 Zim Wiki ，不过这个太简陋了，完全无法满足我的需求；甚至受 小时物理百科 的影响，尝试过用 LaTeX\\LaTeXLATE​X 构建维基，但 LaTeX\\LaTeXLATE​X 对于我的需求而言又稍显复杂了，而且大量交叉引用在PDF中也并不方便阅读。最后在一番比较和取舍之下选择了TiddlyWiki[1]。TiddlyWiki，按官方说法是「一款非线性个人 Web 笔记本」。相比其他笔记和 Wiki 系统，其最大的特点之一是程序本体和数据全部都在一个 html 文件内，这意味着组织和阅读多个词条可以在同一个页面内直接完成，内容的关联更加直接，方便互相比照。同时，还有着非常强大的条目管理功能和插件系统，可扩展性和可定制性都很强。TiddlyWiki 的优点还有很多[2]，这里就不多赘述了。就我而言，更想简单说一下 TiddlyWiki 是如何满足前面提到的几项需求的：内容与表现分离：这一项近乎是一种哲学理念，实践起来是否须要完全符合还是看具体情况。典型地，WikiText 就提供了很多特定语义的语法元素，还有宏、模板嵌入等各种自定义工具。当然，经典地 HTML-CSS-JS 结构也是可以使用的。自动化构建：通过使用 Node.js 上的 TiddlyWiki 服务可以在本地同步保存修改；用 Git 和 Travis CI 实现向 Github Pages 自动部署。可以使用自己定制的模板：这一项其实是“内容与表现分离”的具体实践方法之一。WikiText 支持模板条目和宏。词条的分类灵活，以适应知识体系的逐渐完善：TiddlyWiki 是基于标签分类的，一个词条可以分到多个标签下，这一点比许多按树状层级分类的方案要灵活得多。方便建立知识点（词条）间的联系：词条链接和词条嵌入。需要用笔记时能快速提取：能自动部署到网页上，有网就能看；还有灵活的搜索语法。LaTeX公式输入：KaTeX插件：支持的命令较少，不过是官方提供的，安装很容易。MathJax插件：第三方提供的，比较老了，好像和新版不太兼容，需要折腾（反正我没能折腾成功）。代码块语法高亮Highlight.js插件：这也是官方提供的。除此之外，TiddlyWiki 还有一大优点是简单，几乎所有操作都可以在网页上完成，基本不用到处配置。这对于我这种对web技术基本一无所知的人来说是一个极大的优势。不过也因为我对web技术的不了解，导致很大的功夫都花在自动部署的配置上了，最终也只是是照猫画虎。其间主要参考了 alexashley 的个人Wiki源码[3]、JavaScript 标准参考教程（alpha）[4]、《Blog自动部署实践: Hugo + Travis CI -&gt; GitHub Pages》[5]等资料。最终弄出来的成品在：https://miroox.github.io/wiki/参考资料：TiddlyWiki中文网站 ↩︎使用 TiddlyWiki 打造轻便个人 Wiki 知识库 ↩︎alexashley 的个人Wiki源码 ↩︎package.json文件 - JavaScript 标准参考教程（alpha） ↩︎Blog自动部署实践: Hugo + Travis CI -&gt; GitHub Pages ↩︎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Wiki","slug":"Wiki","permalink":"http://miroox.github.io/blog/tags/Wiki/"},{"name":"Web","slug":"Web","permalink":"http://miroox.github.io/blog/tags/Web/"}]},{"title":"MatrixForm赋值问题","slug":"MatrixFormProblem","date":"2019-09-19T12:27:34.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2019/09/MatrixFormProblem/","link":"","permalink":"http://miroox.github.io/blog/2019/09/MatrixFormProblem/","excerpt":"我们知道，赋值等过程中使用 MatrixForm 往往会导致后续的计算失效。比如：","text":"我们知道，赋值等过程中使用 MatrixForm 往往会导致后续的计算失效。比如：对于这个问题，最正统的解决办法当然是在赋值等计算过程中不使用 MatrixForm，而只在显示时以 MatrixForm 呈现[1]。典型的方案是在输出部分才加上 MatrixForm 包装。不过对于既有代码的问题，一个个手动修改可能略显麻烦，这时可以借助 EchoFunction 在实现类似效果的同时保持代码结构基本不变：要将既有代码调整为这种方式，只需简单的文本替换就可以实现目标。不过，本文要主要要谈的并不是这类传统解决方案，而是通过给 Mathematica 系统打上补丁来实现几乎零修改的解决方案。我们知道，MatrixForm 这类格式封装，当它位于结果的最外层时，Out 输出历史中不会对其进行储存[2]。事实上，所有在 $OutputForms 中的格式封装都具有这样的性质。受此启发，我们不妨把这个性质推广到赋值的情况上来，即这类格式封装出现在赋值运算的右侧时不会将其记录到赋值中。事实上，通过重载 Set 的定义很容易实现这一功能：123GeneralUtilities`BlockProtected[&#123;Set&#125;, Set[lhs_,(form:Alternatives@@$OutputForms)[rhs_]] := form@Set[lhs,rhs]]效果如图：参考：Q&amp;A: Compute with MatrixForm ↩︎为什么我的代码加了MatrixForm后就出问题了？ ↩︎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miroox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"}]},{"title":"基于规则的带步骤符号求导器","slug":"RuleBasedStepByStepDerivative","date":"2019-07-12T14:27:17.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2019/07/RuleBasedStepByStepDerivative/","link":"","permalink":"http://miroox.github.io/blog/2019/07/RuleBasedStepByStepDerivative/","excerpt":"我们知道，Wolfram|Alpha 有一个名为 Step-by-Step Solutions 的功能，可以显示一些数学问题求解的过程。又比如，著名的 Rubi 可以在求解积分的同时显示积分的求解步骤。实际上，这些系统背后大抵都是基于模式匹配和规则变换而实现的，因而原则上来说自己也可以实现一个。当然，就实践而言这些系统都过于复杂了，例如 Rubi 包含了超过六千条规则，其背后的原理远非三言两语可以阐明的。不过，相比于积分，微分的运算规则要简明得多，而且对规则的应用总是简单机械的，并不像积分那样可能会运用到各种技巧。因此，本文将利用 Mathematica 的模式匹配和规则实现一个带步骤符号求导器。","text":"我们知道，Wolfram|Alpha 有一个名为 Step-by-Step Solutions 的功能，可以显示一些数学问题求解的过程。又比如，著名的 Rubi 可以在求解积分的同时显示积分的求解步骤。实际上，这些系统背后大抵都是基于模式匹配和规则变换而实现的，因而原则上来说自己也可以实现一个。当然，就实践而言这些系统都过于复杂了，例如 Rubi 包含了超过六千条规则，其背后的原理远非三言两语可以阐明的。不过，相比于积分，微分的运算规则要简明得多，而且对规则的应用总是简单机械的，并不像积分那样可能会运用到各种技巧。因此，本文将利用 Mathematica 的模式匹配和规则实现一个带步骤符号求导器。 求导规则实现的核心首先在于对求导法则的代码表示。由于 Rule-Based 也是 Wolfram 语言的基本范式，因此这些规则写起来也很直观。首先是几个基本运算规则123456baseRules=&#123; d[c_,x_]/;FreeQ[c,x]:&gt;0, d[lf_Plus,x_]:&gt;Thread[d[lf,x],Plus], d[c_*f_,x_]/;FreeQ[c,x]:&gt;c*d[f,x], d[f_*g_,x_]:&gt;d[f,x]g+d[g,x]f&#125;;这里，使用 d[f,x] 表示 dfdx\\tfrac{\\mathrm{d}f}{\\mathrm{d}x}dxdf​。上述的代码表示了常数求导法则、线性求导法则和乘法求导法则的作用规则。对于复合函数和反函数，需要一个间接的包装来表示类似 f′(g(x))f&#x27;(g(x))f′(g(x)) 的情况，这里将其表示为dfunc[f,gx]类似的形式，其中gx对应于g(x)g(x)g(x)。123456higherRules=&#123; HoldPattern@d[InverseFunction[f_][x_],x_]:&gt;1/dfunc[f,InverseFunction[f][x]], d[f_[g_],x_]/;g=!=x:&gt;dfunc[f,g]d[g,x], d[f_[g_,c_],x_]/;FreeQ[c,x]&amp;&amp;g=!=x:&gt;dfunc[f[#,c]&amp;,g]d[g,x], d[f_[c_,g_],x_]/;FreeQ[c,x]&amp;&amp;g=!=x:&gt;dfunc[f[c,#]&amp;,g]d[g,x]&#125;;需要注意的是，为了避免问题过于复杂化，这里求导的对象都只限于初等函数。因此在考虑复合函数的链导法则时实际不包含多元函数。对于可能遇到地二元初等函数，要么其中一个参数与自变量无关，本质还是一元函数，要么可以通过变形转化成一元形式。此外还有一点需要注意，在链式法则的规则中，模式条件g=!=x是必要的，否则可能陷入无限自递归的窘境。在上面的高阶（反函数、复合函数）规则中，dfunc只是徒具形式的一个表示。为了确实有效地计算这种情况，还需要引入一个替换规则。即在计算得到f′(u)f&#x27;(u)f′(u)后，再进行u→g(x)u\\to g(x)u→g(x)的变量替换。直接表达出来就比如1substRules=dfunc[f_,g_]:&gt;d[f[u],u]/.&#123;u-&gt;g&#125;;不过这种写法当遇到函数f本身蕴含名为u的参量时就可能会出现错误的结果。因而需要使用Module来引入哑元形式，即1substRules=dfunc[f_,g_]:&gt;Module[&#123;u&#125;,d[f[u],u]/.&#123;u-&gt;g&#125;];但这是错误的。因为我们希望在计算出f′(x)f&#x27;(x)f′(x)后再做变量替换。但上面的实现中，d[f[u],u]本身并不会求值，而是通过应用这些规则进行替换而得到的计算结果，从而导致替换发生在计算导数之前，那样就没有意义了。因此需要一个d的立即求值版，命名为dEval。1substRules=dfunc[f_,g_]:&gt;Module[&#123;u&#125;,dEval[f[u],u]/.&#123;u-&gt;g&#125;];关于dEval的实现，一个粗浅的想法是在完成全部规则的定义后，对输入按这些规则进行ReplaceRepeated。当然，这其中还需要一些细节，我们这里暂且按下不表，留待后面再讨论。接下来就是对具体函数的求导规则进行列举，比如123456functionRules=&#123; HoldPattern[d[IgnoringInactive[Exp[x_]],x_]]:&gt;Exp[x], HoldPattern[d[IgnoringInactive[Log[x_]],x_]]:&gt;1/x, HoldPattern[d[IgnoringInactive[Sin[x_]],x_]]:&gt;Cos[x], HoldPattern[d[IgnoringInactive[Cos[x_]],x_]]:&gt;-Sin[x]&#125;;这样一个个手动枚举也比较繁琐，因此我们不妨利用 Mathematica 既有的求导功能来生成结果123456789101112functionRules=Table[ With[&#123;f=f&#125;,HoldPattern@d[IgnoringInactive@f[x_],x_]]-&gt;D[f[x],x], &#123;f,&#123; Sqrt,CubeRoot,RealAbs, Exp,Log,Log2,Log10, Sin,Cos,Tan,Cot,Sec,Csc, ArcSin,ArcCos,ArcTan,ArcCot,ArcSec,ArcCsc, Sinh,Cosh,Tanh,Coth,Sech,Csch, ArcSinh,ArcCosh,ArcTanh,ArcCoth,ArcSech,ArcCsch &#125; &#125;]/.&#123;Rule-&gt;RuleDelayed&#125;;除了这些可以直接表示的一元函数，还有一些形式上是二元函数的一元函数情况，这里简单列举一下12345functionExtRules=&#123; HoldPattern@d[x_^a_.,x_]/;FreeQ[a,x]:&gt;a x^(a-1), HoldPattern@d[a_^x_,x_]/;FreeQ[a,x]:&gt;a^x Log[a], HoldPattern@d[IgnoringInactive@Surd[x_,n_],x_]/;FreeQ[n,x]:&gt;1/(n Surd[x,n]^(n-1))&#125;;稍微值得一提的是，由于Power的OneIdentity属性，模式x_^a_.也会直接匹配x这种情况。除此之外，还有一些二元函数可以通过变形得到上述一元函数的组合1234transferRules=&#123; HoldPattern@d[IgnoringInactive[f_^g_],x_]/;!(FreeQ[f,x]||FreeQ[g,x]):&gt;d[Inactive[Exp][Log[f]g],x], HoldPattern@d[IgnoringInactive@Log[f_,g_],x_]:&gt;d[Log[g]/Log[f],x]&#125;;这里的Inactive[Exp]是为了抑制指数函数的内置化简规则。也正是为了方面使用Inactive控制变形的方向，前面的函数求导规则的模式中都包含了IgnoringInactive。这样，一个囊括了初等函数的符号求导规则就全部完成了。最后将所有规则整合到一起12345678allRules=Flatten@&#123; transferRules, baseRules, functionRules, functionExtRules, substRules, higherRules&#125;;如果只需要进行求导计算，那么直接对输入按这些规则进行替换即可1dEval[f_,x_]:=d[f,x]//.allRules举一个简单的例子测试一下12(dEval==D)[(x^Sin[x]+3x+ArcTan[x])^2/(x^4-3Surd[x^5,3]RealAbs@Log[x]+2),x]//Through//Simplify(*Out: True*)也就是说利用这些规则已经可以实现对初等函数的求导运算了。然而，假如输入的待求导函数不只包含初等函数，那么dEval就无法完全计算，得到的结果中会包含错误的形式。诚然，我们的目标只在解决初等函数的求导，对于初等函数以外的情况无法解决也是正常的，不过从健壮性的角度考虑，这里最好再增加一个条件以避免某些可能出现的潜在问题。12345substRules=dfunc[f_,g_]:&gt;Module[&#123;u&#125;, With[&#123;df=dEval[f[u],u]&#125;, (df/.&#123;u-&gt;g&#125;)/;FreeQ[df,_d|_dfunc] ]];这里利用作用域里的条件模式来保证遇到dEval无法解决的情况时会保持既有的dfunc形式不变。可以试试下面的代码测试一下效果1dEval[Erf[Sin[x]]^2,x] 步骤回显然后是对计算步骤的输出显示。我们希望将替换的每一步都显示出来，因此不能直接使用//.，而应该使用NestWhile之类的方式对每次替换获得更精确的控制。在输出显示上，用CellPrint比较方便，也比单纯的Print好控制格式。首先，对于输出步骤的每个单元，我们希望前面有一个=标记，就像Echo产生的单元前的&gt;&gt;标志符一样。这一点可以利用CellDingbat实现：12345echoStep[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[removeLabels@expr,TraditionalForm],TraditionalForm]],\"Print\", CellDingbat-&gt;Cell[\"=\",\"EchoLabel\"]]; expr)然后，与之类似地，还需要一个函数输出显示最初地状态作为等式的起点。需要注意的是，为了比较好地对齐，需要对两者使用不同的边距：1234567891011echoStep0[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[expr,TraditionalForm],TraditionalForm]],\"Print\", CellMargins-&gt;&#123;&#123;Inherited, Inherited&#125;,&#123;Inherited,Inherited&#125;&#125;]; expr)echoStep[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[expr,TraditionalForm],TraditionalForm]],\"Print\", CellDingbat-&gt;Cell[\"=\",\"EchoLabel\"], CellMargins-&gt;&#123;&#123;Inherited+20, Inherited&#125;,&#123;Inherited,Inherited&#125;&#125;]; expr)进一步地，考虑到复合函数求导时需要转入对其它函数求导的过程，这将打断正在进行的求导步骤间的顺叙关系，从逻辑上进入更深的层级。为了表现这种层级关系，这里同样通过调整边距实现。引入一个层级标志量$dDepth：每当计算dEval时都增加这一标志量，结束时就将其还原；同时利用$dDepth控制边距以实现对边距的适应调整。123456789101112$dDepth=0;echoStep0[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[expr,TraditionalForm],TraditionalForm]],\"Print\", CellMargins-&gt;&#123;&#123;Inherited+20($dDepth-1), Inherited&#125;,&#123;Inherited,Inherited&#125;&#125;]; expr)echoStep[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[expr,TraditionalForm],TraditionalForm]],\"Print\", CellDingbat-&gt;Cell[\"=\",\"EchoLabel\"], CellMargins-&gt;&#123;&#123;Inherited+20$dDepth, Inherited&#125;,&#123;Inherited,Inherited&#125;&#125;]; expr)123dEval[f_,x_]:=Block[&#123;$dDepth=$dDepth+1&#125;,dEvalR[f,x]]dEvalR[f_,x_]:=NestWhile[echoStep@*ReplaceAll[allRules],echoStep0[d[f,x]],!FreeQ[#2,_d|_dfunc]&amp;&amp;UnsameQ[##]&amp;,2]stepD[f_,x_]:=With[&#123;eval=dEval[f,x]&#125;,eval/;FreeQ[eval,_d|_dfunc]]这里将具体的求导运算过程委托到dEvalR函数上，利用以是否存在未完成的求导形式为基本判据，同时辅以不变性作为无法完成时的终止条件。再把stepD作为封装的外部接口，通过条件模式限制，在失败时保持输入形式，避免内部dfunc等内部符号暴露到输出中。测试一下 润色外观可以看到步骤显示中的输出形式很难看。为了增加步骤的可读性，我们可以通过自定义显示格式来润色外观。考虑我们本身使用的代码结构，将公式输出为Leibniz符号的形式比较方便。1234567891011d/:MakeBoxes[d[f_,x_],TraditionalForm]:=Module[&#123;boxes&#125;, boxes=MakeBoxes[f, TraditionalForm]; If[Precedence[Plus]&gt;=Precedence[boxes,TraditionalForm],boxes=RowBox[&#123;\"(\", boxes, \")\"&#125;]]; RowBox[&#123;FractionBox[\"\\[DifferentialD]\", RowBox[&#123;\"\\[DifferentialD]\", MakeBoxes[x, TraditionalForm]&#125;]], boxes&#125;]]dfunc/:MakeBoxes[dfunc[f_, g_], TraditionalForm]:=Module[&#123;fboxes, gboxes&#125;, fboxes=ToBoxes[f[g], TraditionalForm]; gboxes=ToBoxes[g, TraditionalForm]; If[Precedence[Plus]&gt;=Precedence[fboxes, TraditionalForm],fboxes=RowBox[&#123;\"(\", fboxes, \")\"&#125;]]; If[Precedence[Plus]&gt;=Precedence[gboxes, TraditionalForm],gboxes=RowBox[&#123;\"(\", gboxes, \")\"&#125;]]; FractionBox[RowBox[&#123;\"\\[DifferentialD]\", fboxes&#125;], RowBox[&#123;\"\\[DifferentialD]\", gboxes&#125;]]]然后对于被Module局域化符号的显示，像u$nnn这样的形式显然不太好看，在这里也可以给出一个美化模板，它将这类符号的输出形式显示为首字母1makeXForm[sym_Symbol]:=sym/:MakeBoxes[sym,TraditionalForm]=ToBoxes[Symbol[StringPart[SymbolName[sym],1]],TraditionalForm]再用在替换规则中123456substRules=dfunc[f_,g_]:&gt;Module[&#123;u&#125;, makeXForm[u]; With[&#123;df=dEval[f[u],u]&#125;, (df/.&#123;u-&gt;g&#125;)/;FreeQ[df,_d|_dfunc] ]];得到的结果就更接近于数学中的写法了 标注步骤最后，我们还希望给每一步中所使用的特殊规则标注名称，方便理解各个步骤到底做了什么。比如 “乘法法则” “链式法则” 这样的注解。我们首先将这些注解都标记在求导的规则中12345678910111213baseRules=&#123; d[c_,x_]/;FreeQ[c,x]:&gt;dLabeled[0,\"Constant Rule\"], d[lf_Plus,x_]:&gt;dLabeled[Thread[d[lf,x],Plus],\"Linearity Rule\"], d[c_*f_,x_]/;FreeQ[c,x]:&gt;dLabeled[c*d[f,x],\"Linearity Rule\"], d[f_*g_,x_]:&gt;dLabeled[d[f,x]g+d[g,x]f,\"Product Rule\"]&#125;;higherRules=&#123; HoldPattern@d[InverseFunction[f_][x_],x_]:&gt;dLabeled[1/dfunc[f,InverseFunction[f][x]],\"Inverse Function Rule\"], d[f_[g_],x_]/;g=!=x:&gt;dLabeled[dfunc[f,g]d[g,x],\"Chain Rule\"], d[f_[g_,c_],x_]/;FreeQ[c,x]&amp;&amp;g=!=x:&gt;dLabeled[dfunc[f[#,c]&amp;,g]d[g,x],\"Chain Rule\"], d[f_[c_,g_],x_]/;FreeQ[c,x]&amp;&amp;g=!=x:&gt;dLabeled[dfunc[f[c,#]&amp;,g]d[g,x],\"Chain Rule\"]&#125;;还有链式法则使用时，替换后的变元原本指代的是什么也应该标记出来，以方便阅读和理解。1234567substRules=dfunc[f_,g_]:&gt;Module[&#123;u&#125;, makeXForm[u]; With[ &#123;df=dEval[dLabeled[f[u],Row@&#123;\"where \",TraditionalForm[u==g]&#125;],u]&#125;, (df/.&#123;u-&gt;g&#125;)/;FreeQ[df,_d|_dfunc] ]];有了规则中的标记，我们就需要能够从表达式里将标记都提取出来的方法。12345getLabels[expr_]:=With[ &#123;lbs=DeleteDuplicates@Cases[expr,dLabeled[_,lb_]:&gt;lb,&#123;0,Infinity&#125;]&#125;, Row@Flatten@&#123;\"(\",Riffle[lbs,\"; \"],\")\"&#125;/;lbs=!=&#123;&#125;]getLabels[_]=\"\";注意一步计算可以会运用多个规则，输出应该为分割得到的一组。同时，对于重复项最好也应该删除。而这些dLabeled标记形式本身不应出现在求导的过程中，所以应该在每步计算完成后移除1removeLabels[expr_]:=expr/.&#123;dLabeled[e_,_]:&gt;e&#125;然后在输出时，注解通过CellFrameLabels显示在每个单元的右侧。12345678910111213echoStep0[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[removeLabels@expr,TraditionalForm],TraditionalForm]],\"Print\", CellMargins-&gt;&#123;&#123;Inherited+20($dDepth-1), Inherited&#125;,&#123;Inherited,Inherited&#125;&#125;, CellFrameLabels-&gt;&#123;&#123;None,Cell[BoxData@ToBoxes@getLabels[expr],\"MessageText\"]&#125;,&#123;None,None&#125;&#125;]; expr)echoStep[expr_]:=( CellPrint@Cell[BoxData[FormBox[ToBoxes[removeLabels@expr,TraditionalForm],TraditionalForm]],\"Print\", CellDingbat-&gt;Cell[\"=\",\"EchoLabel\"], CellMargins-&gt;&#123;&#123;Inherited+20$dDepth, Inherited&#125;,&#123;Inherited,Inherited&#125;&#125;, CellFrameLabels-&gt;&#123;&#123;None,Cell[BoxData@ToBoxes@getLabels[expr],\"MessageText\"]&#125;,&#123;None,None&#125;&#125;]; expr)最后将这些过程添加到计算的每一步中12345dEvalR[f_,x_]:=NestWhile[ removeLabels@*echoStep@*ReplaceAll[allRules], removeLabels@echoStep0[d[f,x]], !FreeQ[#2,_d|_dfunc]&amp;&amp;UnsameQ[##]&amp;,2]就大功告成了。简单测试一下 小结最终整理得到的完整代码放在 Github 上。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"},{"name":"符号计算","slug":"符号计算","permalink":"http://miroox.github.io/blog/tags/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/"}]},{"title":"关于LaTeX插入矢量图的格式问题","slug":"FormatOfVectorInLaTeX","date":"2019-07-09T06:51:22.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2019/07/FormatOfVectorInLaTeX/","link":"","permalink":"http://miroox.github.io/blog/2019/07/FormatOfVectorInLaTeX/","excerpt":"","text":"简单来说，外部插入矢量图图尽量使用 PDF 格式，以避免生成时的转换。只要输出介质为pdf，那么使用PSTricks和eps插图都是陋习。如果输出介质为pdf，那么所有eps都需要转换为pdf后插入。之所以需要转换，是因为pdfTeX/LuaTeX不带任何PostScript解释器，所以一定要转换成pdf才能插图。而pTeX/XeTeX，则通常需要使用dvipdfmx输出pdf，在用到PostScript代码的时候，即PSTricks和eps图，都会通过管道使用GhostScript转换，这也是拖慢dvipdfmx的一个主要原因。当然，很多编辑部的期刊模板都要求是eps图，甚至是png都要求转成eps（里面其实还是点阵图）。这时候，eps文件留给他们解决，自己该用什么用什么。这都2018年了，别想不开老是用eps图。来自 为什么 用TeXstudio在 XeLaTeX下eps图片不显示, pdflatex下反而可以 ? - 李阿玲的回答 - 知乎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"http://miroox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"},{"name":"LaTeX","slug":"LaTeX","permalink":"http://miroox.github.io/blog/tags/LaTeX/"}]},{"title":"如何在Wolfram语言里造一个Wolfram语言风格的对象","slug":"WLStyleObject","date":"2019-05-06T14:27:17.000Z","updated":"2021-10-25T15:18:25.000Z","comments":true,"path":"2019/05/WLStyleObject/","link":"","permalink":"http://miroox.github.io/blog/2019/05/WLStyleObject/","excerpt":"最近在做 ComputationalOptics包 的时候为了把 LightField 实现为一个比较典型的Wolfram语言风格的对象，使用了很多undocumented方法，这里主要是做一下记录。需要注意的是，这里的“对象”不是指“面向对象”里所说的对象（虽然也有点关系），而是类似于 Entity 或者 TemporalData 这类的对象。","text":"最近在做 ComputationalOptics包 的时候为了把 LightField 实现为一个比较典型的Wolfram语言风格的对象，使用了很多undocumented方法，这里主要是做一下记录。需要注意的是，这里的“对象”不是指“面向对象”里所说的对象（虽然也有点关系），而是类似于 Entity 或者 TemporalData 这类的对象。这里就以前面提到的LightField为例说明一下如何造一个WL风格的对象。首先，分析需求，来看看预期要实现的效果：首先能看到的是LightField对象在输出时显示为一个类似于SparseArray那样的一个摘要框；然后，对象的属性可以通过函数参数的形式读写访问，而且对写入数据参数还会进行检查，这一点应该是WL风格的对象最核心的特征；最后，对象是能被认为是一个原子对象，这点实质是一种封装，可以避免直接用表达式的部分操作来访问对象内容，同样类似SparseArray。进行具体实现前，最基本的，LightField对象数据的组织结构需要确定下来。这里采用的是LightField[type_String, props_Association]的模式，主要是考虑到这种表达式结构在表达光场信息的时候能具有较好的泛化能力。上面的type用来标记光场描述的类型（比如单色平面复振幅），而props则是描述光场所需的具体属性，以关联容器的方式组织数据内容。当然，这些含义对本文而言并不是重点，但也是对象设计和实现中最基本最重要的一步。然后是对属性的读写的实现。单纯的读操作实现起来并不困难，不过需要注意的一点是我们接下来还要将对象转化为原子的，因此不能直接将问题变为利用[[]]提取部分。我们知道，复数Complex也是原子的，它虽然不能直接对部分进行提取，但可以利用模式匹配来获得实部和虚部。基于同样的原理，读属性的核心实现长这样12345getProperty[HoldPattern@LightField[_,props_],prop_]:=Lookup[ props,prop, Message[LightField::ptprop,prop];Missing[\"NotAvailable\",prop]](obj_LightField?LightFieldQ)[prop_]:=getProperty[obj,prop]这其中，LightFieldQ是一个基于模式匹配判断输入是否为格式正确的LightField对象的函数。毕竟，如果基本格式都不正确的话，后面的模式匹配获取部分也无从谈起。而写方法在wolfram语言寻常的语法上就非常困难了，因为WL概念上并不存在引用或者指针这一类东西，符号本身几乎总是充当引用的作用，但在形如a[&quot;Wavelength&quot;] = xxx的表达式里，左侧表达式并不是一个符号，而这种形式常常会将定义关联到符号a的下值中，也就是我们常见的函数定义方式。那么怎么让计算上述形式表达式的时候把它当做一个类似于部分赋值的方式进行处理呢？一个非常自然地想法可能是对LightField赋予上值，不过很遗憾的是这种方案必然是不可行的，因为可变性意味着参数必须以保持的形式传递符号，那么在模式匹配的阶段必然没有机会接触到需要匹配的LightField，这样上值的关联就无法成立。另一种想法则是Unprotect[Set]后添加赋值规则，比如1Set[(sym_Symbol?LightFieldQ)[prop_],val_]:=...这的确不失为一种解决办法，但这一方法实在有些太笨重了。这会导致所有满足模式sym_Symbol[prop_]=val_的代码都还要用LightFieldQ检查一遍，无论sym中是否隐含着LightField。尝试下面的代码，感受一下鬼畜的效果123456gQ[_g]:=(Print[\"Ok\"];True)gQ[_]:=(Print[\"Oops\"];False)Unprotect[Set];Set[(sym_Symbol?gQ)[prop_],val_]:=(Print[Unevaluated[sym[prop]],\"=\",val])Protect[Set];Do[a[1]=1,&#123;a,&#123;1,&lt;||&gt;,g[]&#125;&#125;]（记得清除Set的附加定义）因而我们需要一个更好的解决办法，这就是Language`SetMutationHandler，它的基本用法可以参见下面的相关资料，基本上照葫芦画瓢就行。作为对照，这里给一个与前述Unprotect方法完全类似测试代码123456fQ[_f]:=(Print[\"Ok\"];True)fQ[_]:=(Print[\"Oops\"];False)SetAttributes[mutationHandler,HoldAllComplete]mutationHandler[Set[(sym_Symbol?fQ)[prop_],val_]]:=(Print[Unevaluated[sym[prop]],\"=\",val])Language`SetMutationHandler[f,mutationHandler]Do[a[1]=1,&#123;a,&#123;1,&lt;||&gt;,f[]&#125;&#125;]从输出中可以看到，只有当a的值变为f[]时，上面的匹配测试才会触发。完美符合要求。在具体实现上，还有一些细节，比如对非属性参数检查和报错，对属性值的检查其实是由LightFieldQ对改变后的临时结果整体进行的检查，还有对失败结果需要Language`MutationFallthrough传递到正常的处理流程中，以及Protect[LightField]来避免fallthrough后干扰到LightField自身的定义等等，下面摘取了其中主要的部分1234567891011121314151617181920212223SetAttributes[setProperty,HoldFirst]setProperty[sym_Symbol,prop_,val_]:=Block[ &#123;tmp=sym,tmpprops&#125;, tmpprops=getProperty[tmp,All]; If[KeyExistsQ[tmpprops,prop], tmpprops[prop]=val; tmp=Replace[tmp,HoldPattern@LightField[type_,props_]:&gt;LightField[type,tmpprops]]; If[LightFieldQ[tmp], sym=tmp;val, Message[LightField::setptvp,val,prop]; $Failed ], Message[LightField::setptp,prop]; $Failed ]]SetAttributes[mutationHandler,HoldAllComplete]mutationHandler[Set[(sym_Symbol?LightFieldQ)[prop_],val_]]:=With[ &#123;result=setProperty[sym,prop,val]&#125;, result/;!FailureQ[result]]mutationHandler[_]:=Language`MutationFallthroughLanguage`SetMutationHandler[LightField,mutationHandler]对象的原子化则是利用System`Private`SetNoEntry系列的函数，同样，下面的相关资料里有很详细的介绍。这个系列的函数在不少内部对象的实现里也可以见到，比如Dataset，我们不妨照着做一个。利用神器GeneralUtilities`PrintDefinitions获得其定义，抛开那些无关的，很容易找到下面的内容中间有一些Dataset内部使用的注册机制，抛开那些不看，无非就是System`Private`SetNoEntry原子化后，利用System`Private`NoEntryQ检查防止无限自递归，注意两处的Unevaluated也是防止无限自递归的一环。在相关资料里我们看到10.4以后又引入了几个更便利的函数，于是依葫芦画瓢就可以写成1234(obj_LightField?holdLightFieldQ)/;System`Private`HoldEntryQ[obj]:=With[ &#123;valid=System`Private`HoldSetNoEntry[obj]&#125;, valid]其中holdLightFieldQ就是个保持版的LightFieldQ，作用当然也就不言而喻了。最后是摘要框，这部分其实完全没有必要，不过说到Mathematica，优雅和颜值也是非常重要的一环，而且同样也用到了一套undocumented函数。这部分可以参考下面的相关资料，也可以用神器GeneralUtilities`PrintDefinitions来hack既有摘要框的对象，比如SparseArray其核心无非就是BoxForm`ArrangeSummaryBox，中间量的命名也非常直白，即使不看参考资料也不难猜出使用方法。这三部分都完成了以后，也算是有了一点Wolfram语言风格对象的神韵了。尽管为了这样优雅的使用对象，付出不少丑陋肮脏的实现代码，不过上面看到的一些官方的实现同样也丑陋无比，这倒也算是Wolfram语言的传统艺能了（相关资料：Language`* documentation project - Language`*Mutation*What are some useful, undocumented Mathematica functions? - System`Private`*Entry* functionsHow to create expanding summary boxes like the ones displayed for InterpolatingFunction, NearestFunction, etc.?Object Oriented Programming","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"功能模拟","slug":"功能模拟","permalink":"http://miroox.github.io/blog/tags/%E5%8A%9F%E8%83%BD%E6%A8%A1%E6%8B%9F/"},{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"},{"name":"元编程","slug":"元编程","permalink":"http://miroox.github.io/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"},{"name":"Undocumented","slug":"Undocumented","permalink":"http://miroox.github.io/blog/tags/Undocumented/"}]},{"title":"记Mathematica求导的一些坑","slug":"TrapAboutDerivativeInMma","date":"2019-05-01T08:02:10.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2019/05/TrapAboutDerivativeInMma/","link":"","permalink":"http://miroox.github.io/blog/2019/05/TrapAboutDerivativeInMma/","excerpt":"这篇文章主要是记录一下在回答贴吧上这个问题时所发现的关于Mathematica求导的一些坑。原问题虽然没有明说，但我推测问题背景应该是波特图之类的问题，具体问题如下：","text":"这篇文章主要是记录一下在回答贴吧上这个问题时所发现的关于Mathematica求导的一些坑。原问题虽然没有明说，但我推测问题背景应该是波特图之类的问题，具体问题如下：对这个函数的幅角求导，代入一个数值为什么求出了个复数值啊，实函数求导应该是实数啊。声明了一下x是实数后好像也不行。12345f[x_] := Arg[(-(x - 1)^2 + 4 (4 x^3 - 3 x^2 - x^4))/((x - 1)^2 + 4 (4 x^3 - 3 x^2 - x^4) - 4*I*(x^3 - 3 x^2 + 2 x))]f'[5](*Out: (513125/13791752+(342351 I)/3447938) Arg'[2499/2626-(765 I)/2626]*)N[(513125/13791752+(342351 I)/3447938) Arg'[2499/2626-(765 I)/2626]](*Out: 0.0109427 + 0.0292034 I*)这是程序，我觉得可能是程序表达的问题，那么该怎么去写这个程序呢？新手上路，老哥请指点这段程序恰好碰到了Mathematica在求导问题上的两个坑：Mathematica总是假设链式求导法则是有效的，但这里遇到的Arg本身是一个不可导的函数，链导法则是不成立的。这一点是一个非常常见的坑。然后Mathematica的数值导数设计的也欠合理，在遇到符号求导失效的情况时，Mathematica在计算函数导数时会利用其沿着实轴方向的变化率来近似求导（事实上Arg沿复平面不同方向的变化率通常不相等），而Arg本身总是实数，这样一来得到的Arg'[...]的结果就总是一个实数，然而前面根据链导法则乘出的那一坨又是个复数，自然得到的最终结果也是复数。针对这个问题，可以提出两种解决办法：一个很自然的想法是直接绕开Arg这个不可导的函数，即可以将通过ComplexExpand其转化为ArcTan形式，再去求导就不会有这些问题了：123f[x_]=ComplexExpand[Arg[(-(x-1)^2+4 (4 x^3-3 x^2-x^4))/((x-1)^2+4 (4 x^3-3 x^2-x^4)-4*I*(x^3-3 x^2+2 x))],TargetFunctions-&gt;&#123;Re,Im&#125;];f'[5](*Out: 1117/10504*)还可以反过来利用上述数值导数的坑来解决：因为这里就是要求f沿实轴方向的导数，所以我们不妨利用数值导数始终沿实轴发生这一特性，先从f上就避免符号计算引入错误的链导法则，然后直接让Mathematica对f进行数值求导，于是可以这么写：1234Clear[f]f[x_?NumericQ]:=Arg[(-(x-1)^2+4 (4 x^3-3 x^2-x^4))/((x-1)^2+4 (4 x^3-3 x^2-x^4)-4*I*(x^3-3 x^2+2 x))]f'[5.](*Out: 0.10634*)如果只需要近似的数值值得话，同样可以解决问题。相关链接：来个老哥抬一手~Why does Arg’[1. + I] return -0.5?","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miroox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"}]},{"title":"Mathematica写作自动化技巧","slug":"MmaAutoLiterature","date":"2019-04-07T14:45:31.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2019/04/MmaAutoLiterature/","link":"","permalink":"http://miroox.github.io/blog/2019/04/MmaAutoLiterature/","excerpt":"在使用Mathematica的笔记本的过程中，我们常常希望将它的代码和文档功能结合起来，例如自动将符号计算的公式、图形以文档的书写习惯展示出来，同时隐藏生成代码，使文档显示自然协调。","text":"在使用Mathematica的笔记本的过程中，我们常常希望将它的代码和文档功能结合起来，例如自动将符号计算的公式、图形以文档的书写习惯展示出来，同时隐藏生成代码，使文档显示自然协调。为了达到这一目的，首先需要的是将输入自动隐藏。我们知道，即使在自然状态下，双击输出单元的单元括号]即可隐藏输入单元。这一操作实际相当于选中输出单元后执行了前端令牌&quot;SelectionCloseUnselectedCells&quot;，因此，可以将其写作程序代码12SelectionMove[EvaluationNotebook[],All,GeneratedCell];FrontEndTokenExecute[\"SelectionCloseUnselectedCells\"];在输入单元最后加入上述代码即可在执行后自动折叠隐藏输入单元。不过，当我们需要展示公式时，我们往往希望使用DisplayFormula或者DisplayFormulaNumbered等公式样式。但直接使用CellPrint以此样式输出的话，则因为输入单元与输出的公式单元不会自动编组而无法通过上述方式折叠。所幸单元也支持应用多个样式，将公式样式与Output样式同时应用即可解决。例如：123CellPrint[ExpressionCell[D[x^2,x],\"Output\",\"DisplayFormulaNumbered\"]];SelectionMove[EvaluationNotebook[],All,GeneratedCell];FrontEndTokenExecute[\"SelectionCloseUnselectedCells\"];我们也可以将这些功能都整合进样式表中，在CellEpilog中添加折叠单元代码，在GeneratedCellStyles中改变输出单元的样式。例如，我们可以通过在样式表中添加如下内容来自定义一个FormulaGenerator样式123456Cell[StyleData[\"FormulaGenerator\", StyleDefinitions -&gt; StyleData[\"Input\"]], CellEpilog:&gt;(SelectionMove[ EvaluationNotebook[], All, GeneratedCell]; FrontEndTokenExecute[\"SelectionCloseUnselectedCells\"]), GeneratedCellStyles-&gt;&#123;\"Output\"-&gt;&#123;\"Output\", \"DisplayFormulaNumbered\"&#125;&#125;, MenuSortingValue-&gt;10000]这样，使用FormulaGenerator样式的输入单元在计算后就会生成一个带标号的公式单元并自动隐藏起来。参见：隐藏笔记本的输入How to Keep Input Cells Hidden After Evaluating NotebookHow to set the output be generated in a cell different from “Output”","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"},{"name":"文学编程","slug":"文学编程","permalink":"http://miroox.github.io/blog/tags/%E6%96%87%E5%AD%A6%E7%BC%96%E7%A8%8B/"}]},{"title":"Mathematica通用工具包参考（一）：宏","slug":"WLGeneralUtilitiesMacro","date":"2019-02-27T15:00:13.000Z","updated":"2021-10-25T15:18:25.000Z","comments":true,"path":"2019/02/WLGeneralUtilitiesMacro/","link":"","permalink":"http://miroox.github.io/blog/2019/02/WLGeneralUtilitiesMacro/","excerpt":"GeneralUtilities` 是Mathematica从版本10开始新加入的一个上下文。其中提供了大量的实用函数，包括代码生成、调试、静态分析、迭代器对象等各个领域，一定程度上弥补了Mathematica基础设施不足的状况。这个工具包内包含的函数十分繁杂，在当前版本11.3下，可以通过Names[&quot;GeneralUtilities`*&quot;]//Length看到其共包含了514个符号。这篇文章简单介绍与宏有关的部分。“宏”在编程领域往往作为一种代码生成技术使用，例如在一些编译型语言中，宏展开往往发生在编译或预编译阶段。而在GeneralUtilities`的语境下，宏默认在定义时自动展开，同样也是一种代码生成技术。","text":"GeneralUtilities` 是Mathematica从版本10开始新加入的一个上下文。其中提供了大量的实用函数，包括代码生成、调试、静态分析、迭代器对象等各个领域，一定程度上弥补了Mathematica基础设施不足的状况。这个工具包内包含的函数十分繁杂，在当前版本11.3下，可以通过Names[&quot;GeneralUtilities`*&quot;]//Length看到其共包含了514个符号。这篇文章简单介绍与宏有关的部分。“宏”在编程领域往往作为一种代码生成技术使用，例如在一些编译型语言中，宏展开往往发生在编译或预编译阶段。而在GeneralUtilities`的语境下，宏默认在定义时自动展开，同样也是一种代码生成技术。1Needs[\"GeneralUtilities`\"]下面介绍GeneralUtilities`中的一些实用宏 Scope/ModuleScope我们知道，Mathematica中的局部符号往往需要显式地引入，而不像很多语言在函数体内自动带有作用域。这在使用大量局部变量的时候会带来一些麻烦。而Scope给出了一个解决办法，它自动解析Scope[body]内部的赋值语句，提取与之相关联的符号自动局域化。通过?GeneralUtilities`Scope可以看到它的用法如下：Scope[body] is a macro that expands to a Block with automatically populated local variable list.Variables are detected syntactically by the presence of = and := within body.^= and ^:= can be used to avoid this localization.{sym1,sym2,...} = rhs will localize sym1,sym2,....sym := rhs will localize sym.Local functions definitions head[...] := rhs do not cause localizalization of head.而且它作为一个宏，使用在定义中，则展开发生在定义阶段，从而可以避免调用时因解析和变换带来的额外开销。例如123f[x_]:=Scope[a=x;b^=a;c:=a++;&#123;d,e&#125;=&#123;b,c&#125;;a]Definition[f](*Out[*]= f[x_]:=Block[&#123;a,c,d,e&#125;,a=x;b=a;c:=a++;&#123;d,e&#125;=&#123;b,c&#125;;a]*)可以看到f的定义中，Scope已经转换成了Block作用域，并自动将需要局域化的符号按Block的规则列出了。类似的，ModuleScope自动展开成Module作用域结构。 MemoizedMemoized[body] specifies that body should be evaluted but cached so that subsequent calls with the same value for any bound symbol use the cached value.Memoized[body,Method-&gt;method] can be used, where method is one of {&quot;Association&quot;, &quot;Symbol&quot;, &quot;Inline&quot;, &quot;SystemCache&quot;}, to choose a specific caching method.即所谓的记忆化手法，可以实现空间换时间的优化目的。例如对于Mathematica中一个比较经典的记忆化案例123fib[0]=0;fib[1]=1;fib[n_]:=fib[n]=fib[n-1]+fib[n-2]利用Memoized可以等价地写成123fib[0]=0;fib[1]=1;fib[n_]:=Memoized[fib[n-1]+fib[n-2],Method-&gt;\"Inline\"]除了&quot;Inline&quot;，Memoized还提供了其它几种记忆化的实现手段，包括默认的&quot;SystemCache&quot;、基于关联&quot;Association&quot;和面向符号的&quot;Symbol&quot;，这里不多赘述了。不过似乎目前的&quot;Symbol&quot;方法的实现有问题，无法应用于函数定义中。 SetupTeardownSetupTeardown[setup,body,teardown] evaluates setup, then body, and then teardown, even if an Abort or Throw occurs during evaluation.SetupTeardown是一个确保“初始化-主体-清理”执行顺序的封装，哪怕其中某部分中断或者抛出也会确保其余部分顺序进行。举一个简单的例子1f[]:=SetupTeardown[Print[\"setup\"],Print[\"before\"];Abort[];Print[\"after\"],Print[\"teardown\"]]调用f[]，可以看到即使Abort[]中断计算后，依然继续进行了Print[&quot;teardown&quot;]的计算。这个宏可以用于在计算流程中确保资源的获取和释放，不过实际在Mathematica中应用比较少。 Match/StringMatchMatch[value,patt1:&gt;val1,patt2:&gt;val2,…,default] matches the value to the patti in turn and gives the corresponding vali, or evaluates default if none matched.Match[value,patts...,...] panics if none of the patts matched.Match[patts] is the operator form of Match.长得像Rust的match，用法大抵类似Switch，实际只是Replace的一个封装。StringMatch无非是StringReplace的一个封装。 CatchFailure/CatchFailureAsMessageCatchFailure[body] is a macro evaluates body, but returns a Failure[...] object if a ThrowFailure[...] occurred during evaluation. The current function is automatically used as the message head.CatchFailure[head,body] explicitly uses head as the message head for the failure message.CatchFailureAsMessage[body] is a macro evaluates body, but issues a message if a ThrowFailure[...] occurred during evaluation. The current function is automatically used as the message head.CatchFailureAsMessage[head,body] explicitly uses head as the message head for the failure message.需要配合ThrowFailure一起使用，语义比较清晰的错误捕获。 UnpackAssociation/UnpackOptionsUnpackAssociation[assoc,“Name1”,“Name2”,…] extracts the given keys from the association and sets variables named Namei.UnpackAssociation[assoc,symbol1,symbol2,…] uppercases the first letter of the symbol name to get the key.UnpackAssociation[assoc,symbol1:“Name1”,…] gives an explicit name for each symbol.UnpackOptions[sym1,sym2,…] extracts options with names “Sym1”, “Sym1”, … and assigns them to the symi, where the keys are the title cased version of the symbol names.用法说明已经介绍得比较详细了，下面给一个简单的用例1234Options[f] = &#123;\"A\" -&gt; 1, \"Op\" -&gt; 2&#125;;f[OptionsPattern[]]:=Scope[UnpackOptions[a,op];&#123;a,op&#125;]&#123;f[], f[\"A\" -&gt; 17], f[\"Op\" -&gt; 18], f[\"A\" -&gt; 16, \"Op\" -&gt; 19]&#125;(*Out[*]= &#123;&#123;1,2&#125;,&#123;17,2&#125;,&#123;1,18&#125;,&#123;16,19&#125;&#125;*) CollectToCollectTo需要配合BagInsert使用，实际是Internal`Bag相关函数的封装，目前来看意义不大，不过这个宏没有用法说明，也可能尚未完善。根据定义，可以大致推测CollectTo[{x,y,...},body]可以通过在body部分使用BagInsert[x,val]或者BagInsert[x,val,index]的方式高效地将val添加或插入到动态列表x中。下面给一个简单的用例说明一下用法123f1[n_]:=Scope[CollectTo[&#123;x&#125;,Do[BagInsert[x,i],&#123;i,n&#125;]];x]f2[n_]:=Scope[x=&#123;&#125;;Do[AppendTo[x,i],&#123;i,n&#125;];x]BenchmarkPlot[&#123;f1,f2&#125;,Identity]我的电脑上给出的结果为：可以看到Bag的添加效率基本是普通列表的好几倍。 DoWhileDoWhile[body,test]就像C语言之类的一样，先计算body，再计算test并决定是否循环，实际上就等价于While[body;test]。 ExciseExcise[args...] evaluates to an empty sequence, effectively removing its arguments without evaluation.个人认为没什么用，注释可以做到同样的事，甚至用途更广（Excise只能在使用宏的情况下工作）。 UseMacrosUseMacros[body] does nothing more than trigger macro expansion, use it if you want to use macros in a function but don’t need Scope.在不了解GeneralUtilities`中宏的作用机理的情况下，这个宏的作用可能会令人困惑。事实上，在默认条件下，上述各种宏的自动展开只会发生在赋值等号右边的最外层使用了宏的时候发生。这一事实可以在上述各种的定义中一窥究竟，以Scope为例123Scope &#x2F;: HoldPattern[s:Set[_, _Scope]] :&#x3D; MacroEvaluate @ s;Scope &#x2F;: HoldPattern[sd:SetDelayed[_, _Scope]] :&#x3D; MacroEvaluate @ sd;Scope &#x2F;: HoldPattern[tsd:TagSetDelayed[_, _, _Scope]] :&#x3D; MacroEvaluate @ tsd;同样，UseMacros位于赋值等号右边的最外层时会触发宏自动展开，从而可以解决在内层使用宏无法展开的问题。GeneralUtilities`除了提供上述宏之外，还提供了一些计算和生成宏的辅助工具。 QuotedQuoted[code] is the inert body of code for the purposes of macro expansion.一个代码封装，作用基本和HoldComplete一样，不过使用了一个漂亮的方式输出显示代码。在宏的实现中大量使用。 MacroExpand/MacroExpandListMacroExpand[expr] evaluates all macros present in expr and returns the result in a Quoted expression.Anywhere in a macro, ' can be used to inject EchoRaw calls, '' to inject EchoHold calls, and ''' to wrap a function in Tap.MacroExpandList[expr] expands all macros that occur in expr, returning a list of Quoted expressions that give the intermediate results after each expansion step.MacroExpand展开宏，但是不计算，可以用来预览宏使用的效果。而MacroExpandList列出展开宏的每一步。 MacroEvaluateMacroEvaluate[expr] evaluates all macros present in expr and then evaluates the result.展开宏并计算。可以尝试令$Pre=MacroEvaluate，这样每次计算都会尝试展开宏，从而也就不需要UseMacros来触发展开了。 MacroRulesMacroRules[symbol] gives all the macro application rules associated with the head symbol.可以通过PrintDefinitions[MacroRules]hack得到已定义的函数宏和变换规则。 DefineLiteralMacro/DefineMacro/DefineAliasDefineLiteralMacro[symbol,lhs:=rhs,...] defines a literal macro such that when lhs it is substituted for rhs without evaluation.The same replacement is attached to symbol for use outside a macro context.DefineAlias[newsymbol,oldsymbol] does what it says on the tin.这三者都用来实现自定义宏，但使用和效果上略有不同：DefineLiteralMacro[symbol,lhs:=rhs,...] 定义的是一个字面宏，在替换展开的过程中并不会计算rhs。DefineMacro[symbol,lhs:=rhs,...] 定义的宏则会在展开时计算rhs。DefineAlias[newsymbol,oldsymbol] 定义符号的别名，只对符号有效，而且其展开发生在其它宏展开之前。尝试下面的例子以便更直观地认识到这三者间的联系和区别：123456789DefineMacro[fac1, fac1[x_]:=x!];DefineLiteralMacro[fac2, fac2[x_]:=x!];DefineAlias[fac3, Factorial];MacroExpand[fac1[3]]MacroExpand[fac2[3]]MacroExpand[fac3[3]]MacroExpand[fac2[]]MacroExpand[fac3[]]","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"参考","slug":"参考","permalink":"http://miroox.github.io/blog/tags/%E5%8F%82%E8%80%83/"},{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"},{"name":"元编程","slug":"元编程","permalink":"http://miroox.github.io/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"},{"name":"Undocumented","slug":"Undocumented","permalink":"http://miroox.github.io/blog/tags/Undocumented/"}]},{"title":"在Wolfram语言中模拟指针语义","slug":"PointerInWolfram","date":"2019-01-18T15:15:37.000Z","updated":"2021-10-25T15:18:25.000Z","comments":true,"path":"2019/01/PointerInWolfram/","link":"","permalink":"http://miroox.github.io/blog/2019/01/PointerInWolfram/","excerpt":"背景和问题的引入众所周知，Wolfram语言作为一个极为“高级”的编程语言，并没有提供指针这类较为底层的内存管理手段。而符号本身几乎总是充当了类似引用的作用，比如1234set[sym_Symbol]:=sym=1b=a;set[b];a可以看到符号a的值通过set[b]赋为了1。在这里b形式上充当了类似其它语言中的引用的作用。但这种方式并不通用，只要a已经具有值了，这种平凡的方式就不能起作用了。有的读者可能会想到:=或者Hold封装，不过单靠这些也不能简单地对已具有本值的符号进行修改。因此，本文试图提出一种具有类似其它语言中指针语义的封装，实现对符号的间接操作。","text":"背景和问题的引入众所周知，Wolfram语言作为一个极为“高级”的编程语言，并没有提供指针这类较为底层的内存管理手段。而符号本身几乎总是充当了类似引用的作用，比如1234set[sym_Symbol]:=sym=1b=a;set[b];a可以看到符号a的值通过set[b]赋为了1。在这里b形式上充当了类似其它语言中的引用的作用。但这种方式并不通用，只要a已经具有值了，这种平凡的方式就不能起作用了。有的读者可能会想到:=或者Hold封装，不过单靠这些也不能简单地对已具有本值的符号进行修改。因此，本文试图提出一种具有类似其它语言中指针语义的封装，实现对符号的间接操作。 预期的目标这里想实现一种具有类似C语言用法的指针（引用）封装。当然，由于Mathematica没有直接访问内存的手法，所有引用都是针对符号展开的。具体而言，应该可以实现下面的效果：解引用：123a=1;b=ref[a];deref@b得到1；左值语义：1234a=1;b=ref[a];deref@b=2;a得到2；更复杂的左值：1234a=&#123;1,2,3&#125;;b=ref[a];deref[b][[2]]=4;a得到{1,4,3}；多重引用：12345a=1;b=ref[a];c=ref[b];deref@deref@c=2;a得到2。这里只是举几个例子，文章毕竟不是测试集，也就不再赘述。当然，我们希望能更接近C语言指针的语义。在这里，ref相当于C语言中的&amp;单目运算符，而deref则相当于C语言的*单目运算符。 思路与实现考虑我们需要保有符号，才可能对符号进行引用，因此首先ref必须具有HoldFirst属性。然后deref能在计算时解引用，也就是1deref[ref[sym_]] := sym然后我们需要重载Set以获得左值语义。由于deref可能出现在很深的层次中，单靠TagSetDelayed不能覆盖重载的各种情况。但需要重载的情况必定含有deref，因此可以利用条件模式决定重载策略123Unprotect[Set];Set[lhs_, rhs_] /; MemberQ[Unevaluated[lhs], _deref, &#123;0, Infinity&#125;] := &lt;&lt;具体实现&gt;&gt;Protect[Set];由于引用在这里总是保有着符号，因此左值语义在这里更类似一个宏展开，将=左侧的所有直接或隐含的deref[ref[sym]]结构展开成对应的sym。为了达到这个目的，首先需要保护=的左侧不进行计算，这里只需要一个简单的Hold封装即可。然后上面的所说的“宏展开”细节上应该分两步进行：一是将“隐含”转换为“显含”：直观上来说，可能大家会写成这样的替换规则：deref[r_]:&gt;deref[Evaluate[r]]，但这是不对的。由于Hold封装的存在，需要用到一个名为Trott-Strzebonski的技巧，而且由于前面已经定义了deref[ref[sym_]]:=sym，因此这里必须借助Block局部地清除这个定义才行，另一方面，为了处理多重引用，还需要排除deref[deref[xxx]]这种模式被直接展开。二是对显式结构进行替换：这部分比较简单，直接使用deref@ref[sym_Symbol]:&gt;sym即可。同样也是因为Hold封装的存在，符号sym即使有本值也不会计算。最后将展开的结果还原为赋值表达式即可。综合一下，我们可以得到一个比较完整的代码12345678910111213SetAttributes[ref, HoldFirst]deref[ref[sym_]] := symUnprotect[Set];Set[lhs_, rhs_] /; MemberQ[Unevaluated[lhs], _deref, &#123;0, Infinity&#125;] := With[&#123; lhs1 = Block[&#123;deref&#125;, Hold[lhs] //. &#123; deref@ref[sym_Symbol] :&gt; sym, deref[r : Except[_deref]] :&gt; With[&#123;eval = deref[r]&#125;, eval /; True] (*Trott-Strzebonski*) &#125;]&#125;, Replace[Hold[Set[lhs1, rhs]], Hold[Set[Hold[lhs2_], rhs2_]] :&gt; Set[lhs2, rhs2]] ]Protect[Set];当然，对于一个真正实用的模块而言，还需要一些诸如错误处理之类的细节，但如果只考虑正确使用的话，实现指针语义的核心部分都已经列在这里了。一个相对实用的版本可以在 https://github.com/miRoox/LValueRef 找到。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"功能模拟","slug":"功能模拟","permalink":"http://miroox.github.io/blog/tags/%E5%8A%9F%E8%83%BD%E6%A8%A1%E6%8B%9F/"},{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"},{"name":"元编程","slug":"元编程","permalink":"http://miroox.github.io/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"}]},{"title":"Mathematica黑魔法：符号沙盒","slug":"SymbolSandbox","date":"2019-01-17T15:02:13.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2019/01/SymbolSandbox/","link":"","permalink":"http://miroox.github.io/blog/2019/01/SymbolSandbox/","excerpt":"问题的引入ValueQ是Matheamtica中的一个非常有趣的函数，它判断一个表达式是否会进行求值，而且这种判断有时可以做到无副作用，哪怕求值本身是具有副作用的。比如1234x=0;y:=++xv=ValueQ[y];&#123;v,x&#125;会得到{True,0}的结果。这里的ValueQ[y]显然并没有真正对y求值就作出了判断。不过很遗憾的是这其中哪怕只有略微的改动也会使其作用发生变化，例如1234x=0;y:=++xv=ValueQ[y+0];&#123;v,x&#125;则会得到{True,1}。","text":"问题的引入ValueQ是Matheamtica中的一个非常有趣的函数，它判断一个表达式是否会进行求值，而且这种判断有时可以做到无副作用，哪怕求值本身是具有副作用的。比如1234x=0;y:=++xv=ValueQ[y];&#123;v,x&#125;会得到{True,0}的结果。这里的ValueQ[y]显然并没有真正对y求值就作出了判断。不过很遗憾的是这其中哪怕只有略微的改动也会使其作用发生变化，例如1234x=0;y:=++xv=ValueQ[y+0];&#123;v,x&#125;则会得到{True,1}。具有值集知识的读者可能很容易猜想ValueQ可能具有类似下面的实现123Attributes[ValueQ] &#x3D; &#123;HoldAll, Protected, ReadProtected&#125;ValueQ[sym_Symbol]:&#x3D;Hold[sym]&#x3D;!&#x3D;Hold[sym]&#x2F;.OwnValues[sym]ValueQ[expr_]:&#x3D;Unevaluated[expr]&#x3D;!&#x3D;expr因而具有上面那样的行为也是可以理解的。不过这种不一致性总归让人觉得别扭，尽管这种不一致性本质上来源于Wolfram语言求值策略的复杂性，尤其是Condition的灵活性，使得上面这种策略注定无法真正消除副作用。哪怕是现在这种状况，我们依然可以让ValueQ对符号作用时产生副作用，例如1234x=0;y:=With[&#123;e=++x&#125;, e/;True]v=ValueQ[y];&#123;v,x&#125;也会得到{True,1}。这里用到的技巧叫Trott-Strzebonski，是一种常用的元编程技巧，不过这里不做赘述，对于理解Condition的工作方式的读者想必并不复杂。因此，这里想介绍另一种消去副作用的思路，也就是所谓的“符号沙盒”。 思路与实现如果说ValueQ的思路是尽可能避免求值来消去副作用的话，那么接下来的处理方式则是尽可能将副作用局域化，就好像在沙盒环境中一样。而这也正是标题由来。事实上，Block动态作用域就具有类似的效果。不过直接使用Block的话则略显繁琐，我们希望有一个能自动分析需要局域化的符号并且能继承既有定义的动态作用域。幸运的是，Mathematica中既有的函数足以覆盖我们的需求：Internal`EmbeddedSymbols和Internal`InheritedBlock。尽管这两者都是没有文档的“内部函数”，不过通过测试和分析可以推测他们的功能：Internal`EmbeddedSymbols：可以获取一个表达式所有直接或间接使用的符号Internal`InheritedBlock：继承符号既有定义的动态作用域组合这两者不难得到12345678SetAttributes[&#123;embeddedUserSymbols,symbolSandbox&#125;,HoldFirst]embeddedUserSymbols[expr_]:= Select[Internal`EmbeddedSymbols[expr], Function[sym,ContainsNone[Attributes[sym],&#123;Locked,Protected&#125;],HoldAll] ]/. &#123;Hold[syms___]:&gt;Hold[&#123;syms&#125;]&#125;symbolSandbox[expr_]:=With[&#123;syms=Unevaluated@@embeddedUserSymbols[expr]&#125;, Internal`InheritedBlock[syms,expr] ]这里需要注意的是Internal`EmbeddedSymbols获得的符号不能全部局域化，因此加入了Select滤过具有Locked和Protected属性的符号。然后我们可以给出一个更“安全”的ValueQ12SetAttributes[valueQ,HoldFirst]valueQ[expr_]:=Unevaluated[expr]=!=symbolSandbox[expr]此时1234x=0;y:=++xv=valueQ[y+0];&#123;v,x&#125;会给出{True, 0}的结果，x因对y的求值而产生的改变被限制在valueQ的计算过程中。不过这种局域化仅限于符号，并不能限制诸如文件IO等其它方式的副作用，因此只能叫“符号沙盒”。补充：经过更多测试，发现Internal`EmbeddedSymbols似乎有不太稳定，有时会导致内核崩溃，而且似乎不能完全获取有关的符号。这部分可能有待改进。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"},{"name":"Undocumented","slug":"Undocumented","permalink":"http://miroox.github.io/blog/tags/Undocumented/"}]},{"title":"Mathematica下标赋值问题补遗","slug":"SubcriptInMma-Addendum","date":"2019-01-16T06:55:47.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2019/01/SubcriptInMma-Addendum/","link":"","permalink":"http://miroox.github.io/blog/2019/01/SubcriptInMma-Addendum/","excerpt":"我曾经写过一篇关于Mathematica中下标与赋值问题的文章，不过那篇文章重点解决的是符号关联的问题。但有时，我们可能会遇到另一种问题，比如","text":"我曾经写过一篇关于Mathematica中下标与赋值问题的文章，不过那篇文章重点解决的是符号关联的问题。但有时，我们可能会遇到另一种问题，比如也就是定义了符号的本值之后又想定义带有同样符号的下标值。当然，我们是不推荐这么写的，这会使符号的含义很含混。不过单从实用的角度考虑，让上面的代码正常工作并不困难，只需要对Subscript添加HoldFirst属性即可。1SetAttributes[Subscript,HoldFirst]","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miroox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"}]},{"title":"突然发现部分Wolfram演示项目支持在线运行了","slug":"WolframOnlineDemo","date":"2018-12-01T12:09:39.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2018/12/WolframOnlineDemo/","link":"","permalink":"http://miroox.github.io/blog/2018/12/WolframOnlineDemo/","excerpt":"如题，已经有部分Wolfram演示项目支持在线运行，尽管这个功能貌似还在测试中。","text":"如题，已经有部分Wolfram演示项目支持在线运行，尽管这个功能貌似还在测试中。甚至还支持以内联框架的形式嵌入网页。比如下面这个例子就来自 https://demonstrations.wolfram.com/FraunhoferDiffractionThroughARectangularAperture。不过这个在线运行机制似乎是基于 Wolfram Cloud 实现的，而不是 Web Assembly 之类的本地计算，因此响应速度会有点慢。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"}]},{"title":"解决CurrentValue等动态刷新无法控制的问题","slug":"FixCurrentValueRefresh","date":"2018-11-28T15:09:13.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2018/11/FixCurrentValueRefresh/","link":"","permalink":"http://miroox.github.io/blog/2018/11/FixCurrentValueRefresh/","excerpt":"All problems in computer science can be solved by another level of indirection. [1]最近在拿Mathematica做一些小东西的时候发现CurrentValue等函数在动态中刷新不受Refresh等方式影响。比如","text":"All problems in computer science can be solved by another level of indirection. [1]最近在拿Mathematica做一些小东西的时候发现CurrentValue等函数在动态中刷新不受Refresh等方式影响。比如1Dynamic[Refresh[CurrentValue[\"MousePosition\"], None]]输出会不断刷新，并不受Refresh[□, None]结构控制。另一方面，同样被设计为“过分敏感”的Clock则受Refresh控制，1Dynamic[Refresh[Clock[]], None]]其输出则不会更新。鉴于文档中并没有提到过这个问题，我个人认为这是一个bug。不过几个Current开头的函数都有这个问题，包括CurrentImage、CurrentNotebookImage、CurrentScreenImage，或许这其实是这类函数的一个feature也说不定。然而，出于某些应用场合的需求，我希望这些函数能像其它动态一样受控，这篇文章也因此而来。当然，前面的例子太过“平凡”了，直接使用静态输出就没有那么多事了。如果我们考虑一个定时刷新的光标位置，那么按照一般的写法，可能写成1Dynamic[CurrentValue[\"MousePosition\"], UpdateInterval -&gt; 1]但正如前面指出的，上面这段代码并不能正常地工作。要解决这个问题，实际要引入一个受控的中间层，来间接表示CurrentValue[&quot;MousePosition&quot;]。正如文档中所提到的，通过组合TrackedSymbols和UpdateInterval，我们可以精确控制只受符号变化影响的动态更新。再借助DynamicWrapper同步受控符号与CurrentValue表达式即可。最终我们得到123456DynamicModule[&#123;p&#125;, DynamicWrapper[ Dynamic[p, UpdateInterval -&gt; 1, TrackedSymbols :&gt; &#123;&#125;], p = CurrentValue[\"MousePosition\"] ]]至此，CurrentValue等动态刷新无法控制的问题圆满解决。2019年1月22日补充：这大概确实是一个bug，在SE上的这个问题中作者表示已经将这一情况向Wolfram公司提出了。https://www2.dmst.aueb.gr/dds/pubs/inbook/beautiful_code/html/Spi07g.html ↩︎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miroox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"}]},{"title":"如何方便快捷地查看Mathematica中的符号定义？","slug":"PrintDefinitions","date":"2018-10-07T05:50:12.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2018/10/PrintDefinitions/","link":"","permalink":"http://miroox.github.io/blog/2018/10/PrintDefinitions/","excerpt":"使用1GeneralUtilities`PrintDefinitions[symbol]即可，如下图","text":"使用1GeneralUtilities`PrintDefinitions[symbol]即可，如下图不过就这么结束了好像也不太好，再补充几点：生成的笔记本文档中的符号可以通过点击打开其定义，就好像许多其它语言的IDE中的“Jump to Definition”功能一样。有许多内置函数的定义是看不到的，因为它们的实现可能不是通过Wolfram语言完成的。这时你可能只能看到&lt;&lt;kernel function&gt;&gt;的字样。有些包里的符号可能没有预先加载，也许在第一次调用的时候只会得到一个空的笔记本，这时，你可能需要再运行一次才能得到正确的结果。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"}]},{"title":"Mathematica下标与导数赋值问题的解决方法","slug":"SubscriptAndDerivateInMma","date":"2018-08-23T07:22:43.000Z","updated":"2021-10-25T15:18:25.000Z","comments":true,"path":"2018/08/SubscriptAndDerivateInMma/","link":"","permalink":"http://miroox.github.io/blog/2018/08/SubscriptAndDerivateInMma/","excerpt":"众所周知，Mathematica中虽然使用下标形式非常方便，但如果对下标结构进行直接赋值，它将关联到内部符号Subscript上。这样，在我们大量清理符号定义的时候可能会漏掉一些定义。类似地，导数Derivative有同样的问题，比如对于","text":"众所周知，Mathematica中虽然使用下标形式非常方便，但如果对下标结构进行直接赋值，它将关联到内部符号Subscript上。这样，在我们大量清理符号定义的时候可能会漏掉一些定义。类似地，导数Derivative有同样的问题，比如对于1f'=df使用12Clear[f]Clear[\"`*\"]并不能清除f'的定义。虽说将直接赋值改为用UpSet或者TagSet替代可以将赋值关联到符号f上而不是别的，比如下面的代码。1f/:f'=df但每次多打一些东西总归是不方便，我们总会想找一个一劳永逸的办法。官方文档中提到的对数量值的处理给了我启发。在Wolfram语言中，数量值的处理与上值类似，当定义了f的数量值以后，Wolfram语言就象求值运算N中f的上值一样来输入这一定义.下标的情况相对比较容易处理，类似an的结构在Wolfram语言中实质就是Subscript[a,n]，我们只要把普通的赋值转化为TagSet即可，就如下面的代码所示1234Subscript /: Set[Subscript[a_Symbol, rest__], val_] := TagSet[a, Subscript[a, rest], val]Subscript /: SetDelayed[Subscript[a_Symbol, rest__], val_] := TagSetDelayed[a, Subscript[a, rest], val]Derivative的情况相对要复杂一些，因为即使看上去非常简单的f'[x]在Wolfram语言内部也会表示为Derivative[1][f][x]，我们认为的主要符号f在这个表达式中层次太深，无法直接将TagSet应用在上面，因此只能采取一些迂回的办法。值得庆幸的是，Mathematica也支持纯函数式的导数，例如Sin'会得到Cos[#1]&amp;。而在Derivative[1][f]结构中，f是可以通过TagSet赋予上值的。对于这种情况，采用和前面类似的方法就能解决。1234Derivative /: Set[Derivative[ns__Integer][f_Symbol], val_] := TagSet[f, Derivative[ns][f], val]Derivative /: SetDelayed[Derivative[ns__Integer][f_Symbol], val_] := TagSetDelayed[f, Derivative[ns][f], val]而对于类似Derivative[1][f][x]的情况，虽然我们无法直接对其使用TagSet，但我们可以考虑将其转换为纯函数的情况。动手前先分析，例如f'[x_]:=x我们希望将其转换为f':=Function[{x},x]，为了达到这个目的，需要去掉原本赋值中的模式结构:_。我们知道，像x_的完整形式是Pattern[x,Blanck[]]。因此，提取x_的x只要将其第一部分提取出来即可。综合一下可以写成如下的代码123456Derivative /: Set[Derivative[ns__Integer][f_Symbol][args__Pattern], val_] := Set[Derivative[ns][f], Evaluate[First /@ &#123;args&#125;] \\[Function] val]Derivative /: SetDelayed[Derivative[ns__Integer][f_Symbol][args__Pattern], val_] := Set[Derivative[ns][f], Evaluate[First /@ &#123;args&#125;] \\[Function] val]其中，Evaluate是为了解决Function的HoldAll属性的。除此之外，还有一点值得注意。像Derivative[1]和Derivative[1,0]是不同的，Derivative的参数个数应该与被求导函数的参数个数匹配。考虑了这个问题后，可以将上面的代码改成下面这样，以避免出现类似f'[x_,y_]:=df[x,y]错误形式。12345678910Derivative /: Set[Derivative[ns__Integer][f_Symbol][x__Pattern], val_] := If[Length@&#123;ns&#125; == Length@&#123;x&#125;, Set[Derivative[ns][f], Evaluate[First /@ &#123;x&#125;] \\[Function] val], $Failed]Derivative /: SetDelayed[Derivative[ns__Integer][f_Symbol][x__Pattern], val_] := If[Length@&#123;ns&#125; == Length@&#123;x&#125;, Set[Derivative[ns][f], Evaluate[First /@ &#123;x&#125;] \\[Function] val], $Failed]当然，这种方法不能应对类似f'[1]=0这样的单点导数赋值。但这种基于模式的单点导数定义本身也不是很合适的做法，比如123f'[1]=0;f'[x_]:=xD[f[x],x]其结果是无法体现出f'[1]=0的。因此对于一个函数的某阶导数，应该避免重载。如果有需要，也应该使用Piecewise之类的手段整合成一个函数。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miroox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"},{"name":"元编程","slug":"元编程","permalink":"http://miroox.github.io/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"}]},{"title":"Mathematica程序包的中文与Unicode处理","slug":"UnicodeCharInMmaPackage","date":"2018-08-08T04:28:23.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2018/08/UnicodeCharInMmaPackage/","link":"","permalink":"http://miroox.github.io/blog/2018/08/UnicodeCharInMmaPackage/","excerpt":"Mathematica在处理字符时默认总会将所有字符转换为ASCII字符表示，例如π会转化为\\[Pi]，而像汉字仪这样的一般字符会转化为\\:4eea。这种设计固然可以避免某些环境对非ASCII字符不支持的困难，而且在Mathematica环境下会自动转换成原本的字符，但对于一般的文本阅读环境而言，尤其是在代码中使用一些中文文本或者注释时，这样的内容阅读起来根本无法理解。为了方便在没有Mathematica的环境下也能方便的阅读程序包中的非ASCII的一般字符，下面脚本提供了将\\:nnnn形式的转义序列转换为UTF-8编码下对应的Unicode字符的简单方法","text":"Mathematica在处理字符时默认总会将所有字符转换为ASCII字符表示，例如π会转化为\\[Pi]，而像汉字仪这样的一般字符会转化为\\:4eea。这种设计固然可以避免某些环境对非ASCII字符不支持的困难，而且在Mathematica环境下会自动转换成原本的字符，但对于一般的文本阅读环境而言，尤其是在代码中使用一些中文文本或者注释时，这样的内容阅读起来根本无法理解。为了方便在没有Mathematica的环境下也能方便的阅读程序包中的非ASCII的一般字符，下面脚本提供了将\\:nnnn形式的转义序列转换为UTF-8编码下对应的Unicode字符的简单方法123456#!/usr/bin/env wolframscriptfileName=Last[$ScriptCommandLine];in=Import[fileName,\"Text\"];out=StringReplace[in,(\"\\\\:\"~~(n:Repeated[HexadecimalCharacter,&#123;4&#125;])):&gt;FromCharacterCode[FromDigits[n,16],\"UTF-8\"]];Export[fileName,out,\"Text\",CharacterEncoding-&gt;\"UTF-8\"];经过处理的文件用Mathematica也可以正常打开显示，只是每次保存时又会重新使用转义序列表示非ASCII字符，因而每次修改都应该重新运行脚本。对于程序包，如果在代码正文中也使用了中文等非ASCII字符的话，在使用Get等方式导入包时，可能需要添加选项CharacterEncoding-&gt;&quot;UTF-8&quot;才能正确地显示其中的内容。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miroox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"}]},{"title":"Wolfram语言中的作用域结构","slug":"ScopeInWolframLang","date":"2018-08-06T03:06:12.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2018/08/ScopeInWolframLang/","link":"","permalink":"http://miroox.github.io/blog/2018/08/ScopeInWolframLang/","excerpt":"Wolfram语言中的作用域结构主要有如下5种:ModuleBlockWithDynamicModule命名空间","text":"Wolfram语言中的作用域结构主要有如下5种:ModuleBlockWithDynamicModule命名空间 Module按照文档中的说法，Module提供变量的词法(lexical)定界。它使范围内的变量具有类似C语言中局部变量的行为。然而，和C语言等不同，Wolfram语言没有对变量的名称和对象的区分，同样的名称总是用于指代同一变量。因此，Module在创建局部变量时，实际是创建新的符号并进行替换，比如运行下面的代码：1Module[&#123;x&#125;, x]从输出结果中可以看到形如x$nnn的局部变量。正如前面提到的，Module提供的是变量的词法定界。因此，只有显式出现在作用域中的变量会被局部化。偶尔，这可能带来一些意想不到的结果。典型地，下面的代码12m = i^2;Module[&#123;i = a&#125;, i + m]会输出a+i2。为了有效地实现定界，Module创建的变量都有Temporary属性来控制变量的生存期。它采用类似引用计数的方式来考察一个变量是否还在使用，并决定是否要将变量移除。因此，我们基本不需要考虑可能的变量冲突。12Module[&#123;x&#125;, Print[x]; Attributes[x]]Names[\"x*\"]多数时候，我们可能喜欢使用Module，因为它确实会如我们期望地那样创建新的变量。但它毕竟不是万能的，只有始终明确它的含义和适用的场合，才能保证正确地使用它。思考题1：下面的程序会输出什么？123456x = 1;Module[&#123;x = 2&#125;, Print[x]; Print[Symbol[\"x\"]];]Print[x]延伸阅读：模块和局部变量、模块工作方式 Block与Module不同，Block提供变量的动态定界。它不产生新的变量，只是在作用域内临时地修改变量的值。因此，前面的例子如果用Block改写12m = i^2;Block[&#123;i = a&#125;, i + m]则会输出a+a2。基于这种特性，Block经常被用在将副作用局域化的场合。比如，局部地进行深度递归1234cl[1] = 1;cl[n_Integer?EvenQ] := cl[n/2] + 1cl[n_Integer?OddQ] := cl[3 n + 1] + 1Block[&#123;$RecursionLimit = Infinity&#125;, cl[9780657630]]又比如，局部地清除值12x = 0;Block[&#123;x&#125;, Print[Expand[(1 + x)^3]]]值得注意的是，上面使用了Print直接输出来避免从Block返回的值再被计算。如果普通地从Block返回值，则其中的表达式会由于x=0而重新计算，从而输出1。利用Trace我们可以看到这其中的过程12x = 0;Block[&#123;x&#125;, Expand[(1 + x)^3]] // Trace // Column12345678Block[&#123;x&#125;,Expand[(1+x)^3]]&#123;Expand[(1+x)^3],1+3 x+3 x^2+x^3&#125;1+3 x+3 x^2+x^3&#123;&#123;x,0&#125;,3 0,0&#125;&#123;&#123;&#123;x,0&#125;,0^2,0&#125;,3 0,0&#125;&#123;&#123;x,0&#125;,0^3,0&#125;1+0+0+01Block虽然很便利，但“成也动态定界败也动态定界”，它所带来副作用往往不是显然的，更容易引入一些潜在的错误。另一点值得注意的是，像Table、Plot之类的函数在运算时使用与Block相同的方式局部化变量的值。这意味着使用这些函数时必须同使用Block一样小心123f[x_] := i*xTable[f[i], &#123;i, 5&#125;]Table[f[j], &#123;j, 5&#125;]123&#123;1, 4, 9, 16, 25&#125;&#123;i, 2 i, 3 i, 4 i, 5 i&#125;另一方面，这个特性在使用EvaluationMonitor之类的监视器时会带来很大的方便。比如下面的代码可以直接追踪出求根过程中的步骤1FindRoot[x^2 - 2, &#123;x, 1&#125;, EvaluationMonitor :&gt; Print[\"x=\", x, \" Bias:\", Abs[x^2 - 2]]]思考题2：下面的程序会输出什么？与Module时的情况进行比较。123456x = 1;Block[&#123;x = 2&#125;, Print[x]; Print[Symbol[\"x\"]];]Print[x]延伸阅读：块与模块的比较、块和局部值 WithWith的目的是实现局部常量，但它实质上不过是一个替换罢了。在大多数情况下1With[&#123;x = x0, y = y0&#125;, expr]等价于1Unevaluated[expr] /. &#123;HoldPattern[x] -&gt; x0, HoldPattern[y] -&gt; y0&#125;可以看到，With并不会创建变量，相反，在替换的过程中往往还会减少变量。这个性质往往非常有用。比如，它可以把值插入到保持(held)表达式中：1Table[With[&#123;i = i&#125;, Hold[i]], &#123;i, 5&#125;]输出为1&#123;Hold[1], Hold[2], Hold[3], Hold[4], Hold[5]&#125;但如果不借助With传递一下的话1Table[Hold[i], &#123;i, 5&#125;]输出结果则会是1&#123;Hold[i], Hold[i], Hold[i], Hold[i], Hold[i]&#125;在下面的延伸阅读中的“How To”主题里，可以看到有关这种性质更实际的用法。思考题3：下面的程序会输出什么？12345With[&#123;x = y&#125;, x = 1; Evaluate[Symbol[\"x\"]] = 2;]&lt;|\"x\" -&gt; x, \"y\" -&gt; y|&gt;思考题4：前面提到With可以将值插入保持表达式，考虑如果将With替换为Module或者Block是否能实现同样的效果？为什么？思考题5：前面提到，大多数情况下，With可以等价于一个替换。那么，在什么情况下不能简单地进行替换？比较下面两段程序，思考造成差异的原因，并考虑With的适用范围。1With[&#123;y = x + a&#125;, Function[&#123;x&#125;, x + y]]1Unevaluated[Function[&#123;x&#125;, x + y]] /. &#123;HoldPattern[y] -&gt; x + a&#125;延伸阅读：局部常量、How To | 在 Dynamic 或 Manipulate 内部计算表达式、纯函数和规则中的变量 DynamicModule与Module类似，DynamicModule也建立变量的词法作用域，但两者又有不同：如果说Module将变量局域在一个时间段的话，那么DynamicModule将变量局域在其输出的一个空间区域上。而为了实现这一点，Module对变量的局域化发生在内核中，而DynamicModule对变量的局域化发生在前端。这也可以通过运行下面两段代码验证1Module[&#123;x&#125;, Slider[Dynamic[x]]] // FullForm1DynamicModule[&#123;x&#125;, Slider[Dynamic[x]]] // FullForm从输出结果中可以看到DynamicModule在内核中是以不计算的方式保持着原本的形式，实际上DynamicModule在前端产生一个DynamicModuleBox的框符结构，它虽然不会像ButtonBox或者RowBox之类的显示成一个控件或者布局，但前端会根据它来对内部的变量局域化。1DynamicModule[&#123;x&#125;, Slider[Dynamic[x]]]复制上面代码的输出，在后面加上 //ToBoxes 并计算，得到其框符表示。滑动滑动条，再次计算，可以看到滑动条的值其实是由DynamicModuleBox结构所记录的。这也正是DynamicModule内的状态能保存在文件中，并在跨越不同的内核会话时保持一致的原因。相对地，Module就没有这个能力，比如下面这段代码1Module[&#123;x&#125;, Slider[Dynamic[x]]]由其得到的滑动条，随意滑动一下，如果关闭文件并退出内核的话，再次打开文件它会回到初始的位置上；而如果不关闭文件直接退出内核的话，甚至会出现拖动滑动条却无法将其移动的情况。对后一种情况，个人猜测是由于前端和内核重新连接后，前端原有控件没能和内核中的变量关联上的缘故。思考题6：分别将由DynamicModule和Module得到的滑动条复制到其它地方，拖动滑动条，观察其现象，思考造成这种现象的原因。延伸阅读：动态简介、高级动态功能 命名空间命名空间也被称作上下文。顾名思义，它可以看作一段程序执行的语境，它影响符号的含义。附带的笔记本中，在不同单元中多次出现符号x，但它们之间没有任何关联，也不会互相干扰。这是由于该笔记本默认在每个单元编组都使用独立的上下文。通过计算$Context获取当前上下文，可以得到一个形如Cell$$nnnn`的上下文名称。事实上，Wolfram语言中任何符号的全名都包括两个部分：上下文和短名。全名的典型形式是context`short。其中，符号`在Wolfram语言中被称为上下文标记，它是符号全名的一部分，在使用时又有些类似文件系统中的路径分隔符/或\\。正如我们在命令行环境下键入程序不需要完整的路径，系统会自动在PATH环境变量指定的路径中搜索，在Wolfram语言中的如果只键入符号短名的话，系统首先会在$ContextPath指定的上下文中搜索，如果在既有上下文中找不到该符号，才会在当前上下文中创建一个以此为短名的新符号。上下文的应用通常和程序包联系在一起，以减少不同程序包间可能的符号冲突。因而在Wolfram语言中有两组典型的方式来开启一个上下文环境：一组是Begin[&quot;context`&quot;]和End[]；另一组是BeginPackage[&quot;context`&quot;]和EndPackage[]。下面的代码简单演示了两者对上下文环境的作用12345678910111213Print[\"0:\", $Context, \"|\", $ContextPath]BeginPackage[\"test`\"]; Print[\"1:\", $Context, \"|\", $ContextPath] Begin[\"test1`\"]; Print[\"2:\", $Context, \"|\", $ContextPath] End[]; Print[\"3:\", $Context, \"|\", $ContextPath] Begin[\"`test2`\"]; Print[\"4:\", $Context, \"|\", $ContextPath] End[]; Print[\"5:\", $Context, \"|\", $ContextPath]EndPackage[];Print[\"6:\", $Context, \"|\", $ContextPath]123456789101112130:Cell$$nnnn&#96;|&#123;Cell$$nnnn&#96;,System&#96;&#125;1:test&#96;|&#123;test&#96;,System&#96;&#125;2:test1&#96;|&#123;test&#96;,System&#96;&#125;3:test&#96;|&#123;test&#96;,System&#96;&#125;4:test&#96;test2&#96;|&#123;test&#96;,System&#96;&#125;5:test&#96;|&#123;test&#96;,System&#96;&#125;6:Cell$$nnnn&#96;|&#123;test&#96;,Cell$$nnnn&#96;,System&#96;&#125;可以看到，Begin-End所产生的作用比较纯粹，就是在其作用的范围内改变当前上下文$Context，而对$ContextPath毫无影响。相对地，BeginPackage-EndPackage则有几项副作用，它除了在作用范围内改变$Context和$ContextPath外，在使用EndPackage[]离开其作用范围时不仅将$Context和$ContextPath复原，而且会将还原前的上下文添加到$ContextPath中，从而方便我们直接使用导入包中的符号。在实际的程序包开发中，这两种结构一般都会用到。比如在Mathematica自带示例程序包ExampleData/Collatz.m中有如下代码123456789101112131415161718BeginPackage[\"Collatz`\"]Collatz::usage = \"Collatz[n] gives a list of the iterates in the 3n+1 problem, starting from n. The conjecture is that this sequence always terminates.\"Begin[\"`Private`\"]Collatz[1] := &#123;1&#125;Collatz[n_Integer] := Prepend[Collatz[3 n + 1], n] /; OddQ[n] &amp;&amp; n &gt; 0Collatz[n_Integer] := Prepend[Collatz[n/2], n] /; EvenQ[n] &amp;&amp; n &gt; 0End[ ]EndPackage[ ]这个例子中我们可以看到一个程序包典型的上下文结构安排。BeginPackage-EndPackage主要用于引入接口性质的符号，而具体实现部分则往往置于Begin-End结构中以尽可能避免符号污染。思考题7：x和`x之间有什么区别？运行下面两段代码，观察结果。思考并理解`的含义。12345x = 1;Begin[\"`test`\"];x = 2;&#123;Context[], Context[x]&#125;End[];12345`x = 1;Begin[\"`test`\"];`x = 2;End[];&#123;`x, `test`x&#125;延伸阅读：上下文、上下文和程序包、建立 Wolfram 语言程序包、对不同的笔记本自动使用独立的上下文环境、处理符号名称遮盖的问题相关代码交互见 笔记本。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"语法","slug":"语法","permalink":"http://miroox.github.io/blog/tags/%E8%AF%AD%E6%B3%95/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"}]},{"title":"理解Wolfram语言（上）","slug":"UnderstandWolframLang-I","date":"2018-06-04T06:02:10.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2018/06/UnderstandWolframLang-I/","link":"","permalink":"http://miroox.github.io/blog/2018/06/UnderstandWolframLang-I/","excerpt":"“一切皆表达式”Everything is an expression.是的，理解了上面这句话，就基本理解了Wolfram语言。至于其它的，那都是细枝末节。","text":"“一切皆表达式”Everything is an expression.是的，理解了上面这句话，就基本理解了Wolfram语言。至于其它的，那都是细枝末节。当然，想要理解这句话，首先要明白Wolfram语言里的表达式是什么。典型地，f[x,y] 就是一个表达式，它由一个头部 f，以及两个项 x 和 y 构成。通常，我们会用 f[x,y] 来表示一个函数 f(x,y)f(x,y)f(x,y)，但同时，这种形式也代表了Wolfram语言里表达式的一般结构。一般的，表达式由头部和项组成，而头部和项同样也是表达式。这种结构不仅可以用来表示函数，它也可以用来表示列表、图形、动态控件，甚至是笔记本。表达式的这种灵活性为Wolfram语言语法的高度一致性，在理解了这种一致性的基础上，再去看Wolfram语言的各种行为，就会变得好理解很多。再举几个例子(通过FullForm可以获得一个表达式的完整形式)：算术表达式列表图形非符号头部的表达式按钮控件笔记本对象（输出仅供参考） 对象是结构化的表达式前面提到了Wolfram语言表达式的一般结构，即：一个表达式由头部和若干项构成，而头部和项同样也是表达式，直到某个不可再分的原子对象，比如数字、字符串和符号。在最初的例子里，f[x,y]中，头部f，项x，y都是符号。而对于更复杂的表达式，往往有较深的层次和较多的子项，但如果掌握了一些方法（比如 善用 TreeForm），分析一个表达式的结构并不困难。理解了表达式的结构，以及Wolfram语言的这种一致性，那么Wolfram语言的很多设计与行为就好理解了。比如，列表的下标为何从1开始？因为本质上，运算符[[...]]提供的是按索引获取表达式各个项的一般方法，而作为语言一致性的表现，[[0]]获取的是表达式的头部。因此，对任何列表，获取“下标”为0的部分得到的结果都会是List。同样，像1[[0]]这种在别的语言的使用者眼里看起来莫名奇妙的表达式，在Wolfram语言中是完全正确的（当然，我们推荐使用语义更清晰的Head[1]进行表达）。事实上，不仅仅是[[...]]，有相当一部分的列表操作可以以完全一致的行为用在任何表达式上，例如Length、Cases、Sort、Map……掌握好这些函数，在面对很多问题的时候都会有所帮助。而表达式的这种结构特性使得它可以承载并组织各种各样的信息。自然而然地，我们可以使用表达式来表示对象。作为展示“对象是结构化的表达式”的例子，再来看一个有趣的小trick：上面这个例子实际展示了Plot 函数在绘图时是如何进行抽样的。而方法也很简单，只是把图中的线段替换为点。而这种操作之所以可行，也是表达式一致性的体现。在这里，函数Plot输出的图形实际是一个Graphics 对象，从构成上看，无非就是包含一些图形基元和图形指令的Graphics表达式，只要将连接点的Line替换为不连接的Point就可以显示出那些抽样点了。 小结“一切皆表达式”是Wolfram语言语法的核心。Wolfram语言用表达式来表示算式、数据、图形、控件等等。而掌握了表达式的结构，对Wolfram语言里的各种对象、操作都会有更清晰准确地认识。在下篇里，将会讲到Wolfram语言中表达式的另一个重点——表达式的计算，以及我们如何控制计算。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"语法","slug":"语法","permalink":"http://miroox.github.io/blog/tags/%E8%AF%AD%E6%B3%95/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"}]},{"title":"解除GitHub仓库的Fork连接","slug":"2018-5-19-RemoveGitHubFork","date":"2018-05-19T15:45:10.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2018/05/2018-5-19-RemoveGitHubFork/","link":"","permalink":"http://miroox.github.io/blog/2018/05/2018-5-19-RemoveGitHubFork/","excerpt":"这是一篇灌水文。GitHub的Fork功能实际上主要是服务于Pull Request，然而我以前并没有正确地认识到这一点，简单地把Fork当clone使，导致有些时候不太方便。比如生成这个博客的仓库，以前是直接Forkleopardpan的博客得到的。现在我想解除这种Fork关系，但同时保留提交的历史。然而在网上却没有找到有关的教程，没办法，只能自己试试。","text":"这是一篇灌水文。GitHub的Fork功能实际上主要是服务于Pull Request，然而我以前并没有正确地认识到这一点，简单地把Fork当clone使，导致有些时候不太方便。比如生成这个博客的仓库，以前是直接Forkleopardpan的博客得到的。现在我想解除这种Fork关系，但同时保留提交的历史。然而在网上却没有找到有关的教程，没办法，只能自己试试。实际做起来却意外的简单。首先，把删去所有与本地仓库连接的远程仓库12$ git remote remove origin$ git remote remove upstream然后，把GitHub上自己的远程仓库给删了。最后，在GitHub上重新建立同名仓库，然后把本地仓库关联上去。1$ git remote add origin &lt;your repo&gt;于是就大功告成了。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://miroox.github.io/blog/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://miroox.github.io/blog/tags/GitHub/"}]},{"title":"中国古代有没有科学？辩论材料","slug":"DebateOfScienceInAncientChina","date":"2018-04-14T14:13:22.000Z","updated":"2021-06-03T12:28:24.000Z","comments":true,"path":"2018/04/DebateOfScienceInAncientChina/","link":"","permalink":"http://miroox.github.io/blog/2018/04/DebateOfScienceInAncientChina/","excerpt":"核心论点：中国古代没有科学","text":"核心论点：中国古代没有科学 立论论点与依据首先要达成关于科学是什么的共识。如果这一层的基本共识没有达成，所有的辩驳都如图对牛弹琴。因此这本质上是一个划界的问题——科学的边界在哪里？划分边界的依据——知识？知识有其时效性，知识的正确性无法保证。划分边界的依据——方法？科学哲学家们在这方面做了大量探索（逻辑实证主义、否证主义、范式结构、研究纲领等等），但并没有形成定论。“不存在这样一种关于科学和科学方法的普遍主张，使得它可以适用于所有科学和科学发展的所有历史阶段。”划分边界的依据——社会建制？这个观点倒是无可厚非，但和我们的一般认识相差较远，而且似乎也不太好操作。近代意义上的科学，始于由哥白尼揭开序幕，伽利略作为先锋，牛顿推向最高潮的近代科学革命。论据核心：近现代科学是“科学”的概念核心。允许有外延但不应无限制的扩张。这场革命不仅产生了我们现代意义上的科学知识（例如：自由落体定律、牛顿运动定律），更重要的是它带来了自然哲学界研究范式的转换，使得实验方法逐渐取代亚里士多德的自然主义思想成为主流。而作为“科学”而使用的 science 一词当时还尚未诞生，那时人们研究的还是 natural philosophy ，也就是所谓的“自然哲学”。我们将其称之为“科学”一定程度上也只是后人的附会。这并不意味这自然哲学就是科学。概念的演化是渐变的，但并不意味着两者就是同一的。相反，这场革命恰恰标志着哲学与科学开始逐渐分野。从这个意义上说，不仅中国古代没有科学，西方“古代”（中世纪前）也没有科学。或者说，“科学”本身就是近代才发生的概念，为什么一定要将它套用到古代的知识上去呢？一般我们不会把炼金术、占星术和巫医划分为科学，尽管它们很大程度上就是某些科学的前身。基于同样的立场，我们也不应该认为中国古代存在科学。是否犯了时代误植，乃至辉格史观的问题？科学本身就是近代才发生的概念。毋宁说把早期自然哲学这些划为科学才是某种时代误植。科学≠正确，我这里阐述的主要是概念的一致性问题，并不意味着炼金术这些在当时那个时代是荒谬愚蠢的。退一步说，即使不认为西方古代没有科学，从源流的角度讲，中国古代也与近现代科学并无多少瓜葛。相对的，西方古代有着较明显的学科沿袭，即某些前科学逐渐向科学演化的过程。而中国近代的科学，大抵都是从西方接收过来的，而非自发地由某些前科学性质的学科向科学转换。前科学到科学的演化：自然哲学 → 科学（物理）占星术 → 天文学炼金术 → 化学……由于历史不能重演，所以也无法证明如果西方没有打开中国的国门，中国是否会自发地发生这种转换。 驳论可能的切入点概念泛化：无端地扩大概念的范畴或外延，而缺乏适当的依据。时代误植：只使用现代视角解读历史，理所当然地将现代的认知移植到古人身上。辉格史观：时代误植的延伸——凡是和现在一致的就是好的，凡是和现在不一致的就是愚蠢的。滥用比喻：“思想家的危险就是给比喻诱惑得忘记了被比喻的原物，把比喻上生发出来的理论认为适用于被比喻的原物。”预觉神话：神话本身是中立的，但它往往带有立场和偏见。典型：阴阳八卦的结构启发了二进制的发明。李约瑟的立场：去欧洲中心化思潮，基督徒（博爱主义），道家思想的信奉者。","categories":[{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miroox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://miroox.github.io/blog/tags/%E5%93%B2%E5%AD%A6/"},{"name":"科学哲学","slug":"科学哲学","permalink":"http://miroox.github.io/blog/tags/%E7%A7%91%E5%AD%A6%E5%93%B2%E5%AD%A6/"}]},{"title":"C/C++的一些常见的坑(1)","slug":"TrapInCCpp-1","date":"2017-11-17T16:12:34.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2017/11/TrapInCCpp-1/","link":"","permalink":"http://miroox.github.io/blog/2017/11/TrapInCCpp-1/","excerpt":"根据个人经验和见闻总结而来。主要涉及C和C++语法和语义方面的一些陷阱。","text":"根据个人经验和见闻总结而来。主要涉及C和C++语法和语义方面的一些陷阱。 求值顺序在著名的《谭C》教材的误导下，中国学生对表达式的求值顺序的误解可能是最深的。首先要明确地是，运算符对运算数的求值顺序与运算符的结合性没有任何关系，而且，无论是C语言还是C++，几乎所有运算符对运算数进行求值的顺序都是 未指定的，甚至在某些情况下会构成 未定义行为。另一方面，C和C++在这方面的规定较为复杂，而且随着标准版本的变化，相关概念也有较大的变化。因此，除非你自认为自己对这方面的规定十分清楚，我建议尽量让程序里的每一个表达式保持结构简单，尤其避免在一个表达式对同一个对象里产生超过一次 副作用。这不光可以避免未定义行为或者未指定行为，也有助于增强程序的可读性。例如：123456789//badi = ++i + i++; // C 和 C++ 中都为未定义的行为i = ++i + 1; // C 中始终为未定义行为；C++11 前为未定义的行为f(i = -2, i = -2); // C 中始终为未定义行为；C++17 前为未定义的行为a[i] = i++; // C 中始终为未定义行为；C++17 前为未定义的行为1234567891011//good//i = ++i + i++; // what does the coder want to do?i = i + 2;i = -2;f(i, i);++i;a[i] = i;参见 C：求值顺序、C++：求值顺序 字符常量/字面量的类型简而言之，C语言中无前缀修饰的 字符常量 的类型是 int ；而C++中无前缀修饰的 字符字面量 的类型默认是 char （除非字符在执行字符集中无法用单字节表示，这时其类型为 int ）。是的，在 C 和 C++ 里他们的叫法都不同。C 把嵌入代码的常量值称为 常量 或 字面量 ，其中 常量 是 右值表达式， 字面量 是 左值表达式 ；而 C++ 中统称为 字面量 。其它编码的字符常量/字面量的具体内容参见下面的链接。参见：C：字符常量、C++：字符字面量 数组指代器不是指针常量同样是受《谭C》等一批国内教科书的毒害，有不少人认为数组就是指针常量。但实际上数组的类型就是数组类型，只是使用时大多数情况下会隐式转换成其首元素指针的 非左值 。正因为这种转换的存在，所以我们才能像指针一般使用数组，又因为其结果是非左值，所以不可以被赋值。但另一方面，在C语言中，函数参数列表中的数组声明，在对应的函数调用时其实际参数的值是一个指针。（可以说是C的一个黑点了）详细的转换规则见下面的链接。参见：C：数组到指针转换、C++：数组到指针转换 static 储存类指定符之所以写这一条，是因为听说有驱动程序把以 static 修饰的对象定义在头文件里导致内存爆炸的传闻。这么看 static 确实有一些坑，无论是C语言还是C++，作为储存类指定符的 static 都具有多重语义，而且在不同情况下含义不尽相同。简洁起见，这里不考虑与 thread_local（或者 _Thread_local ）组合的情况；标识符（C）和名称（C++）统称为名称。首先要明确的是，储存类指定符都包含两层内涵，一是指定 对象 的 储存期 ，一是指定 名称 的 链接 。这是两个层次的内涵，也是很多初学者比较模糊的。一方面，被 static 修饰的对象拥有 静态储存期 ，该对象生存期基本和整个程序一样长；另一方面，被 static 修饰的名称通常为 内部链接 ，即该名称的只在当前的翻译单元可被引用；除非被 static 修饰的是一个局部变量，那么它（的名称）的链接为 无链接 ，即该名称只能在它所在的作用域中被引用。可以看出，static 确实可以让我们在头文件里定义函数或者对象而不引发重定义错误，因为包含一个头文件就是把整个头文件复制到源文件里，那么在每一个包含该头文件的源文件里都有一个被 static 修饰的对象/函数，它们虽然具有同样的名称，但由于所用是内部链接，所以它们指代的是（各自翻译单元的）不同实体，因而在内存受限的设备上大量包含这样的头文件就有可能导致内存爆炸。还要注意的一点是，对于C，无论是全局还是块作用域中的静态对象，其初始化器必须为常量表达式，且初始化发生于主函数前。而对于C++，静态局部变量的可以不用常量表达式初始化，而且可能等到控制流首次经过其声明时才初始化。（注1：对于C++，类中的 static 声明代表不绑定到类实例的 静态成员 ）（注2：C99后 static 还可能用于函数声明中的 静态数组下标 ）参考：C：存储类指定符、C++：存储类指定符、C：静态初始化器、C++：静态初始化、C++：静态局部变量 某些整数运算的坑懒得写了，见 @孙明琦 的 整理一发C++整数运算的所有细节 main 函数的原型著名语言律师 @幻の上帝 对此 早有论述。这里只摘录一下主要结论：void main() 在 C 仍然可以是符合标准(conforming)的扩展；在 C++ 中不返回 int 的 main 直接不符合标准。参见 C：主函数、C++：主函数 volatile 类型限定符volatile 大概是被误解最多的 C/C++ 语言特性之一。简而言之，volatile 只是代表 读副作用 ，与什么 多线程、 原子性 以及 memory barrier 都没什么关系（尽管 MSVC 提供了额外的语义使之可以用于多线程编程，但这种特性不可移植，不推荐使用）。而 volatile 本来的意图主要是用于模拟映射于内存的硬件I/O，以及信号处理函数。（注：Java 里的 volatile 具有原子访问的语义。）参见 C：volatile 类型限定符、C++：cv 类型限定符、MSDN：volatile、C：信号处理函数、C++：如同规则应该会有下一篇的，大概。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"参考","slug":"参考","permalink":"http://miroox.github.io/blog/tags/%E5%8F%82%E8%80%83/"},{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C语言","slug":"C语言","permalink":"http://miroox.github.io/blog/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://miroox.github.io/blog/tags/C/"},{"name":"语法","slug":"语法","permalink":"http://miroox.github.io/blog/tags/%E8%AF%AD%E6%B3%95/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miroox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"基于改进的Chirikov映射的彩色图像加密算法","slug":"ImageEncryptImprovedChirikovMap","date":"2017-10-18T15:10:11.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2017/10/ImageEncryptImprovedChirikovMap/","link":"","permalink":"http://miroox.github.io/blog/2017/10/ImageEncryptImprovedChirikovMap/","excerpt":"项目见 GitHub摘要：基于改进的Chirikov映射来实现一种彩色图像加密的算法。该方法通过在Chirikov映射中增加一个参数来增加算法的随机性。采用像素数据置乱的方法实现图像加密。并进行了一些数值仿真来验证加密方案的性能。关键词：图像加密；混沌映射；数据安全","text":"项目见 GitHub摘要：基于改进的Chirikov映射来实现一种彩色图像加密的算法。该方法通过在Chirikov映射中增加一个参数来增加算法的随机性。采用像素数据置乱的方法实现图像加密。并进行了一些数值仿真来验证加密方案的性能。关键词：图像加密；混沌映射；数据安全 1.引言随着网络的普及，数据的流通越来越方便，数据安全形势也变得越来越严峻。计算机技术的发展也得使数据（例如文本、图像）加密变得简单。密码编码学和密码分析学应运而生，成为了两个相互对立又相互促进的学科。图像加密的方法有多种，其中一类是数字加密技术，另一类是光学加密技术。数字加密技术一般是基于伪随机数，通过逻辑运算或者代数运算得到随机数据。数字图像加密技术又分空间置乱和像素变换技术。 2.研究方法空间置乱技术通过改变像素的空间位置，将原始图像变成一个杂乱无序、不可见的新图像。基于置乱技术的图像加密技术一般可以认为是对图像矩阵进行有限步长的初等矩阵转换，以此打乱图像像素的排列位置，达到图像加密的目的。像素变换技术则改变图像灰度值的大小，重新生成一幅图像。通常采用伪随机数对原图像进行逻辑运算以获得加密图像。混沌映射是产生伪随机数的方法之一，因其对初值和参数具有高度的敏感性，不易破解，适用于各种加密场合，常用的映射有Logistic映射。本文采用了改进后的Chirikov映射作为随机数的来源，并综合应用了置乱的技术。 2.1 Chirikov变换及其改进Chirikov标准映射表达式为：(xn+1yn+1)=((ksin⁡yn+xn)mod 2π(xn+1+yn)mod 2π)\\begin{pmatrix} x_{n+1} \\\\ y_{n+1} \\end{pmatrix}= \\begin{pmatrix} (k\\sin y_n+x_n)\\mod 2\\pi\\\\ (x_{n+1}+y_n)\\mod 2\\pi \\end{pmatrix}(xn+1​yn+1​​)=((ksinyn​+xn​)mod2π(xn+1​+yn​)mod2π​)包含有一个 kkk 参数.k=0.5k=0.5k=0.5k=1.2k=1.2k=1.2k=4.5k=4.5k=4.5k=6.5k=6.5k=6.5k=8.2k=8.2k=8.2k=10k=10k=10不同参数 kkk 对应的映射的迭代轨迹从映射图像可以看出，只有当 kkk 的大小超过某一阈值后，映射才会变得混沌，均匀充满整个相空间。为此，我们在其中添加了一个参数 hhh ，增加了混沌映射输入参数的任意性。改进后的Chirikov映射表达式：(xn+1yn+1)=((ksin⁡yn+xn)mod 2π(xn+1+hyn)mod 2π)\\begin{pmatrix} x_{n+1} \\\\ y_{n+1} \\end{pmatrix}= \\begin{pmatrix} (k\\sin y_n+x_n)\\mod 2\\pi\\\\ (x_{n+1}+hy_n)\\mod 2\\pi \\end{pmatrix}(xn+1​yn+1​​)=((ksinyn​+xn​)mod2π(xn+1​+hyn​)mod2π​)包含了 kkk 和 hhh 两个参数.h=1h=1h=1 k=2k=2k=2h=1.5h=1.5h=1.5 k=0.5k=0.5k=0.5h=1.5h=1.5h=1.5 k=2k=2k=2h=2h=2h=2 k=0.5k=0.5k=0.5h=2h=2h=2 k=0.5k=0.5k=0.5h=2h=2h=2 k=1k=1k=1h=2h=2h=2 k=1k=1k=1h=3.5h=3.5h=3.5 k=1k=1k=1h=3.5h=3.5h=3.5 k=2k=2k=2不同 hhh、kkk 参数对应的映射的迭代轨迹 2.2 用于图像加密基本算法将改进的Chirikov映射用于彩色图像加密的大致流程：①读入图片与密钥；②将密钥代表的参数映射到合适的范围内；③读取图片的像素数据成一个[行,列,RGB]的三维数组，并将每个R或G或B值转换成8位的bit array，然后将其展平为长度为 NNN 的一维数组；④用第②步生成的参数，使用改进的Chirikov映射生成一个充分长的序对 (x,y)(x,y)(x,y) 列表并线性地扩充为 n×Nn\\times Nn×N 的整型序对列表；⑤对第③步生成的一维数组进行置乱，使用上一步生成的序对列表中的 xxx 和 yyy 作为需要交换的数据的位置依次置换；⑥从上一步置换完的数据中重新还原成图片。解密流程和加密流程基本一致，只是在上述第③步后对整个数组进行反向排序。下面是上述流程中进行一维数组置乱部分的Mathematica代码：123456789101112(*shuffle list with improved chirikov map*)(*parameters: k, h, x, y, source-data*)encryptShuffle=Compile[&#123; &#123;k,_Real&#125;,&#123;h,_Real&#125;,&#123;x,_Real&#125;,&#123;y,_Real&#125;,&#123;source,_Integer,1&#125; &#125;,Block[&#123;data,pos&#125;,data=source; pos=(NestList[ (*nest to generate a list of the position need to shuttle*) Mod[#[[2]]+k Sin[#[[1]]]+&#123;h #[[1]],0&#125;,2. Pi]&amp;, (*improved Chirikov map*) &#123;x,y&#125;,2*Length[data] ]*Length[data]/(2 Pi)) (*normalize*) //Ceiling (*take integer part*); Scan[(data[[#]]=data[[Reverse@#]])&amp;,pos,1]; (*shuffle data*) data] (*return value: shuffled data*)]; 3.数值模拟原图像加密图像解密图像原图像素和加密像素分布直方图由直方图可以看出，加密算法将图片的像素分布均匀化，有效的增加了原图像素的熵值。基本排除通过加密图像就能看出原图像的大概轮廓的可能性。但对于常见的有损压缩（如JEPG），由于其会截去图像的高频分量，因而会导致加密图像损失大量信息，导致无法还原出原图像。 安全性测试保持其它参数不变，改变 hhh保持其它参数不变，改变 kkkMSE(means square error)为均方误差，表征原始图像与解密图像的差异。MSE=0时表示两图像相等。由上图可知，密钥参数取值范围进入到一个很小的区间（ 10 -15 数量级）时，才有可能将图片解密出来。这能有效防止对加密图像使用枚举遍历进行破解。 遮挡攻击测试被遮挡的加密图像对应的解密图像上表显示对应对加密图像不同遮挡面积的还原效果。遮挡方法是用绘图工具在加密图像上填充了一个多边形。当遮挡面积约为原图的25%时，解密图像与原图像间的MSE=0.039，视觉效果上仍能清楚分辨出与原图的形状、色彩信息。当遮挡面积约为原图的50%时，解密图像与原图像间的MSE=0.154，此时只能勉强看到原图的轮廓，色彩信息已不可辩。 4.结论我们基于Chirikov映射的改进算法设计了一种彩色图像加密方法，并对加密解密结果进行了安全性测试和鲁棒性测试，具有良好的加密效果。本方法的主要不足是未提出有效方法解决因压缩图像中数据丢失产生的解密失真问题，图像只能以无损格式储存。 参考文献[1] Mimoun Hamdi, Rhouma Rhouma, Safya Belghith, A Selective Compression-Encryption Of Images Based On SPIHT Coding and Chirikov Standard MAP, Signal Processing, http://dx.doi.org/10.1016/j.sigpro.2016.09.011[2] Yushu Zhang, Di Xiao, Double optical image encryption using discrete Chirikov standard map and chaos-based fractional random transform, Optics and Lasers in Engineering, http://dx.doi.org/10.1016/j.optlaseng.2012.11.001","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"图像加密","slug":"图像加密","permalink":"http://miroox.github.io/blog/tags/%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%AF%86/"},{"name":"图像处理","slug":"图像处理","permalink":"http://miroox.github.io/blog/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"混沌","slug":"混沌","permalink":"http://miroox.github.io/blog/tags/%E6%B7%B7%E6%B2%8C/"},{"name":"算法","slug":"算法","permalink":"http://miroox.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"使用Mathematica实现基于类的面向对象","slug":"ClassBasedOOPWithMma","date":"2017-09-01T15:54:41.000Z","updated":"2021-10-25T15:18:25.000Z","comments":true,"path":"2017/09/ClassBasedOOPWithMma/","link":"","permalink":"http://miroox.github.io/blog/2017/09/ClassBasedOOPWithMma/","excerpt":"Mathematica 通常被宣传为 符号式 、 函数式 的编程语言，不过 维基百科 宣称它支持 13种编程范式，其中还包括 面向对象 编程。尽管大家似乎都不把 Mathematica 当编程语言，不过出于兴趣，也为了提升对 Mathematica 语言特性和面向对象的理解，于是有了这篇文章。比较理想的情况是能够以类似 C++ 或者 Java 那样的形式来创建和使用类与对象，以此为目标进行设计。","text":"Mathematica 通常被宣传为 符号式 、 函数式 的编程语言，不过 维基百科 宣称它支持 13种编程范式，其中还包括 面向对象 编程。尽管大家似乎都不把 Mathematica 当编程语言，不过出于兴趣，也为了提升对 Mathematica 语言特性和面向对象的理解，于是有了这篇文章。比较理想的情况是能够以类似 C++ 或者 Java 那样的形式来创建和使用类与对象，以此为目标进行设计。首先考虑的当然是上网搜索，可惜网上的实现大多不完善，封装、继承、多态都不全。一番查找之下，这篇文章 给我的启发最大，让我确立了封装类的基本思路。而继承与多态受到 Lua 中利用元表来模拟继承的启发。（注：本文中提到的多态主要指 子类多态 ）好，废话不多说，先上代码。1234567891011121314151617181920212223242526272829303132333435363738394041(*nil*)SetAttributes[nil,ReadProtected];nil[___]=nil;(*default*)(*new*)SetAttributes[new,&#123;ReadProtected,HoldFirst&#125;];new[nil]=nil;(*type of*)SetAttributes[typeOf,ReadProtected];typeOf[obj_]:=If[Evaluate[obj@type]===nil,nil,obj@type,Head[obj]];(*to make sure every expression has a type*)(*classQ*)SetAttributes[classQ,ReadProtected];classQ[obj_]:=typeOf[obj]==class||typeOf[obj]==nil;(*nil is a special class*)(*class*)SetAttributes[class,&#123;ReadProtected,HoldAll&#125;];class[identifier_Symbol,&#123;privDecls___Symbol&#125;,body_]:=class[identifier,nil,&#123;privDecls&#125;,body];class[identifier_Symbol,baseClass_?classQ,&#123;privDecls___Symbol&#125;,body_]:=With[ &#123;className=SymbolName[identifier], upperClassName=StringReplace[SymbolName[identifier],StartOfString~~h_:&gt;ToUpperCase[h]]&#125;, SetAttributes[identifier,&#123;ReadProtected,HoldAll&#125;]; identifier@type=class; (*'type'Q*) SetAttributes[Evaluate[Symbol[className&lt;&gt;\"Q\"]],ReadProtected]; Evaluate[Symbol[className&lt;&gt;\"Q\"]][obj_]:=If[ obj[Evaluate[Symbol[\"is\"&lt;&gt;upperClassName]]], True,False,False ]; (*constructor*) new[identifier]:=Module[ &#123;$self,$base,privDecls&#125;, SetAttributes[$self,&#123;HoldAll,ReadProtected&#125;]; SetAttributes[$base,ReadProtected]; SetAttributes[#,ReadProtected]&amp;/@&#123;privDecls&#125;;(*encapsulation*) $base=new[baseClass];(*inheritance*) $self[mem_]:=$base@mem;(*polymorphism*) $self@type=identifier;(*type*) $self[Evaluate[Symbol[\"is\"&lt;&gt;upperClassName]]]=True;(*subtyping*) (*body*) ReleaseHold[Hold[body]/.&#123;self-&gt;$self,base-&gt;$base,public-&gt;$self&#125;]; $self(*reference semantics*) ];]在分析这些代码前，先来看一个简单的例子，看看如何做到封装继承多态。定义一个基类123456789class[testBase, &#123;text&#125;, (*initialize*) text=\"Base\"; (*public method*) public@setText[str_String]:=(text=str); public@getText[]:=text; public@print[]:=Print[\"This is base. The text is \"&lt;&gt;text]]再定义一个派生类1234class[testDerived,testBase, &#123;&#125;, public@print[]:=Print[\"This is derived. The text is \"&lt;&gt;self@getText[]]]最后定义一个（带类型约束的）测试函数（注：testBaseQ 由 class 自动生成）1testFun[obj_?testBaseQ]:=obj@print[];对于一个基类对象执行12obj1=new[testBase];testFun[obj1]会输出1This is base. The text is Base而对于一个派生类对象执行123obj2=new[testDerived];obj2@setText[\"Derived\"];testFun[obj2]则会输出1This is derived. The text is Derived可以看到，之前提到的目标基本已经满足了。封装继承多态都有，形式和 C++ 、Java 也很相似。下面大致分析它的实现方式。首先，随处可见的 SetAttributes[_,ReadProtected] 只是为了在包装成函数包后让实现对外不可见，不是重点。然后看代码的开始，定义了一个 nil 。它的定位大概类似于 C++ 中的 nullptr ，表示一个“空”对象。略有不同的是， nil 既是对象又是类型，这是 Mathematica 符号式编程的优势。1nil[___]=nil;(*default*)这段代码表示的是 nil 的任何方法得到的结果都是 nil 。结合后面利用责任链模式（见后文）实现的多态，这里事实上给所有对象的方法提供了一个缺省的实现。也就是说，如果一个对象调用了一个不存在的方法，那么它得到的结果就是 nil 。这比 Mathematica 本身默认以保持符号形式不变的方法具有更清晰的类型语义。接下来是 new 。设计上，它的意义同 C++ 基本是一致的。1new[nil]=nil;这段代码的目的和前面差不多，也是责任链传递的底端。而后是 typeOf ，一个获取类型的辅助函数。由于 Mathematica 的动态性，它可以对应于 C++ 中的 decltype() 或者 typeof() 。1typeOf[obj_]:=If[Evaluate[obj@type]===nil,nil,obj@type,Head[obj]];(*to make sure every expression has a type*)正如后面的注释所述，最后的 Head[obj] 只是为了保证任何表达式都能有一个类型。注意使用时尽量不要用它来约束类型。至于这里为什么要用 Evaluate ，读者不妨自己想想。接着是 classQ ，同样也是个类型判断的辅助类，用于约束 class 的参数。1classQ[obj_]:=typeOf[obj]==class||typeOf[obj]==nil;(*nil is a special class*)读者不妨想想我为什么要把 nil 也视作类。然后终于进入正题 class 了。1class[identifier_Symbol,&#123;privDecls___Symbol&#125;,body_]:=class[identifier,nil,&#123;privDecls&#125;,body];这句没什么好说的，给不做任何继承的类提供一个默认参数。中间略过一些细枝末节，直接看到 (*'type'Q*) 那里。1234Evaluate[Symbol[className&lt;&gt;\"Q\"]][obj_]:=If[ obj[Evaluate[Symbol[\"is\"&lt;&gt;upperClassName]]], True,False,False];同样是利用 Mathematica 的动态性，自动生成一个多态的类型测试函数。注意 If 最后一项 False 使得它的行为更为确定。然后是最为核心的 new 函数的特化（这个词从 C++ 里来，我觉得这么说更有表现力）。Module 开始声明了这几个局部变量1&#123;$self,$base,privDecls&#125;,$ 开头约定为内部符号，避免名称冲突。$self 即要创建的对象实例自身，new 最后返回的就是它。由于从模块返回的就是它，因而它的生存期会被延长（参见 属性 Temporary ）。受它影响，那些间接被 $self 引用的对象生存期也会延长，这就是利用 Module 封装对象属性的机理。$base 是基类对象。用于实现继承机制。privDecls 即用户定义的私有成员，注意它是 class 传参进来的，这似乎可以限制 Module 的自动改名能力。12$base=new[baseClass];(*inheritance*)$self[mem_]:=$base@mem;(*polymorphism*)这两段就是实现继承多态的核心部分。学过设计模式的话很容易可以看出这其实就是一种 责任链模式 。责任链模式简单的说就是向一条候选的对象链发出请求，根据请求以及运行时的情况决定一个对象是响应请求还是将其传递给下一级。在这里，就是将 $self 处理不了的成员调用传递给 $base 从而实现继承。而对于基类定义过的方法，在派生类中重写即可实现多态（准确地说，还需要类型约束）。1$self@type=identifier;(*type*)没什么好说的。1$self[Evaluate[Symbol[\"is\"&lt;&gt;upperClassName]]]=True;(*subtyping*)这条就是 'type'Q 的实现部分。注意它也是 $self 的成员，也就是继承的部分。也就是说一个派生类对象一定也会满足基类的类型测试函数。藉此，一套完整的子类多态就实现了。最后是类定义的主体。1ReleaseHold[Hold[body]/.&#123;self-&gt;$self,base-&gt;$base,public-&gt;$self&#125;];由于 ReplaceAll 没有任何 Hold 系列属性，因此替换前需要 Hold 。public-&gt;$self 就是一个语法糖。1$self(*reference semantics*)new 最后返回 $self ，因此赋值操作，如 obj=new[object] 只是让 obj 成了一个指向 $self 的引用。也就如大家知道的那样，面向对象编程使用的大多是引用语义而不是值语义，这点需要注意。还有一点值得注意的是，继承只继承公有部分，即使你是以 public@privMethod 的形式（其中 privMethod 在 privDecls 中声明了）定义的，因为你无法在外部获取被模块改名了的 privMethod ）结语略。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"功能模拟","slug":"功能模拟","permalink":"http://miroox.github.io/blog/tags/%E5%8A%9F%E8%83%BD%E6%A8%A1%E6%8B%9F/"},{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"},{"name":"元编程","slug":"元编程","permalink":"http://miroox.github.io/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"}]},{"title":"基于Qt实现类似Notepad++的标签页拖放功能","slug":"DnDTabWithQt","date":"2017-08-16T03:31:23.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2017/08/DnDTabWithQt/","link":"","permalink":"http://miroox.github.io/blog/2017/08/DnDTabWithQt/","excerpt":"在我的常用软件中，Google Chrome 和 Notepad++ 都可以做到拖拽标签页在标签栏移动，在两个窗口间移动，以及创建新的窗口。作为 这个项目 的一部分，打算实现一个功能类似的 Tab Widget 。","text":"在我的常用软件中，Google Chrome 和 Notepad++ 都可以做到拖拽标签页在标签栏移动，在两个窗口间移动，以及创建新的窗口。作为 这个项目 的一部分，打算实现一个功能类似的 Tab Widget 。 设计目标Google Chrome 和 Notepad++ 的拖放标签页功能基本上是类似的，但细节上也略有差别Google ChromeNotepad++标签栏内移动标签时是平滑过渡的标签栏内移动标签时没有过渡动画两个窗口间移动根据释放的位置插入到标签栏两窗口间移动只是简单附加到标签栏最后标签移动到标签栏外立即产生一个新窗口在 Notepad++ 窗口外释放鼠标产生一个新窗口移动产生的新窗口不是独立的进程移动产生的新窗口是独立的进程可以看出 Google Chrome 和 Notepad++ 功能上各有千秋，综合一下两者各自的优点并考虑可实现性，基本的设计目标为：在标签栏内移动标签可以改变标签的顺序，且是平滑过渡。（事实上 Qt 自带的 QTabWidget 在 setMovable(true) 后就是这种效果。）在两窗口间移动时，如果释放点在标签栏上，就根据释放的位置插入标签栏，否则附加到标签栏的最后。拖拽标签到主窗口外释放鼠标产生一个新窗口，且新窗口是独立的进程。如果新窗口不是独立的进程，那问题就简化了一大半，而且这样的例子网上也有很多，如：QTabWidget 实现类似QQ聊天窗口 ）当然，我们还需要一个具体的情境。出于简单考虑，以多文档浏览器为例，使用只读的 QTextBrowser 作为标签页，其 source 属性还可以用来保存文件路径，十分便利。 设计思路及实践过程显然，设计目标1是很容易满足的，只要 tabWidget-&gt;setMovable(true) ，因此把重点放在目标2、3上。首先想到的当然是参考现有的源码，考虑到 Chromium 太过复杂，于是选择参考了 Notepad++ 的 源码 然而发现里面依赖于一些诸如 ::WindowFromPoint() 、::GetClassName() 之类的Win32函数，旋即放弃了这条道路。考虑将目标的问题分解。基本的，移动这个操作实际上是创建和删除的复合。对于 QTabWidget ，虽然提供了QTabWidget::addTab() 、QTabWidget::insertTab() 之类的创建函数，但 QTabWidget::removeTab() 并不实际上销毁对应的页面，因此还需要一个确实能删除标签页的函数。定义 QTabWidget 的子类 MyTabWidget（以下所有代码中的省略号 ... 都表示我们目前不关心这些部分，其细节将在后面逐渐补全）123456789101112131415161718//mytabwidget.h#ifndef MYTABWIDGET_H#define MYTABWIDGET_H#include &lt;QTabWidget&gt;class MyTabWidget : public QTabWidget&#123; Q_OBJECTpublic: MyTabWidget(QWidget * parent = Q_NULLPTR); ~MyTabWidget() &#123;&#125; void removeTabActually(int index); ...&#125;;#endif // MYTABWIDGET_H实现删除标签页的方法1234567891011//mytabwidget.cpp#include \"mytabwidget.h\"...void MyTabWidget::removeTabActually(int index)&#123; widget(index)-&gt;deleteLater(); removeTab(index);&#125;...虽然现在看上去没有必要派生一个新类 MyTabWidget ，但这个类在后面还会有其它用途。接下来考虑拖放如何传递数据。最容易想到的当然是 QDrag ，而且我们知道文本编辑器通常通过传递 URLs 来实现拖放打开文件。类似地，我们也可以借助 URL 来传递拖放标签页的信息。由于目标2中对释放点在标签栏上和其它地方有不同要求，因此对标签栏和主窗口分别重新实现 dragEnterEvent() 和 dropEvent() 。主窗口很容易处理12345678910111213141516171819202122232425//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;class QString;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: explicit MainWindow(QWidget *parent = 0); ~MainWindow() &#123;&#125; void openFile(QString fileName); void openFileAt(QString fileName, int tabIndex); ...protected: void dragEnterEvent(QDragEnterEvent *event) override; void dropEvent(QDropEvent *event) override; ...&#125;;#endif // MAINWINDOW_H123456789101112131415161718192021222324252627282930313233343536373839//mainwindow.cpp#include \"mainwindow.h\"#include \"mytabwidget.h\"#include &lt;QUrl&gt;#include &lt;QMimeData&gt;#include &lt;QDragEnterEvent&gt;#include &lt;QDropEvent&gt;...MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; ... setAcceptDrops(true); ...&#125;...void MainWindow::dragEnterEvent(QDragEnterEvent *event)&#123; if(event-&gt;mimeData()-&gt;hasUrls()) event-&gt;acceptProposedAction(); else event-&gt;ignore();&#125;void MainWindow::dropEvent(QDropEvent *event)&#123; const QMimeData * mimeData = event-&gt;mimeData(); if(mimeData-&gt;hasUrls()) &#123; for (const QUrl&amp; url : mimeData-&gt;urls()) &#123; openFile(url.toLocalFile()); &#125; event-&gt;acceptProposedAction(); &#125; else &#123; event-&gt;ignore(); &#125;&#125;而对于标签栏，借助 Qt 的信号-槽机制同样也不难实现1234567891011121314151617181920212223242526//mytabbar.h#ifndef MYTABBAR_H#define MYTABBAR_H#include &lt;QTabBar&gt;class QString;class MyTabBar : public QTabBar&#123; Q_OBJECTpublic: MyTabBar(QWidget * parent = Q_NULLPTR); ~MyTabBar() &#123;&#125;signals: void openFileRequest(QString/*fileName*/,int/*tabIndex*/); ...protected: void dragEnterEvent(QDragEnterEvent *event) override; void dropEvent(QDropEvent *event) override; ...&#125;;#endif // MYTABBAR_H1234567891011121314151617181920212223242526272829303132333435363738//mytabbar.cpp#include \"mytabbar.h\"#include &lt;QUrl&gt;#include &lt;QMimeData&gt;#include &lt;QDragEnterEvent&gt;#include &lt;QDropEvent&gt;MyTabBar::MyTabBar(QWidget *parent) : QTabBar(parent)&#123; setMovable(true); setAcceptDrops(true);&#125;...void MyTabBar::dragEnterEvent(QDragEnterEvent *event)&#123; if(event-&gt;mimeData()-&gt;hasUrls()) event-&gt;acceptProposedAction(); else event-&gt;ignore();&#125;void MyTabBar::dropEvent(QDropEvent *event)&#123; const QMimeData * mimeData = event-&gt;mimeData(); if(mimeData-&gt;hasUrls()) &#123; for (const QUrl&amp; url : mimeData-&gt;urls()) &#123; emit openFileRequest(url.toLocalFile(),tabAt(event-&gt;pos())); &#125; event-&gt;acceptProposedAction(); &#125; else &#123; event-&gt;ignore(); &#125;&#125;...注意到 MyTabBar 的信号 void MyTabBar::openFileRequest(QString/*fileName*/,int/*tabIndex*/) 与MainWindow 的函数 void MainWindow::openFileAt(QString fileName, int tabIndex) 间参数的对应关系，显然要将他们连接起来。不过在此之前，我们还需要 MyTabWidget 做一个中继，于是123456789101112131415161718192021//mytabwidget.h#ifndef MYTABWIDGET_H#define MYTABWIDGET_H#include &lt;QTabWidget&gt;class MyTabWidget : public QTabWidget&#123; Q_OBJECTpublic: MyTabWidget(QWidget * parent = Q_NULLPTR); ~MyTabWidget() &#123;&#125; void removeTabActually(int index);signals: void openFileRequest(QString/*fileName*/,int/*tabIndex*/); ...&#125;;#endif // MYTABWIDGET_H12345678910111213141516171819//mytabwidget.cpp#include \"mytabwidget.h\"#include \"mytabbar.h\"MyTabWidget::MyTabWidget(QWidget * parent) : QTabWidget(parent)&#123; auto mTabBar = new MyTabBar(this); setTabBar(mTabBar); connect(mTabBar,&amp;MyTabBar::openFileRequest,this,&amp;MyTabWidget::openFileRequest); ...&#125;void MyTabWidget::removeTabActually(int index)&#123; widget(index)-&gt;deleteLater(); removeTab(index);&#125;然后在主窗口中连接信号1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//mainwindow.cpp#include \"mainwindow.h\"#include \"mytabwidget.h\"#include &lt;QTextBrowser&gt;#include &lt;QMessageBox&gt;#include &lt;QFileInfo&gt;#include &lt;QFile&gt;#include &lt;QTextStream&gt;#include &lt;QUrl&gt;#include &lt;QMimeData&gt;#include &lt;QDragEnterEvent&gt;#include &lt;QDropEvent&gt;...MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; ... auto tabWidget = new MyTabWidget(this); setCentralWidget(tabWidget); setAcceptDrops(true); connect(tabWidget,&amp;MyTabWidget::openFileRequest,this,&amp;MainWindow::openFileAt); ...&#125;void MainWindow::openFile(QString fileName)&#123; return openFileAt(fileName,-1); //If index is out of range, the tab is simply appended. //see http://doc.qt.io/qt-5/qtabwidget.html#insertTab&#125;void MainWindow::openFileAt(QString fileName, int tabIndex)&#123; QFile file(fileName); if(! file.open(QFile::ReadOnly | QFile::Text)) &#123; QMessageBox::warning(this,tr(\"Error\"), tr(\"Cannot open file %1:\\n%2\").arg(fileName).arg(file.errorString())); return ; &#125; QTextStream in(&amp;file); auto browser = new QTextBrowser(this); auto tabWidget = qobject_cast&lt;MyTabWidget*&gt;(centralWidget()); Q_ASSERT(tabWidget); auto index = tabWidget-&gt;insertTab(tabIndex,browser,QFileInfo(fileName).baseName()); tabWidget-&gt;setCurrentIndex(index); browser-&gt;setAcceptDrops(false); QGuiApplication::setOverrideCursor(Qt::WaitCursor); browser-&gt;setSource(QUrl::fromLocalFile(fileName)); browser-&gt;setPlainText(in.readAll()); QGuiApplication::restoreOverrideCursor(); file.close();&#125;...void MainWindow::dragEnterEvent(QDragEnterEvent *event)&#123; if(event-&gt;mimeData()-&gt;hasUrls()) event-&gt;acceptProposedAction(); else event-&gt;ignore();&#125;void MainWindow::dropEvent(QDropEvent *event)&#123; const QMimeData * mimeData = event-&gt;mimeData(); if(mimeData-&gt;hasUrls()) &#123; for (const QUrl&amp; url : mimeData-&gt;urls()) &#123; openFile(url.toLocalFile()); &#125; event-&gt;acceptProposedAction(); &#125; else &#123; event-&gt;ignore(); &#125;&#125;从上面我们可以看到，openFileAt() 打开文件后将其插入标签栏上特定的位置，而 openFile() 只是普通的打开并附到标签栏最后，和目标2是对应的。由于拖放接收的是 URL ，所以普通的文件拖放打开也顺便实现了。至此，两窗口间拖放的接收部分就完成了。在考虑发送部分之前，先考虑目标3情况下创建的新窗口如何接收数据。虽然乍一看似乎也可以通过 QDrag 来传递信息，但由于创建新窗口和释放拖放基本是同时发生的，而 QDrag 本身不能创建新窗口，因此在一次拖放中不能指望只携带 URL 信息的 QDrag 给新窗口传递信息。注意到我们是在启动新进程的同时传递信息，最传统的方法就是命令行参数。显然，命令行参数里肯定要有要打开的文件路径。而且我们还希望在鼠标释放的地方创建新窗口，所以还需要有窗口的位置参数。即123456789101112131415161718192021222324252627282930313233343536//main.cpp#include \"mainwindow.h\"#include &lt;QApplication&gt;#include &lt;QCommandLineParser&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); QCommandLineParser parser; parser.addOptions(&#123; &#123;\"x\",\"move window to indicated left side position on screen\",\"posX\",\"100\"&#125;, &#123;\"y\",\"move window to indicated top position on screen\",\"posY\",\"100\"&#125; /*name, description, value name, default value*/ &#125;); parser.addPositionalArgument(\"filePath\",\"file to open\"); parser.process(a); bool converted; auto x = parser.value(\"x\").toInt(&amp;converted); if(!converted) x = 100; auto y = parser.value(\"y\").toInt(&amp;converted); if(!converted) y = 100; QStringList filePaths = parser.positionalArguments(); MainWindow w; w.move(x,y); w.show(); for(const QString&amp; filePath : filePaths) &#123; w.openFile(filePath); &#125; return a.exec();&#125;这样，新窗口接收数据的部分也完成了。然后是发送数据的部分。移动标签显然是要覆写标签栏的鼠标移动事件。由于标签栏内的移动 Qt 本身已经有实现了，因此只考虑标签栏外的情况。123456789101112131415161718192021222324252627//mytabbar.h#ifndef MYTABBAR_H#define MYTABBAR_H#include &lt;QTabBar&gt;class QString;class MyTabBar : public QTabBar&#123; Q_OBJECTpublic: MyTabBar(QWidget * parent = Q_NULLPTR); ~MyTabBar() &#123;&#125;signals: void openFileRequest(QString/*fileName*/,int/*tabIndex*/); void dragTabRequest(int/*tabIndex*/);protected: void dragEnterEvent(QDragEnterEvent *event) override; void dropEvent(QDropEvent *event) override; void mouseMoveEvent (QMouseEvent *event) override;&#125;;#endif // MYTABBAR_H123456789101112131415161718192021222324252627282930313233343536373839404142434445//mytabbar.cpp#include \"mytabbar.h\"#include &lt;QUrl&gt;#include &lt;QMimeData&gt;#include &lt;QDragEnterEvent&gt;#include &lt;QDropEvent&gt;#include &lt;QMouseEvent&gt;MyTabBar::MyTabBar(QWidget *parent) : QTabBar(parent)&#123; setMovable(true); setAcceptDrops(true);&#125;void MyTabBar::dragEnterEvent(QDragEnterEvent *event)&#123; if(event-&gt;mimeData()-&gt;hasUrls()) event-&gt;acceptProposedAction(); else event-&gt;ignore();&#125;void MyTabBar::dropEvent(QDropEvent *event)&#123; const QMimeData * mimeData = event-&gt;mimeData(); if(mimeData-&gt;hasUrls()) &#123; for (const QUrl&amp; url : mimeData-&gt;urls()) &#123; emit openFileRequest(url.toLocalFile(),tabAt(event-&gt;pos())); &#125; event-&gt;acceptProposedAction(); &#125; else &#123; event-&gt;ignore(); &#125;&#125;void MyTabBar::mouseMoveEvent(QMouseEvent *event)&#123; if(event-&gt;buttons()==Qt::LeftButton) &#123; if(!geometry().contains(event-&gt;pos())) &#123; emit dragTabRequest(currentIndex()); &#125; &#125; QTabBar::mouseMoveEvent(event);&#125;同样是利用信号-槽机制12345678910111213141516171819202122//mytabwidget.h#ifndef MYTABWIDGET_H#define MYTABWIDGET_H#include &lt;QTabWidget&gt;class MyTabWidget : public QTabWidget&#123; Q_OBJECTpublic: MyTabWidget(QWidget * parent = Q_NULLPTR); ~MyTabWidget() &#123;&#125; void removeTabActually(int index);signals: void openFileRequest(QString/*fileName*/,int/*tabIndex*/); void dragTabRequest(int/*tabIndex*/);&#125;;#endif // MYTABWIDGET_H12345678910111213141516171819#include \"mytabwidget.h\"#include \"mytabbar.h\"#include &lt;QDebug&gt;MyTabWidget::MyTabWidget(QWidget * parent) : QTabWidget(parent)&#123; auto mTabBar = new MyTabBar(this); setTabBar(mTabBar); connect(mTabBar,&amp;MyTabBar::openFileRequest,this,&amp;MyTabWidget::openFileRequest); connect(mTabBar,&amp;MyTabBar::dragTabRequest,this,&amp;MyTabWidget::dragTabRequest);&#125;void MyTabWidget::removeTabActually(int index)&#123; widget(index)-&gt;deleteLater(); removeTab(index);&#125;最后是关键的拖放实现。注意到既然接收拖放就是在窗口间移动标签页，那么不接收拖放就可以作为创建新窗口。当然这么做会有一定的副作用，只能说是一种委曲求全的方法。具体的问题在后面再谈。12345678910111213141516171819202122232425//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;class QString;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: explicit MainWindow(QWidget *parent = 0); ~MainWindow() &#123;&#125; void openFile(QString fileName); void openFileAt(QString fileName, int tabIndex); void dragTab(int tabIndex);protected: void dragEnterEvent(QDragEnterEvent *event) override; void dropEvent(QDropEvent *event) override;&#125;;#endif // MAINWINDOW_H123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120//mainwindow.cpp#include \"mainwindow.h\"#include \"mytabwidget.h\"#include &lt;QTextBrowser&gt;#include &lt;QMessageBox&gt;#include &lt;QFileInfo&gt;#include &lt;QFile&gt;#include &lt;QTextStream&gt;#include &lt;QUrl&gt;#include &lt;QMimeData&gt;#include &lt;QDrag&gt;#include &lt;QWindow&gt;#include &lt;QScreen&gt;#include &lt;QProcess&gt;#include &lt;QCursor&gt;#include &lt;QDragEnterEvent&gt;#include &lt;QDropEvent&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; ...//setup ui auto tabWidget = new MyTabWidget(this); setCentralWidget(tabWidget); setAcceptDrops(true); connect(tabWidget,&amp;MyTabWidget::openFileRequest,this,&amp;MainWindow::openFileAt); connect(tabWidget,&amp;MyTabWidget::dragTabRequest,this,&amp;MainWindow::dragTab);&#125;void MainWindow::openFile(QString fileName)&#123; return openFileAt(fileName,-1); //If index is out of range, the tab is simply appended. //see http://doc.qt.io/qt-5/qtabwidget.html#insertTab&#125;void MainWindow::openFileAt(QString fileName, int tabIndex)&#123; QFile file(fileName); if(! file.open(QFile::ReadOnly | QFile::Text)) &#123; QMessageBox::warning(this,tr(\"Error\"), tr(\"Cannot open file %1:\\n%2\").arg(fileName).arg(file.errorString())); return ; &#125; QTextStream in(&amp;file); in.setAutoDetectUnicode(true); auto browser = new QTextBrowser(this); auto tabWidget = qobject_cast&lt;MyTabWidget*&gt;(centralWidget()); Q_ASSERT(tabWidget); auto index = tabWidget-&gt;insertTab(tabIndex,browser,QFileInfo(fileName).baseName()); tabWidget-&gt;setCurrentIndex(index); browser-&gt;setAcceptDrops(false); QGuiApplication::setOverrideCursor(Qt::WaitCursor); browser-&gt;setSource(QUrl::fromLocalFile(fileName)); browser-&gt;setPlainText(in.readAll()); QGuiApplication::restoreOverrideCursor(); file.close();&#125;void MainWindow::dragTab(int tabIndex)&#123;// if(!isTabMovable(tabIndex)) // ...//impossible in this situation auto tabWidget = qobject_cast&lt;MyTabWidget*&gt;(centralWidget()); Q_ASSERT(tabWidget); auto browser = qobject_cast&lt;QTextBrowser*&gt;(tabWidget-&gt;widget(tabIndex)); Q_ASSERT(browser); auto drag = new QDrag(this); auto mimeData = new QMimeData; QPixmap thumbnail = windowHandle()-&gt;screen()-&gt;grabWindow(browser-&gt;winId()); mimeData-&gt;setUrls(&#123;browser-&gt;source()&#125;); drag-&gt;setMimeData(mimeData); drag-&gt;setPixmap(thumbnail.scaled(200,200)); auto dragAction = drag-&gt;exec(/*Qt::MoveAction*/Qt::LinkAction); int currentIndex = tabWidget-&gt;indexOf(browser); if (dragAction==Qt::LinkAction/*Qt::MoveAction*/) &#123; tabWidget-&gt;removeTabActually(currentIndex); &#125; else if (dragAction==Qt::IgnoreAction) &#123; if(QProcess::startDetached(qApp-&gt;applicationFilePath(), &#123;\"-x\",QString::number(QCursor::pos().x()), \"-y\",QString::number(QCursor::pos().y()), browser-&gt;source().toLocalFile()&#125;)) &#123; tabWidget-&gt;removeTabActually(currentIndex); &#125; &#125; else &#123; return; &#125; if(tabWidget-&gt;count()==0) &#123; qApp-&gt;closeAllWindows(); &#125;&#125;void MainWindow::dragEnterEvent(QDragEnterEvent *event)&#123; if(event-&gt;mimeData()-&gt;hasUrls()) event-&gt;acceptProposedAction(); else event-&gt;ignore();&#125;void MainWindow::dropEvent(QDropEvent *event)&#123; const QMimeData * mimeData = event-&gt;mimeData(); if(mimeData-&gt;hasUrls()) &#123; for (const QUrl&amp; url : mimeData-&gt;urls()) &#123; openFile(url.toLocalFile()); &#125; event-&gt;acceptProposedAction(); &#125; else &#123; event-&gt;ignore(); &#125;&#125;这里值得注意的有两点。一个是在 drag-&gt;exec() 之后重新获取了部件当前的索引 currentIndex ，这是由于拖放后可能会导致索引改变；另一个是拖放提供的行为是 Qt::LinkAction 而不是 Qt::MoveAction ，这是由于桌面（即资源管理器）以及相当一部分常见程序对 Qt::MoveAction 和 Qt:: CopyAction 的拖放是可以直接接收的，导致创建新窗口几乎不会发生，而且还会带来一些意料外的副作用，因此最后选择了大多数常见程序不会接收的 Qt::LinkAction 。这样，一个具有标签页拖放功能的多文本浏览器就基本完成了。完整源码参见 https://github.com/miRoox/DnDTabWidget/tree/v1.0","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"功能模拟","slug":"功能模拟","permalink":"http://miroox.github.io/blog/tags/%E5%8A%9F%E8%83%BD%E6%A8%A1%E6%8B%9F/"},{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Qt","slug":"Qt","permalink":"http://miroox.github.io/blog/tags/Qt/"},{"name":"拖放","slug":"拖放","permalink":"http://miroox.github.io/blog/tags/%E6%8B%96%E6%94%BE/"}]},{"title":"【翻译】代数数据类型的代数结构（中）","slug":"TheAlgebraOfADT-II","date":"2017-07-02T14:54:34.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2017/07/TheAlgebraOfADT-II/","link":"","permalink":"http://miroox.github.io/blog/2017/07/TheAlgebraOfADT-II/","excerpt":"原文链接我以此题目在2012年11月的伦敦Haskell会议上做了演讲。演讲的视频见 YouTube ，幻灯片见 GitHub 。这篇是系列的第二部分；你可以在这里阅读第一部分上一次我介绍了单位类型 Unit 或者 () 以及零类型 Void 。我同时还介绍了类型运算符 Add 和 Mul ，以及函数类型 a-&gt;b 。","text":"原文链接我以此题目在2012年11月的伦敦Haskell会议上做了演讲。演讲的视频见 YouTube ，幻灯片见 GitHub 。这篇是系列的第二部分；你可以在这里阅读第一部分上一次我介绍了单位类型 Unit 或者 () 以及零类型 Void 。我同时还介绍了类型运算符 Add 和 Mul ，以及函数类型 a-&gt;b 。在这篇文章中，我将同时使用Haskell记号和数学记号。下面这个表可以帮助你在这两者之间转换。Void⁡↔0() ,Unit⁡↔1Add⁡ a b↔a+b(a,b) , Mul⁡ a b↔a⋅ba→b↔ba\\begin{aligned} \\operatorname{Void} &amp;&amp; \\leftrightarrow &amp;&amp; 0 \\\\ () \\,, \\operatorname{Unit} &amp;&amp; \\leftrightarrow &amp;&amp; 1 \\\\ \\operatorname{Add} \\; a \\; b &amp;&amp; \\leftrightarrow &amp;&amp; a + b \\\\ (a,b) \\,,\\; \\operatorname{Mul} \\; a \\; b &amp;&amp; \\leftrightarrow &amp;&amp; a \\cdot b \\\\ a \\rightarrow b &amp;&amp; \\leftrightarrow &amp;&amp; b ^ a \\end{aligned}Void(),UnitAddab(a,b),Mulaba→b​​↔↔↔↔↔​​01a+ba⋅bba​在这篇文章中我将着眼于递归类型，并展示如何在以各种方式使用类型代数来推导出关于类型的有趣事实。 Maybe 类型构造子让我们通过探索 Maybe a 来放松一下。这表示它这个类型可能包含类型 aaa 的一个值，也可能为空。它定义如下：1data Maybe a = Nothing | Just a竖线表示这是一个和类型，所以如果我们已经定义了类型 Nothing 和 Just a ，我们可以使用我们上次定义的类型 Add 来写。它看起来就像下面这样：1234data Nothing = Nothingdata Just a = Just atype Maybe a = Add Nothing (Just a)看我们是怎么把 data 声明替换为 type 声明的？这意味着 Maybe a 不再是一个新类型 —— 而只是一个已知类型的同义词。但我们可以更进一步。注意到 Nothing 只具有一个值，所以它等价于 () 。类似的，Just 是类型 aaa 的一个单一值的容器，故它等价于 aaa 。因而我们有1type Maybe a = Add () a也就是说，Maybe aaa 与 1 + aaa 是一样的。Maybe 所做的事就是给一个类型添加一个可能的值。 递归类型 列表Haskell中基本的列表是 链式表 。一个列表 asasas 要么是空的，记作 [] ，要么是将单个 aaa 附加到另一个列表 asasas 上而构成的，记作 a : as 。如果我们想要自己定义一个列表，我们可以写成1data List a = Nil | Cons a (List a)让我们来花点时间看一下这个声明的结构。和 Maybe 一样，List 类型是两种更简单类型的和。加数是 Nil ，是一个等价于 () 的无参构造子。被加数是 Cons a (List a) ，是一个包含 aaa 和列表 asasas 的乘积。如果我们将列表写作 L(a)L(a)L(a) ，那么它的代数形式是L(a)=1+a⋅L(a)L(a) = 1 + a \\cdot L(a)L(a)=1+a⋅L(a)这好像意味着我们可以在Haskell中将列表类型写作1type List a = Add () (a, (List a))但实际上这不能通过编译。其原因是类型别名会在类型检查之后，编译之前的编译期被展开。这个定义永远不会停止展开 —— 它会像下面这样一直展开1Add () (a, Add () (a, Add () (a, ...)))等等。这不行的原因与Haskell处理递归类型定义的方式有关（和大多数具有复杂的类型系统的语言一样，它使用 同构递归类型而不是等同递归类型 [1] ）它的方式是使用 newtype 声明替代 type 声明，并将类型包装在一个新的类型构造子 L 中：1newtype List a = L (Add () (a, List a))这样只是为了满足类型检查器 —— 当代码被编译时，额外的构造子会被优化掉，我们所剩的与上面使用 type 的声明相同。如果我们将类型 List a 写作 L(a)L(a)L(a) ，那么这个列表的声明就是说L(a)=1+a⋅L(a)L(a) = 1 + a \\cdot L(a)L(a)=1+a⋅L(a)为了看清列表 实际上 是什么，我们可以开始通过反复替代来展开定义。在展开式中，无论何时我看见了具有 a⋅aa\\cdot aa⋅a 形式的类型，我都会用 a2a^2a2 替代以节省空间。练习 ：表达式 a2a^2a2 可以用序对 (a,a)(a,a)(a,a) 或函数 2→a2\\rightarrow a2→a 表示。证明它们是一样的。L(a)=1+a⋅L(a)=1+a⋅(1+a⋅L(a))=1+a+a2⋅(1+a⋅L(a))=1+a+a2+a3⋅(1+a⋅L(a))=…=1+a+a2+a3+a4+a5+⋯\\begin{aligned} L(a) &amp; = 1 + a \\cdot L(a) \\\\ &amp; = 1 + a \\cdot (1 + a \\cdot L(a)) \\\\ &amp; = 1 + a + a ^ 2 \\cdot (1 + a \\cdot L(a)) \\\\ &amp; = 1 + a + a ^ 2 + a ^ 3 \\cdot (1 + a \\cdot L(a)) \\\\ &amp; = \\ldots \\\\ &amp; = 1 + a + a ^ 2 + a ^ 3 + a ^ 4 + a ^ 5 + \\cdots \\end{aligned}L(a)​=1+a⋅L(a)=1+a⋅(1+a⋅L(a))=1+a+a2⋅(1+a⋅L(a))=1+a+a2+a3⋅(1+a⋅L(a))=…=1+a+a2+a3+a4+a5+⋯​这告诉我们 aaa 的列表要么是空列表，要么是包含单个 aaa 的列表，要么是包含两个 aaa 的列表，要么是包含三个 aaa 的列表，等等。也许你已经知道这一点 —— 但代数告诉我们的更加简洁！但现在，这有一件确实很酷的事情。让我们从列表的方程式开始，而不是使用反复替代的方法，同时忘掉一会儿我们的对象是类型，并假装它们是任意的表达式。这意味着我们有理由使用任何我们喜欢的技巧来“求解 L(a)L(a)L(a) ”。首先在等式两边同时减去 L(a)L(a)L(a) ：L(a)−a⋅L(a)=1L(a) - a \\cdot L(a) = 1L(a)−a⋅L(a)=1然后分解出等式左侧的因子：(1−a)⋅L(a)=1(1 - a) \\cdot L(a) = 1(1−a)⋅L(a)=1最后，两边同时除以 1−a1-a1−a ：L(a)=11−aL(a) = \\frac{1}{1-a}L(a)=1−a1​这看起来没有意义，因为我们不知道一个类型减去另一个类型是什么意思，也不知道一个类型除以另一个类型是什么意思。但是它一点有意思的事都不能告诉我们吗？如果你学习过微积分，你也许记得许多函数都可以按照 泰勒级数 进行展开。我们可以 问一问 Wolfram Alpha 1/(1−a)1/(1-a)1/(1−a) 的泰勒级数是什么，然后它会告诉我们：L(a)=1+a+a2+a3+a4+⋯L(a) = 1 + a + a ^ 2 + a ^ 3 + a ^ 4 + \\cdotsL(a)=1+a+a2+a3+a4+⋯也就是说，L(a)L(a)L(a) 的级数展开，恰恰就是我们通过反复替代化简得到的式子。尽管我们通过对类型进行了一些完全不合理的操作，极大地滥用了代数，但还是得到了一个合理的结果。 树考虑节点处有值的二叉树。在Haskell中你可以像这样写1data Tree a = Empty | Node a (Tree a) (Tree a)以一种可能令人熟悉的方式，我们可以将它看作两个类型的和 —— 一个等价于 () 的无参类型，和一个积类型。这一次它是三个项的乘积，但这并不是个问题 —— 我们可以使用嵌套的乘积，其形式为 (a, (b, c)) 。根据我们所知道的运算关系（再一次，我们使用 newtype 来获得一个递归的定义），其定义为1newtype Tree a = T (Add () (a, (Tree a, Tree a)))在代数的语言中，如果把 T(a)T(a)T(a) 作为树的类型，我们可以写出T(a)=1+a⋅T(a)2T(a) = 1 + a\\cdot T(a)^2T(a)=1+a⋅T(a)2为了更好地解决树是什么，我们可以采用与列表相同的方式进行重复替换，但那会更加麻烦。相对的，我们可以用重新排列方程的技巧来求解 T(a)T(a)T(a) 吗？首先，将所有东西移到方程的同一侧：a⋅T(a)2−T(a)+1=0a \\cdot T(a)^2 - T(a) + 1 = 0a⋅T(a)2−T(a)+1=0我们可以看出它是关于 T(a)T(a)T(a) 的 二次方程 ，因此我们可以使用二次方程求根公式求出T(a)=1−1−4a2aT(a) = \\frac{1 - \\sqrt{1 - 4 a}}{2a}T(a)=2a1−1−4a​​这比列表类型的方程更没意义。取一个类型的平方根是个什么意思？但是，不要慌张，我们再一次 问问 Wolfram Alpha 它的级数展开，然后它会告诉我们T(a)=1+a+2a2+5a3+14a4+⋯T(a) = 1 + a + 2a ^ 2 + 5a ^ 3 + 14a ^ 4 + \\cdotsT(a)=1+a+2a2+5a3+14a4+⋯那么我们如何理解它呢？前两项告诉我们，一个树可以是空的（如果它是 Empty ），或者可以有一个类型为 aaa 的值（如果它是 Node a Empty Empty ）。然后下一项告诉我们，一个树可以以两种不同的方式包含两个类型为 aaa 的值。而再下一项告诉我们，一个树可以以五种不同的方式包含三个类型为 aaa 的值。但我们确实可以看出这些，如果我们枚举所有二叉树，并且将他们按所包含的值的个数分组。有一棵树没有值，有一棵树有一个值，有两棵树有两个值，有五棵树有三个值 —— 正如这个图片中描述的（从 Flajolet 和 Sedgewick 所著的优秀书籍 《解析组合数学》 中摘来的）。方程能计算可以存在的不同二叉树的数目！这一计数属性与我们在第一篇文章中看到的简单计数实例有关，也与 组合种类（combinatorial species） [2] 有关，正如 Brent Yorgey 所写的有关拓展。种类（species）和类型（types）有许多的共同点，尽管它们并不是同一样东西。 七树合一（Seven Trees In One）如果我们限制树只包含单位类型，例如 Tree () ，那么 T(a)T(a)T(a) 中的 aaa 就等于 1 ，然后我们可以写出树的定义式方程T=1+T2T = 1 + T^2T=1+T2通过代数方法，重复地使用公式 T2=T−1T ^ 2 = T - 1T2=T−1 ，我们可以化简为T6=(T−1)3=T3−3T2+3T−1=T(T−1)−3T2+3T−1=−2T2+2T−1=−2(T−1)+2T−1=1\\begin{aligned} T^6 &amp; = (T-1) ^ 3 \\\\ &amp; = T ^ 3 - 3T ^ 2 + 3T - 1 \\\\ &amp; = T (T - 1) - 3T ^ 2 + 3T - 1 \\\\ &amp; = - 2T ^ 2 + 2T - 1 \\\\ &amp; = -2(T-1) + 2T - 1 \\\\ &amp; = 1 \\end{aligned}T6​=(T−1)3=T3−3T2+3T−1=T(T−1)−3T2+3T−1=−2T2+2T−1=−2(T−1)+2T−1=1​当你把它解释为语言的类型时，这表示一个树的六元组与单位类型等价。换句话说，只存在一个树的六元组。这显然是无意义的，那么是哪里出了问题呢？更神秘的是如果我们在等式两边同时乘 TTT ，我们会得到T7=TT ^ 7 = TT7=T这并 不是 没有意义的 —— 它表明一个树的七元组和单个树等价。乍一看，这不是一个深刻的结果。任何两个具有 可数无限多 个可能值的类型都是等价的 —— 这就是可数的意思。然而，还有比这更巧妙的。在论文 七树合一（Seven Trees In One） 中，Andreas Blass 不仅展示了如何找到七个树到一个树的确切映射和逆映射（实质上，他就是告诉你如何写出前一篇所说的 from 和 to 函数），而且还表明，这些函数从来都不需要再任何树上深入四层以上。最后，他解释了为什么 T7=TT ^ 7 = TT7=T 是有效的，而 T6=1T ^ 6 = 1T6=1 却不是。事实上，通过我上面给出的使用减法的方法，派生出类似的方法，你可以转换为不使用减法的“诚实的”证明，因此对于类型也是有效的 —— 但当你开始所用的 TTT 的幂必须是一个大于6的倍数的幂。因此你可以将 T7T ^ 7T7 化简为 TTT（因为 7 = 6 + 1 ），而不能将 T6T ^ 6T6 化简为 1 。 一个解释？如果你认为这篇文章提出的问题比提供的答案还要多，这是十分公正的。例如：类型的减法、除法和开方是什么意思？对于仍然具有意义、可计算、可解释的类型方程，我们还可以做什么？为什么对类型方程进行不合理的操作却可以得到有意义的答案？作为最后一个问题的预热，一个可以给类型建模的数学结构叫 半环 。这也就是说，你可以加或乘对象，并且你有对应于 0 和 1 的对象。这里有一篇 Marcelo Fiore 和 Tom Leinster 的论文，表明如果你从一个 复数 TTT 开始，它由方程t=p(t)t = p(t)t=p(t)定义 ，其中 ppp 是一个多项式，并且化简为q1(t)=q2(t)q_1(t) = q_2(t)q1​(t)=q2​(t)其中 q1q_1q1​ 和 q2q_2q2​ 不是常量（他们不能只是 1 ），那么同样的结果对于半环也是正确的。特别地，它对于类型也是正确的，也就是你可以找到一个不使用减法以及其它对于类型而言非法的运算的证明。下一次，我将解释拉链（zippers）数据结构是什么，然后描述如何对类型进行微积分。原文中的 “isorecursive” 和 “equirecursive” 找不到已有的翻译，我按照wikipedia中的描述做了一定的意译。简单地说，isorecursive 类型与其展开之间是不同的类型，只是两者之间是同构的；而 equirecursive 类型与其展开是完全等同的。 ↩︎原文中的 “combinatorial species” 找不到既有的翻译，根据字面意思翻译了一下。 ↩︎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"},{"name":"翻译作品","slug":"翻译作品","permalink":"http://miroox.github.io/blog/categories/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://miroox.github.io/blog/tags/%E7%BF%BB%E8%AF%91/"},{"name":"科普","slug":"科普","permalink":"http://miroox.github.io/blog/tags/%E7%A7%91%E6%99%AE/"},{"name":"Haskell","slug":"Haskell","permalink":"http://miroox.github.io/blog/tags/Haskell/"}]},{"title":"从马克思主义基本原理看程序设计","slug":"MarxismInProgramDesign","date":"2017-06-04T16:56:23.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2017/06/MarxismInProgramDesign/","link":"","permalink":"http://miroox.github.io/blog/2017/06/MarxismInProgramDesign/","excerpt":"（这篇是马克思主义基本原理课程的大作业，各位要是看到什么觉得不对的地方，也还请一笑了之）","text":"（这篇是马克思主义基本原理课程的大作业，各位要是看到什么觉得不对的地方，也还请一笑了之）马克思主义是关于自然、社会和人类思维发展一般规律的学说，而马克思主义基本原理是马克思主义理论体系的核心内容，是对马克思主义立场、观点和方法的集中概括。另一方面，随着计算机技术、移动技术的飞速发展，各种各样的的应用程序已经渗透到了人们生活的方方面面，而程序设计是关于程序如何编写设计的方法和范式，其思想也体现了许多马克思主义的原理。我们知道，编程语言是人们与计算机对话的一种方式，是程序的一种表达形式。显然，我们可以使用不同的编程语言实现同样的效果或达到同样的目的。另一方面，由于不同编程语言本身有不同的设计目标，因而对同一问题采用不同语言解决的难易不同，选取合适的编程语言也就非常重要了，比如要与硬件打交道则需要像汇编语言或C语言这样偏底层的语言，要面对高并发环境则需要像Erlang这样低耦合的函数式语言，要制作用户界面那么选择XAML或QML这样的陈述性语言可能更为合适，等等。当然，我们既反对忽视程序设计而夸大编程语言的作用，也要积极利用合适的编程语言去促进程序的设计，这与马克思主义中的内容决定形式的原理是相一致的。算法和数据结构常常被认为是一个程序的核心，它们是从程序中抽象出来的一般方法，而程序可以看作是算法与数据结构的具体化。比如快速排序算法大致就是将数据分割成两个小部分，并使得其中一个部分的所有数据比另一个部分都要小，然后对分割出的每堆不断进行这个操作，又比如队列这种数据结构就是对数据先进先出这种特征的抽象。这种抽象使得我们不必受编程中繁琐的具体内容所困，从而把握住程序的本质特征，进而能够对程序的具体行为和性能作出准确的分析。有了这些分析，我们也就有了程序设计的一些最基本的判据，甚至可以做一些简单程序的设计了。这一过程体现的正是马克思唯物辩证法中的抽象与具体的方法。代码复用可以说是程序设计的一大核心主题，广义上的代码复用就是指对代码的重复利用。有效的代码复用可以极大地解放程序员的生产力，使得程序员不必将精力和体力耗费在枯燥繁琐的拷贝修改上，而将精力和智力花费在其它更有价值的地方。同时，代码复用本身也是一个具体到抽象的过程，它使我们可以从更高的角度看问题，例如我们前面提到的快速排序算法，我们显然不关心其中数据的具体类型是什么，只要它们是“具有序关系的”，我们就可以对它们使用快速排序算法，但对于一些强类型语言，你可能不得不为每一种“具有序关系的”类型提供一个实现，尽管它们之间可能只有微小的差异，而如果运用一些代码复用的手段，比如模版或者泛型，我们只需要提供一种实现代码即可达到目的。这样，我们不仅提高了生产力，而且提升了代码的抽象层次，使得代码的层次结构更为清晰，也有利于将来的维护。具体地，代码复用的常见实现手段有：泛型、模版、继承、多态、模块化，以及各种各样的设计模式等等。由于篇幅的限制，下面重点讲讲模块化与设计模式。模块化也是程序设计中的一大主题，它虽然是代码复用的一种实现手段，但其意义不止于此。模块化是一个比较宽泛的概念，随着划分粒度的不同，大至一个程序库，小至一段函数，都可以称之为“模块”。“高内聚，低耦合”是我们常听到的模块设计的原则，所谓“内聚”是从功能角度度量模块内的联系程度，而“耦合”则是从数据访问的角度度量模块间的关联程度。高内聚的模块应当专心做好一件事，而低耦合的模块与模块间应该只通过少且简单的接口进行交互。这种原则使得程序的层次结构十分清晰，有利于程序的开发和维护，同时，模块充分的独立性也给程序后续的维护和升级带来便利。可以看到，模块化进一步地解放了程序员的生产力。但另一方面，我们在实践中经常会遇到模块粒度的问题，显然，一个粗粒度的模块会包含许多细粒度的模块，那么粗粒度模块的高内聚，与细粒度模块间的低耦合就构成了一对矛盾。一种有效的解决策略是粗粒度的模块做抽象普遍的事，而细粒度的模块做具体特殊的事，例如一个图形界面库里面有一个对话框类，而对话框类里面有一个显示文本的方法。模块化的另一个矛盾是“高内聚，低耦合”虽然可以提高开发和维护的效率，但往往也会降低运行效率，而与之相对的“低内聚，高耦合”虽然加大了程序开发与维护的难度，但同时也换取了更高的运行效率。对于这个矛盾只能采取具体问题具体分析的方法，综合考虑程序具体的运行环境、硬件配置，以及程序本身的设计目标，进行合理的取舍。所谓设计模式就是一系列程序设计中常见问题的通用解决方案，因而代码的可复用性也是其目标之一。以著名的MVC（模型-视图-控制器）模式为例，它将用户界面分离成三类对象，模型是应用对象，视图表达它在屏幕上的显示，控制器定义界面对用户输入的响应方式。对于一个用户输入，控制器获取它并将指令和数据传递给模型，由模型来更新数据库并通知视图刷新，最后由视图将结果返回给用户。它可以看作普遍联系观与否定之否定规律的运用，将现象与本质、内容与形式剥离开来，再重新建立起它们间的联系。这样，既克服了传统界面设计中数据、显示与业务逻辑高度耦合的混杂状态，又保持了数据、显示与业务逻辑之间的联系性与一致性。对于其它设计模式，这里就不再赘述了，只想用下面这幅图来展示普遍联系的观点是如何在设计模式中运用的（图中每一个方框都代表这一种设计模式，箭头表达了设计模式间是如何联系与转化的）。（上图摘自《设计模式：可复用面向对象软件的基础》）运用马克思主义基本原理，可以加深我们对软件设计的体会与理解。但“纸上得来终觉浅，绝知此事要躬行”，只有真正将马克思主义基本原理和程序设计贯彻到实践中去，才能让知识开花结果，制作出好的程序来。","categories":[{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miroox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"}],"tags":[{"name":"程序设计","slug":"程序设计","permalink":"http://miroox.github.io/blog/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"哲学","slug":"哲学","permalink":"http://miroox.github.io/blog/tags/%E5%93%B2%E5%AD%A6/"},{"name":"马克思主义","slug":"马克思主义","permalink":"http://miroox.github.io/blog/tags/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89/"}]},{"title":"【翻译】代数数据类型的代数结构（上）","slug":"TheAlgebraOfADT-I","date":"2017-05-27T13:44:34.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2017/05/TheAlgebraOfADT-I/","link":"","permalink":"http://miroox.github.io/blog/2017/05/TheAlgebraOfADT-I/","excerpt":"原文链接我以此题目在2012年11月的伦敦Haskell会议上做了演讲。演讲的视频见 YouTube ，幻灯片见 GitHub 。在本系列文章中，我将在不提及范畴论和高等数学的情况下解释Haskell的数据类型为什么被称为 代数的。","text":"原文链接我以此题目在2012年11月的伦敦Haskell会议上做了演讲。演讲的视频见 YouTube ，幻灯片见 GitHub 。在本系列文章中，我将在不提及范畴论和高等数学的情况下解释Haskell的数据类型为什么被称为 代数的。你高中所学的代数始于数字（例如：1、2、3……）和运算符（例如：加法和乘法）。运算符给你一种组合数字并从中产生新数字的方法。例如：将1和2通过加法运算结合起来将得到一个新数字3，我们通常将这个事实表述为1+2=31 + 2 = 31+2=3当你稍微长大一点之后，你会学到能够代替数字的变量（例如： xxx 、 yyy 、 zzz ……）。在你更大一些之后，你会知道一些代数遵循的法则，诸如0+x=x1⋅x=x\\begin{aligned} 0 + x &amp;= x \\\\ 1 \\cdot x &amp;= x \\end{aligned}0+x1⋅x​=x=x​它们对于 xxx 的任何值都成立。此外还有一些其它的规则来定义数字和运算的性质。当数学家们谈论代数时，他们意味着的是比这更普遍的东西。一个数学上的代数包含三个部分：对象 是代数的“事物”。对象的集合定义了我们要讨论的是什么。运算 给出将旧事物结合成新事物的方法。规则 是对象和操作间的关系。在中学的代数中，数字是对象，而加法、乘法和友谊是运算。 Haskell类型的代数在Haskell类型的代数中，对象是类型，例如 Bool 和 Int。运算符从已有的类型中产生新的类型。一个实例是类型构造子 Maybe 。它本身不是类型，但你可以使用它产生类型 —— 例如 Maybe Bool 和 Maybe Int，而它们是类型。另一个例子是 Either，它从两个旧有类型中产生新类型 —— 例如 Either Int Bool。 计数通过对类型可能具有的 值 进行计数，我们可以看到它与我们熟悉的数字代数的联系。我们取 Bool 的定义为1data Bool = False | True一个类型为 Bool 的对象有两种可能的取值 —— 它要么是 False 要么是 True （技术上来讲，它还有可能会是 undefined ，但我会在后文中忽略这个事实）。不严谨地说，类型 Bool 就对应于数字代数中的“2”。如果说 Bool 是2，那么什么是1呢？它应当是一个只有唯一取值的类型。在计算机科学文献中，这种类型通常称为 Unit 并有如下定义1data Unit = Unit在Haskell中已经存在一种只有唯一取值的类型了 —— 它是 () （读作“Unit”）。你不能自己定义它，但如果你可以，它大概长这样1data () = ()使用这种计数方法类推，Int 对应于数字 2322^{32}232 ，这正是类型 Int 所具有的值的数目（至少在我的机器上是这样的）。 加法原则上我们可以有对应于3、4、5等等的类型。有时我们可能真的需要这样做 —— 比如对应于7的类型可以用于编码一周的七天。但是，如果我们可以从旧的类型建立起新的类型岂不是更好。这就需要我们请出代数中的运算符一个对应于加法的类型是1data Add a b = AddL a | AddR b也就是说，类型 a+ba+ba+b 是一个具有标签的联合体[1]，它可以是 aaa 或 bbb。要了解为什么这对应于加法，我们可以重新审视一下计数法。让我们假设 aaa 是 Bool 而 bbb 是 ()，那么 aaa 有2种取值而 bbb 有1种取值。至于类型 Add Bool () 有多少种取值呢？我们可以将他们列出一个表：1addValues = [AddL False, AddL True, AddR ()]这其中有三个值，而 3 = 2 + 1 。这通常被称为是一个 和类型。在Haskell中，和类型通常使用 Either，它的定义为1data Either a b = Left a | Right b但我坚持使用 Add。 乘法一个对应于乘法的类型是1data Mul a b = Mul a b也就是说，类型 a⋅ba\\cdot ba⋅b 是一个容纳 aaa 和 bbb 的容器。通过计数法可以证明其与乘法间的对应关系 —— 如果我们把 aaa 和 bbb 都定为 Bool，那么类型 Mul Bool Bool 可能的值为1mulValues = [Mul False False, Mul False True, Mul True False, Mul True True]这其中有四个值，即 4=2×24 = 2 \\times 24=2×2。这通常被称为 积类型。在Haskell中乘积是序对类型：1data (,) a b = (a, b)但我坚持使用 Mul。 零使用加法和乘法我们可以产生任何1以上的数字所对应的类型 —— 但是0呢？它应当是一个没有任何值的类型。这听起来很奇怪，但你可以定义这样的类型：1data Void注意到在数据的定义中没有构造子，因此无法构造 Void 类型的值 —— 它有零个值，这正是我们想要的！ Haskell类型的代数中的规则我们前面定义的类型有什么规则？就如同数字代数里那样，有一道规则能够断言两个对象是否相等 —— 在我们这，对象就是指类型。然而，当我谈论到 相等性 时，我的意思不是Haskell中函数 (==) 的意义下的相等，而是两种类型之间存在着一一对应的关系 —— 也就是说，当我说 aaa 和 bbb 两种类型相等时，我的意思是你可以写出两个函数12from :: a -&gt; bto :: b -&gt; a它将 aaa 的值与 bbb 的值配对，因此下面的等式总是成立的（这里的 == 是真正的Haskell式的相等）12to (from a) == afrom (to b) == b比如，我认为类型 Bool 与类型 Add () () 等价的。因为我可以通过如下的函数证明它们的等价性：1234567to :: Bool -&gt; Add () ()to False = AddL ()to True = AddR ()from :: Add () () -&gt; Boolfrom (AddL _) = Falsefrom (AddR _) = True后面，我会使用三等号，===，来表示类型之间的这种等价关系。 加和类型的运算法则加法有两条运算规则：1Add Void a === a意即类型 Add Void a 与类型 a 具有相同数目的值，而1Add a b === Add b a意味着你求和是什么次序无关紧要。这可以两条法则写成你可能更为熟悉的算数代数的形式0+x=xx+y=y+x\\begin{aligned} 0 + x &amp;= x \\\\ x + y &amp;= y +x \\end{aligned}0+xx+y​=x=y+x​假如你喜欢做练习，你可以在 Haskell 代数中证明上述法则的正确性 —— 无论是采用计数法，还是通过写出 from 和 to 函数。 乘积类型的运算法则乘法有三个有用的法则：1Mul Void a === Void意味着任何类型与 Void 相乘，你都会得到 Void ，1Mul () a === a意即与 () 不改变任何东西，而1Mul a b === Mul b a意味着你做乘积是什么次序无关紧要。这些法则更让人熟悉的形式是0⋅x=01⋅x=xx⋅y=y⋅x\\begin{aligned} 0 \\cdot x &amp;= 0 \\\\ 1 \\cdot x &amp;= x \\\\ x \\cdot y &amp;= y \\cdot x \\end{aligned}0⋅x1⋅xx⋅y​=0=x=y⋅x​两个小练习：（1）证明上述法则在 Haskell 代数中的有效性，（2）解释为什么我们不需要下面这样的法则12Mul a Void === VoidMul a () === a此外，我们还有一条联系加法和乘法运算的法则：1Mul a (Add b c) === Add (Mul a b) (Mul a c)这一条推理起来可能有点棘手，但写出对应的 from 和 to 函数并不太难。这条法则的算术版长得比较友好a⋅(b+c)=a⋅b+a⋅ca \\cdot (b + c) = a \\cdot b + a \\cdot ca⋅(b+c)=a⋅b+a⋅c它被称为 分配 律。 函数类型除了像 Int 和 Bool 这样的实体类型，Haskell 中还有 函数 类型，如 Int -&gt; Bool 或 Double -&gt; String 。如何将它们也纳入到这种代数里面？为了解决这个问题，我们重新回到计数法。类型 a→ba\\rightarrow ba→b 包含多少种函数？让我们具体来看，把 aaa 和 bbb 都定为 Bool。值 False 可以映射到 True 或者 False，对于值 True 也是如此 —— 因此，有 2⋅2=22=42 \\cdot 2 = 2 ^{2} = 42⋅2=22=4 种可能的 Bool -&gt; Bool 函数。为了真正的明确它们，我们可以将其枚举如下12345678910111213f1 :: Bool -&gt; Bool -- 等价于 'id'f1 True = Truef1 False = Falsef2 :: Bool -&gt; Bool -- 等价于 'const False'f2 _ = Falsef3 :: Bool -&gt; Bool -- 等价于 'const True'f3 _ = Truef4 :: Bool -&gt; Bool -- 等价于 'not'f4 True = Falsef4 False = True如果 bbb 仍然是（只有两个值的）Bool 类型，而 aaa 是具有三个值的类型，如1data Trio = First | Second | Third那么每个 First 、Second 和 Third 可以映射到两个可能值，因而总共有 2⋅2⋅2=23=82 \\cdot 2 \\cdot 2 = 2^{3} = 82⋅2⋅2=23=8 种 Trio -&gt; Bool 类型的函数。采用同样的方法可以得到一般的规律。如果 AAA 是类型 aaa 的值的个数， BBB 是类型 bbb 的值的个数，那么类型 a→ba\\rightarrow ba→b 值的个数为BAB^{A}BA这说明了使用 指数类型 作为函数类型的常用术语的理由。 函数的运算法则这里有两条关于单位类型的函数类型的运算法则。它们是1() -&gt; a === a这意味着有和类型 a 的值一样多的函数 () -&gt; a ，以及1a -&gt; () === ()这意味着只存在唯一的一个函数 a -&gt; () —— 特别地，它就是 const () 。这两条规则的算术形式是a1=a1a=1\\begin{aligned} a^{1} &amp;= a \\\\ 1^{a} &amp;= 1 \\end{aligned}a11a​=a=1​还有允许提取出共同参数的法则：1(a -&gt; b, a -&gt; c) === a -&gt; (b,c)其算术形式为ba⋅ca=(bc)ab^{a} \\cdot c^{a} = (bc)^{a}ba⋅ca=(bc)a以及关于返回其它函数的函数1a -&gt; (b -&gt; c) === (b,a) -&gt; c其算术形式为(cb)a=cb⋅a(c^{b})^{a} = c^{b \\cdot a}(cb)a=cb⋅a当右侧部分的变量顺序切换，同时删除左侧的括号后，最后这条法则可能会变得更为令人熟悉1a -&gt; b -&gt; c === (a,b) -&gt; c这也就是我们所谓的柯里化和非柯里化的函数。再说一次，通过写出对应的 from 和 to 函数来证明所有的这些法则是一项有趣的练习。 下一篇在下一篇文章中我将着眼于递归类型，比如列表和二叉树，并展示如何在以各种方式使用类型代数来推导出关于类型的有趣事实。此处原文为 “… the type a + b is a tagged union …” 。具有标签的联合体（tagged union）这个翻译可能不是很准确，但网上也没找到其它合适的翻译，特此注明。 ↩︎","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"},{"name":"翻译作品","slug":"翻译作品","permalink":"http://miroox.github.io/blog/categories/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://miroox.github.io/blog/tags/%E7%BF%BB%E8%AF%91/"},{"name":"科普","slug":"科普","permalink":"http://miroox.github.io/blog/tags/%E7%A7%91%E6%99%AE/"},{"name":"Haskell","slug":"Haskell","permalink":"http://miroox.github.io/blog/tags/Haskell/"}]},{"title":"西方著名哲学家 课程笔记","slug":"WesternPhilosopher","date":"2017-04-01T15:22:33.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2017/04/WesternPhilosopher/","link":"","permalink":"http://miroox.github.io/blog/2017/04/WesternPhilosopher/","excerpt":"当时记录的基本就是一些关键词，所以可能不太通顺。","text":"当时记录的基本就是一些关键词，所以可能不太通顺。 0. 绪论世界三大哲学传统的特点：中国哲学与伦理学紧密联系；印度哲学与宗教紧密联系；西方哲学与科学紧密联系。研究西方哲学家时应避免：辉格史观贴标签（如：唯心主义、不可知论等）移时史观 [1] 1. 前苏格拉底时期闲暇 惊异 自由——哲学产生和发展的三个条件 1.1 伊奥尼亚自然哲学家 1.1.1 米利都派主要人物：泰勒斯、阿那克西曼德、阿那克西米尼米利都派的始基：水 -&gt; Aperion -&gt; 气 1.1.1.1 泰勒斯世界是由水构成的体现出抽象、还原的思想（当代科学的核心方法）。 1.1.1.2 阿那克西曼德Aperion（indefinite）那产生存在之物者，也就是遵照必然而毁灭的过程回归于它的东西，因为事物遵循着时间的秩序而相互付出它们的不义所造成的痛苦的代价并得到补偿 1.1.1.3 阿那克西米尼气我们的灵魂，因为它是空气，是使我们每个人结成一体的原则；同样，空气也包围着整个世界。 1.1.2 爱菲斯的赫拉克利特事物永恒变化，但遵循 logos [2]。这个有秩序的宇宙 [3] 对万物都是相同的它既不是神也不是人所创造的，它过去、现在和将来永远是一团永恒的活火，按一定尺度燃烧，一定尺度熄灭。人不能两次踏入同一条河流生与死，梦与醒，老与少，是同样的东西。后者变化，就成为前者，前者变回来，则称为后者。战争对于以前都是共同的。斗争就是正义，世间万物都是通过斗争而产生和灭亡的。 1.2 存在论的诞生 1.2.1 毕达哥拉斯学派主要人物：毕达哥拉斯万物皆数。存在的本质是形式（数）。 1.2.2 埃里亚学派主要人物：色诺芬尼、巴门尼德、芝诺 1.2.2.1 色诺芬尼神是抽象的、普遍的、不变的假如牛、马和狮子有手，并且和人一样用手作画塑像，那么它们也会按照各自的模样，绘制出马形的神和狮形的神。 1.2.2.2 巴门尼德有存在，不可能不存在，这是确定性的道路，因为它伴随着真理。另一条则是，有不存在，非有存在，这是条狭窄的小路，在这条路上，女神说：“没有什么东西照亮你的脚步”。能被思维者和能存在者是同一个东西。存在是永恒的，是一，连续不可分；存在是不动的，是真实的，可以被思想；感性世界的具体事物是非存在，是假相，不能被思想。 1.2.2.3 芝诺否认运动。假设时空连续导致的悖论：阿喀琉斯追龟、二分法假设时空不连续导致的悖论：飞矢不动、游行队伍 1.3 元素派自然哲学家① 恩培多克勒的四根说水、火、土、气② 阿那克萨戈拉的种子说种子的动力来自心智 1.4 原子论古希腊自然哲学的巅峰。“朴素唯物主义”[4]主要人物：留基伯、德谟克利特 2. 古希腊三杰古希腊哲学的特点：没有额外的目的。（实质：思考哲学问题本身是贵族身份的象征。）已有的关于世界本源的认识：质料、始基、Arche形式（数学）逻辑动力 -&gt; 心智（spirit） 2.0 智者运动智者派（Sophists）被诟病的原因：有功利性相对主义诡辩影响：使哲学从自然哲学走到人类社会。主要人物：普罗泰戈拉 2.1 苏格拉底① 确定性的追求与智者派相对② 自知无知 与 德行即知识③ 未经审视的人生不值得过④ 苏格拉底之死 2.2 柏拉图① 洞穴隐喻② 四线段比喻③ 理念论流变世界 - 理念世界知识是理念世界的实体学习都是忆旧④ 理想的人和理想国 2.3 亚里士多德分科法：理论学科实践学科创制学科to exist - 实体 - 单一物一切存在的实体都只能是单一物，而不能是抽象物。（用于反对柏拉图的理念论）逻辑：演绎推理。核心 - 三段论关于世界的本源（人工物）四因说：质料、形式、动力、目的（自然物） 潜能-现实宇宙：洋葱模型 3. 希腊化、罗马时期和中世纪的哲学与宗教 3.1 快乐主义① 昔勒尼派② 伊壁鸠鲁主义伊壁鸠鲁的三种快乐：自然而必要：朋友、自由、思想、食物、蔽风雨处、衣服自然但不必要：广宅、私人浴室、宴饮、鱼、肉不自然又不必要：名望、权势③ 快乐是唯一的善 3.2 德性主义① 犬儒主义② 斯多葛主义③ 德性是唯一的善④ 依照自然和理性生活我们个人的本性都是普遍本性的一部分，因此主要的善就是以一种顺其自然的方式生活。也就是一个人自己的本性和顺从普遍的本性。这就是按照德性而生活。愿意的人，命运领着走；不愿意的人，命运牵着走。塞涅卡我是必然要死的，但难道我就必须呻吟而死吗？我必然是被囚禁的，但难道我就必须哀怨吗？我是必然要遭流放的，但是难道因此就有任何人能阻止我，使我不能欢笑、勇敢而又镇定了吗？“那么我把你锁起来”。你说什么？锁起我来？你可以锁住我的腿，但是我的意志是你锁不了的，连宙斯都无法驯服它。爱比克泰德 3.3 怀疑主义主要人物：皮浪、恩披里克核心思想：归纳都不是确定的演绎都不能带来新知识演绎的前提归根结底来源于归纳不存在任何确定性的知识​​​。 3.4 基督教哲学基督教面临的问题：上帝存在的证明神正论 3.4.1 奥古斯丁上帝赋予人自由意志。 3.4.2 托马斯·阿奎纳上帝存在的后天证明（相对于过去的本体论证明）：因果链证明生物层次证明特创论… 4. 近代哲学的兴起背景：① 文艺复兴与宗教改革② 资本主义与科学革命③ 教权与皇权相争④ 新柏拉图主义兴起 ​​​​特点：研究方向由本体论转向了认识论主体性原则认识论的两个方面：认识的来源认识可靠性的评价标准 4.0 两大主要阵营经验主义：培根、洛克、贝克莱、休谟理性主义：笛卡尔、斯宾诺莎、莱布尼兹 4.1 培根① 四假象说② 伟大的复兴③ 新工具：归纳法-相对于基督教所推崇的亚里士多德的演绎法 4.2 笛卡尔认识的评价标准：理性认识的来源：天赋① 笛卡尔的方法：普遍怀疑法分析综合法② 身心关系③ 天赋观念 4.3 斯宾诺莎上帝是万物的动因，一切事物都在上帝之中。认识的来源：（单一的）上帝 4.4 莱布尼兹认识的来源：有无数个本源。单子论。 4.5 洛克① 批判天赋观念② 感觉和内省③ 白板说④ 两种性质说 4.6 贝克莱存在就是被感知物是观念的集合 4.7 休谟① 激进经验主义② 怀疑论③ 否定因果律否定因果律，挖去了科学的根基。另一方面，当时科学所表现出的机械论[5]，可以说是挖去了神学的根基。 5. 德国唯心主义 5.1 康德有两种东西，我对它们的思考越是深沉和持久，他们在我心灵中唤起的赞叹和敬畏就会越来越历久弥新，一是我们头顶浩瀚灿烂的星空，一是我们心中的道德律。康德区分两种不同的理性：一种是在我们的日常生活中运用，称为实践理性；另一种是在探索真理时所用，称为纯粹理性。康德的认识模型：物自体（thing-in-itself）———————————— 感官现象感性直观：时间 、空间知性范畴：质、量、关系、样式理性理念：上帝、灵魂、世界二律背反：一正题：世界在时间和空间上是有限的反题：世界在时间和空间上是无限的二正题：世界上一切都由单一、不可分的部分构成的反题：世界上没有单一的东西，一切都是复杂可分的三正题：世界上存在着自由反题：没有自由，一切都是必然的四正题：存在着世界的最初原因反题：没有世界的最初原因《纯粹理性批判》指出形而上学中研究的诸问题（如意志自由、灵魂不朽、上帝存在）是不可证明的，而《实践理性批判》则指出一个社会想要正常运转需要将它们作为假设相信。附注：关于辉格史观和移时可以 见此 ↩︎logos 一词经常被翻译成“道”，但它与中国哲学中的“道”是不同的。logos 可以称之为“普遍的理性”（或谓之“言辞”）。相对的，中国哲学中的“道”是意境的，不可言明的。 ↩︎Cosmos 其对应的反义词是 Chaos。 ↩︎“朴素”一词在哲学中的的含义：未证实的。 ↩︎Mechanism ，当时哲学和科学的两大传统之一；另一个是 Organism（有机论）。 ↩︎","categories":[{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miroox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://miroox.github.io/blog/tags/%E5%93%B2%E5%AD%A6/"},{"name":"笔记","slug":"笔记","permalink":"http://miroox.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"旧作：【翻译】MIX 文件格式","slug":"MIXFormat","date":"2017-03-25T02:12:33.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2017/03/MIXFormat/","link":"","permalink":"http://miroox.github.io/blog/2017/03/MIXFormat/","excerpt":"原文地址 XCC Homepage 中 Documents -&gt; MIX File format 。 MIX 文件格式 CopyrightCopyright © 2000 Olaf van der SpekThis program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 介绍作者：Olaf van der Spek。本文解释了命令与征服：泰伯利亚黎明、红色警戒、泰伯利亚之日使用的MIX文件的格式MIX文件用于存储其他文件，与ZIP文件相同，但没有压缩。我将在本文档中使用C++表示法。","text":"原文地址 XCC Homepage 中 Documents -&gt; MIX File format 。 MIX 文件格式 CopyrightCopyright © 2000 Olaf van der SpekThis program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 介绍作者：Olaf van der Spek。本文解释了命令与征服：泰伯利亚黎明、红色警戒、泰伯利亚之日使用的MIX文件的格式MIX文件用于存储其他文件，与ZIP文件相同，但没有压缩。我将在本文档中使用C++表示法。123typedef unsigned char byte;typedef unsigned short word;typedef unsigned long dword; 首部(Header)一个MIX文件由两部分组成：一个首部和一个主体。首部存储有关文件数，总文件大小和每个内部文件的ID，偏移量和大小的信息泰伯利亚黎明的MIX文件没有做加密，而红色警戒和泰伯利亚之日的MIX文件可能对首部的一部分使用了Blowfish算法加密。我将首先介绍泰伯利亚黎明的MIX文件。12345struct t_mix_header&#123; __int16 c_files; // 内部文件数目 __int32 size; // 主体的大小，不包括这个首部和索引&#125;;紧接在其后的是内部文件的索引。该索引由具有以下结构的C语言文件条目组成。123456struct t_mix_index_entry&#123; unsigned __int32 id; // ID，代替一个正常的文件名来标识文件 __int32 offset; // 相对主体开头的偏移量 __int32 size; // 这个内部文件的大小&#125;;在这个索引之后是实际主体的开头。现在来介绍泰伯利亚之日/红色警戒的MIX文件。它始于一个32位的标记(flag)，这个标记表明这个MIX文件是否有校验和(checksum)以及是否已经被加密。12const int mix_checksum = 0x00010000;const int mix_encrypted = 0x00020000;如果一个MIX文件有校验和，那么在主体之后20字节处会包含一个校验和。这个校验和可以被忽略或删除。如果这个MIX文件被加密了，那么在被称为key_source的标记之后有一80字节的块。它可以用于计算Blowfish算法的密钥。如果MIX文件没被加密，那么这个标记之后将会是一个普通的首部。好了，MIX文件的首部使56字节密钥的Blowfish算法加密。这意味着在key_source之后，存在许多需要解密的8字节块。你可以通过解密包含MIX首部的第一个区域来知道有多少个区域。然后查看这里有多少个内部文件并计算首部和索引的大小。 IDsID用于标识每个文件。它们可以从原始的文件名中计算出来。这里有两个不同的版本来计算ID，一个用于泰伯利亚黎明和红色警戒而另一个用于泰伯利亚之日。我使用如下的代码来计算ID。12345678910111213141516171819202122232425262728293031323334353637383940int Cmix_file::get_id(t_game game, string name)&#123; name = to_upper(name); // 转换为大写 if (game != game_ts) &#123; // 用于泰伯利亚黎明和红色警戒 int i = 0; unsigned int id = 0; int l = name.length(); // 文件名长度 while (i &lt; l) &#123; unsigned int a = 0; for (int j = 0; j &lt; 4; j++) &#123; a &gt;&gt;= 8; if (i &lt; l) a += static_cast&lt;unsigned int&gt;(name[i]) &lt;&lt; 24; i++; &#125; id = (id &lt;&lt; 1 | id &gt;&gt; 31) + a; &#125; return id; &#125; else &#123; // 用于泰伯利亚之日 const int l = name.length(); int a = l &gt;&gt; 2; if (l &amp; 3) &#123; name += static_cast&lt;char&gt;(l - (a &lt;&lt; 2)); int i = 3 - (l &amp; 3); while (i--) name += name[a &lt;&lt; 2]; &#125; Ccrc crc; // 使用普通的CRC(循环冗余校验?)函数 crc.init(); crc.do_block(name.c_str(), name.length()); return crc.get_crc(); &#125;&#125; 主体主体包含未压缩和未加密格式的内部文件。 校验和关于校验和，目前唯一知道的只有它有20字节长。只要你修改对应的标记，你就可以安全的删去它。 Blowfish算法在MIX文件中，Blowfish算法用于加密和解密首部。你可以使用这个代码来加密/解密首部。首先，你需要用set_key来设置密钥。这不是80字节的key_source，所以你首先要用下面关于WS密钥计算的代码来计算密钥。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423typedef dword t_bf_p[18];typedef dword t_bf_s[4][256];class Cblowfish&#123;public: void set_key(const byte* key, int cb_key); void encipher(dword&amp; xl, dword&amp; xr) const; void encipher(const void* s, void* d, int size) const; void decipher(dword&amp; xl, dword&amp; xr) const; void decipher(const void* s, void* d, int size) const;private: inline dword Cblowfish::S(dword x, int i) const; inline dword Cblowfish::bf_f(dword x) const; inline void Cblowfish::ROUND(dword&amp; a, dword b, int n) const; t_bf_p m_p; t_bf_s m_s;&#125;;const t_bf_p p = &#123; 0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89, 0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 0x9216d5d9, 0x8979fb1b&#125;;const t_bf_s s = &#123; 0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e, 0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013, 0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e, 0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440, 0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a, 0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193, 0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032, 0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239, 0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0, 0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe, 0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d, 0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463, 0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09, 0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb, 0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8, 0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82, 0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573, 0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b, 0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4, 0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c, 0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1, 0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9, 0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf, 0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af, 0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915, 0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a, 0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266, 0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1, 0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1, 0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8, 0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd, 0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7, 0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331, 0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af, 0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87, 0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c, 0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd, 0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509, 0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a, 0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960, 0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28, 0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84, 0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf, 0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e, 0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281, 0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696, 0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73, 0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0, 0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105, 0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250, 0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285, 0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061, 0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc, 0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340, 0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7, 0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068, 0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840, 0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504, 0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb, 0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6, 0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b, 0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b, 0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c, 0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc, 0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564, 0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115, 0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728, 0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0, 0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e, 0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d, 0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b, 0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb, 0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c, 0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9, 0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe, 0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc, 0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9, 0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c, 0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169, 0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027, 0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62, 0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634, 0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76, 0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc, 0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c, 0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0, 0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe, 0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b, 0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6, 0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22, 0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59, 0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c, 0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28, 0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd, 0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319, 0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f, 0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166, 0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb, 0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47, 0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370, 0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048, 0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd, 0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f, 0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525, 0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e, 0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299, 0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc, 0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a, 0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b, 0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060, 0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f, 0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6&#125;;void Cblowfish::set_key(const byte* key, int cb_key)&#123; int i, j; dword datal, datar; memcpy(m_p, p, sizeof(t_bf_p)); memcpy(m_s, s, sizeof(t_bf_s)); j = 0; for (i = 0; i &lt; 18; i++) &#123; int a = key[j++]; j %= cb_key; int b = key[j++]; j %= cb_key; int c = key[j++]; j %= cb_key; int d = key[j++]; j %= cb_key; m_p[i] ^= a &lt;&lt; 24 | b &lt;&lt; 16 | c &lt;&lt; 8 | d; &#125; datal = datar = 0; for (i = 0; i &lt; 18;) &#123; encipher(datal, datar); m_p[i++] = datal; m_p[i++] = datar; &#125; for (i = 0; i &lt; 4; i++) &#123; for (j = 0; j &lt; 256;) &#123; encipher(datal, datar); m_s[i][j++] = datal; m_s[i][j++] = datar; &#125; &#125;&#125;inline dword Cblowfish::S(dword x, int i) const&#123; return m_s[i][(x &gt;&gt; ((3 - i) &lt;&lt; 3)) &amp; 0xff];&#125;inline dword Cblowfish::bf_f(dword x) const&#123; return ((S(x, 0) + S(x, 1)) ^ S(x, 2)) + S(x, 3);&#125;inline void Cblowfish::ROUND(dword&amp; a, dword b, int n) const&#123; a ^= bf_f(b) ^ m_p[n];&#125;void Cblowfish::encipher(dword&amp; xl, dword&amp; xr) const&#123; dword Xl = xl; dword Xr = xr; Xl ^= m_p[0]; ROUND (Xr, Xl, 1); ROUND (Xl, Xr, 2); ROUND (Xr, Xl, 3); ROUND (Xl, Xr, 4); ROUND (Xr, Xl, 5); ROUND (Xl, Xr, 6); ROUND (Xr, Xl, 7); ROUND (Xl, Xr, 8); ROUND (Xr, Xl, 9); ROUND (Xl, Xr, 10); ROUND (Xr, Xl, 11); ROUND (Xl, Xr, 12); ROUND (Xr, Xl, 13); ROUND (Xl, Xr, 14); ROUND (Xr, Xl, 15); ROUND (Xl, Xr, 16); Xr ^= m_p[17]; xr = Xl; xl = Xr;&#125;void Cblowfish::decipher(dword&amp; xl, dword&amp; xr) const&#123; dword Xl = xl; dword Xr = xr; Xl ^= m_p[17]; ROUND (Xr, Xl, 16); ROUND (Xl, Xr, 15); ROUND (Xr, Xl, 14); ROUND (Xl, Xr, 13); ROUND (Xr, Xl, 12); ROUND (Xl, Xr, 11); ROUND (Xr, Xl, 10); ROUND (Xl, Xr, 9); ROUND (Xr, Xl, 8); ROUND (Xl, Xr, 7); ROUND (Xr, Xl, 6); ROUND (Xl, Xr, 5); ROUND (Xr, Xl, 4); ROUND (Xl, Xr, 3); ROUND (Xr, Xl, 2); ROUND (Xl, Xr, 1); Xr ^= m_p[0]; xl = Xr; xr = Xl;&#125;static inline dword reverse(dword v)&#123; _asm &#123; mov eax, v xchg al, ah rol eax, 16 xchg al, ah mov v, eax &#125; return v;&#125;void Cblowfish::encipher(const void* s, void* d, int size) const&#123; const dword* r = reinterpret_cast&lt;const dword*&gt;(s); dword* w = reinterpret_cast&lt;dword*&gt;(d); size &gt;&gt;= 3; while (size--) &#123; dword a = reverse(*r++); dword b = reverse(*r++); encipher(a, b); *w++ = reverse(a); *w++ = reverse(b); &#125;&#125;void Cblowfish::decipher(const void* s, void* d, int size) const&#123; const dword* r = reinterpret_cast&lt;const dword*&gt;(s); dword* w = reinterpret_cast&lt;dword*&gt;(d); size &gt;&gt;= 3; while (size--) &#123; dword a = reverse(*r++); dword b = reverse(*r++); decipher(a, b); *w++ = reverse(a); *w++ = reverse(b); &#125;&#125; CRC在MIX文件中，CRC用来计算一个文件的ID。你可以使用这个代码来计算一个文件名的ID，但你也能用它来计算其它东西的CRC，例如一个文件。这与ZIP文件使用的CRC相同。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Ccrc&#123;public: void do_block(const void* data, int size); void init() &#123; m_crc = 0; &#125; int get_crc() const &#123; return m_crc; &#125;private: unsigned int m_crc;&#125;;int crc_table[256] = &#123; 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d&#125;;void Ccrc::do_block(const void* data, int size)&#123; const unsigned char* r = reinterpret_cast&lt;const unsigned char*&gt;(data); m_crc = ~m_crc; while (size--) m_crc = (m_crc &gt;&gt; 8) ^ crc_table[*r++ ^ (m_crc &amp; 0xff)]; m_crc = ~m_crc;&#125; WS密钥计算这部分涵盖了Westwood Studio的密钥计算。这是一个将80字节的key_source作为输入并输出56字节的密钥的函数。它使用一个非常大的整数算法。你需要调用的函数是void get_blowfish_key(const byte* s, byte* d)。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423char *pubkey_str = \"AihRvNoIbTn85FZRYNZRcT+i6KpU+maCsEqr3Q5q+LDB5tH7Tz2qQ38V\";const static char char2num[] = &#123; -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1&#125;;typedef dword bignum4[4];typedef dword bignum[64];typedef dword bignum130[130];struct&#123; bignum key1; bignum key2; dword len;&#125; pubkey;bignum glob1;dword glob1_bitlen, glob1_len_x2;bignum130 glob2;bignum4 glob1_hi, glob1_hi_inv;dword glob1_hi_bitlen;dword glob1_hi_inv_lo, glob1_hi_inv_hi;static void init_bignum(bignum n, dword val, dword len)&#123; memset((void *)n, 0, len * 4); n[0] = val;&#125;static void move_key_to_big(bignum n, char *key, dword klen, dword blen)&#123; dword sign; int i; if (key[0] &amp; 0x80) sign = 0xff; else sign = 0; for (i = blen*4; i &gt; klen; i--) ((char *)n)[i-1] = sign; for (; i &gt; 0; i--) ((char *)n)[i-1] = key[klen-i];&#125;static void key_to_bignum(bignum n, char *key, dword len)&#123; dword keylen; int i; if (key[0] != 2) return; key++; if (key[0] &amp; 0x80) &#123; keylen = 0; for (i = 0; i &lt; (key[0] &amp; 0x7f); i++) keylen = (keylen &lt;&lt; 8) | key[i+1]; key += (key[0] &amp; 0x7f) + 1; &#125; else &#123; keylen = key[0]; key++; &#125; if (keylen &lt;= len*4) move_key_to_big(n, key, keylen, len);&#125;static dword len_bignum(bignum n, dword len)&#123; int i; i = len-1; while ((i &gt;= 0) &amp;&amp; (n[i] == 0)) i--; return i+1;&#125;static dword bitlen_bignum(bignum n, dword len)&#123; dword ddlen, bitlen, mask; ddlen = len_bignum(n, len); if (ddlen == 0) return 0; bitlen = ddlen * 32; mask = 0x80000000; while ((mask &amp; n[ddlen-1]) == 0) &#123; mask &gt;&gt;= 1; bitlen--; &#125; return bitlen;&#125;static void init_pubkey()&#123; dword i, i2, tmp; char keytmp[256]; init_bignum(pubkey.key2, 0x10001, 64); i = 0; i2 = 0; while (i &lt; strlen(pubkey_str)) &#123; tmp = char2num[pubkey_str[i++]]; tmp &lt;&lt;= 6; tmp |= char2num[pubkey_str[i++]]; tmp &lt;&lt;= 6; tmp |= char2num[pubkey_str[i++]]; tmp &lt;&lt;= 6; tmp |= char2num[pubkey_str[i++]]; keytmp[i2++] = (tmp &gt;&gt; 16) &amp; 0xff; keytmp[i2++] = (tmp &gt;&gt; 8) &amp; 0xff; keytmp[i2++] = tmp &amp; 0xff; &#125; key_to_bignum(pubkey.key1, keytmp, 64); pubkey.len = bitlen_bignum(pubkey.key1, 64) - 1;&#125;static dword len_predata()&#123; dword a = (pubkey.len - 1) / 8; return (55 / a + 1) * (a + 1);&#125;static long int cmp_bignum(bignum n1, bignum n2, dword len)&#123; n1 += len-1; n2 += len-1; while (len &gt; 0) &#123; if (*n1 &lt; *n2) return -1; if (*n1 &gt; *n2) return 1; n1--; n2--; len--; &#125; return 0;&#125;static void mov_bignum(bignum dest, bignum src, dword len)&#123; memmove(dest, src, len*4);&#125;static void shr_bignum(bignum n, dword bits, long int len)&#123; dword i, i2; i2 = bits / 32; if (i2 &gt; 0) &#123; for (i = 0; i &lt; len - i2; i++) n[i] = n[i + i2]; for (; i &lt; len; i++) n[i] = 0; bits = bits % 32; &#125; if (bits == 0) return; for (i = 0; i &lt; len - 1; i++) n[i] = (n[i] &gt;&gt; bits) | (n[i + 1] &lt;&lt; (32 -bits)); n[i] = n[i] &gt;&gt; bits;&#125;static void shl_bignum(bignum n, dword bits, dword len)&#123; dword i, i2; i2 = bits / 32; if (i2 &gt; 0) &#123; for (i = len - 1; i &gt; i2; i--) n[i] = n[i - i2]; for (; i &gt; 0; i--) n[i] = 0; bits = bits % 32; &#125; if (bits == 0) return; for (i = len - 1; i &gt; 0; i--) n[i] = (n[i] &lt;&lt; bits) | (n[i - 1] &gt;&gt; (32 -bits)); n[0] &lt;&lt;= bits;&#125;static dword sub_bignum(bignum dest, bignum src1, bignum src2, dword carry, dword len)&#123; dword i1, i2; len += len; while (--len != -1) &#123; i1 = *(word *)src1; i2 = *(word *)src2; *(word *)dest = i1 - i2 - carry; src1 = (dword *)(((word *)src1) + 1); src2 = (dword *)(((word *)src2) + 1); dest = (dword *)(((word *)dest) + 1); if ((i1 - i2 - carry) &amp; 0x10000) carry = 1; else carry = 0; &#125; return carry;&#125;static void inv_bignum(bignum n1, bignum n2, dword len)&#123; bignum n_tmp; dword n2_bytelen, bit; long int n2_bitlen; init_bignum(n_tmp, 0, len); init_bignum(n1, 0, len); n2_bitlen = bitlen_bignum(n2, len); bit = ((dword)1) &lt;&lt; (n2_bitlen % 32); n1 += ((n2_bitlen + 32) / 32) - 1; n2_bytelen = ((n2_bitlen - 1) / 32) * 4; n_tmp[n2_bytelen / 4] |= ((dword)1) &lt;&lt; ((n2_bitlen - 1) &amp; 0x1f); while (n2_bitlen &gt; 0) &#123; n2_bitlen--; shl_bignum(n_tmp, 1, len); if (cmp_bignum(n_tmp, n2, len) != -1) &#123; sub_bignum(n_tmp, n_tmp, n2, 0, len); *n1 |= bit; &#125; bit &gt;&gt;= 1; if (bit == 0) &#123; n1--; bit = 0x80000000; &#125; &#125; init_bignum(n_tmp, 0, len);&#125;static void inc_bignum(bignum n, dword len)&#123; while ((++*n == 0) &amp;&amp; (--len &gt; 0)) n++;&#125;static void init_two_dw(bignum n, dword len)&#123; mov_bignum(glob1, n, len); glob1_bitlen = bitlen_bignum(glob1, len); glob1_len_x2 = (glob1_bitlen + 15) / 16; mov_bignum(glob1_hi, glob1 + len_bignum(glob1, len) - 2, 2); glob1_hi_bitlen = bitlen_bignum(glob1_hi, 2) - 32; shr_bignum(glob1_hi, glob1_hi_bitlen, 2); inv_bignum(glob1_hi_inv, glob1_hi, 2); shr_bignum(glob1_hi_inv, 1, 2); glob1_hi_bitlen = (glob1_hi_bitlen + 15) % 16 + 1; inc_bignum(glob1_hi_inv, 2); if (bitlen_bignum(glob1_hi_inv, 2) &gt; 32) &#123; shr_bignum(glob1_hi_inv, 1, 2); glob1_hi_bitlen--; &#125; glob1_hi_inv_lo = *(word *)glob1_hi_inv; glob1_hi_inv_hi = *(((word *)glob1_hi_inv) + 1);&#125;static void mul_bignum_word(bignum n1, bignum n2, dword mul, dword len)&#123; dword i, tmp; tmp = 0; for (i = 0; i &lt; len; i++) &#123; tmp = mul * (*(word *)n2) + *(word *)n1 + tmp; *(word *)n1 = tmp; n1 = (dword *)(((word *)n1) + 1); n2 = (dword *)(((word *)n2) + 1); tmp &gt;&gt;= 16; &#125; *(word *)n1 += tmp;&#125;static void mul_bignum(bignum dest, bignum src1, bignum src2, dword len)&#123; dword i; init_bignum(dest, 0, len*2); for (i = 0; i &lt; len*2; i++) &#123; mul_bignum_word(dest, src1, *(word *)src2, len*2); src2 = (dword *)(((word *)src2) + 1); dest = (dword *)(((word *)dest) + 1); &#125;&#125;static void not_bignum(bignum n, dword len)&#123; dword i; for (i = 0; i &lt; len; i++) *(n++) = ~*n;&#125;static void neg_bignum(bignum n, dword len)&#123; not_bignum(n, len); inc_bignum(n, len);&#125;static dword get_mulword(bignum n)&#123; dword i; word *wn; wn = (word *)n; i = (((((((((*(wn-1) ^ 0xffff) &amp; 0xffff) * glob1_hi_inv_lo + 0x10000) &gt;&gt; 1) + (((*(wn-2) ^ 0xffff) * glob1_hi_inv_hi + glob1_hi_inv_hi) &gt;&gt; 1) + 1) &gt;&gt; 16) + ((((*(wn-1) ^ 0xffff) &amp; 0xffff) * glob1_hi_inv_hi) &gt;&gt; 1) + (((*wn ^ 0xffff) * glob1_hi_inv_lo) &gt;&gt; 1) + 1) &gt;&gt; 14) + glob1_hi_inv_hi * (*wn ^ 0xffff) * 2) &gt;&gt; glob1_hi_bitlen; if (i &gt; 0xffff) i = 0xffff; return i &amp; 0xffff;&#125;static void dec_bignum(bignum n, dword len)&#123; while ((--*n == 0xffffffff) &amp;&amp; (--len &gt; 0)) n++;&#125;static void calc_a_bignum(bignum n1, bignum n2, bignum n3, dword len)&#123; dword g2_len_x2, len_diff; word *esi, *edi; word tmp; mul_bignum(glob2, n2, n3, len); glob2[len*2] = 0; g2_len_x2 = len_bignum(glob2, len*2+1)*2; if (g2_len_x2 &gt;= glob1_len_x2) &#123; inc_bignum(glob2, len*2+1); neg_bignum(glob2, len*2+1); len_diff = g2_len_x2 + 1 - glob1_len_x2; esi = ((word *)glob2) + (1 + g2_len_x2 - glob1_len_x2); edi = ((word *)glob2) + (g2_len_x2 + 1); for (; len_diff != 0; len_diff--) &#123; edi--; tmp = get_mulword((dword *)edi); esi--; if (tmp &gt; 0) &#123; mul_bignum_word((dword *)esi, glob1, tmp, 2*len); if ((*edi &amp; 0x8000) == 0) &#123; if (sub_bignum((dword *)esi, (dword *)esi, glob1, 0, len)) (*edi)--; &#125; &#125; &#125; neg_bignum(glob2, len); dec_bignum(glob2, len); &#125; mov_bignum(n1, glob2, len);&#125;static void clear_tmp_vars(dword len)&#123; init_bignum(glob1, 0, len); init_bignum(glob2, 0, len); init_bignum(glob1_hi_inv, 0, 4); init_bignum(glob1_hi, 0, 4); glob1_bitlen = 0; glob1_hi_bitlen = 0; glob1_len_x2 = 0; glob1_hi_inv_lo = 0; glob1_hi_inv_hi = 0;&#125;static void calc_a_key(bignum n1, bignum n2, bignum n3, bignum n4, dword len)&#123; bignum n_tmp; dword n3_len, n4_len, n3_bitlen, bit_mask; init_bignum(n1, 1, len); n4_len = len_bignum(n4, len); init_two_dw(n4, n4_len); n3_bitlen = bitlen_bignum(n3, n4_len); n3_len = (n3_bitlen + 31) / 32; bit_mask = (((dword)1) &lt;&lt; ((n3_bitlen - 1) % 32)) &gt;&gt; 1; n3 += n3_len - 1; n3_bitlen--; mov_bignum(n1, n2, n4_len); while (--n3_bitlen != -1) &#123; if (bit_mask == 0) &#123; bit_mask = 0x80000000; n3--; &#125; calc_a_bignum(n_tmp, n1, n1, n4_len); if (*n3 &amp; bit_mask) calc_a_bignum(n1, n_tmp, n2, n4_len); else mov_bignum(n1, n_tmp, n4_len); bit_mask &gt;&gt;= 1; &#125; init_bignum(n_tmp, 0, n4_len); clear_tmp_vars(len);&#125;static void process_predata(const byte* pre, dword pre_len, byte *buf)&#123; bignum n2, n3; const dword a = (pubkey.len - 1) / 8; while (a + 1 &lt;= pre_len) &#123; init_bignum(n2, 0, 64); memmove(n2, pre, a + 1); calc_a_key(n3, n2, pubkey.key2, pubkey.key1, 64); memmove(buf, n3, a); pre_len -= a + 1; pre += a + 1; buf += a; &#125;&#125;void get_blowfish_key(const byte* s, byte* d)&#123; static public_key_initialized = false; if (!public_key_initialized) &#123; init_pubkey(); public_key_initialized = true; &#125; byte key[256]; process_predata(s, len_predata(), key); memcpy(d, key, 56);&#125; 链接http://www.counterpane.com/blowfish.html","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"},{"name":"翻译作品","slug":"翻译作品","permalink":"http://miroox.github.io/blog/categories/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"红警","slug":"红警","permalink":"http://miroox.github.io/blog/tags/%E7%BA%A2%E8%AD%A6/"},{"name":"翻译","slug":"翻译","permalink":"http://miroox.github.io/blog/tags/%E7%BF%BB%E8%AF%91/"},{"name":"参考","slug":"参考","permalink":"http://miroox.github.io/blog/tags/%E5%8F%82%E8%80%83/"},{"name":"文件格式","slug":"文件格式","permalink":"http://miroox.github.io/blog/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"}]},{"title":"旧作：借助卷积定理证明中心极限定理","slug":"ProveCRTWithConvolution","date":"2016-12-10T01:49:11.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2016/12/ProveCRTWithConvolution/","link":"","permalink":"http://miroox.github.io/blog/2016/12/ProveCRTWithConvolution/","excerpt":"摘要 ：中心极限定理的研究在概率论具有重要地位，它揭示了大量独立同分布的的随机变量之和的极限趋势为正态分布，在统计学以及其它许多学科中都有重要的应用。但教材[1]中并没有给出其具体证明。本文将从傅里叶变换中的卷积定理的角度证明该定理。关键词 ：中心极限定理, 傅里叶变换, 卷积定理","text":"摘要 ：中心极限定理的研究在概率论具有重要地位，它揭示了大量独立同分布的的随机变量之和的极限趋势为正态分布，在统计学以及其它许多学科中都有重要的应用。但教材[1]中并没有给出其具体证明。本文将从傅里叶变换中的卷积定理的角度证明该定理。关键词 ：中心极限定理, 傅里叶变换, 卷积定理 引言Everyone believes in it: experimentalists believing that it is a mathematical theorem, mathematicians believing that it is an empirical fact. [2]Henri Poincaré对中心极限定理的研究实质上始于1733年棣莫弗（A. de Moirvre）对二项分布的极限分布的研究，并得到了拉普拉斯（P.-S. Laplace）、泊松（S.-D. Possion）、贝塞尔（A.L. Bessel）、柯西（A.-L. Cauchy）等人的进一步研究和推广。但总体上，由于当时概率论不太受数学家重视，中心极限定理在很长一段时间没有得到一个完整的严格证明，直到1901年李雅普诺夫（A.M. Lyapunov）借助特征函数的工具才有了一个条件较为宽松的严格证明。[3]一个常用的中心极限定理如下：[1]定理 1 （独立同分布的中心极限定理）如果随机变量序列 X1,X2,⋯ ,Xn,⋯X_{1},X_{2},\\cdots ,X_{n},\\cdotsX1​,X2​,⋯,Xn​,⋯ 独立同分布，并且具有有限的数学期望和方差 E(Xi)=μ,D(Xi)=σ2&gt;0(i=1,2,3,⋯ )E(X_{i})=\\mu ,D(X_{i})=\\sigma ^{2}&gt;0 (i=1,2,3,\\cdots )E(Xi​)=μ,D(Xi​)=σ2&gt;0(i=1,2,3,⋯) ，则对一切 x∈Rx\\in {\\rm\\bf{R}}x∈R 有lim⁡n→∞P(1nσ(∑i=1nXi−nμ)≤x)=∫−∞x12πe−t22dt\\lim_{n\\to\\infty} P\\left(\\frac{1}{\\sqrt{n}\\sigma}\\left(\\sum_{i=1}^{n}X_{i}-n\\mu \\right)\\le x\\right) = \\int_{-\\infty }^{x}\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^{2}}{2}}\\mathrm{d}tn→∞lim​P(n​σ1​(i=1∑n​Xi​−nμ)≤x)=∫−∞x​2π​1​e−2t2​dt本文将以上述定理为例，从卷积定理的角度对其进行证明。 卷积定理及中心极限定理的证明 卷积、卷积与独立随机变量之和的关系在傅里叶变换的语境下，卷积的概念如下：[4]定义 1 （卷积）给定定义在 (−∞,+∞)(-\\infty,+\\infty)(−∞,+∞) 上的函数 f1(t)f_{1}(t)f1​(t) 与 f2(t)f_{2}(t)f2​(t) ，称由含参变量 ttt 的广义积分所确定的函数g(t)=∫−∞+∞f1(τ)f2(t−τ)dτg(t) = \\int_{-\\infty}^{+\\infty}f_{1}(\\tau)f_{2}(t-\\tau)\\mathrm{d}\\taug(t)=∫−∞+∞​f1​(τ)f2​(t−τ)dτ为函数 f1(t)f_{1}(t)f1​(t) 与 f2(t)f_{2}(t)f2​(t) 的卷积，记为g(t)=f1(t)∗f2(t)g(t) = f_{1}(t) \\ast f_{2}(t)g(t)=f1​(t)∗f2​(t)出于方便，我们只考虑连续型随机变量（离散型随机变量通常可以通过在连续型随机变量的概率密度函数中使用 Dirac δ 函数来表示）。我们注意到，对于独立随机变量 X1,X2X_{1},X_{2}X1​,X2​ ，其概率密度为 f1(x1),f2(x2)f_{1}(x_{1}),f_{2}(x_{2})f1​(x1​),f2​(x2​) ，那么对于任意的 Y∈RY\\in \\textbf{R}Y∈R ，都有P(X1+X2≤Y)=∬x1+x2≤Yf1(x1)f2(x2)dx1dx2=∫−∞Y∫−∞+∞f1(x1)f2(y−x1)dx1dy=∫−∞Y(f1∗f2)(y)dy\\begin{aligned} P(X_{1}+X_{2}\\le Y) &amp;= \\iint_{x_{1}+x_{2}\\le Y}f_{1}(x_{1})f_{2}(x_{2})\\mathrm{d}x_{1}\\mathrm{d}x_{2} \\\\ &amp;= \\int_{-\\infty}^{Y}\\int_{-\\infty}^{+\\infty}f_{1}(x_{1})f_{2}(y-x_{1})\\mathrm{d}x_{1}\\mathrm{d}y \\\\ &amp;= \\int_{-\\infty}^{Y}(f_{1}\\ast f_{2})(y)\\mathrm{d}y \\end{aligned}P(X1​+X2​≤Y)​=∬x1​+x2​≤Y​f1​(x1​)f2​(x2​)dx1​dx2​=∫−∞Y​∫−∞+∞​f1​(x1​)f2​(y−x1​)dx1​dy=∫−∞Y​(f1​∗f2​)(y)dy​亦即，若记随机变量 Y=X1+X2Y=X_{1}+X_{2}Y=X1​+X2​，则其概率密度函数fY(y)=(f1∗f2)(y)f_{Y}(y) = (f_{1}\\ast f_{2})(y)fY​(y)=(f1​∗f2​)(y)归纳地，对于随机变量 Y=X1+X2+⋯+XnY=X_{1}+X_{2}+\\cdots+X_{n}Y=X1​+X2​+⋯+Xn​，其概率密度函数fY(y)=(f1∗f2∗⋯∗fn)(y)f_{Y}(y) = (f_{1}\\ast f_{2} \\ast \\cdots \\ast f_{n})(y)fY​(y)=(f1​∗f2​∗⋯∗fn​)(y) 中心极限定理的证明众所周知，傅里叶变换可以将函数的卷积变换为像函数的乘积，即所谓的卷积定理[5]定理 2 （卷积定理）给定两个函数f1(t),f2(t)f_{1}(t),f_{2}(t)f1​(t),f2​(t)，记F1(ω)=F[f1(t)],F2(ω)=F[f2(t)]F_{1}(\\omega)=\\mathscr{F} [f_{1}(t)],F_{2}(\\omega)=\\mathscr{F} [f_{2}(t)]F1​(ω)=F[f1​(t)],F2​(ω)=F[f2​(t)]，则F[f1(t)∗f2(t)]=F1(ω)⋅F2(ω)\\mathscr{F} [f_{1}(t) \\ast f_{2}(t)] = F_{1}(\\omega)\\cdot F_{2}(\\omega)F[f1​(t)∗f2​(t)]=F1​(ω)⋅F2​(ω)这样，独立的随机变量之和的概率密度函数的求解可以得到简化。下面进行对定理 1 进行证明：对于独立同分布的随机变量序列 X1,X2,⋯ ,Xn,⋯X_{1},X_{2},\\cdots ,X_{n},\\cdotsX1​,X2​,⋯,Xn​,⋯ ，具有相同的概率密度 f(x)f(x)f(x)，不妨取其期望 E(Xi)=0E(X_{i})=0E(Xi​)=0， 方差 D(Xi)=1D(X_{i})=1D(Xi​)=1（一般的，对于期望为 μ\\muμ，方差为 σ2\\sigma^{2}σ2 的随机变量 X′X&#x27;X′，总能通过变换 X=X′−μσX=\\frac{X&#x27;-\\mu}{\\sigma}X=σX′−μ​ 化为这种“标准”的形式）。另记随机变量Yn=1n(∑i=1nXi)Y_{n} = \\frac{1}{\\sqrt{n}}\\left(\\sum_{i=1}^{n}X_{i} \\right)Yn​=n​1​(i=1∑n​Xi​)其概率密度为fn(y)=n(f∗⋯∗f⏟n)(ny)f_{n}(y) = \\sqrt{n}(\\underbrace{ f\\ast\\cdots\\ast f}_{n})(\\sqrt{n}y)fn​(y)=n​(nf∗⋯∗f​​)(n​y)记 F[f(x)]=F(ω)\\mathscr{F}[f(x)]=F(\\omega)F[f(x)]=F(ω) ，对 fn(y)f_{n}(y)fn​(y) 做傅里叶变换F[fn(y)]=F[n(f∗⋯∗f⏟n)(ny)]=nF[(f∗⋯∗f⏟n)(ny)]=(F(f∗⋯∗f⏟n))(ωn)=(F(ωn))n\\begin{aligned} \\mathscr{F} [f_{n}(y)] &amp;= \\mathscr{F} [\\sqrt{n}(\\underbrace{ f\\ast\\cdots\\ast f}_{n})(\\sqrt{n}y)] \\\\ &amp;= \\sqrt{n}\\mathscr{F} [(\\underbrace{ f\\ast\\cdots\\ast f}_{n})(\\sqrt{n}y)] \\\\ &amp;= (\\mathscr{F} (\\underbrace{ f\\ast\\cdots\\ast f}_{n}))\\left(\\frac{\\omega}{\\sqrt{n}}\\right) \\\\ &amp;= \\left(F\\left(\\frac{\\omega}{\\sqrt{n}}\\right)\\right)^{n} \\end{aligned}F[fn​(y)]​=F[n​(nf∗⋯∗f​​)(n​y)]=n​F[(nf∗⋯∗f​​)(n​y)]=(F(nf∗⋯∗f​​))(n​ω​)=(F(n​ω​))n​另一方面F(ωn)=∫−∞+∞f(x)e−ıωnxdx(1)F\\left(\\frac{\\omega}{\\sqrt{n}}\\right) = \\int_{-\\infty}^{+\\infty}f(x)e^{-\\imath\\dfrac{\\omega}{\\sqrt{n}}x}\\mathrm{d}x \\tag{1}F(n​ω​)=∫−∞+∞​f(x)e−ın​ω​xdx(1)注意到 ∣e−ıωnx∣=1\\left\\vert e^{-\\imath\\frac{\\omega}{\\sqrt{n}}x}\\right\\vert =1∣∣∣​e−ın​ω​x∣∣∣​=1，故上述积分绝对收敛。对 e−ıωnxe^{-\\imath\\frac{\\omega}{\\sqrt{n}}x}e−ın​ω​x 做泰勒展开F(ωn)=∫−∞+∞[1−ıωnx+12(ıωnx)2+Rn(x)]f(x)dx=∫−∞+∞f(x)dx−ıωn∫−∞+∞xf(x)dx−ω22n∫−∞+∞x2f(x)dx+∫−∞+∞Rn(x)f(x)dx=1−ω22n+∫−∞+∞Rn(x)f(x)dx\\begin{aligned} F\\left(\\frac{\\omega}{\\sqrt{n}}\\right) &amp;= \\int_{-\\infty}^{+\\infty} \\left[1 - \\imath\\dfrac{\\omega}{\\sqrt{n}}x + \\dfrac{1}{2}\\left(\\imath\\dfrac{\\omega}{\\sqrt{n}}x\\right)^{2} + R_{n}(x)\\right] f(x)\\mathrm{d}x \\\\ &amp;= \\int_{-\\infty}^{+\\infty}f(x)\\mathrm{d}x - \\imath\\dfrac{\\omega}{\\sqrt{n}}\\int_{-\\infty}^{+\\infty}xf(x)\\mathrm{d}x - \\dfrac{\\omega^{2}}{2n}\\int_{-\\infty}^{+\\infty}x^{2}f(x)\\mathrm{d}x + \\int_{-\\infty}^{+\\infty}R_{n}(x)f(x)\\mathrm{d}x \\\\ &amp;= 1-\\dfrac{\\omega^{2}}{2n} + \\int_{-\\infty}^{+\\infty}R_{n}(x)f(x)\\mathrm{d}x \\end{aligned}F(n​ω​)​=∫−∞+∞​[1−ın​ω​x+21​(ın​ω​x)2+Rn​(x)]f(x)dx=∫−∞+∞​f(x)dx−ın​ω​∫−∞+∞​xf(x)dx−2nω2​∫−∞+∞​x2f(x)dx+∫−∞+∞​Rn​(x)f(x)dx=1−2nω2​+∫−∞+∞​Rn​(x)f(x)dx​由于式(1)中的积分总是有限的，故上式中∫−∞+∞Rn(x)f(x)dx=o(1n),n→∞\\int_{-\\infty}^{+\\infty}R_{n}(x)f(x)\\mathrm{d}x=o\\left(\\frac{1}{n}\\right) \\qquad ,n\\to\\infty∫−∞+∞​Rn​(x)f(x)dx=o(n1​),n→∞因而lim⁡n→∞(F(ωn))n=lim⁡n→∞(1−ω22n+o(1n))n=e−ω22\\lim_{n\\to\\infty}\\left(F\\left(\\frac{\\omega}{\\sqrt{n}}\\right)\\right)^{n} = \\lim_{n\\to\\infty}\\left(1-\\frac{\\omega^{2}}{2n}+o\\left(\\frac{1}{n}\\right)\\right)^{n} = e^{-\\frac{\\omega^{2}}{2}}n→∞lim​(F(n​ω​))n=n→∞lim​(1−2nω2​+o(n1​))n=e−2ω2​对上式求傅里叶逆变换即可得lim⁡n→∞fn(y)=F−1[e−ω22]=12πe−ω22\\lim_{n\\to\\infty}f_{n}(y) = \\mathscr{F}^{-1} \\left[e^{-\\frac{\\omega^{2}}{2}}\\right] = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{\\omega^{2}}{2}}n→∞lim​fn​(y)=F−1[e−2ω2​]=2π​1​e−2ω2​定理 1 得证。类似地，只要将 YnY_{n}Yn​ 改写为 X1+X2+⋯+Xnn\\frac{X_{1}+X_{2}+\\cdots +X_{n}}{n}nX1​+X2​+⋯+Xn​​，按同样的方法不难得到大数定律。 结论中心极限定理的研究曾在概率论中占据中心地位，而傅里叶变换对微分、积分、卷积等运算都具有简化的作用。将傅里叶变换运用到概率论中可以获得极大的便利，由于概率分布具有归一化的性质，因而对概率密度函数使用傅里叶变换总是可行的，实际上，概率论中的“特征函数”就是对概率密度函数的傅里叶变换，可以说，它的出现把概率理论的研究推上了一个新的台阶。参考资料:[1]: 王勇主编 2014 大学数学. 概率论与数理统计 （北京：高等教育出版社） 第141页[2]: JinZhihui 2013 正态分布的前世今生（下） http://cos.name/2013/01/story-of-normal-distribution-2/[3]: 杨静, 邓明立 2013 中心极限定理的创立与发展 科学 Vol.65 No.5[4]: 哈尔滨工业大学数学系组编；包革军，邢宇明，盖云英编 2013 复变函数与积分变换 （第三版） （北京：科学出版社） 第241页[5]: 哈尔滨工业大学数学系组编；包革军，邢宇明，盖云英编 2013 复变函数与积分变换 （第三版） （北京：科学出版社） 第247页","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miroox.github.io/blog/categories/%E6%95%B0%E7%90%86%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miroox.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"},{"name":"概率论","slug":"概率论","permalink":"http://miroox.github.io/blog/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"傅里叶变换","slug":"傅里叶变换","permalink":"http://miroox.github.io/blog/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"}]},{"title":"旧作：【翻译】CSF文件格式","slug":"CSFFileFormat","date":"2016-12-07T16:24:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2016/12/CSFFileFormat/","link":"","permalink":"http://miroox.github.io/blog/2016/12/CSFFileFormat/","excerpt":"原文链接 CSF文件格式CSF文件存储了红色警戒2/尤里的复仇（也有将军/绝命时刻和其它可能）的字符串表。","text":"原文链接 CSF文件格式CSF文件存储了红色警戒2/尤里的复仇（也有将军/绝命时刻和其它可能）的字符串表。 标头(The Header)CSF文件的标头有0x18个字节长。它以如下方式构成偏移量类型描述0x00char[4]“FSC”CSF文件的头部标识符。如果这里不是“FSC”，游戏将不会加载这个文件。0x04DWORDCSF版本CSF格式的版本号。红警2、尤里的复仇、将军、绝命时刻以及BFME系列使用版本3。救世传说(NOx)使用版本2。这些版本间实际有什么差别是未知的。感谢Siberian GRemlin提供了这些信息。 见此0x08DWORD标签数这个字符串表中全部标签的数目。0x0CDWORD字符串数这个字符串表中全部字符串对的数目。（一个字符串对由一个Unicode编码的Value和一个ASCII编码的ExtraValue组成，一个标签可以包含不止一个这样的字符串对，但实际上只有第一个字符串对的Value会被游戏所使用。）0x10DWORD（未使用）这个部分不会被游戏所使用，这意味着它是没有用的。如果需要，你可以在其中存储一个额外的信息标记，来让你的程序使用它（假如你想写一个程序来读取CSF文件）。0x14DWORD语言这个字符串表使用的语言。参见下面的列表语言语言（DWORD类型）可以具有以下值（其他值将被识别为“未知”）：0 = 美国（英语） *1 = 英国（英语）2 = 德语 *3 = 法语 *4 = 西班牙语5 = 意大利语6 = 日语7 = 无意义(Jabberwockie)8 = 韩语 *9 = 汉语 *&gt;9 = 未知* 红警2/尤里的复仇已经用这些语言发布。 标签(Labels)在标头之后，跟着标签数据。标签可以视为字符串表中的条目（例如：“GUI:OK”是一个标签）。每个标签有一个 name （ASCII编码的字符串，例如“NAME:MTNK”）以及零或若干个字符串对。正如前面提到的，一个字符串对由一个Unicode编码的Value（例如：“灰熊坦克”）和一个ASCII编码的ExtraValue（在原版的ra2.csf/ra2md.csf中没有例子，也不会被游戏所使用）。现在让我们来看看数据是如何在CSF文件中储存的： 标签标头(Label header)标签的数据始于一个标签标头，它以如下方式构成：偏移量类型描述0x00char[4]“LBL”标签标识符如果这里不是“LBL”，游戏将无法将后面的数据识别为标签数据，并且会读取后面的4字节。0x04DWORD字符串对的数目这是与这个标签关联的字符串对的数目。通常为1。0x08DWORD标签长度(LabelNameLength)此值保存后面的标签名称的大小。0x0Cchar[LabelNameLength]标签名一个长度为偏移量为0x08的DWORD的 非 '\\0’终止的字符串。如果长度超过的话，剩下部分的会被截去。ra2md.csf中的第一个标签可以在0x18处找到。注：空格、制表符、换行符会从标签名中格式化出去，因此他们不能被使用。 值(Values)其数据（字符串对）直接接在标签标头的后面。这是它构成的方式：偏移量类型描述0x00char[4]“RTS” 或 “WRTS”标识符“RTS”意味着这个标签 没有 ExtraValue。“WRTS”意味着在Value数据后还跟着ExtraValue的数据（见下）。其它任何数据都是无效的。0x04DWORD值长度(ValueLength)它保存后面的Unicode字符串（Value）的长度。0x08byte[ValueLength*2]值(Value)它保存 编码后的 标签的值(Value)。注意它有ValueLength*2字节长，因为值是一个Unicode字符串，即每个字符是一个字(word)而不是一个字节(byte)。将这里的数据解码成Unicode字符串时，注意 不是 每个字节都是值的数据（或者用0xFF减它，参见下面的示例）。0x8+ValueLength*2DWORD额外值长度(ExtraValueLength)这里保存了后面跟着的额外数据(ExtraValue)字符串的长度。只有标识符为“WRTS”而不是“RTS”时，它以及后面的数据才会存在。0x8+ValueLength*2+0x4char[ExtraValueLength]额外值(ExtraValue)与标签名相似，这是一个长度为ExtraValueLength的非’\\0’终止的字符串。如果长度超过的话，剩下部分的会被截去。将value解码将value解码成Unicode字符串时，注意不是每个字节都是值的数据（或者用0xFF减它）。一个C++的示例：1234int ValueDataLength = ValueLength &lt;&lt; 1;for(int i = 0; i &lt; ValueDataLength; ++i) &#123; ValueData[i] = ~ValueData[i];&#125;","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"},{"name":"翻译作品","slug":"翻译作品","permalink":"http://miroox.github.io/blog/categories/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"红警","slug":"红警","permalink":"http://miroox.github.io/blog/tags/%E7%BA%A2%E8%AD%A6/"},{"name":"翻译","slug":"翻译","permalink":"http://miroox.github.io/blog/tags/%E7%BF%BB%E8%AF%91/"},{"name":"参考","slug":"参考","permalink":"http://miroox.github.io/blog/tags/%E5%8F%82%E8%80%83/"},{"name":"文件格式","slug":"文件格式","permalink":"http://miroox.github.io/blog/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"}]},{"title":"旧作：低观点下的线性微分方程的解法","slug":"LODESolutionUnderLowViewpoint","date":"2016-12-05T15:16:23.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2016/12/LODESolutionUnderLowViewpoint/","link":"","permalink":"http://miroox.github.io/blog/2016/12/LODESolutionUnderLowViewpoint/","excerpt":"低观点的话，就只能上技巧了吧？摘要 ：一种不涉及线性微分方程解的结构的方法。","text":"低观点的话，就只能上技巧了吧？摘要 ：一种不涉及线性微分方程解的结构的方法。 一阶常系数线性非齐次微分方程的另解对于非齐次方程y′=p(x)y+q(x)xxxx其中，q(x)≠0(1)y&#x27;=p(x)y+q(x)\\phantom{xxxx} \\text{其中，} q(x)\\neq 0 \\tag{1}y′=p(x)y+q(x)xxxx其中，q(x)​=0(1)即y′−p(x)y=q(x)y&#x27;-p(x)y=q(x)y′−p(x)y=q(x)为了在上式左边得到导数乘法公式的形式(f⋅g)′=f′⋅g+f⋅g′(2)(f\\cdot g)&#x27;=f&#x27;\\cdot g+f\\cdot g&#x27; \\tag{2}(f⋅g)′=f′⋅g+f⋅g′(2)等式两边同乘 f(x)f(x)f(x) ，即y′⋅f(x)−p(x)y⋅f(x)=q(x)f(x)(3)y&#x27;\\cdot f(x)-p(x)y\\cdot f(x)=q(x)f(x) \\tag{3}y′⋅f(x)−p(x)y⋅f(x)=q(x)f(x)(3)比对公式(2)，f(x)f(x)f(x) 应满足 f′(x)=−p(x)f(x)f&#x27;(x)=-p(x)f(x)f′(x)=−p(x)f(x)容易解得f(x)=e−∫p(x)dx(4)f(x)=\\mathrm{e}^{-\\int p(x)dx} \\tag{4}f(x)=e−∫p(x)dx(4)（任意常数显然没有必要）则(3)式可以化成 (y⋅f(x))′=q(x)f(x)(y\\cdot f(x))&#x27;=q(x)f(x)(y⋅f(x))′=q(x)f(x)，解得y=1f(x)(C+∫q(x)f(x)dx)y=\\frac{1}{f(x)}(C+\\int q(x)f(x)dx)y=f(x)1​(C+∫q(x)f(x)dx)再带入(4)，即有y=e∫p(x)dx(C+∫q(x)e−∫p(x)dxdx)(5)y=\\mathrm{e}^{\\int p(x)dx}(C+\\int q(x)\\mathrm{e}^{-\\int p(x)dx}dx) \\tag{5}y=e∫p(x)dx(C+∫q(x)e−∫p(x)dxdx)(5)本方法的核心在于凑出导数乘法公式形式，相当于再解一个齐次微分方程，思路比常数变易法要显然，因此也不必记忆公式，知道凑乘法的思路即可，而且容易推广到其它问题上（比如中值定理凑函数的问题，以及下面的高阶线性微分方程等）。 二阶常系数线性齐次方程y′′+py′+qy=0y&#x27;&#x27;+py&#x27;+qy=0y′′+py′+qy=0令 p=−(r1+r2)p=-(r_{1}+r_{2})p=−(r1​+r2​), q=r1r2q=r_{1}r_{2}q=r1​r2​，即 r1,r2r_{1}, r_{2}r1​,r2​ 是 x2+px+q=0x^{2}+px+q=0x2+px+q=0 的根，显然存在。则y′′−(r1+r2)y′+r1r2y=0 ⟹ (y′′−r1y′)−r2(y′−r1y)=0 ⟹ (y′−r1y)′−r2(y′−r1y)=0\\begin{aligned} y&#x27;&#x27;-(r_{1}+r_{2})y&#x27;+r_{1}r_{2}y&amp;=0 \\\\ \\implies (y&#x27;&#x27;-r_{1}y&#x27;)-r_{2}(y&#x27;-r_{1}y)&amp;=0 \\\\ \\implies (y&#x27;-r_{1}y)&#x27;-r_{2}(y&#x27;-r_{1}y)&amp;=0 \\end{aligned}y′′−(r1​+r2​)y′+r1​r2​y⟹(y′′−r1​y′)−r2​(y′−r1​y)⟹(y′−r1​y)′−r2​(y′−r1​y)​=0=0=0​可得y′−r1y=C0er2x(6)y&#x27;-r_{1}y=C_{0}\\mathrm{e}^{r_{2}x} \\tag{6}y′−r1​y=C0​er2​x(6)若 r1≠r2r_{1}\\neq r_{2}r1​​=r2​ ：对(6)式两边同时乘 e−r1x\\mathrm{e}^{-r_{1}x}e−r1​x ，则有e−r1xy′−r1e−r1xy=C0e(r2−r1)x ⟹ (e−r1xy)′=C0e(r2−r1)x ⟹ y=C0r2−r1er2x+C1er1x(7)\\begin{aligned} \\mathrm{e}^{-r_{1}x}y&#x27;-r_{1}\\mathrm{e}^{-r_{1}x}y&amp;=C_{0}\\mathrm{e}^{(r_{2}-r_{1})x} \\\\ \\implies (\\mathrm{e}^{-r_{1}x}y)&#x27;&amp;=C_{0}\\mathrm{e}^{(r_{2}-r_{1})x} \\\\ \\implies y&amp;=\\frac{C_{0}}{r_{2}-r_{1}}\\mathrm{e}^{r_{2}x}+C_{1}\\mathrm{e}^{r_{1}x} \\tag{7} \\end{aligned}e−r1​xy′−r1​e−r1​xy⟹(e−r1​xy)′⟹y​=C0​e(r2​−r1​)x=C0​e(r2​−r1​)x=r2​−r1​C0​​er2​x+C1​er1​x​(7)不妨记 C2=C0r2−r1C_{2}=\\frac{C_{0}}{r_{2}-r_{1}}C2​=r2​−r1​C0​​ ，即y=C2er2x+C1er1xy=C_{2}\\mathrm{e}^{r_{2}x}+C_{1}\\mathrm{e}^{r_{1}x}y=C2​er2​x+C1​er1​x若 r1=r2r_{1}=r_{2}r1​=r2​ ，记作rrr ：对(6)式两边同时乘 e−rx\\mathrm{e}^{-rx}e−rx ，则e−rxy′−re−rxy=C0⇒(e−rxy)′=C0⇒y=C0xerx+C1erx(8)\\begin{aligned} \\mathrm{e}^{-rx}y&#x27;-r\\mathrm{e}^{-rx}y&amp;=C_{0} \\\\ \\Rightarrow (\\mathrm{e}^{-rx}y)&#x27;&amp;=C_{0} \\\\ \\Rightarrow y&amp;=C_{0}x\\mathrm{e}^{rx}+C_{1}\\mathrm{e}^{rx} \\tag{8} \\end{aligned}e−rxy′−re−rxy⇒(e−rxy)′⇒y​=C0​=C0​=C0​xerx+C1​erx​(8)事实上，对(7)式取极限 r2→r1=rr_{2}\\rightarrow r_{1}=rr2​→r1​=r 亦可得到(8)式。 二阶常系数线性非齐次方程一般形式y′′+py′+qy=f(x)y&#x27;&#x27;+py&#x27;+qy=f(x)y′′+py′+qy=f(x)与齐次方程类似处理，(y′−r1y)′−r2(y′−r1y)=f(x)(y&#x27;-r_{1}y)&#x27;-r_{2}(y&#x27;-r_{1}y)=f(x)(y′−r1​y)′−r2​(y′−r1​y)=f(x)实质上，这等价于两个一阶线性非齐次方程：u′−r2u=f(x)y′−r1y=u(x)\\begin{aligned} u&#x27;-r_{2}u&amp;=f(x) \\\\ y&#x27;-r_{1}y&amp;=u(x) \\end{aligned}u′−r2​uy′−r1​y​=f(x)=u(x)​利用之前一阶线性非齐次方程中方法即可解出yyy一般地，对 nnn 阶常系数线性微分方程 y(n)+a1y(n−1)+⋯+any=f(x)y^{(n)}+a_{1}y^{(n-1)}+\\cdots +a_{n}y=f(x)y(n)+a1​y(n−1)+⋯+an​y=f(x)等价于求解 nnn 个一阶非齐次微分方程：un′−rnun=f(x)un−1′−rn−1un−1=un(x)⋮u2′−r2u2=u3(x)y′−r1y=u2\\begin{aligned} u_{n}&#x27;-r_{n}u_{n}&amp;=f(x) \\\\ u_{n-1}&#x27;-r_{n-1}u_{n-1}&amp;=u_{n}(x) \\\\ &amp;\\vdots \\\\ u_{2}&#x27;-r_{2}u_{2}&amp;=u_{3}(x) \\\\ y&#x27;-r_{1}y&amp;=u_{2} \\end{aligned}un′​−rn​un​un−1′​−rn−1​un−1​u2′​−r2​u2​y′−r1​y​=f(x)=un​(x)⋮=u3​(x)=u2​​（其中，r1,r2,⋯ ,rnr_{1},r_{2},\\cdots ,r_{n}r1​,r2​,⋯,rn​ 是代数方程 xn+a1xn−1+⋯+an=0x^{n}+a_{1}x^{n-1}+\\cdots +a_{n}=0xn+a1​xn−1+⋯+an​=0 的根） 二阶常系数线性非齐次方程特殊形式y′′+py′+qy=eαx[P(x)cos⁡βx+Q(x)sin⁡βx](9)y&#x27;&#x27;+py&#x27;+qy=\\mathrm{e}^{\\alpha x} [ P(x)\\cos \\beta x+Q(x)\\sin \\beta x ] \\tag{9}y′′+py′+qy=eαx[P(x)cosβx+Q(x)sinβx](9)（其中 P(x),Q(x)P(x),Q(x)P(x),Q(x) 是 nnn 次多项式）这是前面一般形式的一种特殊的情况，只需要注意如下两个事实：①由欧拉恒等式 eıx=cos⁡x+ısin⁡x\\mathrm{e}^{\\imath x}=\\cos x+\\imath \\sin xeıx=cosx+ısinx，知上式右边可化为S(x)eλxS(x)\\mathrm{e}^{\\lambda x}S(x)eλx其中，λ=α+ıβ\\lambda =\\alpha +\\imath \\betaλ=α+ıβ，S(x)S(x)S(x)是适当的 nnn 次多项式；②对于 nnn 次多项式 S(x)S(x)S(x)，若 λ≠0\\lambda \\neq 0λ​=0，则∫S(x)eλx=T(x)eλx+C\\int S(x)\\mathrm{e}^{\\lambda x}=T(x)\\mathrm{e}^{\\lambda x}+C∫S(x)eλx=T(x)eλx+C其中，T(x)T(x)T(x) 也是 nnn 次多项式。由此不难得到，对式(9)若 α+ıβ\\alpha +\\imath \\betaα+ıβ是方程x2+px+q=0x^{2}+px+q=0x2+px+q=0 的二重根则 y=x2eαx[R(x)cos⁡βx+S(x)sin⁡βx]+C1xerx+C2erxy=x^{2}\\mathrm{e}^{\\alpha x} [ R(x)\\cos \\beta x+S(x)\\sin \\beta x ] +C_{1}x\\mathrm{e}^{rx}+C_{2}\\mathrm{e}^{rx}y=x2eαx[R(x)cosβx+S(x)sinβx]+C1​xerx+C2​erx若 α+ıβ\\alpha +\\imath \\betaα+ıβ是方程x2+px+q=0x^{2}+px+q=0x2+px+q=0 的某个单根则 y=xeαx[R(x)cos⁡βx+S(x)sin⁡βx]+C1er1x+C2er2xy=x\\mathrm{e}^{\\alpha x} [ R(x)\\cos \\beta x+S(x)\\sin \\beta x ] +C_{1}\\mathrm{e}^{r_{1}x}+C_{2}\\mathrm{e}^{r_{2}x}y=xeαx[R(x)cosβx+S(x)sinβx]+C1​er1​x+C2​er2​x若 α+ıβ\\alpha +\\imath \\betaα+ıβ不是是方程x2+px+q=0x^{2}+px+q=0x2+px+q=0 的根则 y=eαx[R(x)cos⁡βx+S(x)sin⁡βx]+C1er1x+C2er2xy=\\mathrm{e}^{\\alpha x} [ R(x)\\cos \\beta x+S(x)\\sin \\beta x ] +C_{1}\\mathrm{e}^{r_{1}x}+C_{2}\\mathrm{e}^{r_{2}x}y=eαx[R(x)cosβx+S(x)sinβx]+C1​er1​x+C2​er2​x其中 R(x),S(x)R(x),S(x)R(x),S(x) 是待定的 nnn 次多项式，r1,r2r_{1},r_{2}r1​,r2​（或 rrr）是方程 x2+px+q=0x^{2}+px+q=0x2+px+q=0 的根（或重根）。 欧拉方程xny(n)+a1xn−1y(n−1)+⋯+any=f(x)x^{n}y^{(n)}+a_{1}x^{n-1}y^{(n-1)}+\\cdots +a_{n}y=f(x)xny(n)+a1​xn−1y(n−1)+⋯+an​y=f(x)令 x=etx=\\mathrm{e}^{t}x=et，有xky(k)=ddt((ddt−1)((ddt−2)(⋯(ddt−(k−1))y⋯ )))x^{k}y^{(k)}=\\frac{d}{dt} \\left( \\left(\\frac{d}{dt}-1\\right) \\left( \\left(\\frac{d}{dt}-2\\right) \\left( \\cdots \\left(\\frac{d}{dt}-(k-1)\\right)y \\cdots \\right) \\right) \\right)xky(k)=dtd​((dtd​−1)((dtd​−2)(⋯(dtd​−(k−1))y⋯)))则方程化为关于 ttt 的常系数线性微分方程，可按前面nnn阶常系数线性微分方程的方法求解。","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miroox.github.io/blog/categories/%E6%95%B0%E7%90%86%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miroox.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"},{"name":"微积分","slug":"微积分","permalink":"http://miroox.github.io/blog/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"}]},{"title":"旧作：一点小思辨","slug":"LogicAndExperience","date":"2016-04-18T04:08:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2016/04/LogicAndExperience/","link":"","permalink":"http://miroox.github.io/blog/2016/04/LogicAndExperience/","excerpt":"","text":"西方哲学导论课的老师举过一个例子：“一个方的三角形是圆的”，想以此来说明“逻辑的对象应当是可经验的”。如果直接当一个原子命题处理的话看起来似乎是不满足排中律或者背反律，但我考虑了一下，觉得下面这种形式化才是适当的[1]：论域：平面上所有三角形组成的集合。Rx：x是方的。Ox：x是圆的。则前述命题：∀x(Rx ∧ Ox) 显然为假。其否定：∃x(﹁Rx ∨ ﹁Ox) 显然为真。这样看，背反律和排中律并没有出问题。至于前面那种错误应该是因为论域“所有方的三角形组成的集合”本身是空集，而空集没有任何元素，自然无法讨论属于它的个体词构成的命题。[2]但如果我们进一步考察“‘所有方的三角形组成的集合’本身是空集”的理由时，我们不得不重新思考“三角形”和“方的”这些从具体事物中抽象出来的理想化的一般结构的概念，很显然，下面的定义是符合我们直观的认识的：三角形：一个图形是三角形，当且仅当这个图形是三个不在同一直线上的点由直线（线段）两两连接构成。方的：一个图形是方的，当且仅当这个图形是凸多边形[3]且每个顶角都是直角。不难证明，在平面上“…是三角形”和“…是方的”是一对互斥的性质，这样，“所有方的三角形组成的集合”即“所有既是三角形又是方的图形组成的集合”是空集。但如果不是在平面上呢？当然，不是平面就不会有直线了，因而我们考虑直线更本质的特征，可以发现“直线（段）是连接连接平面上两点的所有曲线中最短的”，即所谓的“测地线”。这样，我们给出“三角形”更一般的定义：一个图形是三角形，当且仅当这个图形是三个不在同一测地线上的点由测地线（线段）两两连接构成。一般的多边形类似。现在让我们考虑一个简单的特例——球面几何。球面的测地线即球的大圆，我们发现很容易找到一个既是“三角形”又是“方的”图形（在球面上标注经纬线，两个相距90°的经线和赤道围成的图形，每个顶角都是直角，也是凸多边形（包围区域是个凸集），而且也是是三个不在同一大圆上的点由大圆（弧）两两连接构成），而圆是“其上所有点到某定点的距离相等的点”这在球面几何上也没有必要更改。这样，作为一个原子命题的原命题“一个方的三角形是圆的”为假是显然的了，而其否定“一个方的三角形不是圆的”则为真。而我们知道，球面几何的一切规则都是内蕴的[4]，一个人完全可以在不清楚球面几何的直观模型下只基于公理得出同样的结论。这样来看，逻辑似乎可以对那些非经验的，逻辑自身衍生出来的对象做出一些有意义的处理。[5]上面这个论证可以说是漏洞百出，我重看的时候简直不堪卒读，我虽然多次让自己警惕论证的“言辞陷阱”，却还是掉了进去QAQ。那些论证看似在摆脱概念，但实际上又完全陷入了概念的泥淖。最大的问题是概念的同一性，虽然关于“三角形”和“方的”的第二种概念与第一种概念以及我们的俗常观念是相容的，但这绝不意味着第二种概念与我们原始命题“一个方的三角形是圆的”里相应的概念是等同的。这里的问题在于“一个方的三角形”不与任何我们经验的概念对应，这时，言辞成了纯粹的形式，“一个方的三角形”本身无法在我们的常俗语境中确定，因而是“无意义”的，我们的讨论陷入了一个困境——语境缺失。为了解决这个问题，我重新考察了这些概念（分解后）在常俗语境下的定义。[6]值得注意的是，这种考察本身已经脱离了我们的常俗语境，重构出了新的语境，在这个语境下，我们使用了一些原本语境中不存在的语词来分析，“三角形”等概念虽然由于恰当定义的原因还没有发生畸变，却已经具有充分的广延性，这时，“规范滑坡”[7]已经发生了。而后借助重定义推广“三角形”等词的概念，一番波折后，居然把全新语境下的概念套用到了原始命题上，完全脱离了命题原本的含义，只留下一个形式的壳被我翻来覆去地套在不同的内涵上。出现这种情况的原因在于，这些语境都有公共的语词，如“三角形”等，为了将他们联系起来，我预设了一个更宽泛的公共语境，而这个而这个超经验的公共语境的合理性是我们无法证明的，于是出现了泛化的“无边界讨论”。论述的谬误澄清了之后，让我们再回到原本的问题：“逻辑的对象是否应该是可经验的？”这个问题的困难在于，对于不可经验的对象，我们不能保证正确地把握它，而我们似乎已经找到了这样的命题，让我们的逻辑律出现了悖谬。另一方面，来自数学的证言似乎又给我们一线生机，它所基于的演绎系统似乎完全是超经验的，却又无比正确。好，简单地考察一下，两句话的两个“正确”的判定标准显然不同，前者是符合经验，后者是符合逻辑。也就是说，这些不过是同义反复罢了，再一次落入了语词的陷阱。但这也给我们指出了一条明路，我们将考察一些预设。对于“逻辑的对象是否应该是可经验的”的判断总是无法避免地需要引入“正确”或者类似的概念，而判定的标准本身总归会涉及“经验的”或者“逻辑的”，在各个不同的范式中，同义反复似乎是不可避免的。我们或许可以按照证伪主义的要求，给这个问题处以死刑——“无意义”。尽管如此，证伪主义本身也在哲学批判的范围之内，更深入的讨论依旧是可能的。钱鍾书在《说“回家”》中讲过：“思想家的危险就是给比喻诱惑得忘记了被比喻的原物，把比喻上生发出来的理论认为适用于被比喻的原物。”而我大概是被形式诱惑得忘记了问题的实质吧。虽然说了一大堆好像又绕回了原点，但在“回家”的路上收获的思考和方法才是这短暂旅途中最重要的吧。注释（或是反思）：“……是适当的”其实并没有解决任何问题，不过是退而求其次的折衷。 ↩︎ ↩︎这里有两个问题：一是为什么论域不能为空，上面的理由看起来非常有理，但其实和“逻辑的对象应当是可经验的”是同义反复的。二是这里讲的还是关于谓词逻辑的，却没有解释命题逻辑的原子命题p为何出现了不符合背反律的情况（命题逻辑里没有个体词和论域的概念），我目前只能认为命题逻辑有着不可避免的缺陷。 ↩︎ ↩︎凸多边形排除了诸如“凹”字形、“凸”字形的可能。 ↩︎即使说，我们完全可以脱离三维欧式空间里的球面这个模型，而基于球面几何公理来认识球面几何。（这里应该还要存疑，虽然我觉得球面几何也可以像平面几何那样仅基于公理地建立，但我并没有查到相关的资料-_-!） ↩︎这一块问题实在太多了QAQ。这句的一个主要问题是，逻辑本身和它的衍生都不过是一些形式，而意义则要在人赋予给这些形式时才会有。 ↩︎这里和后面讲的都是第二部分（用重定义的方法来讨论），对于第一部分（用谓词逻辑来讨论）的反省参见[1:1][2:1]。 ↩︎当一个范式超越了个体语言的控制时，为了求得一个规范而得到一个脆弱的公共语境，但对于这个公共语境，当我们嫁接了方法论后，可能涉及到这个公共语境不存在的语词来进行分析，而新引进的语词所实践的意义本身被用来表述范式本身，使得原有的范式失效了，或者说被人无意识地扩大了。这个过程即所谓的“规范滑坡”。 ↩︎","categories":[{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miroox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://miroox.github.io/blog/tags/%E5%93%B2%E5%AD%A6/"},{"name":"逻辑","slug":"逻辑","permalink":"http://miroox.github.io/blog/tags/%E9%80%BB%E8%BE%91/"}]},{"title":"旧作：陈天权 数学分析讲义 部分习题答案（第二弹）","slug":"ChengTianQuan-02","date":"2016-02-02T06:28:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2016/02/ChengTianQuan-02/","link":"","permalink":"http://miroox.github.io/blog/2016/02/ChengTianQuan-02/","excerpt":"说明：这里的答案全部是我自己写的，不保证完全正确。题目不抄了，只标题号，书没有就没办法了。题目都是选我感兴趣且会做的。","text":"说明：这里的答案全部是我自己写的，不保证完全正确。题目不抄了，只标题号，书没有就没办法了。题目都是选我感兴趣且会做的。 2.3.1 (i)注意每个 bmb_mbm​ 都是序列 ana_nan​ 的上界，由确界公理知 sup⁡n∈Nan\\sup_{n\\in\\N}a_nsupn∈N​an​存在且比每个 bmb_mbm​ 都小。 (ii)与(i)同理，显然 (iii)由(i)知 ∀m∈N,sup⁡n∈Nan&lt;bm\\forall m\\in\\N,\\sup_{n\\in\\N}a_n&lt; b_m∀m∈N,supn∈N​an​&lt;bm​，结合(ii)，显然 sup⁡n∈Nan&lt;inf⁡n∈Nbn\\sup_{n\\in\\N}a_n&lt; \\inf_{n\\in\\N}b_nsupn∈N​an​&lt;infn∈N​bn​ (iv)由(iii)显然⋂n∈N[an,bn]⊇[sup⁡n∈Nan,inf⁡n∈Nbn]\\bigcap_{n\\in\\N}\\left[a_n,b_n\\right]\\supseteq\\left[\\sup_{n\\in\\N}a_n,\\inf_{n\\in\\N}b_n \\right]n∈N⋂​[an​,bn​]⊇[n∈Nsup​an​,n∈Ninf​bn​]又∀x&lt;sup⁡n∈Nan,∃m∈N,am&gt;x, 即x∉⋂n∈N[an,bn]\\forall x&lt; \\sup_{n\\in\\N}a_n,\\exist m\\in\\N,a_m&gt;x,\\,\\text{即} x\\notin\\bigcap_{n\\in\\N}\\left[a_n,b_n\\right]∀x&lt;n∈Nsup​an​,∃m∈N,am​&gt;x,即x∈/​n∈N⋂​[an​,bn​]以及∀y&gt;inf⁡n∈Nbn,∃m∈N,bm&lt;x\\forall y&gt; \\inf_{n\\in\\N}b_n,\\exist m\\in\\N,b_m&lt; x∀y&gt;n∈Ninf​bn​,∃m∈N,bm​&lt;x可知⋂n∈N[an,bn]=[sup⁡n∈Nan,inf⁡n∈Nbn]\\bigcap_{n\\in\\N}\\left[a_n,b_n\\right]=\\left[\\sup_{n\\in\\N}a_n,\\inf_{n\\in\\N}b_n \\right]n∈N⋂​[an​,bn​]=[n∈Nsup​an​,n∈Ninf​bn​] 2.3.2 (i)若 r∉[k,l]r\\notin[k,l]r∈/​[k,l]，则令 g=2k+l3,h=k+2l3g=\\frac{2k+l}{3},h=\\frac{k+2l}{3}g=32k+l​,h=3k+2l​，显然 [g,h]⊂[k,l][g,h]\\subset[k,l][g,h]⊂[k,l]若 r∈[k,l]r\\in[k,l]r∈[k,l]，则令 g=2r+l3,h=r+2l3g=\\frac{2r+l}{3},h=\\frac{r+2l}{3}g=32r+l​,h=3r+2l​，有 r∉[g,h]⊂[k,l]r\\notin[g,h]\\subset[k,l]r∈/​[g,h]⊂[k,l] (ii)与(i)相同的构造方式，易得。 (iii)与(i)相同，只要令{cn+1=2cn+dn3,dn+1=cn+2dn3an+1∉[cn,dn]cn+1=2an+1+dn3,dn+1=an+1+2dn3an+1∈[cn,dn]\\begin{cases} c_{n+1}=\\frac{2c_n+d_n}{3},d_{n+1}=\\frac{c_n+2d_n}{3} &amp; a_{n+1}\\notin[c_n,d_n]\\\\ c_{n+1}=\\frac{2a_{n+1}+d_n}{3},d_{n+1}=\\frac{a_{n+1}+2d_n}{3} &amp; a_{n+1}\\in[c_n,d_n] \\end{cases}{cn+1​=32cn​+dn​​,dn+1​=3cn​+2dn​​cn+1​=32an+1​+dn​​,dn+1​=3an+1​+2dn​​​an+1​∈/​[cn​,dn​]an+1​∈[cn​,dn​]​ (iv)由2.3.1结论（闭区间套定理）， ⋂n=1[cn,dn]≠∅\\bigcap_{n=1}[c_n,d_n]\\ne\\empty⋂n=1​[cn​,dn​]​=∅由数学归纳法∀x∈D,x∉⋂n=1[cn,dn]\\forall x\\in D,x\\notin\\bigcap_{n=1}[c_n,d_n]∀x∈D,x∈/​n=1⋂​[cn​,dn​] (v)∀n∈N,[cn,dn]⊂[c,d]\\forall n\\in\\N,[c_n,d_n]\\subset[c,d]∀n∈N,[cn​,dn​]⊂[c,d]归纳地，⋂n=1[cn,dn]⊂[c,d]\\bigcap_{n=1}[c_n,d_n]\\subset[c,d]n=1⋂​[cn​,dn​]⊂[c,d]故∃x∈⋂n=1[cn,dn]⊂[c,d],x∉D\\exist x\\in\\bigcap_{n=1}[c_n,d_n]\\subset[c,d],x\\notin D∃x∈n=1⋂​[cn​,dn​]⊂[c,d],x∈/​D (vi)对于任何一个 φ:N↦R\\varphi:\\N\\mapsto\\Rφ:N↦R，记 an=φ(n)a_n=\\varphi(n)an​=φ(n)由(v)中结论知，总 ∃x∈[c,d],x∉φ(N)\\exist x\\in[c,d],x\\notin\\varphi(\\N)∃x∈[c,d],x∈/​φ(N)，即 [c,d][c,d][c,d] 不可数。 2.3.3 (i)显然 a∈Ka\\in Ka∈K (ii)显然 bbb 是 KKK 的一个上界，有确界公理知 M=sup⁡KM=\\sup KM=supK 存在。 (iii)显然 (iv)由确界公理以及确界的性质知∀ε&gt;0,(M−ε,M]∩K≠∅\\forall\\varepsilon&gt;0,(M-\\varepsilon,M]\\cap K\\ne\\empty∀ε&gt;0,(M−ε,M]∩K​=∅即存在 c∈K,c&gt;M−εc\\in K,c&gt;M-\\varepsilonc∈K,c&gt;M−ε，使 [a,c][a,c][a,c] 能被 {Iα:α∈J}\\{I_\\alpha:\\alpha\\in J\\}{Iα​:α∈J} 的某个有限子族覆盖故 [a,M−ε]⊂[a,c][a,M-\\varepsilon]\\subset[a,c][a,M−ε]⊂[a,c] 能被开区间族 {Iα:α∈J}\\{I_\\alpha:\\alpha\\in J\\}{Iα​:α∈J} 的某个有限子族覆盖 (v)因为开区间族 {Iα:α∈J}\\{I_\\alpha:\\alpha\\in J\\}{Iα​:α∈J} 覆盖了 [a,b][a,b][a,b]，故 ∃α∈J,M∈Iα\\exist\\alpha\\in J,M\\in I_\\alpha∃α∈J,M∈Iα​又因 IαI_\\alphaIα​ 是开区间，故 ∃ε&gt;0,[M−ε,M]⊂Iα\\exist\\varepsilon&gt;0,[M-\\varepsilon,M]\\subset I_\\alpha∃ε&gt;0,[M−ε,M]⊂Iα​注意到(iv)中 ε\\varepsilonε 的任意性显然 [a,M][a,M][a,M] 也能被 {Iα:α∈J}\\{I_\\alpha:\\alpha\\in J\\}{Iα​:α∈J} 的某个有限子族覆盖。 (vi)假若 M&lt;bM&lt; bM&lt;b，由于(v)中的 IαI_\\alphaIα​ 是开区间，故∃0&lt;δ&lt;b−M,M+δ∈Iα\\exist 0&lt; \\delta&lt; b-M,M+\\delta\\in I_\\alpha∃0&lt;δ&lt;b−M,M+δ∈Iα​则 [a,M+δ][a,M+\\delta][a,M+δ] 也可被 {Iα:α∈J}\\{I_\\alpha:\\alpha\\in J\\}{Iα​:α∈J} 的某个有限子族覆盖，这与 MMM 是 KKK 的上确界矛盾。 (vii)由(v)和(vi)，显然。 (viii)假若 N\\NN 有上界 MMM，则[1,M]⊂⋃x∈[1,M](x−13,x+13)[1,M]\\subset\\bigcup_{\\mathclap{x\\in[1,M]} }\\left(x-\\frac{1}{3},x+\\frac{1}{3} \\right)[1,M]⊂x∈[1,M]​⋃​(x−31​,x+31​)由(vii)中结论（有限覆盖定理）[1,M][1,M][1,M] 可以被 ⋃x∈[1,M](x−13,x+13)\\bigcup_{x\\in[1,M] }\\left(x-\\frac{1}{3},x+\\frac{1}{3} \\right)⋃x∈[1,M]​(x−31​,x+31​) 的某个有限子族覆盖注意到其每个区间 (x−13,x+13)\\left(x-\\frac{1}{3},x+\\frac{1}{3} \\right)(x−31​,x+31​) 长度为 23&lt;1\\frac{2}{3}&lt; 132​&lt;1故每个区间 (x−13,x+13)\\left(x-\\frac{1}{3},x+\\frac{1}{3} \\right)(x−31​,x+31​) 至多只包含一个自然数又 [1,M][1,M][1,M] 可以被 ⋃x∈[1,M](x−13,x+13)\\bigcup_{x\\in[1,M] }\\left(x-\\frac{1}{3},x+\\frac{1}{3} \\right)⋃x∈[1,M]​(x−31​,x+31​) 的某个有限子族覆盖故 [1,M][1,M][1,M] 中只包含有限个整数，这与 N\\NN 是无限集矛盾，故 N\\NN 无上界。 (ix)考虑如 2.3.1 的闭区间套[a1,b1]⊃[a2,b2]⊃⋯⊃[an,bn]⊃⋯[a_1,b_1]\\supset[a_2,b_2]\\supset\\cdots\\supset[a_n,b_n]\\supset\\cdots[a1​,b1​]⊃[a2​,b2​]⊃⋯⊃[an​,bn​]⊃⋯以 U=(a1,b1+1)U=(a_1,b_1+1)U=(a1​,b1​+1) 为空间，显然∀k∈N,[ak,bk]⊂U\\forall k\\in\\N,[a_k,b_k]\\subset U∀k∈N,[ak​,bk​]⊂U任何一个闭区间的余集 [an,bn]C=(a1−1,an)∪(bn,b1+1)[a_n,b_n]^C=(a_1-1,a_n)\\cup(b_n,b_1+1)[an​,bn​]C=(a1​−1,an​)∪(bn​,b1​+1) 是两个开区间之并假若⋂n=1∞[an,bn]=∅\\bigcap_{n=1}^\\infty [a_n,b_n]=\\emptyn=1⋂∞​[an​,bn​]=∅则⋃n=1∞[an,bn]C=U⊃(a1,b1)\\bigcup_{n=1}^\\infty [a_n,b_n]^C=U\\supset(a_1,b_1)n=1⋃∞​[an​,bn​]C=U⊃(a1​,b1​)由(vii)中结论（有限覆盖定理）存在 ⋃n=1∞[an,bn]C\\bigcup_{n=1}^\\infty [a_n,b_n]^C⋃n=1∞​[an​,bn​]C 的某个有限子族可以将 [a1,b1][a_1,b_1][a1​,b1​] 覆盖而 ⋃n=1∞[an,bn]C\\bigcup_{n=1}^\\infty [a_n,b_n]^C⋃n=1∞​[an​,bn​]C 的开子区间可以表示为 (a1−1,am)(a_1-1,a_m)(a1​−1,am​) 或 (bk,b1+1)(b_k,b_1+1)(bk​,b1​+1)考虑在某个有限子族中这些开区间里标号（mmm 或 kkk）最大的一个，其标号为 lll，注意到闭区间套的性质，则 [al+1,bl+1]⊂[a1,b1][a_{l+1},b_{l+1}]\\subset[a_1,b_1][al+1​,bl+1​]⊂[a1​,b1​] 无法被覆盖，导出矛盾，故⋂n=1∞[an,bn]≠∅\\bigcap_{n=1}^\\infty [a_n,b_n]\\ne\\emptyn=1⋂∞​[an​,bn​]​=∅ 2.3.4 (i)由 [a,b]⊂⋃j=1n(cj,dj)[a,b]\\subset\\bigcup_{j=1}^n (c_j,d_j)[a,b]⊂⋃j=1n​(cj​,dj​)必存在开区间 (k,l)(k,l)(k,l) 使 [a,b]⊂(k,l)=⋃j∈G(cj,dj)[a,b]\\subset(k,l)=\\bigcup_{j\\in G}(c_j,d_j)[a,b]⊂(k,l)=⋃j∈G​(cj​,dj​)（其中 G⊂{1,2,…,n}G\\subset\\{1,2,\\dots,n\\}G⊂{1,2,…,n}）（否则 ∃x∈[a,b],x∉⋃j=1n(cj,dj)\\exist x\\in[a,b],x\\notin\\bigcup_{j=1}^n (c_j,d_j)∃x∈[a,b],x∈/​⋃j=1n​(cj​,dj​) 与题设矛盾）由数学归纳法和开区间的简单性质易证 l−k&lt;∑j∈G(dj−cj)l-k&lt; \\sum_{j\\in G}(d_j-c_j)l−k&lt;∑j∈G​(dj​−cj​)因而b−a&lt;l−k&lt;∑j∈G(dj−cj)&lt;∑j=1n(dj−cj)b-a&lt; l-k&lt; \\sum_{j\\in G}(d_j-c_j)&lt; \\sum_{j=1}^n(d_j-c_j)b−a&lt;l−k&lt;j∈G∑​(dj​−cj​)&lt;j=1∑n​(dj​−cj​) (ii)由 2.3.3(vii) 的有限覆盖定理，必存在某个有限集 F⊂JF\\subset JF⊂J 使得 [a,b]⊂⋃α∈FIα[a,b]\\subset\\bigcup_{\\alpha\\in F}I_\\alpha[a,b]⊂⋃α∈F​Iα​又由(i)，即有b−a&lt;∑α∈F∣Iα∣≤sup⁡有限集F⊂J∑α∈F∣Iα∣b-a&lt; \\sum_{\\alpha\\in F}|I_\\alpha|\\le\\sup_{\\text{有限集}F\\subset J }\\sum_{\\alpha\\in F}|I_\\alpha|b−a&lt;α∈F∑​∣Iα​∣≤有限集F⊂Jsup​α∈F∑​∣Iα​∣ (iii)任意给定 ε&gt;0\\varepsilon&gt;0ε&gt;0，记 D={a1,a2,…,an,… }D=\\{a_1,a_2,\\dots,a_n,\\dots \\}D={a1​,a2​,…,an​,…}，并取 In=(an−2−n−2ε,an+2−n−2ε)I_n=\\left(a_n-2^{-n-2}\\varepsilon,a_n+2^{-n-2}\\varepsilon \\right)In​=(an​−2−n−2ε,an​+2−n−2ε)显然 D=⋃n=1∞InD=\\bigcup_{n=1}^\\infty I_nD=⋃n=1∞​In​，且 ∑n=1∞∣In∣=ε2&lt;ε\\sum_{n=1}^\\infty |I_n|=\\frac{\\varepsilon}{2}&lt; \\varepsilon∑n=1∞​∣In​∣=2ε​&lt;ε。 (iv)假若 [a,b][a,b][a,b] 是可数集，由(ii)知 [a,b][a,b][a,b] 必定能被某个开区间族 {Iα:α∈J}\\{I_\\alpha :\\alpha\\in J \\}{Iα​:α∈J} 覆盖，且b−a&lt;sup⁡有限集F⊂J∑α∈F∣Iα∣b-a&lt; \\sup_{\\text{有限集}F\\subset J }\\sum_{\\alpha\\in F}|I_\\alpha|b−a&lt;有限集F⊂Jsup​α∈F∑​∣Iα​∣取开区间族 {Iα:α∈J}\\{I_\\alpha :\\alpha\\in J \\}{Iα​:α∈J} 中蕴含了 {Ii:i∈F}\\{I_i :i\\in F \\}{Ii​:i∈F} 的某个可数子族 {In:n∈E}\\{I_n :n\\in E \\}{In​:n∈E}，显然∑n∈E∣In∣&gt;sup⁡有限集F⊂J∑α∈F∣Iα∣\\sum_{n\\in E}|I_n|&gt;\\sup_{\\text{有限集}F\\subset J }\\sum_{\\alpha\\in F}|I_\\alpha|n∈E∑​∣In​∣&gt;有限集F⊂Jsup​α∈F∑​∣Iα​∣又由(iii)，取 ε=b−a2\\varepsilon=\\frac{b-a}{2}ε=2b−a​，则有b−a&lt;sup⁡有限集F⊂J∑α∈F∣Iα∣&lt;∑n∈E∣In∣&lt;b−a2b-a&lt; \\sup_{\\text{有限集}F\\subset J }\\sum_{\\alpha\\in F}|I_\\alpha|&lt; \\sum_{n\\in E}|I_n|&lt; \\frac{b-a}{2}b−a&lt;有限集F⊂Jsup​α∈F∑​∣Iα​∣&lt;n∈E∑​∣In​∣&lt;2b−a​导出矛盾，故 [a,b][a,b][a,b] 是不可数集。 2.3.5 (i)将 SSS 中的点按大小排序 a0&lt;a1&lt;⋯&lt;ana_0&lt; a_1&lt; \\cdots&lt; a_na0​&lt;a1​&lt;⋯&lt;an​显然只要某个 Iα⊂[x,y]I_\\alpha\\subset[x,y]Iα​⊂[x,y]，就有 S∩[x,y]=∅S\\cap[x,y]=\\emptyS∩[x,y]=∅假设有某个 ai∈[x,y]a_i\\in[x,y]ai​∈[x,y]，由 λ\\lambdaλ 的选取，必有 ai−1&lt;x,ai+1&gt;ya_{i-1}&lt; x,a_{i+1}&gt;yai−1​&lt;x,ai+1​&gt;y故 [x,y][x,y][x,y] 中最多含有 SSS 的一个点。 (ii)x∈Iα=(kα,lα)x\\in I_\\alpha=(k_\\alpha,l_\\alpha)x∈Iα​=(kα​,lα​)显然 yyy 只可能满足 kα&lt;x&lt;y&lt;lαk_\\alpha&lt; x&lt; y&lt; l_\\alphakα​&lt;x&lt;y&lt;lα​ 或者 y≥lαy\\ge l_\\alphay≥lα​ 其中之一，而后者显然使 lα∈[x,y]l_\\alpha\\in[x,y]lα​∈[x,y]，与题设矛盾，故 y∈(kα,lα)y\\in(k_\\alpha,l_\\alpha)y∈(kα​,lα​) (iii)[x,y]∩S={h}[x,y]\\cap S=\\{h\\}[x,y]∩S={h}以 hhh 为端点的开区间不会盖住 hhh对于任何一个盖住 hhh 的开区间 Iβ=(kβ,lβ)I_\\beta=(k_\\beta,l_\\beta)Iβ​=(kβ​,lβ​)，必有 [x,y]⊂Iβ[x,y]\\subset I_\\beta[x,y]⊂Iβ​，否则 [x,y]∩S={h,kβ}⊻[x,y]∩S={h,lβ}[x,y]\\cap S=\\{h,k_\\beta\\}\\veebar [x,y]\\cap S=\\{h,l_\\beta\\}[x,y]∩S={h,kβ​}⊻[x,y]∩S={h,lβ​} 为真，与(i)中结论矛盾，故 [x,y]⊂Iβ[x,y]\\subset I_\\beta[x,y]⊂Iβ​ (iv)由(i)的结论和(ii),(iii)的讨论，综述易得。 2.3.6由 2.3.3(vii) 的有限覆盖定理∃有限集F⊂J,[a,b]⊂⋃α∈FIα\\exist\\text{有限集}F\\subset J,[a,b]\\subset\\bigcup_{\\alpha\\in F}I_\\alpha∃有限集F⊂J,[a,b]⊂α∈F⋃​Iα​又由 2.3.5(iv) 的结论，综述易得。 2.3.7 (i)必要性显然；充分性：假若 ∃ε0&gt;0,E∩(l−ε0,l+ε0)\\exist\\varepsilon_0&gt;0,E\\cap(l-\\varepsilon_0,l+\\varepsilon_0)∃ε0​&gt;0,E∩(l−ε0​,l+ε0​)是有限集，记为 {a1,a2,…,an}\\{a_1,a_2,\\dots,a_n\\}{a1​,a2​,…,an​}取\\varepsilon=\\min_{\\substack{1\\le i\\le n\\\\ a_i\\ne l} }\\left|a_i-l\\right|则 (E∖{l})∩(l−ε,l+ε)=∅(E\\setminus\\{l\\})\\cap(l-\\varepsilon,l+\\varepsilon)=\\empty(E∖{l})∩(l−ε,l+ε)=∅，矛盾，故充分性得证。 (ii)根据否定命题的原则，显然。 (iii)取 [a,b]⊃E[a,b]\\supset E[a,b]⊃E，若 EEE 无聚点，则 ∀x∈E,∃εx&gt;0,E∩(x−εx,x+εx)\\forall x\\in E,\\exist \\varepsilon_x&gt;0, E\\cap(x-\\varepsilon_x,x+\\varepsilon_x)∀x∈E,∃εx​&gt;0,E∩(x−εx​,x+εx​)是有限集由 2.3.3(vii) 的有限覆盖定理∃{x1,x2,…,xn}⊂[a,b],[a,b]⊂⋃j=1n(xj−εxj,xj+εxj)\\exist\\{x_1,x_2,\\dots,x_n \\}\\subset[a,b], [a,b]\\subset\\bigcup_{j=1}^n\\left(x_j-\\varepsilon_{x_j},x_j+\\varepsilon_{x_j} \\right)∃{x1​,x2​,…,xn​}⊂[a,b],[a,b]⊂j=1⋃n​(xj​−εxj​​,xj​+εxj​​)而E=E∩[a,b]⊂⋃j=1nE∩(xj−εxj,xj+εxj)E=E\\cap[a,b]\\subset\\bigcup_{j=1}^nE\\cap\\left(x_j-\\varepsilon_{x_j},x_j+\\varepsilon_{x_j} \\right)E=E∩[a,b]⊂j=1⋃n​E∩(xj​−εxj​​,xj​+εxj​​)（有限个有限集之并）故 EEE 是有限集。 (iv)若 Z\\ZZ 有上界，则 Z+\\Z_{+}Z+​ 亦有上界，而 Z+\\Z_{+}Z+​ 以 111 为下界，故 Z+\\Z_{+}Z+​ 有界由 (iii) 的聚点存在定理， Z+\\Z_{+}Z+​ 有聚点，记为 lll则 (l−13,l+13)∩Z+\\left(l-\\frac{1}{3},l+\\frac{1}{3} \\right)\\cap\\Z_{+}(l−31​,l+31​)∩Z+​ 应为无限集，但 (l−13,l+13)\\left(l-\\frac{1}{3},l+\\frac{1}{3} \\right)(l−31​,l+31​) 中至多包含一个整数，与 lll 是聚点矛盾，故 Z+\\Z_{+}Z+​ 无上界，Z\\ZZ 亦无上界。同理易证 Z\\ZZ 无下界。 (v)由 (iv) Z\\ZZ 无界易得。 (vi)假若 ∃ε0&gt;0,∀N∈N,n−mN≥ε0\\exist\\varepsilon_0&gt;0,\\forall N\\in\\N,\\frac{n-m}{N}\\ge\\varepsilon_0∃ε0​&gt;0,∀N∈N,Nn−m​≥ε0​， 则 ∀N∈N,N≤n−mε0\\forall N\\in\\N,N\\le\\frac{n-m}{\\varepsilon_0}∀N∈N,N≤ε0​n−m​ 与 N\\NN 无上界矛盾，得证。 (vii)任意给定 ε&gt;0\\varepsilon&gt;0ε&gt;0，对 ∀x∈[a,b]\\forall x\\in[a,b]∀x∈[a,b]，由 (v) 知 ∀N∈N,∃m,n∈Z,m&lt;Na&lt;Nb&lt;n\\forall N\\in\\N,\\exist m,n\\in\\Z, m&lt; Na&lt; Nb&lt; n∀N∈N,∃m,n∈Z,m&lt;Na&lt;Nb&lt;n，即有 mN&lt;a≤x≤b&lt;nN\\frac{m}{N}&lt; a\\le x\\le b&lt; \\frac{n}{N}Nm​&lt;a≤x≤b&lt;Nn​又由 (vi) 知 ∀ε&gt;0,∃N∈N,n−mN&lt;ε\\forall\\varepsilon&gt;0,\\exist N\\in\\N,\\frac{n-m}{N}&lt; \\varepsilon∀ε&gt;0,∃N∈N,Nn−m​&lt;ε故∀ε&gt;0,(Q∩[a,b]∖{x})∩(x−ε,x+ε)≠∅\\forall\\varepsilon&gt;0,(\\mathbb{Q}\\cap[a,b]\\setminus\\{x\\})\\cap(x-\\varepsilon,x+\\varepsilon)\\ne\\empty∀ε&gt;0,(Q∩[a,b]∖{x})∩(x−ε,x+ε)​=∅即 xxx 是 Q∩[a,b]\\mathbb{Q}\\cap[a,b]Q∩[a,b] 的聚点。 2.3.8 (i)显然。 (ii)取 [a,b][a,b][a,b] 使 ∀n∈N,xn∈[a,b]\\forall n\\in\\N,x_n\\in[a,b]∀n∈N,xn​∈[a,b]，记 [a1,b1]=[a,b][a_1,b_1]=[a,b][a1​,b1​]=[a,b]将 [a1,b1][a_1,b_1][a1​,b1​] 二等分，则至少有一边包含 {xn}\\{x_n\\}{xn​} 的无穷多项，记为 [a2,b2][a_2,b_2][a2​,b2​]，类似地，将 [a2,b2][a_2,b_2][a2​,b2​] 二等分，取包含 {xn}\\{x_n\\}{xn​} 无穷多项的一边 [a3,b3][a_3,b_3][a3​,b3​]，……以此类推得到闭区间套 [an,bn][a_n,b_n][an​,bn​]，且 ∀n∈N\\forall n\\in\\N∀n∈N，[an,bn][a_n,b_n][an​,bn​] 包含 {xn}\\{x_n\\}{xn​} 的无穷多项由 2.3.1 的闭区间套定理，并注意到 bn−an=b−a2n−1→0b_n-a_n=\\frac{b-a}{2^{n-1} }\\to0bn​−an​=2n−1b−a​→0∃l,⋂n=1∞[an,bn]={l}而∀ε&gt;0,∃n∈N,(l−ε,l+ε)⊃[an,bn]\\exist l,\\bigcap_{n=1}^{\\infty}[a_n,b_n]=\\{l\\}\\text{而}\\forall\\varepsilon&gt;0,\\exist n\\in\\N,(l-\\varepsilon,l+\\varepsilon)\\supset[a_n,b_n]∃l,n=1⋂∞​[an​,bn​]={l}而∀ε&gt;0,∃n∈N,(l−ε,l+ε)⊃[an​,bn​]故 lll 是 {xn}\\{x_n\\}{xn​} 的聚点。 2.3.9不妨设 b∈Bb\\in Bb∈B，取 x=sup⁡Ax=\\sup Ax=supA显然 ∀ε&gt;0,A∩(x−ε,x+ε)≠∅\\forall\\varepsilon&gt;0,A\\cap(x-\\varepsilon,x+\\varepsilon)\\ne\\empty∀ε&gt;0,A∩(x−ε,x+ε)​=∅，而 x≤bx\\le bx≤b若 x=bx=bx=b，显然 B∩(x−ε,x+ε)∋bB\\cap(x-\\varepsilon,x+\\varepsilon)\\ni bB∩(x−ε,x+ε)∋b若 x&lt;bx&lt; bx&lt;b，∀ε&gt;0,∀y∈A,x+ε&gt;y\\forall\\varepsilon&gt;0,\\forall y\\in A,x+\\varepsilon&gt;y∀ε&gt;0,∀y∈A,x+ε&gt;y，而 [a,b]=A∪B[a,b]=A\\cup B[a,b]=A∪B故 0&lt;ε&lt;b−x,x+ε∈B0&lt; \\varepsilon&lt; b-x, x+\\varepsilon\\in B0&lt;ε&lt;b−x,x+ε∈B，得证。 2.3.10 (i)考察 n+1n+1n+1 个实数 lα−⌊lα⌋l\\alpha-\\lfloor l\\alpha\\rfloorlα−⌊lα⌋（其中 l∈{1,2,…,n+1}l\\in\\{1,2,\\dots,n+1\\}l∈{1,2,…,n+1}）注意 ∀l∈{1,2,…,n+1},lα−⌊lα⌋&lt;1\\forall l\\in\\{1,2,\\dots,n+1\\}, l\\alpha-\\lfloor l\\alpha\\rfloor&lt; 1∀l∈{1,2,…,n+1},lα−⌊lα⌋&lt;1故在这组数中至少有两个数满足∣(l2α−⌊l2α⌋)−(l1α−⌊l1α⌋)∣&lt;1n,1&lt;l1&lt;l2&lt;n+1\\left|(l_2\\alpha-\\lfloor l_2\\alpha\\rfloor)-(l_1\\alpha-\\lfloor l_1\\alpha\\rfloor) \\right|&lt; \\frac{1}{n},\\quad 1&lt; l_1&lt; l_2&lt; n+1∣(l2​α−⌊l2​α⌋)−(l1​α−⌊l1​α⌋)∣&lt;n1​,1&lt;l1​&lt;l2​&lt;n+1现取 k=l2−l1≤n,m=⌊l2α⌋−⌊l1α⌋k=l_2-l_1\\le n, m=\\lfloor l_2\\alpha\\rfloor-\\lfloor l_1\\alpha\\rfloork=l2​−l1​≤n,m=⌊l2​α⌋−⌊l1​α⌋，则 kα−m&lt;1nk\\alpha-m&lt; \\frac{1}{n}kα−m&lt;n1​即有∣α−mk∣&lt;1kn\\left|\\alpha-\\frac{m}{k} \\right|&lt; \\frac{1}{kn}∣∣∣​α−km​∣∣∣​&lt;kn1​ (ii)假若只有有限个这样的有理数 mini\\frac{m_i}{n_i}ni​mi​​，满足 ∣α−mini∣&lt;1ni2\\left|\\alpha-\\frac{m_i}{n_i} \\right|&lt; \\frac{1}{n_i^2}∣∣∣​α−ni​mi​​∣∣∣​&lt;ni2​1​（i∈{1,2,…,p}i\\in\\{1,2,\\dots,p\\}i∈{1,2,…,p}）令δ=min⁡1≤i≤p∣α−mini∣\\delta=\\min_{1\\le i\\le p}\\left|\\alpha-\\frac{m_i}{n_i} \\right|δ=1≤i≤pmin​∣∣∣∣​α−ni​mi​​∣∣∣∣​取 N&gt;1δN&gt;\\frac{1}{\\delta}N&gt;δ1​，并取 m,n∈N,(0&lt;n&lt;N)m,n\\in\\N,(0&lt; n&lt; N)m,n∈N,(0&lt;n&lt;N) 使得∣α−mn∣&lt;1nN&lt;1n2\\left|\\alpha-\\frac{m}{n} \\right|&lt; \\frac{1}{nN}&lt; \\frac{1}{n^2}∣∣∣​α−nm​∣∣∣​&lt;nN1​&lt;n21​即 m,nm,nm,n 满足题意同时注意到∣α−mn∣&lt;1nN&lt;δn&lt;δ\\left|\\alpha-\\frac{m}{n} \\right|&lt; \\frac{1}{nN}&lt; \\frac{\\delta}{n}&lt; \\delta∣∣∣​α−nm​∣∣∣​&lt;nN1​&lt;nδ​&lt;δ即 mn∉{mini:1≤i≤p}\\frac{m}{n}\\notin\\left\\{\\frac{m_i}{n_i}:1\\le i\\le p \\right\\}nm​∈/​{ni​mi​​:1≤i≤p}，导出矛盾故满足 ∣α−mn∣&lt;1n2\\left|\\alpha-\\frac{m}{n}\\right|&lt; \\frac{1}{n^2}∣∣​α−nm​∣∣​&lt;n21​ 的有理数 mn\\frac{m}{n}nm​ 有无限个。","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miroox.github.io/blog/categories/%E6%95%B0%E7%90%86%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miroox.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"},{"name":"题解","slug":"题解","permalink":"http://miroox.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"},{"name":"微积分","slug":"微积分","permalink":"http://miroox.github.io/blog/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"}]},{"title":"旧作：【翻译】如何编写PKT文件","slug":"PKTFile","date":"2015-12-19T13:50:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2015/12/PKTFile/","link":"","permalink":"http://miroox.github.io/blog/2015/12/PKTFile/","excerpt":"来自PPM（只翻关键部分）作者：Dark Templar X简单来说，它是控制当有扩展地图包时，什么地图将出现在遭遇战的各种模式中。当然，MPR和YRM格式的地图没必要有它。不管怎样，其基本的设置类似于rules文件中的载具列表，里面有地图的列表以及各个地图的细节内容。","text":"来自PPM（只翻关键部分）作者：Dark Templar X简单来说，它是控制当有扩展地图包时，什么地图将出现在遭遇战的各种模式中。当然，MPR和YRM格式的地图没必要有它。不管怎样，其基本的设置类似于rules文件中的载具列表，里面有地图的列表以及各个地图的细节内容。PKT文件创建起来非常容易：新建一个文本文档并重命名为modname.pkt 即可。名字并不重要，但它有助于分辨文件的来源。首先是[MultiMaps]部分。例如：12345[MultiMaps] 1=SOMEMAP1 2=SOMEMAP2 3=SOMEMAP3 ……然后是对地图的定义。例如：123456[SOMEMAP1] Description=DESC:SOMEMAP1 CD=0,1,2 MinPlayers=2 MaxPlayers=2 GameMode=standard, meatgrind[SOMEMAP1]是地图文件的名字。Description=是CSF中对应的“类型:项目”名。CD=指定哪个盘需要在地图里播放。注： 在例举中我把所有的三个都用上了，建议你也这么做。（译注：这条应该是废弃了，参见后面的补充）MinPlayers=决定这个地图的最少玩家数。（译注：不应小于2）MaxPlayers=决定这个地图的最多玩家数，不能大于8。GameMode=决定可以使用的游戏模式，模式参考mpmodes(md).ini。补充：Allied General 的回复：据我所知，PKT文件只在遭遇战开发者套装里的文件中有所提及。CD=我认为它实际上已经废弃了，因为在assault.pkt中CD=0 是默认的使用方法，而且我也没有因它遇见过任何问题。GameMode=是PKT中最有用的部分，因为它可以使你能够定义一些有可用地图的特殊模式。例如在你的mpmodes(md).ini中有=GUI:FFAAssault, STT:ModeFFAAssault,MPFreeForAllMD.ini, assault, false那么任何有GameMode=assault的地图将会使用MPFreeForAllMD.ini里的设置，或者你也可以特别为它做一个，比如MPCaptureOnlyMD.ini。","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"},{"name":"翻译作品","slug":"翻译作品","permalink":"http://miroox.github.io/blog/categories/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"红警","slug":"红警","permalink":"http://miroox.github.io/blog/tags/%E7%BA%A2%E8%AD%A6/"},{"name":"翻译","slug":"翻译","permalink":"http://miroox.github.io/blog/tags/%E7%BF%BB%E8%AF%91/"},{"name":"参考","slug":"参考","permalink":"http://miroox.github.io/blog/tags/%E5%8F%82%E8%80%83/"}]},{"title":"旧作：陈天权 数学分析讲义 部分习题答案（第一弹）","slug":"ChengTianQuan-01","date":"2015-12-13T13:08:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2015/12/ChengTianQuan-01/","link":"","permalink":"http://miroox.github.io/blog/2015/12/ChengTianQuan-01/","excerpt":"说明：这里的答案全部是我自己写的，不保证完全正确。题目不抄了，只标题号，书没有就没办法了。题目都是选我感兴趣且会做的。","text":"说明：这里的答案全部是我自己写的，不保证完全正确。题目不抄了，只标题号，书没有就没办法了。题目都是选我感兴趣且会做的。 4.1.1 (i)由 f(0)=f(0)+f(0)f(0)=f(0)+f(0)f(0)=f(0)+f(0) 知 f(0)=0f(0)=0f(0)=0n=1n=1n=1 时显然成立，而∀x∈R,∀n∈N+,f((n+1)x)=f(x)+f(nx)\\forall x\\in\\R,\\forall n\\in\\N_{+},f((n+1)x)=f(x)+f(nx)∀x∈R,∀n∈N+​,f((n+1)x)=f(x)+f(nx)由归纳原理知∀x∈R,∀n∈N+,f(nx)=f(x)n(1)\\forall x\\in\\R,\\forall n\\in\\N_{+},f(nx)=f(x)n \\tag{1}∀x∈R,∀n∈N+​,f(nx)=f(x)n(1)带入 x=1x=1x=1，即∀n∈N+,f(n)=f(1)n(2)\\forall n\\in\\N_{+},f(n)=f(1)n \\tag{2}∀n∈N+​,f(n)=f(1)n(2)又∀n∈N,f(n)+f(−n)=f(0)=0\\forall n\\in\\N, f(n)+f(-n)=f(0)=0∀n∈N,f(n)+f(−n)=f(0)=0即f(−n)=−f(n)=f(1)⋅(−1)f(-n)=-f(n)=f(1)\\cdot(-1)f(−n)=−f(n)=f(1)⋅(−1)故∀m∈Z,f(m)=f(1)m(3)\\forall m\\in\\Z,f(m)=f(1)m \\tag{3}∀m∈Z,f(m)=f(1)m(3)带入 x=mnx=\\frac{m}{n}x=nm​ 于(1)式，∀m∈Z,∀n∈N+,f(m)=f(mn)n\\forall m\\in\\Z,\\forall n\\in\\N_{+},f(m)=f\\left(\\frac{m}{n}\\right)n∀m∈Z,∀n∈N+​,f(m)=f(nm​)n又由(3)式知∀m∈Z,∀n∈N+,f(mn)=1nf(m)=mnf(1)\\forall m\\in\\Z,\\forall n\\in\\N_{+},f\\left(\\frac{m}{n}\\right)=\\frac{1}{n}f(m)=\\frac{m}{n}f(1)∀m∈Z,∀n∈N+​,f(nm​)=n1​f(m)=nm​f(1)即∀p∈Q,f(p)=f(1)p(4)\\forall p\\in\\mathbb{Q},f(p)=f(1)p \\tag{4}∀p∈Q,f(p)=f(1)p(4)又因∀x∈R,∃pn∈Q,lim⁡n→∞pn=x\\forall x\\in\\R,\\exist p_n\\in\\mathbb{Q},\\lim_{n\\to\\infty}p_n=x∀x∈R,∃pn​∈Q,n→∞lim​pn​=x结合 f(x)f(x)f(x) 的连续性可得∀x∈R,f(x)=f(1)x\\forall x\\in\\R,f(x)=f(1)x∀x∈R,f(x)=f(1)x (ii)令 g(x)=log⁡f(1)f(x)g(x)=\\log_{f(1)}{f(x)}g(x)=logf(1)​f(x)，则g(x+y)=log⁡f(1)f(x+y)=log⁡f(1)f(x)+log⁡f(1)f(y)=g(x)+g(y)g(x+y)=\\log_{f(1)}{f(x+y)}=\\log_{f(1)}{f(x)}+\\log_{f(1)}{f(y)}=g(x)+g(y)g(x+y)=logf(1)​f(x+y)=logf(1)​f(x)+logf(1)​f(y)=g(x)+g(y)由(i)中结论知 g(x)=g(1)x=xg(x)=g(1)x=xg(x)=g(1)x=x，则 f(x)=f(1)g(x)=f(1)xf(x)=f(1)^{g(x)}=f(1)^xf(x)=f(1)g(x)=f(1)x (iii)令 g(x)=f(ex)g(x)=f\\left(\\mathrm{e}^x\\right)g(x)=f(ex)，则g(x+y)=f(ex⋅ey)=f(ex)⋅f(ey)=g(x)⋅g(y)g(x+y)=f\\left(\\mathrm{e}^x\\cdot\\mathrm{e}^y\\right)=f(\\mathrm{e}^x)\\cdot f(\\mathrm{e}^y)=g(x)\\cdot g(y)g(x+y)=f(ex⋅ey)=f(ex)⋅f(ey)=g(x)⋅g(y)由(ii)可知 g(x)=g(1)x=f(e)xg(x)=g(1)^x=f(e)^xg(x)=g(1)x=f(e)x，故 f(x)=g(ln⁡x)=f(e)ln⁡x=xln⁡f(e)f(x)=g(\\ln x)=f(e)^{\\ln x}=x^{\\ln f(e)}f(x)=g(lnx)=f(e)lnx=xlnf(e) (iv)令 g(x)=f(ex)g(x)=f\\left(\\mathrm{e}^x\\right)g(x)=f(ex)，则g(x+y)=f(ex⋅ey)=f(ex)+f(ey)=g(x)+g(y)g(x+y)=f\\left(\\mathrm{e}^x\\cdot\\mathrm{e}^y\\right)=f(\\mathrm{e}^x)+f(\\mathrm{e}^y)=g(x)+g(y)g(x+y)=f(ex⋅ey)=f(ex)+f(ey)=g(x)+g(y)由(i)知 g(x)=g(1)x=f(e)xg(x)=g(1)x=f(e)xg(x)=g(1)x=f(e)x，故 f(x)=g(ln⁡x)=f(e)ln⁡xf(x)=g(\\ln x)=f(e)\\ln xf(x)=g(lnx)=f(e)lnx 4.1.3考虑 (0,1]∖Q\\left(0,1\\right]\\setminus\\mathbb{Q}(0,1]∖Q：由 Archimedes 原理，∀ε&gt;0,∃N∈N+,∀n≥N,1n&lt;ε\\forall\\varepsilon&gt;0,\\exist N\\in\\N_{+},\\forall n\\ge N,\\frac{1}{n}&lt; \\varepsilon∀ε&gt;0,∃N∈N+​,∀n≥N,n1​&lt;ε另一方面，在区间 (0,1]\\left(0,1\\right](0,1] 上，分母小于 NNN 的有理数不会超过 N2−N2\\frac{N^2-N}{2}2N2−N​ 个，因此，必定∃δ&gt;0,∃p∈(x−δ,x+δ)∩Q,∣R(p)−R(x)∣≤1N&lt;ε\\exist\\delta&gt;0,\\exist p\\in(x-\\delta,x+\\delta)\\cap\\mathbb{Q},|R(p)-R(x)|\\le\\frac{1}{N}&lt;\\varepsilon∃δ&gt;0,∃p∈(x−δ,x+δ)∩Q,∣R(p)−R(x)∣≤N1​&lt;ε即 RRR 在 xxx 处连续。再考虑 (0,1]∩Q\\left(0,1\\right]\\cap\\mathbb{Q}(0,1]∩Q：∀δ&gt;0,∃q∈(x−δ,x+δ),q∈R∩Q\\forall\\delta&gt;0,\\exist q\\in(x-\\delta,x+\\delta),q\\in\\R\\cap\\mathbb{Q}∀δ&gt;0,∃q∈(x−δ,x+δ),q∈R∩Q显然，只要取 ϵ=R(x)2\\epsilon=\\frac{R(x)}{2}ϵ=2R(x)​，就不可能找到一个 δ&gt;0\\delta&gt;0δ&gt;0 使得 ∀y∈(x−δ,x+δ),∣R(y)−R(x)∣&lt;ε\\forall y\\in(x-\\delta,x+\\delta),|R(y)-R(x)|&lt; \\varepsilon∀y∈(x−δ,x+δ),∣R(y)−R(x)∣&lt;ε，故 RRR 在 xxx处不连续。","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miroox.github.io/blog/categories/%E6%95%B0%E7%90%86%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miroox.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"},{"name":"题解","slug":"题解","permalink":"http://miroox.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"},{"name":"微积分","slug":"微积分","permalink":"http://miroox.github.io/blog/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"}]},{"title":"旧作：泰矿模拟研究","slug":"Tiberium","date":"2015-10-11T12:48:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2015/10/Tiberium/","link":"","permalink":"http://miroox.github.io/blog/2015/10/Tiberium/","excerpt":"","text":"本文综合了 PPM Forum 上 Allied General 大神的教程以及 RA2DIY 上 kenosis 大神的教程，并经本人实践调试总结而成。Allied General 的教程kenosis 的教程 总体思路一、泰矿对步兵的毒害：用矿石闪光动画刷出粒子从而伤害。（kenosis使用动画刷碎片的方法，但我在实践时失败了）二、（蓝色）泰矿爆炸：给宝石加上Explodes=yes并用爆炸动画刷出碎片从而引发连锁反应。（当然，你或许需要泰伯利亚矿石的模型。自己想办法找吧。） 具体代码 Tiberium Damage12345678910111213141516171819202122232425262728293031323334;******* in RULSEMD.INI *******[AudioVisual](......)OreTwinkleChance=1;30 ; At map startup, there is 1 chance in N that a cell with ore will get a twinkle anim.;I alter this value to make the damage continous(......)[Particles](......)XX=OreGasPart ; \"XX\" is an ordinal[Warheads](......)YY=OreWH ; \"YY\" is an ordinal[OreGasPart]Image=none ; its invisible MaxDC=15 ; how many frames before damage occur, keep it small so damage occurs quickly MaxEC=60 ; how many frames this last for, keep it small to reduce lag Damage=15 ; how much it hurts, this damage ignores tags such as ImmuneToPoison even if the attached warhead is Poison=yes Warhead=OreWH ; the scissors, paper, rock of the damage StartFrame=0 ; best not to mess with this EndStateAI=20 ; best not to mess with this WindEffect=1 ; determines how far this particle moves from its starting position (defaults to 0) BehavesLike=Gas ; best not to mess with this StateAIAdvance=4 ;; best not to mess with this [OreWH]CellSpread=1 ; area effect damage PercentAtMax=1 ; keep damage high Verses=100%,100%,100%,1%,0%,1%,0%,0%,0%,0%,0% ; maybe you should change the armor of your SLAV to spcial_1 ProneDamage=300% ; multipler to apply to damage when infantry use prone sequence in art. InfDeath=8 ; virusdie12345678910;******* in ARTMD.INI ********[TWNK1]LoopCount=-1 ; this animation plays forever RandomLoopDelay=120,300 ; this gives a delay on the anim playing DetailLevel=2 ;I don't know what's this, best not to mess with this HideIfNoOre=true ; dont play this anim if no ore present ;Trailer=TWNK2 ;I tried and failed;SpawnDelay=1 ;sorry, the Great kenosisSpawnsParticle=OreGasPartNumParticles=1 ; the number to spawn, keep this low to minimise lag Tiberium BOOM!123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778;******** in RULSEMD.INI *********[General](......)BarrelExplode=EXPLOLRGX;EXPLOLRG ; exploding crates animation;I convert it because many warheads use EXPLOLRG as its AnimList, and I need distinguish from it.(......)[CombatDamage]AmmoCrateDamage=200 ; damage generated from exploding ammo crate overlay;Tiberium explosion damamge, but you'd better not to mess with this (......)C4Warhead=Super ;gs HE ;gs What? C4 sets a timer that forces the destruction of a building. This warhead is used throughout the code to mean \"Absolute damage\" ; this is the warhead that C4 uses to damage buildings;Tiberium explosion warhead, DON'T alter this!!!(......)[Animations](......)WWWW=EXPLOLRGX ; \"WWWW\" is an ordinalZZZZ=GEMDBR ; as above[GEM01]Name=GemsTiberium=yesLegalTarget=falseRadarInvisible=falseRadarColor=140,0,140;Land=Rock;ChainReaction=no;CellAnim=BIGBLUE;Image=GEM01;NoUseTileLandType=true;DrawFlat=falseExplodes=yes[GEM02](......) ;leave outExplodes=yes[GEM03](......) ;leave outExplodes=yes[GEM04](......) ;leave outExplodes=yes[GEM05](......) ;leave outExplodes=yes[GEM06](......) ;leave outExplodes=yes[GEM07](......) ;leave outExplodes=yes[GEM08](......) ;leave outExplodes=yes[GEM09](......) ;leave outExplodes=yes[GEM10](......) ;leave outExplodes=yes[GEM11](......) ;leave outExplodes=yes[GEM12](......) ;leave outExplodes=yes123456789101112131415161718192021222324252627282930;******** in ARTMD.INI *******[EXPLOLRGX]Image=EXPLOLRGTranslucent=yesUseNormalLight=yesReport=Explosion09Crater=yesScorch=yesTrailerAnim=GEMDBRTrailerSeperation=1[GEMDBR] ; maybe you need a shp with only ONE pixelElasticity=0.0MinZVel=12.0MaxXYVel=10.0ExpireAnim=TWLT026Damage=20DamageRadius=100Warhead=HE IsTiberium=trueLoopStart=0LoopEnd=8LoopCount=-1Rate=500;DetailLevel=0RandomRate=220,500Bouncer=yesTiberiumRadius=1TiberiumSpawnType=TIB01 ; GEM to ORE :)","categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"红警","slug":"红警","permalink":"http://miroox.github.io/blog/tags/%E7%BA%A2%E8%AD%A6/"},{"name":"功能模拟","slug":"功能模拟","permalink":"http://miroox.github.io/blog/tags/%E5%8A%9F%E8%83%BD%E6%A8%A1%E6%8B%9F/"}]},{"title":"旧作：七三一纪行","slug":"731","date":"2015-09-20T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2015/09/731/","link":"","permalink":"http://miroox.github.io/blog/2015/09/731/","excerpt":"","text":"Who controls the past controls the future; who controls the present controls the past.George OrwellNineteen Eighty-four初到平房，现代风格的第一展区首先给了我以极大的震撼。金燦的斜阳撒在魆黑的方形外壳上，仿若一座未来的要塞堡垒从地面突兀耸起，又如一尊异域的猛兽蛰伏着却溢放辉芒。时代确竟是不同了，昔日的废土上也生长起了这样伟岸的前卫建筑，可它却是拿来纪念历史的——历史又一次走在了我们的前面吗？进入展馆前，要通过一道安检。安检，本质上是一种过滤、防御系统，再加上门前站岗的警员，更加强了我对它那种要塞堡垒的印象——或许它确实是个堡垒，想将时间凝结在这个历史的黑匣子里，保护起来，收藏起来，乃至供奉起来。这确实是人类的记忆啊，无怪是要保护起来的。穿越滤门，进入了第一个展厅。映入眼帘的是由中文、英文、日文、韩文、俄文分别书写的“反人类暴行”几个大字，明耀的灯光打在字上，与幽暗的空间鲜明的对比，仿佛在向世界昭示日军的罪证暴行。可黑暗毕竟是更多的，是否暗示着更多的历史依旧笼罩在摩耶之幕下呢？随后是一些日军生化部队的布置介绍，基本上是一些纲要树图，也没有多少文物资料。有意思的是，除了731部队，还有诸如644部队之类的其它生化部队，可为什么只有731部队闻名呢？再往后走，看见的大抵不过是一些复原的模型、复制的资料以及一些残破不堪的日军遗物。这些东西，作为证据，感觉并不充分有力。作为外行，它们即使全是赝作，我们又能看出什么端倪呢？研究辨别它们，本是历史学家的工作。可如今，对历史学家的存真去伪似乎却愈发困难咯。当然，也不是真的那么无物可看。导游带领着，浮光掠影地扫过大部分资料，讲述着老生常谈的论调，这样的行程未免太过无趣。因此我亦步亦趋地随着大部队，用自己的双眼寻找spot。有两张有趣的照片，拍摄了七三一部队的拔河比赛和盂兰盆节，他们雀跃着，欢歌着，洋溢着幸福，可他们将要成为什么？传说“恶魔都有两副面孔”，或许是再贴切不过了。在一个展厅里，陈列着大量诸如“A报告”、“Q报告”之类的“topsecret”的复件，确实像是最详实的资料了。“美国人成了历史的记录者，因为他们有比中国人更客观的立场和更翔实的资料。”可他们真的有立场吗？可他们真的可信赖吗？作为罪行的掩盖者，这莫非又是某个庞大计划的一环？还有日本人的，他们大都是口述史或回忆录式的，这本应成为最有力的证据吧？可西方人似乎并不这么看。这些内容更像是在中国共产党的“洗脑”下诞生的。“日本是一个多么文明有礼的国家啊，又怎么会做出如此残忍的虐杀呢？”“所谓坦白视频里的老兵哭的太过头，表现地太激动，简直像个疯子。共产党是洗脑的高手，毫无疑问这是他们阴谋。”展厅里也有艺术。染血的手术台、十字架的刑场，还有用光影在墙上绘成的囚窗和掌印……鬼气森森的艺作给历史带上了一层阴森神秘之感。和历史一样，艺术毕竟也是一项主观的、充满创造力的行为啊。离开第一展区前，有一个不小的商店，陈列着各式的纪念品和书籍。“这是历史的商品化？抑或是历史的资本价值得以发挥？”无论如何，我都不曾购买一份纪念。它正淌过我的指尖。离开第一展区要通过一个宽敞的隧道，沿途没有警卫也没有安检，成为了一个堡垒的巨大破绽，仿佛将宝脉的“气”都放了出去。安全性的失却，令它那超现实的神秘感削弱了大半，却又像回归了历史。第二展区在开阔的室外，这是要参观真正的历史了。可就是在七三一本部的旧址旁，团簇着大量的鸽子。和平也被战争的过往吸引着啊。而后来到一处破败的铁架房前，据说这里曾经是炼狱。可炼狱也被时间摧残得辨认不出了，又有多少亡魂在这里徘徊？在锅炉房面前，我们明确地知道了什么缺失了。那些消失的钢筋暗示着历史的连续，时间并未在此定格。而令钢筋消失的，不同样也是不能忘记的历史吗？冷冻实验室旁有一片树林，人们称它们“历史的见证者”，可它们从未听从我们的呼唤。它们真的见证了什么吗？我不知道。而后我看见了一方凝固的时间。匿身地下的小动物饲养室完好的保存下来，这是值得庆幸的。可作为暴行的证据，它似乎有些太弱了。这也是谋划好的吗？“謝罪と不戦平和の誓い”据说这是日本唯一在中国明确表达谢罪之意的纪念碑。感觉却像是“为了忘却的纪念”。最后离开之时，我回顾这片残垣，却想起了哈尔滨的烟霾弥漫，不得不回忆起刘宇昆的《纪录片：终结历史之人》。这是一部几乎没有剧情的小说。或者，对于一部纪录片，本身也不需要什么剧情。身为著名美籍华裔科幻作家的刘宇昆带来了一个简单的故事：为了向世人还原731部队的暴行，美籍华裔历史学家埃文•魏与妻子美籍日裔物理学家桐野明美一起制作了一台可以将参与者带回过去亲眼目睹历史事件的机器，但正如“人不能两次踏入同一条河流”，这种回顾只有一次机会，而由此引发的一系列纷争则远远超出了他们的意料与控制。可他丰富地展现了不同国家不同立场的不同人的态度与观点，让真实与赝品纠缠。这正是我们难以做到的。“我是在报纸上看到这条新闻的。报纸上说魏博士不是中国人，而是美国人。中国人都知道731部队，所以这对我们来说不算什么新闻。我实在懒得搭理这种事。那些无知的年轻人们成天叫嚣着抵制日货，然后一转头就迫不及待地去买下一期漫画。干嘛要听他们瞎扯？他们只会空口煽动民众，自己什么都不做。”“我接下来说的话一定会引起公愤，但是事实就是事实。在主席执政期间所发生的三年自然灾害和随之而来的文化大革命中，死去的人也是不计其数。战争是痛苦的，但是这不过是中国人所经历的众多痛苦中的其中一个而已。在中国，无人哀悼的悲惨往事多了去。那个魏博士真是没事找事的蠢货。历史能当饭吃，能当水喝，能当衣服穿吗？”“但是按照埃文的观点——我认为他这么想是完全合理的——一旦他接受了中国政府的任何资助，监控，或依附于中国政府，那么他的工作在西方人的眼里就毫无可信性了。因此埃文拒绝了中国给予的所有帮助，甚至请来美国外交官加以干涉。这一举动引发了中国人的众怒和排斥。最后，中国政府迫于滚滚而来的负面舆论，叫停了埃文的项目。对此几乎没有一个中国人起来为他辩护，因为他们觉得埃文和明美给中国历史及其子民非但没有带来福音，反而使其遭受了更多的损害——甚至也许是处心积虑的行为。”“日本侵略在中国造成一千六百多万人死亡。数目虽然庞大，却并不是发生在像平房区这样的死亡工厂或南京的屠杀竞技场等这些抢占报纸头条，夺人眼球的地方。相反，他们是在无数个僻静的小村庄，城镇和偏远的山区惨遭屠杀，强奸，然后再屠杀，他们的尖叫声随着刺骨的寒风渐渐消失，甚至于他们的名字也都渐渐被人遗忘。但是这些人也应该受到人们的怀念。”“虽然隔着一片狭窄的海域，中国和日本对二战暴行的态度却不谋而合：一些人要求以‘和平’和‘社会主义’的共同愿望遗忘历史；一些人将战争回忆牵扯上爱国之心；一些人把受害者和犯罪者同时打造成服务国家需要的标志。由此看来，中国的这些零碎的，不完整的回忆片段和日本的沉默不过是一枚硬币的正反面而已。”“魏博士的观点核心在于，他认为没有真实的回忆，就没有真正的和解。正是因为没有真实的回忆，各国的国民才无法感受和体会并牢记受难者的苦痛。只有每个人都能以自己的方式讲述出那段历史，我们才能够挣脱历史的束缚。”“他的方法存在很多问题。我们有大量的心理案例以及法律法规可质疑这些目击证词的可靠性。而且对于‘桐野技术’所具有的一次性特点，我们也深感忧虑。‘桐野技术’似乎会毁灭它所研究的对象，消除被见证的历史。通俗地说，就是你再也不可能回到其他目击者已经经历的那一时刻——因为经历之后它就随之消失。既然每一个目击证人的证词没有其它证词可以验证，那么我们怎么能依靠这样一种手段去寻找真相呢？”“我们生活的时代非常推崇个人化的真实记录，比如自传这种形式。目击者的叙述所具有的直接性和现实性给人一种强烈的可信感，在我们看来他们所传达的信息比任何小说都要真实。但是，矛盾的是，我们又总是迫不及待想在这些故事里找到任何一个与事实相悖和不符之处，然后宣布整个故事不过是虚构而已。我们的心理就是具有这样一种极端的阴郁特性。可是话说回来，我们从一开始就应该认清这种叙述本身就带着不可克服的主观性，不过那并不意味他们就没有传达真相。”由于篇幅的关系，我不再继续列举更多的内容了。刘宇昆在小说中探讨的早已不只是七三一的暴行揭露了，更是对历史虚无主义探讨，是对人与历史关系的研究。引用约翰•H•阿诺德在《历史之源》结尾中的一段话：确定一种记载优于另外一种的危险在于，它是为了把“历史”浇铸成一个单一的真实故事。主观的历史学家（具有他们自己的成见、阶级利益和性别政治）试图将他们的事件版本作为唯一可能的版本呈现出来。然而，认为历史中存在单一的真实故事，这一观念仍然具有极大的吸引力，因而也具有极大的危险性。报纸每天谈论“历史”会如何对政治家或事件做出评判，政治家在“历史向我们表明”的基础上为外交政策辩护，全球的战争集团以“他们的历史”为基础证明其杀戮的正当性。这是省略了人的历史——不管过去发生了什么，也不管现在它被用作何意，都要取决于人，取决于人的选择、判断、行为和观念。给过去的真实故事贴上“历史”的标签，是为了让它们看起来是独立于人的参与和作用而发生的。毕竟是人书写的历史啊。你觉得呢？","categories":[{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miroox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"}],"tags":[{"name":"作文","slug":"作文","permalink":"http://miroox.github.io/blog/tags/%E4%BD%9C%E6%96%87/"},{"name":"散记","slug":"散记","permalink":"http://miroox.github.io/blog/tags/%E6%95%A3%E8%AE%B0/"}]},{"title":"旧作：从芝诺悖论到无穷小分析","slug":"ZenoParadoxAndCalculus","date":"2015-07-19T09:17:45.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2015/07/ZenoParadoxAndCalculus/","link":"","permalink":"http://miroox.github.io/blog/2015/07/ZenoParadoxAndCalculus/","excerpt":"（高中毕业的暑假写的）百度文库版 前言：这是本人第一次写科普，解释可能并不很形象。建议知识水平在初中以上的读者阅读（高中水平以下的建议先阅读后面的注释[1]）。本人水平有限，如有错误，欢迎各位指正。","text":"（高中毕业的暑假写的）百度文库版 前言：这是本人第一次写科普，解释可能并不很形象。建议知识水平在初中以上的读者阅读（高中水平以下的建议先阅读后面的注释[1]）。本人水平有限，如有错误，欢迎各位指正。 一、“可望不可即”——芝诺之惑一只运动速度为10米每秒的兔子与一只运动速度1米每秒的乌龟同向而行。开始时，乌龟在兔子前方9米处。问：何时兔子追上乌龟？[2]这道题即使是小学四五年级的学生应该也能立即答出“一秒”的答案来的。然而，我们“聪明的”古希腊哲学家芝诺却为这个问题头疼不已。他在脑中模拟，想：兔子在追上乌龟之前，先要抵达两者原距离的一半处，而此时乌龟已经向前走了一段距离，接下来，兔子又要先到两者第二次距离的一半处，这时乌龟又向前走了一段，如此往复，兔子永远也无法追上乌龟。[3]芝诺的做法似乎无可非议，可问题在哪呢？有人认为，时空并非无限可分，存在某种最小单元[4]，因此，他的“如此往复”，必将终止于某一阶段。那么，假如我们暂时抛却这个瑕疵，假设时空是 无限可分的 ，芝诺的推理就对了吗？聪明的读者也许很快就会注意到：无穷的过程是否需要无限的时间？这便是这个问题的关键。[5] [6]为了避免文章中出现许多公式与符号，我们将这个问题简化成另一个等价的问题上：“永远无法抵达的终点”：当乌龟正为自己的秘术沾沾自喜时，却发现自己永远也抵达不了一米前的终点。他首先要抵达终点的一半处，然后要抵达剩余路程的一半处，如此往复，自己永远也到达不了终点的地方。再强化一点，将终点无限移近，那他甚至无法起动。[7]果真如此吗？答案当然是否定的。对于每一段，乌龟所花的时间分别是 12,14,18,116,⋯\\frac{1}{2},\\frac{1}{4},\\frac{1}{8},\\frac{1}{16},\\cdots21​,41​,81​,161​,⋯乌龟所花的总时间 t=12+14+18+116+⋯t=\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\frac{1}{16}+\\cdotst=21​+41​+81​+161​+⋯有一点级数知识的读者当然知道求解，但我这里要提供一个小学生也能看懂的办法[8]：12+14+18+116+⋯=12+12(12+14+18+116+⋯ )⇒12(12+14+18+⋯ )=12⇒12+14+18+⋯=1\\begin{aligned} \\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\frac{1}{16}+\\cdots &amp;= \\frac{1}{2}+\\frac{1}{2}(\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\frac{1}{16}+\\cdots) \\\\ \\Rightarrow \\frac{1}{2}(\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\cdots) &amp;= \\frac{1}{2} \\\\ \\Rightarrow \\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\cdots &amp;= 1 \\end{aligned}21​+41​+81​+161​+⋯⇒21​(21​+41​+81​+⋯)⇒21​+41​+81​+⋯​=21​+21​(21​+41​+81​+161​+⋯)=21​=1​当然，更聪明的读者也许会说：在空间上， 12,14,18,116,⋯\\frac{1}{2},\\frac{1}{4},\\frac{1}{8},\\frac{1}{16},\\cdots21​,41​,81​,161​,⋯ 这些距离都是从111m中分割出来的，而且除此之外也 没有剩下的 [9]，那它们的总和自然也是111。显然， 无限的过程并不对应着无限的时间 。而且，这样算出的时间与一般方法并无二致。芝诺的错误，在于 人为的 将连续统进行了无限的划分，并错误的认为无限的任务必定不能在有限的时间内完成。不过，我们的数学家又怎会止步于此，他们在此基础上提出了一种思想实验——“超级计算机”：这种计算机启动后0.5秒输出圆周率小数点后的第一位数，然后过0.25秒输出第二位数，之后再0.125秒输出第三位数，以此类推，那么一秒后我们可以得到圆周率的最后一位数。（尽管我们知道它没有最后一位）[10]当然，在现实世界中，由于种种原因，这样的机器是不可能实现的，但这并不妨碍数学家们的想象它的运作。它从某个侧面揭示了数学的一种反常识现象。[11]但如果从实证的角度，这种“超级任务”不可完成，恰恰证明了芝诺这种将时间进行 人为划分 是无效的。[12]芝诺的谬误，在现在看来是可笑的。但是在这条通往正确的荆棘之路上，第奥根尼、亚里士多德、黑格尔……大量的数学家哲学家或是误入歧途，或是倒在了求索之路上。与此同时，伴随着流数、级数等运算的深入研究，“无限”这个既抽象又形象的概念，也就需要一个逻辑上更切实的定义。 二、“瞬时是不是零？”——牛顿的尴尬上节提到的芝诺其实是一个相当“高产”的哲学家，他一生曾巧妙地构建了四十多个悖论，其中，为了捍卫他老师巴门尼德关于“存在”不动、是“一”的学说[13]所提出的有关运动的四个悖论最为著名，上节讲的“追击悖论”便是当中的一个。而另一个著名悖论“飞矢不动”则更加凶猛，时日至今仍争论不断。“飞矢不动”：芝诺问他的学生：“一支射出的箭是动的还是不动的？”“那还用说，当然是动的。”“确实是这样，在每个人的眼里它都是动的。可是，这支箭在每一个瞬间里都有它的位置吗？”“有的，老师。”“在这一瞬间里，它占据的空间和它的体积一样吗？”“有确定的位置，又占据着和自身体积一样大小的空间。”“那么，在这一瞬间里，这支箭是动的，还是不动的？”“不动的，老师”“这一瞬间是不动的，那么其他瞬间呢？”“也是不动的，老师”“所以，射出去的箭是不动的？”芝诺的论证中，有许多十分可疑的概念，而最可疑的是他对“ 不动 ”的阐述： 有确定的位置，又占据着和自身体积一样大小的空间 。表述十分拗口，而且仔细观察，这是有关运动的概念，却完全没有涉及时间。现在我们知道，在 运动 这个概念中时间是 必不可少的 。[14]很显然，如果失去时间，运动自然也就不复存在。而对任何一个瞬间，仅凭这一瞬间的空间状态其运动与否是无法判断的，只有这一瞬间 前后 物体的空间状态明晰了，我们才能判断它的运动状态。然而，“瞬时速度”的横空出现让我们上面的说法又变得尴尬起来。原则上，我们只要知道某一刻的瞬时速度，它在这一刻的运动状态就几乎完全确定下来。[15]而瞬时速度是 瞬时的 ，它所讲的应该是 这一时刻 ，而非时间。因此，时间对运动状态判断的影响似乎又不那么重要了。瞬时速度，这个概念也许诞生于伽利略对匀变速直线运动的研究，或者在更早的时候就有了雏形，但真正普适的计算方法，却是伴随着微积分的诞生与发展而产生的。说起微积分，大家可能会想起牛顿与莱布尼兹的微积分创始人之争。事实上，微积分既非开始于他们，也非完成于他们。积分的概念上可追溯到古希腊的阿基米德，而导数（微分）的计算也在他们半个世纪前的开普勒时代就出现了。到17世纪，一批继承了伽利略和开普勒工作的科学家，关心着两个问题：①求切线的问题；②求曲线长度、曲面面积以及不规则物体体积的问题。而牛顿和莱布尼兹的伟大之处就在于指出了这两个问题的重要联系，即我们今天所说的牛顿-莱布尼兹公式。牛顿出于动力学研究的需要，在他的老师巴罗的工作的影响下，得到了这个重要的结果，但这个结果的广泛使用相当程度上应归功于莱布尼兹出色的形式符号。其实，巴罗在几何学的研究中已经揭示出了上面两个问题的联系，但他并未提出一般的导数与积分的概念，因而完全没有涉及运动学与动力学领域。而到了牛顿，他虽先于莱布尼兹得到这个结果，但却没有立即发表。之后，莱布尼兹在与物理学家惠更斯为一件外交事务交往时，在一个短的惊人的时间内学到了微分和积分这种新的数学概念，不久，他便独立于牛顿获得了这一结果，并立即发表了它。事后，崇拜牛顿的人与莱布尼兹的朋友发生了激烈的争执，前者毫无根据地指责莱布尼兹剽窃。随后，卷入这场争执的人越来越多，甚至发展成了一场英国科学家与欧洲大陆科学家之间历时两百多年的争执。这样的争执对科学发展是毫无意义的。特别，使用比较繁琐的牛顿的符号，并蔑视欧洲大陆莱布尼兹学派的工作，竟成为英国数学家爱国与忠于信仰的表现。这种陈腐的思想使得到了18世纪，欧洲大陆出现了伯努利、欧拉、拉格朗日以及拉普拉斯这样的数学大家时，英吉利海峡北面的不列颠岛上竟没有一个人的才华可以与他们相提并论的。事实上，不同的人从不同的问题出发，经历不同的思路，得到同一个重要的结果，这种“殊途同归”的现象在人类文明史上是屡见不鲜的。而那种追名逐利的做法却会给科学带来巨大伤害。再回到瞬时速度，假如我们直接套用平均速度的算法显然是行不通的，因为一瞬间，时间是0，物体的位移也是0，而 00\\frac{0}{0}00​ 是无意义的。那么牛顿他们是怎么做的？[16]我们知道，对于自由落体运动，其位移 sss 与时间 ttt 的关系满足： s=12gt2s=\\frac{1}{2}gt^{2}s=21​gt2给时间ttt一个极小的增量 Δt\\Delta tΔt，显然从 ttt 到 t+Δtt+\\Delta tt+Δt 这段时间的平均速度为v=ΔsΔt=12g(t+Δt)2−12g(t)2Δt=12g(2t+Δt)v=\\frac{\\Delta s}{\\Delta t}=\\frac{\\frac{1}{2}g(t+\\Delta t)^{2}-\\frac{1}{2}g(t)^{2}}{\\Delta t}=\\frac{1}{2}g(2t+\\Delta t)v=ΔtΔs​=Δt21​g(t+Δt)2−21​g(t)2​=21​g(2t+Δt)略去 Δt\\Delta tΔt，即瞬时速度 v=gtv=gtv=gt这也就是我们说自由落体是匀加速直线运动（速度随时间线性增加）的原因。在这里，我们注意到一个重要的步骤： 略去 Δt\\Delta tΔt 。略去它，从本质上是令它 等于零 。牛顿对此解释称其为无限小增量，是一种 静止 的无穷小量，而莱布尼兹则认为它是高阶无穷小的误差，应当忽略。很显然，这样的推理是不严密的， Δt\\Delta tΔt 一会儿不是零，一会儿又是零。另一方面，直觉和经验告诉人们运动的物体每一刻都有一个相对应的瞬时速度，而牛顿和莱布尼兹的做法确实可以求出相应的瞬时速度来，许多数学家和物理学家因而也承认了这种做法的有效性。好景不长，1734年英国的哲学家神学家贝克莱发表了一本针对微积分基础的小册子《分析学家》，引起了数学界的轩然大波，诱发了我们所谓的“第二次数学危机”。这本小册子只有104页，却对微积分的基本概念，基本方法等全部内容提出了全面批评。一方面，他批评了微积分当中许多基本概念如流数、瞬[17]、无穷小增量、初生量、消失量[18]等的模糊性。在他看来，这些重要的概念都是“隐晦的神秘物”，是“混乱与模糊”、“无理与荒谬”。对于瞬时速度，贝克莱的观点似乎与现在思想异曲同工——既然速度不能离开时间和空间，那么根本不能想象一个时间为零的瞬时速度。另一方面，他指出了微积分基本方法的缺陷。称牛顿首先给xxx一个增量，之后又令它“消失”（等于零），显然违背了背反律，所得流数实际上不过是0/0。对于消失量，他讥讽的诘问：“这些消失的增量究竟是什么呢？它们既不是有限量，又不是无限小，也不是零，难道我们不应该称它们为消失的鬼魂吗？”同时，他也攻击莱布尼兹的微分法，认为莱布尼兹依靠“忽略高级无穷小的误差”的做法，不过是“从错误的原理出发，通过错误的抵消，得出的不科学但是正确的结论。”“在每一门其他科学中，人们用他们的原理证明他们的结论，而不是用结论来证明他们的原理。”贝克莱主教的诘难，无疑是犀利的。他一针见血地指出了早期微积分发展时种种逻辑上的弊病，使微积分的基础问题得到了更大的重视。尽管如此，整个18世纪众多数学家弥补微积分漏洞的尝试都没能获得圆满的结果。分析学（微积分是其基础）就在这种浑浑噩噩的状态下不断发展。直至19世纪，柯西迈出了微积分走向严格化的关键一步，并由德国数学家魏尔斯特拉斯提出了完善的“ε-δ定义”，将微积分与实数紧密结合起来，最终实现“分析算术化”，使微积分建立在一个严谨的逻辑基础上，第二次数学危机也就此圆满解决。 三、“ ε-δ 的无穷小分析”——魏尔斯特拉斯的解释在讲魏尔斯特拉斯的解释之前，我们先来谈谈两个数学的逻辑符号的意义：逻辑算子“∀\\forall∀”“∃\\exists∃”。它们往往放在命题的前面，用于约束命题中的变量。“∀\\forall∀”是全称量词，读作“对任意的……”，但它的意义应当是“对任意 给定的 ……”。比如一个命题，“∀x∈U，p(x)\\forall x\\in U，p(x)∀x∈U，p(x)”，其中， xxx 是 UUU 中的任一元素。但同时，在判定 p(x)p(x)p(x) 之前， xxx 必须确定下来。此时，单独研究 p(x)p(x)p(x) 所用的是之前给定的 xxx ，不能再更改。“∃\\exists∃”是特称量词，读作“存在……”，它的意义比“∀\\forall∀”要显然一些。但有一点值得注意：特称量词既不能确定满足条件的变量的个数，更无法得到满足条件的解。如果说全称命题是先给定 xxx ，再考虑 p(x)p(x)p(x) 的话；对特称命题的判定则应先看 p(x)p(x)p(x) ，再考虑是否存在满足的 xxx。从这里，可以看出，全称量词下的变量乍看之下是“运动”的，却也有静止的时候；特称量词下的变量，看起来固定，却又有些随意。这种辩证的关系贯穿着整个数学，尤其是数学分析。认识了这一点，才能正确的理解微积分的内涵。有了之前的铺垫，下面便开始讲魏尔斯特拉斯的阐释。首先，来看他关于函数极限的几条看起来比较吓人的定义[19]：1.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (a−A,a)∪(a,a+A)(a-A,a)\\cup (a,a+A)(a−A,a)∪(a,a+A) 的集合（其中 AAA 是某个允许的正数）。若∀ε&gt;0,∃0&lt;δ≤A,∀x∈(a−δ,a)∪(a,a+δ),∣f(x)−α∣&lt;ε\\forall \\varepsilon&gt;0, \\exists 0&lt; \\delta\\le A, \\forall x\\in (a-\\delta,a)\\cup (a,a+\\delta), \\vert f(x)-\\alpha\\vert &lt; \\varepsilon∀ε&gt;0,∃0&lt;δ≤A,∀x∈(a−δ,a)∪(a,a+δ),∣f(x)−α∣&lt;ε则称函数 f(x)f(x)f(x) 当 x→ax\\to ax→a 时 趋于 （或 收敛于 ）极限 α\\alphaα。也称函数 f(x)f(x)f(x) 当 x→ax\\to ax→a 时 有极限 α\\alphaα，记作 lim⁡x→af(x)=α\\lim_{x\\to a}{f(x)}=\\alphalimx→a​f(x)=α 。2.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (a−A,a)(a-A,a)(a−A,a) 的集合（其中 AAA 是某个允许的正数）。若∀ε&gt;0,∃0&lt;δ≤A,∀x∈(a−δ,a),∣f(x)−α∣&lt;ε\\forall \\varepsilon&gt;0, \\exists 0&lt; \\delta\\le A, \\forall x\\in (a-\\delta,a), \\vert f(x)-\\alpha\\vert &lt; \\varepsilon∀ε&gt;0,∃0&lt;δ≤A,∀x∈(a−δ,a),∣f(x)−α∣&lt;ε则称函数 f(x)f(x)f(x) 当 x→a−x\\to a_{-}x→a−​ 时 趋于 （或 收敛于 ）极限 α\\alphaα。也称函数 f(x)f(x)f(x) 当 x→ax\\to ax→a 时 有左极限 α\\alphaα，记作 lim⁡x→a−f(x)=α\\lim_{x\\to a_{-}}{f(x)}=\\alphalimx→a−​​f(x)=α 。3.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (a,a+A)(a,a+A)(a,a+A) 的集合（其中 AAA 是某个允许的正数）。若∀ε&gt;0,∃0&lt;δ≤A,∀x∈(a,a+δ),∣f(x)−α∣&lt;ε\\forall \\varepsilon&gt;0, \\exists 0&lt; \\delta\\le A, \\forall x\\in (a,a+\\delta), \\vert f(x)-\\alpha\\vert &lt; \\varepsilon∀ε&gt;0,∃0&lt;δ≤A,∀x∈(a,a+δ),∣f(x)−α∣&lt;ε则称函数 f(x)f(x)f(x) 当 x→a+x\\to a_{+}x→a+​ 时 趋于 （或 收敛于 ）极限 α\\alphaα。也称函数 f(x)f(x)f(x) 当 x→ax\\to ax→a 时 有右极限 α\\alphaα，记作 lim⁡x→a+f(x)=α\\lim_{x\\to a_{+}}{f(x)}=\\alphalimx→a+​​f(x)=α 。4.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (a−A,a)(a-A,a)(a−A,a) 的集合（其中 AAA 是某个允许的正数）。若∀M∈R,∃0&lt;δ≤A,∀x∈(a−δ,a),f(x)&gt;M\\forall M \\in\\mathbb{R}, \\exists 0&lt; \\delta\\le A, \\forall x\\in (a-\\delta,a), f(x)&gt;M∀M∈R,∃0&lt;δ≤A,∀x∈(a−δ,a),f(x)&gt;M则称函数 f(x)f(x)f(x) 当 x→a−x\\to a_{-}x→a−​ 时 趋于 （或 发散于 ）∞\\infty∞。也称函数 f(x)f(x)f(x) 当 x→ax\\to ax→a 时 有左极限是无穷大，记作 lim⁡x→a−f(x)=∞\\lim_{x\\to a_{-}}{f(x)}=\\inftylimx→a−​​f(x)=∞ 。类似的，还有 右极限是无穷大 的5.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (a−A,a)(a-A,a)(a−A,a) 的集合（其中 AAA 是某个允许的正数）。若∀M∈R,∃0&lt;δ≤A,∀x∈(a−δ,a),f(x)&lt;M\\forall M \\in\\mathbb{R}, \\exists 0&lt; \\delta\\le A, \\forall x\\in (a-\\delta,a), f(x)&lt; M∀M∈R,∃0&lt;δ≤A,∀x∈(a−δ,a),f(x)&lt;M则称函数 f(x)f(x)f(x) 当 x→a−x\\to a_{-}x→a−​ 时 趋于 （或 发散于 ）−∞-\\infty−∞。也称函数 f(x)f(x)f(x) 当 x→ax\\to ax→a 时 有左极限是负无穷大，记作 lim⁡x→a−f(x)=−∞\\lim_{x\\to a_{-}}{f(x)}=-\\inftylimx→a−​​f(x)=−∞ 。类似的，还有 右极限是负无穷大 的6.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (A,+∞)(A,+\\infty )(A,+∞) 的集合（其中 AAA 是某个允许的正数）。若∀ε&gt;0,∃M≥A,∀x&gt;M,∣f(x)−α∣&lt;ε\\forall \\varepsilon&gt;0, \\exists M\\ge A, \\forall x&gt;M , \\vert f(x)-\\alpha\\vert &lt; \\varepsilon∀ε&gt;0,∃M≥A,∀x&gt;M,∣f(x)−α∣&lt;ε则称函数 f(x)f(x)f(x) 当 x→+∞x\\to +\\inftyx→+∞ 时 趋于 （或 发散于 ）极限 α\\alphaα。也称函数 f(x)f(x)f(x) 当 x→+∞x\\to +\\inftyx→+∞ 时 有极限 α\\alphaα，记作 lim⁡x→+∞f(x)=α\\lim_{x\\to +\\infty}{f(x)}=\\alphalimx→+∞​f(x)=α 。类似的，还有当 x→−∞x\\to -\\inftyx→−∞ 时 有极限 α\\alphaα的7.假设函数 f(x)f(x)f(x) 的定义域是在实轴上并包含 (A,+∞)(A,+\\infty)(A,+∞) 的集合（其中 AAA 是某个允许的正数）。若∀M∈R,∃L≥A,∀x&gt;L,f(x)&gt;M\\forall M \\in\\mathbb{R}, \\exists L\\ge A, \\forall x&gt;L , f(x)&gt;M∀M∈R,∃L≥A,∀x&gt;L,f(x)&gt;M则称函数 f(x)f(x)f(x) 当 x→+∞x\\to +\\inftyx→+∞ 时 趋于 （或 发散于 ）∞\\infty∞。也称函数 f(x)f(x)f(x) 当 x→+∞x\\to +\\inftyx→+∞ 时 有极限 ∞\\infty∞，记作 lim⁡x→+∞f(x)=∞\\lim_{x\\to +\\infty}{f(x)}=\\inftylimx→+∞​f(x)=∞ 。类似的，还有当 x→−∞x\\to -\\inftyx→−∞ 时 有极限 ∞\\infty∞ 的，当 x→+∞x\\to +\\inftyx→+∞ 时 有极限 −∞-\\infty−∞ 的，当 x→−∞x\\to -\\inftyx→−∞ 时 有极限 −∞-\\infty−∞ 的8.除此之外，还有当 xxx 趋于某个值或无穷时函数 f(x)f(x)f(x) 没有极限的情况。上面的概念看似复杂而且数目繁多，但其理念都是相似的。其中， 1 是最具有普遍性，也最利于我们加以阐明的。为了使论述更加形象，我们从一个具体的例子开始。考虑函数 f(x)=x3+xxf(x)=\\frac{x^{3}+x}{x}f(x)=xx3+x​显然，函数f(x)f(x)f(x)在x=0x=0x=0处没有定义，但 ∀x≠0,f(x)=x2+1\\forall x\\ne 0, f(x)=x^{2}+1∀x​=0,f(x)=x2+1 。即 f(x)−1=x2f(x)-1=x^{2}f(x)−1=x2 。这样，我们只需把 xxx 限制在0的 充分小的邻域内 ，这个差就可以小到 任何我们所希望的程度 。比如，x=±110f(x)=1100x=±1100f(x)=110000\\begin{aligned} x&amp;=\\pm\\frac{1}{10} &amp;{} f(x)&amp;=\\frac{1}{100}\\\\ x&amp;=\\pm\\frac{1}{100} &amp;{} f(x)&amp;=\\frac{1}{10000} \\end{aligned}xx​=±101​=±1001​​f(x)f(x)​=1001​=100001​​等等。一般地，对于任何一个确定的正数 ε\\varepsilonε，无论它有多么小，只要我们控制xxx与0的差小于 δ=ε\\delta =\\sqrt{\\varepsilon}δ=ε​ 的话，那么 f(x)f(x)f(x) 与1之间的差将小于 ε\\varepsilonε。因为∣x∣&lt;ε⇒∣f(x)−1∣=∣x2∣&lt;ε\\vert x\\vert &lt; \\sqrt{\\varepsilon} \\Rightarrow \\vert f(x)-1\\vert =\\vert x^{2}\\vert &lt; \\varepsilon∣x∣&lt;ε​⇒∣f(x)−1∣=∣x2∣&lt;ε此时我们就称 lim⁡x→0x3+xx=1\\lim_{x\\to 0}{\\frac{x^{3}+x}{x}}=1limx→0​xx3+x​=1再让我们回到极限概念 1 ，第一句话实际是为了让求x=ax=ax=a处的极限成为可能—— f(x)f(x)f(x) 要在 aaa 的附近有定义。这个“附近”应当与 aaa 无限的“近” [20]，而它的半径 AAA 可以任意的小。注意这个定义是挖去了“心” x=ax=ax=a 的，但它并没有要求 f(x)f(x)f(x) 在 aaa 处没有定义。事实上， f(a)f(a)f(a) 是否存在以及其值是多少对 f(x)f(x)f(x) 在该点的极限都没有影响。只有 f(x)f(x)f(x) 在该点附近的“趋势”才决定它的极限。第二句话也就是定义的关键。首先，是“对于任意的正数ε\\varepsilonε”。注意，在这一步后， ε\\varepsilonε 必须给定，无论是100还是1/100或是别的什么，固定下来进入下一步后就不能改变。然后，为了方便理解，我们先跳过“存在……”这个部分，因为 δ\\deltaδ 要根据后面来确定[21]。先看“对任意包含于 (a−δ,a)∪(a,a+δ)(a-\\delta ,a)\\cup (a,a+\\delta )(a−δ,a)∪(a,a+δ) 的 xxx”，当然，这里的 xxx 同样要给定。但由于我们的 δ\\deltaδ 还“未定”，因此，我们更要留意 xxx 的遍历性，即 xxx 是可以 取遍 条件内的任何值的。再到最后一个部分，即 f(x)f(x)f(x) 与某定值 α\\alphaα 之间的差可以小于之前给定的 ε\\varepsilonε。这时再往回看，如果定值 α\\alphaα 真是 f(x)f(x)f(x) 在 aaa 处的极限，那么我们总能找到一个合适的 δ\\deltaδ，使得任何一个包含于 (a−δ,a)∪(a,a+δ)(a-\\delta ,a)\\cup (a,a+\\delta)(a−δ,a)∪(a,a+δ) 的 xxx ，都能使最后一部分的论断成立。最后，我们再考虑 ε\\varepsilonε 的任意性，你可以不断缩小 ε\\varepsilonε，但上述的论断始终成立。这样，定值 α\\alphaα 便是 f(x)f(x)f(x) 在 aaa 处的极限，否则，就不是。 需要注意的是，定值 α\\alphaα 的确定是先于这里面所有的步骤的，极限的定义实际上是一种判定定理，但如何求出它则有赖于我们的数学技巧。还有一点，我们虽然通常把求极限的过程称为“趋于……”，但在 ε−δ\\varepsilon-\\deltaε−δ 定义中，自变量的范围是被动的[22]，它不以任何物理或几何意义去“趋于”一个极限 aaa。然而这个词以及符号 →\\to→ 我们仍然保留，而且没有任何一个科学家需要或打算忽视这种表达所具有的启示性直观感受。但当我们要验证或判定一个极限时，我们仍需应用 ε−δ\\varepsilon-\\deltaε−δ 定义。至于这个定义是否很好的符合我们直观“动态”的趋近的观念，正如几何公理并不完美地提供了空间直观观念的描述[23]，它的表述丢掉了一些直观认为是真实的东西，却让这些概念有了更合适更逻辑化的数学结构。最后，我们再梳理一遍定义 1 的文字表述（省去前面有关函数定义域的要求）：对于任意小的正数 ε\\varepsilonε，我们总能找到一个正数 δ\\deltaδ，使得任何在 (a−δ,a)∪(a,a+δ)(a-\\delta ,a)\\cup (a,a+\\delta )(a−δ,a)∪(a,a+δ) 内的 xxx，都能让 f(x)f(x)f(x) 与某定值 α\\alphaα 之间的差可以小于之前给定的 ε\\varepsilonε。阐明了最关键的定义 1 ，我们再来看看其它几个概念中需要注意的地方。左极限与右极限实际上是极限的弱化，它们使求区间边界处的极限成为可能。但另一方面，在某点有左极限、右极限并不意味着一定有极限，只有该点左右极限相等时才有极限。另外一个重要概念的就是我们分析中的“无穷”。通常，分析中的“无穷”不是一个 实在的 概念[24]，而且往往要与其它成分结合起来使用。比如我们可以把极限的概念说成当自变量与 aaa 相差一个无穷小量时，因变量与 α\\alphaα 的差也是一个无穷小量。这里，我们要注意前后两个“无穷小量”的意义是 不同的 。当然，这种说法十分粗略，正如前面所说，牢记极限的标准概念才是研究科学应有的谨严态度（尽管如此，许多物理学家和工程师都喜欢用“无穷小量”、“微元”之类的表述）。类似的，所谓“无穷大”在不同的地方意义也不同。用于自变量时是“存在某个值，当 xxx 大于它，……”；用于因变量时是“对于任意某个给定值，（某条件下）， f(x)f(x)f(x) 都比它大”。同样，也有人把它简单地理解成“一个比任何其他数都要大的数”。显然，照这样理解，一个有限的数无论如何也加不到无限，这大概也是芝诺追龟问题的理由吧。[25]理清了极限的概念，在谈导数之前，我们先来讲一下“连续”。有了前面的极限的铺垫，连续也就很好定义了。先说 f(x)f(x)f(x) 在（不在边界的）某一点 aaa（附近）的连续性[26]：函数值 f(a)f(a)f(a) 存在；极限 lim⁡x→af(x)\\lim_{x\\to a}{f(x)}limx→a​f(x) 存在；f(a)=lim⁡x→af(x)f(a)=\\lim_{x\\to a}{f(x)}f(a)=limx→a​f(x)以上三点都成立的话，我们就称f(x)f(x)f(x)在aaa处连续。如果函数的定义域连通[27]且函数在定义域内的每一点连续，我们则称函数f(x)f(x)f(x)连续。了解了前面极限的几何意义，我们很容易看出，连续的定义也符合我们直观上对连续的认识。而如果我们从连续的角度看的话，极限在很多时候是把一些不连续的函数扩张成一个连续的函数，譬如之前例举的函数 f(x)=x3+xxf(x)=\\frac{x^{3}+x}{x}f(x)=xx3+x​ ，如果我们令一个新函数f‾(x)={f(x),if x≠01,if x=0\\overline{f}(x)= \\begin{cases} f(x),&amp; \\text{if}\\ x\\neq 0 \\\\ 1, &amp; \\text{if}\\ x=0 \\end{cases}f​(x)={f(x),1,​if x​=0if x=0​那么新函数在原来函数的定义域内与原来的函数完全是相同的。但与原来函数不同的是，它成了 R\\mathbb{R}R 上的一个连续函数。这个过程我们叫“保证函数连续性的延拓”[28]，它合理地将函数的范围扩大了，同时函数原有的部分也没有改变。只要我们承认函数的连续性，这样的延拓就是有意义的。最后，我们再来谈谈分析中最基础的，也是曾困扰了数学界许多年的导数（微分）。在抛弃了无穷小量的现在[29]，借助极限，我们很容易将导数的概念建立在一个严谨的逻辑基础上面。函数 f(x)f(x)f(x) 在某点 aaa 处的导数定义为[30]f′(a)=lim⁡Δx→0f(a+Δx)−f(a)Δxf&#x27;(a)=\\lim_{\\Delta x\\to 0}{\\frac{f(a+\\Delta x)-f(a)}{\\Delta x}}f′(a)=Δx→0lim​Δxf(a+Δx)−f(a)​至于所谓的瞬时速度不过是位移对时间的导数 v⃗=lim⁡Δt→0Δs→Δt\\vec v =\\lim_{\\Delta t\\to 0}{\\frac{\\overrightarrow{\\Delta s}}{\\Delta t}}v=limΔt→0​ΔtΔs​ ，由极限的定义我们知道瞬时速度绝不是单属于某一 时刻 的性质，而与这一时刻 前后 的状态息息相关。那么瞬时速度本身的涵义，则是 ttt 到 t+Δtt+\\Delta tt+Δt（或 t+Δtt+\\Delta tt+Δt 到 ttt 当 Δt&lt;0\\Delta t&lt;0Δt&lt;0 时）的平均速度 v(Δt)v(\\Delta t)v(Δt) 在 Δt=0\\Delta t=0Δt=0 处进行延拓的结果，而只要我们相信时空的连续性[31]，瞬时速度的内涵也无可置疑。有了瞬时速度，配合我们所谓的“无穷小分析”，大量的动力学问题也才有了解决的可能。在现代科学中，“无穷小分析”已经渗透到各个领域，几乎无所不在。本文主要介绍的不过是无穷小分析中基础中的基础——极限与导数，而关于它们的认识却困扰了数学界百余年。一切正如马克思所说：“在科学上没有平坦的大道，只有不畏劳苦沿着陡峭山路攀登的人，才有希望达到光辉的顶点！” 参考资料：[1]【美】莫里斯·克莱因. 古今数学思想.第1册. 张理京，张锦炎，江泽涵译. 上海：上海科学技术出版社. 2002[2]【美】莫里斯·克莱因. 古今数学思想.第2册. 朱学贤等译. 上海：上海科学技术出版社. 2002[3]【美】莫里斯·克莱因. 古今数学思想.第4册. 邓东皋等译. 上海：上海科学技术出版社. 2002[4] 韩雪涛. 从惊讶到思考：数学悖论奇景. 长沙：湖南科学技术出版社. 2007[5] 陈天权. 数学分析讲义·第一册. 北京：北京大学出版社. 2009[6]【美】R·柯朗，H·罗宾. 什么是数学：对思想和方法的基本研究. I·斯图尔特修订. 左平，张饴慈译. 上海：复旦大学出版社. 2011（部分图片来自网络）这些主要是给知识水平在高中以下的读者参考的：集合 ： 朴素地， 集合 就是一些东西的总体（这些东西中不应有重复（ 内涵 与 外延 都相同），比如： {1,1}\\{1,1\\}{1,1} 这种记法是错误的，但 {(1,0),1}\\{(1,0),1\\}{(1,0),1} 是合法的）。总体中的东西被称为这个集合的 元素 （如：“xxx 是集合 AAA 中的元素”，记作“x∈Ax\\in Ax∈A”）。若两个集合的每个元素都相同，则这两个集合 相等 。如果一个集合的全部元素都属于另一个集合，则该集合称之为这另一个集合的 子集 （如：集 AAA 是集 BBB 的子集，记作“A⊆BA\\subseteq BA⊆B”）。两个集合的 交集 ，即两个集合公共元素组成的集合（如：集 AAA 与集 BBB 的交集，记作“A∩BA\\cap BA∩B”）。两个集合的 并集 ，即这两个集合所有元素组成的集合（如：集 AAA 与集 BBB 的并集，记作“A∪BA\\cup BA∪B”）。元素都是数的集合叫 数集 ，本文中出现的集合都是数集。本文出现了的几个数集符号：自然数集 N\\mathbb{N}N、正整数集 N+\\mathbb{N}_{+}N+​、实数集 R\\mathbb{R}R。区间 ：集合的一种表现形式，都是实数集 R\\mathbb{R}R 的子集。(a,b)(a,b)(a,b) 表示满足 a&lt;x&lt;ba&lt; x&lt; ba&lt;x&lt;b 的所有 xxx 组成的集合；[a,b)[a,b)[a,b) 表示满足 a≤x&lt;ba≤ x&lt; ba≤x&lt;b的所有 xxx 组成的集合；(a,b](a,b](a,b] 表示满足 a&lt;x≤ba&lt; x≤ ba&lt;x≤b 的所有 xxx 组成的集合；[a,b][a,b][a,b] 表示满足 a≤x≤ba≤ x≤ ba≤x≤b 的所有 xxx 组成的集合。函数 ：在本文中是指两个 数集 之间的对应关系，它使得其中一个数集的任何一个元素在另一个数集中都有 唯一确定 的一个元素与之对应。比如一个集 AAA 到集 BBB 的函数 f:A→Bf:A\\to Bf:A→B 是使得任何 x∈Ax\\in Ax∈A，都存在 y∈By\\in By∈B，满足 y=f(x)y=f(x)y=f(x) 的对应关系，这里，我们称集 AAA 为 定义域 ，集 BBB 为 值域 ， xxx 为 自变量 ， yyy 为 因变量 。分析：与几何、代数等并列的数学主要分支之一。微积分是其基础。矢量：区别于标量（数量），它既有大小，又有方向，加减运算遵循平行四边形定则。 ↩︎芝诺原始的悖论讲的是阿喀琉斯追龟（阿喀琉斯是古希腊善跑的勇士），但问题的实质是一样的。另外，实际生活中的兔子要更快，乌龟要更慢。 ↩︎这个问题的数学解答：按芝诺的分法，记第 nnn 次兔子走过的路程为 ana_{n}an​ (m)，所花的时间为 tnt_{n}tn​ (s)，同时乌龟走过的路程为 bnb_{n}bn​ (m)，并记nnn次兔子走过的总距离 An=∑k=1nakA_{n}=\\sum_{k=1}^{n} a_{k}An​=∑k=1n​ak​ (m)，所花的总时间 Tn=∑k=1ntkT_{n}=\\sum_{k=1}^{n} t_{k}Tn​=∑k=1n​tk​ ，这段时间乌龟走过的总路程 Bn=∑k=1nbkB_{n}=\\sum_{k=1}^{n} b_{k}Bn​=∑k=1n​bk​ 。由题设， a1=92a_{1}=\\dfrac{9}{2}a1​=29​ ， tn=an10t_{n}=\\frac{a_{n}}{10}tn​=10an​​ ， bn=tnb_{n}=t_{n}bn​=tn​ ，即bn=an10b_{n}=\\frac{a_{n}}{10}bn​=10an​​并且， an+1=Bn−An+92a_{n+1}=\\frac{B_{n}-A_{n}+9}{2}an+1​=2Bn​−An​+9​又bn=an10b_{n}=\\frac{a_{n}}{10}bn​=10an​​ ，故Bn=An10B_{n}=\\frac{A_{n}}{10}Bn​=10An​​ ，因而， an+1=92−9An20a_{n+1}=\\frac{9}{2}-\\frac{9 A_{n}}{20}an+1​=29​−209An​​ ……①同理， an+2=92−9An+120a_{n+2}=\\frac{9}{2}-\\frac{9 A_{n+1}}{20}an+2​=29​−209An+1​​ ……②②-①，得 an+2=1120an+1,(n≥1)a_{n+2}=\\frac{11}{20}a_{n+1} ,(n\\ge 1)an+2​=2011​an+1​,(n≥1)又由①， a2=92−9a120=92⋅1120a_{2}=\\frac{9}{2}-\\frac{9 a_{1}}{20}=\\frac{9}{2}\\cdot\\frac{11}{20}a2​=29​−209a1​​=29​⋅2011​故an=92(1120)n−1a_{n}=\\frac{9}{2}(\\frac{11}{20})^{n-1}an​=29​(2011​)n−1 ， bn=920(1120)n−1b_{n}=\\frac{9}{20}(\\frac{11}{20})^{n-1}bn​=209​(2011​)n−1 ， tn=920(1120)n−1t_{n}=\\frac{9}{20}(\\frac{11}{20})^{n-1}tn​=209​(2011​)n−1则An=10(1−(1120)n)A_{n}=10(1-(\\frac{11}{20})^{n})An​=10(1−(2011​)n) ， Bn=1−(1120)nB_{n}=1-(\\frac{11}{20})^{n}Bn​=1−(2011​)n ， Tn=1−(1120)nT_{n}=1-(\\frac{11}{20})^{n}Tn​=1−(2011​)n龟兔间距离 dn=Bn−An+9=(1120)nd_{n}=B_{n}-A_{n}+9=(\\frac{11}{20})^{n}dn​=Bn​−An​+9=(2011​)n ，当n→∞n\\to \\inftyn→∞ ， dn→0d_{n}\\to 0dn​→0故追击时间 T=lim⁡n→∞Tn=1T=\\lim_{n\\to \\infty}{T_{n}}=1T=limn→∞​Tn​=1 ↩︎这种说法并不准确。事实上，目前的量子力学、量子宇宙学都并没有否认时空的连续性，只是认为小于一定尺度（普朗克长度/普朗克时间）内发生的物理过程 没有意义 。 ↩︎ ↩︎后文中我们会知道，无限在分析中并不是一个 实在 的量，定义上无限即 不可达到 ，这大概就是芝诺认为追及是不可能的的原因。（可参见[25:1]。） ↩︎事实上，这个问题更准确的认识应当是芝诺 人为划分 的 芝诺时 与我们实际中的 固有时 之间转化的差异。在这里，芝诺时的全部只对应于固有时的[0,1)[0,1)[0,1)（单位：秒）这个区间。因此，芝诺所说的“不可达到”，实际上是芝诺时的 划分意义 上的不可达到，因为他的时间“永远”也走不到1秒。 ↩︎ ↩︎ ↩︎ ↩︎这个问题实际上是芝诺的另一个经典悖论——“二分法悖论”。但两者的解决办法相同。 ↩︎直接这样处理并不严谨，因为在各种级数中，只有绝对收敛的级数才满足加法结合律。 ↩︎“没有剩下”即默认了乌龟能够抵达目的地，这可能是有违芝诺本意的。 ↩︎这个问题也可以套用[6:1]中的解决办法，即“超级计算机”的输出也是按芝诺时来度量的，电脑的输出规则实际是一个关于时间的函数，但它的定义域只在 [0,1)[0,1)[0,1) （单位：秒）这个区间内， t=1st=1st=1s 时的情况对它来说是 未定义的 。 ↩︎ ↩︎ ↩︎“反常识现象”是指超穷基数的大小比较。详情见下一篇《“潜无限”与“实无限”》。 ↩︎“无效”的原因如[6:2]与[10:1]中所述。 ↩︎巴门尼德的学说认为存在是永恒的，是一，连续不可分，可以被思想，以及感性世界的具体事物是非存在，是假象，等等。 ↩︎现在，物理学界更多认为有运动（尤其是周期运动）才有时间（或者时间的度量），完全静态的宇宙中不存在时间。 ↩︎“几乎完全”是因为瞬时速度为零时，如果加速度不为零，物体也不处于静止状态。 ↩︎严格来说，这是当时一些数学家的做法，牛顿的方法形式上更复杂，但并没有本质的差别。 ↩︎“瞬”是牛顿早期使用的不可分增量，而“流数”则是在处理连续变量时使用的。 ↩︎“初生量”的概念确实不清不楚，大概是自变量与因变量的增量 Δt\\Delta tΔt 以及 Δs\\Delta sΔs；而“消失量”是指它们两个正在“消失”时的量（牛顿的解释）。 ↩︎这个定义最早是由柯西与1820年左右提出的，但准确的数学符号表示还是由魏尔斯特拉斯给出的。 ↩︎任意地 给定误差，范围内总有点与 aaa 的距离小于该误差。 ↩︎从整体上看，如果 α\\alphaα 是极限的话，应当有一个适当的函数 g(x)g(x)g(x) 使得 δ\\deltaδ 最大不超过 g(ε)g(\\varepsilon)g(ε) 即可，就像例函数中的 δ=ε\\delta =\\sqrt{\\varepsilon}δ=ε​ 一样。从这个意义上讲， δ\\deltaδ 也算是“确定”的。 ↩︎极限概念的一个关键点是，我们是靠控制因变量的范围来控制自变量的。这和我们平时的认知可能有些不一样。而且，误差 ε\\varepsilonε 虽然是任意给定的，但给定多少是没有先后的，既不是从大到小，也不是从小到大，甚至没有任何顺序可言。给定 ε\\varepsilonε 的值这一步是非时间的，我们可以想象成有无数个并列的进程，所有进程的第一步都给定了一个正数，每个进程给出的正数各不相同，且所有进程给出的正数将每一个正数都覆盖到了，然后，它们各自再走向下一步。这一点与我们直观上的“趋于”确实相差很大。 ↩︎没有大小的点、没有宽度的线、无限延伸的直线……这些概念在现实中都是不存在的，是从现实事物中抽象出的理想元素，但对于我们研究现实确实起到了很大的作用。 ↩︎尽管如此，在勒贝格积分中我们引入了包含无穷大元素 ±∞{\\pm\\infty }±∞ 的扩张了的实数集 R‾\\overline{\\mathbb{R}}R，在非标准分析中我们引入了含有无穷小数和无穷大数的超实数系 R∗\\mathbb{R}*R∗，在集论中我们甚至有可以比较大小的“无限”——超穷基数。它们都是有明确数学意义的概念。 ↩︎ ↩︎事实上，极限也不能直接帮我们解决这个问题。虽然，无穷级数 ∑k=1∞12k=1\\sum_{k=1}^{\\infty}\\frac{1}{2^{k}}=1∑k=1∞​2k1​=1 。但根据极限的定义，这个级数的真正含义应当是 ∀ε&gt;0,∃N∈N+,∀n≥N,∣∑k=1n12k−1∣&lt;ε\\forall \\varepsilon&gt;0, \\exists N \\in \\mathbb{N}_{+}, \\forall n\\ge N, \\vert \\sum _{k=1}^{n} \\frac{1}{2^{k}} -1 \\vert &lt; \\varepsilon∀ε&gt;0,∃N∈N+​,∀n≥N,∣∑k=1n​2k1​−1∣&lt;ε ，并不允许“真正的”无限出现。这似乎让我们第一节中的解决办法难以在逻辑上站住脚。另一方面，这解释了[6:3]和[10:2]中的全部“芝诺时”只对应与我们固有时的[0,1)[0,1)[0,1) （单位：秒）的原因。 ↩︎ ↩︎在边界时，我们有左连续与右连续，分别对应于左极限与右极限的情况。 ↩︎这个条件简单的说就是函数的定义域应该可以表示成一个区间。连通性，比较形象的说法是集合中的任何两点可以用一条每一点都属于该集合的线连接起来（这实际上是道路连通，在这里没有太多差别）。 ↩︎事实上，这只是延拓的一种方法，只适用于有限个可去间断点的情况。更复杂的情况我们需要限制更多条件（可微、光滑之类的），而且延拓的结果可能不止一种。 ↩︎如[24:1]所述，于1960年左右发展起来的非标准分析用完美的逻辑使曾经不光彩“无穷小”重新焕发生机。唯一的缺陷是它所使用的数理逻辑方法太过艰深，以致难以普及。 ↩︎在现代分析中，导数（微分）不再是一个数，而是一个线性映射，是对原有函数的线性近似。 ↩︎见[4:1]。 ↩︎","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miroox.github.io/blog/categories/%E6%95%B0%E7%90%86%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miroox.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"},{"name":"微积分","slug":"微积分","permalink":"http://miroox.github.io/blog/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"},{"name":"科普","slug":"科普","permalink":"http://miroox.github.io/blog/tags/%E7%A7%91%E6%99%AE/"}]},{"title":"旧作：Idea","slug":"Idea","date":"2015-07-09T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2015/07/Idea/","link":"","permalink":"http://miroox.github.io/blog/2015/07/Idea/","excerpt":"(不怎么科幻的科幻小说，曾投稿至科幻星云网举办的第四届幻想类征文比赛)","text":"(不怎么科幻的科幻小说，曾投稿至科幻星云网举办的第四届幻想类征文比赛) Idea [1]大自然到底能否究诘呢？歌德一切都明亮起来。视野的中央有一道轮廓，比周围的色彩更暗淡一些。轮廓的最上部圆中带方，经由一段短轴似的结构与下面的主体——“躯干”——平滑相连。“躯干”又连接着上下共四个分支——“肢”。“上肢”在结点处自然弯曲，并在其末端散出更多细小的分支——“指”。分支是灵活的，只要他想。“肢”可以按他的意愿绕关节灵活转动。“指”可以按他的意愿弯曲扭动。活动视野却不能让“躯干”从中脱离。「自我」他如是认为。“有意思的开头。”埃尔温博士自语着，将页面收藏后，关闭了IdeaReader的视窗。“是时候干正事了。”埃尔温博士有晨读的习惯，劳逸结合的同时还常常能给他带来好的灵感。而现在正是准备博士论文的时候。事实上，论文的内容已经在他的心中酝酿许久了。虽然其中的创见早已被他人提到过，但没有一个人的模型像他这样完备自洽。“多美妙啊！”想着，埃尔温博士不由地兴奋起来，轻盈的手指在键盘上跃动颤抖。大部分的时间里，理论物理的研究非常枯燥无味。除了大量的运算和繁琐的检查，常常还不得不研读许多晦涩抽象的数学文献以寻找理论研究的突破口。高强度的工作让埃尔温博士早生华发，甚至有了些绝顶的趋势。天天在书房里研究的埃尔温长年不修边幅，脏兮兮的衣服，蓬乱的头发，胡子拉碴的脸上还有浓重的黑眼圈，怎么看都是一副屌丝(loser)的样子，以至于他的许多老同学讥讽地称他为“埃尔温大学士(Bachelor Erwin)”。[2]“好呀，你们这群以貌取人的家伙。”埃尔温醉醺醺地摆动着手指，摇头晃脑，绯红的面庞闪亮着油光，“看我下次聚会的时候把缇娜带来～”“哇哦！大伙听到了没，埃尔温说他下次要把他的充气玩偶带来呢！”“该不会是最近挺流行的那个什么‘虚拟偶像’吧？想想我们的‘埃尔温大学士(Bachelor Erwin)’整天对着掌机甜言蜜语……天哪！我要笑破肚皮了。哈哈哈……”“啊哈哈哈……”“……”“呵——欠～”“有些累了。”感觉屏幕上的字变得有些模糊，埃尔温博士推了推他的金丝眼镜，“或许我应该休息一下，转换一下心情。”保存好论文的草稿，埃尔温博士从收藏中打开今晨读的那段开头，微笑着，饶有兴趣地，继续读了下去。睁开眼。「我」依旧在视野中央。周围散布着一些奇异的团块，有些地方有棱角，有些地方又很圆滑，不时地，还会发生一些形变。它们在空中，时而飘移，时而碰撞，有时竟还会对穿而去。“无法解释的现象。”他认为。这时，一个较大的团块从右侧向他飞来。几乎本能地，他伸展弯曲的“上肢”将团块拨开，却突然发现几乎所有团块都变向右移去。“这些团块，虽然没有直接连接在一起，但有一种无形的联系将它们‘超距’地合为一个整体。”他思考着，左侧又有团块向他扑来。自然，他想用“上肢”将其推开。出人意料的是，他毫不费力地穿了过去，只不过叠合的地方色彩更深了一些。这使他能够区分「自己」与团块。“这个团块”他沉思了一会儿，“有着和我不一样的「成分」，因而我们彼此之间没有任何作用，呈现「孤立」状态……”……“孤立子！”从事多年物理研究的埃尔温博士立马想到了这个名词，眼里仿佛冒出了金光。“不过，‘他’就没有考虑过‘视野在身体之外’这个问题吗？如果从这个角度考虑的话……是‘平面国人奇遇记’？不，这应当是柏拉图古老的‘洞穴寓言’吧。”埃尔温博士漫无目的地发散着奇思异想，思绪如脱缰的野马自由奔腾。“这就是我们物理学的现状与终结吧。”如同靡菲斯特的低语，梦魇般的念头将埃尔温博士牢牢抓住。他摇摇头，仿佛要将这个念头逐出脑海，却又如水手结般越扯越紧。几乎无意识地，埃尔温博士在保存之前便关闭了IdeaReader的窗口。孤独的空气中弥漫起了焦躁的氛围。“也许。”埃尔温博士在扶椅上闭目静思了一会儿。“至少我希望这篇论文能够成为解答。”「众所周知，由于“宇宙监督假设”，几乎所有的奇点都被安全地隐藏与事件视界之内。正因如此，我们能够使用一些熟悉的物理定律来描述和预测我们所能观测到的世界，而免于裸奇点所带来的糟糕影响。」「然而，当我们试图追溯宇宙之初时，大爆炸奇点似乎是一个纯粹的裸奇点，它使我们的一切物理法则在大爆炸开始时失效。」「通常，裸奇点的出现意味着某一理论的局限性。因而，奇点的解析研究便成为了宇宙学中早期宇宙研究的活跃领域。」「注意到事件视界所带来的便利性，我们猜想：大爆炸奇点是否也会被一个事件视界所包裹？」「我们知道，三维空间中的黑洞其视界是二维的。但我们感知的这个宇宙有三个空间维度，因而遮蔽大爆炸奇点的事件视界应当也是三维的。」「借助DGP模型的方法，我们成功诱导出了宇宙的膜世界表达——宇宙像一个在五维（包含时间）史瓦西黑洞上的球形三维膜一样产生。」「遮蔽大爆炸奇点的三维事件视界，应该是四维宇宙中巨大恒星坍缩产生的。」「暗物质的星际锁链也许来源与四维星体。」「宇宙膨胀本质上其实是黑洞事件视界的扩大。」「坍缩前的四维恒星质量越大，其黑洞的三维视界就越平坦。我们宇宙的平坦性源于巨大的四维恒星。」「由于四维宇宙可能存在了无限久，空间已趋于光滑，因而三维宇宙也继承了这种光滑性。」「……」[3]“一个合理的理论模型——光滑性和平坦性、暗物质与暗能量……诸多难题都可以解释，剩下的就是更加精确的天文观测来检验了。”夜已深暝，埃尔温博士最后审读了一遍他的论文。“该睡觉了。”简单洗漱后，埃尔温博士来到床边，踌躇地望着床头那个名为IdeaReader的枕状仪器。​「“IdeaReader 睡眠版”产品使用说明书：（捕捉思想的每一点灵光…）产品概述：失眠者和聪明人的福音！本机是一款前卫实用的精神保健仪器，适用于床榻、扶椅等休憩之处。枕上它，您不仅会告别失眠的烦恼，还可以保留住梦中的灵光一闪，让您在工作中创新的源泉不竭。功能特点：【催眠脉冲】按个人特征滤调后的电磁脉冲，无害剂量，促进睡眠，告别失眠烦恼。【梦境捕捉】与脑波调谐，放大信号，活化潜意识里的创造力，读取梦中信息。【梦境重构】重现梦境，输出图像文本，把握睡梦中闪念的灵光。………… 」“不会的吧……不会的。”埃尔温博士坐在床边喃喃自语，“我很清醒认识到了本质……恶魔不会到来。”躺下，IdeaReader像感应到猎物的猫类一样亮起了侧灯的光。积累了一天的疲怠如潮水般很快将埃尔温的意识吞没，带他沉入梦乡。“视野在躯体之外，这意味着什么？”他明白了，宛如醍醐灌顶。“所见之「我」，不过是投射在壁面上的光影假象。实在之我，则应存在于更高层次的空间中。”一切简单明了。“异常之‘形变’不过是旋转导致的投影面变化；奇诡之‘对穿’本是不同层物体投影的邂逅；莫名的‘超距’作用实则‘我’被推行移动。‘成分’、‘孤子’……冗余的的解释变得毫无必要。新的视野下，不同的现象获得了简洁的统一。这是事物认知的新纪元！”突然，一个与众不同的物件从他眼前飘过。“抓住它。”他想着，“手”第一次在视野中展现出它真正的构造。抓住的一瞬间，如神谕般的信息向他的思想奔流。一把匕首。“生存游戏么？”他能感受到嘴角扬起的弧线。他摇荡双腿，如鱼儿般游动起来，在壁面上划出一道优美的弧。​“来了。”猎物就在眼前，毫无察觉地将要害暴露。光线昏暗，他将手中的利刃向前刺去。​匕首从背部穿入对方的身体，刺向心脏的位置。这是他的胜利。“嗯？”被刺中的对手没有任何反应，只看见对方的匕首插在了空中。“痛！”可他的胸口却传来剧痛。浑身失力，视野模糊。感到天旋地转的他看见了对方的恶魔之影——那匕首插入了“空”，可它的“影”却穿入一团心形的暗影之中。如将灭之烛光，他的思维前所未有的活跃起来，无数的猜想像走马灯般闪过，似蛛网般交织缠结，企图寻找一个答案。“全息……”他如蒙神启。​​参考资料：【1】理想国/（古希腊）柏拉图著；郭斌和，张竹明译.—北京：商务印书馆，1986.8【2】超越时空：通过平行宇宙、时间卷曲和第十维度的科学之旅/（美）加来道雄（Kaku，M.）著；刘玉玺，曹志良译.—上海：上海科技教育出版社，2009.6【3】越弱越暗越美丽/李淼著.—南京：江苏文艺出版社，2013.4【4】Out of the White Hole: A Holographic Origin for the Big Bang. Razieh Pourhasan, Niayesh Afshordi and Robert B. Mann in Journal of Cosmology and Astroparticle Physics, Vol. 2014, Article No. JCAP04(2014)005;April 2014.注释：[1]: “idea”一词有“主意”、“想法”、“表象”、“信念”等译意。[2]: “bachelor”有“学士”的意思，也有“单身汉”之意。[3]: 关于论文的那一段：真正的论文大概不会这么写，其中部分内容参考了 参考资料【4】的摘要。","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miroox.github.io/blog/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"科幻","slug":"科幻","permalink":"http://miroox.github.io/blog/tags/%E7%A7%91%E5%B9%BB/"}]},{"title":"旧作：关于函数列 x,x²+x,x³+3x²+x,x⁴+6x³+7x²+x,……","slug":"BellPolynomial","date":"2015-06-27T09:33:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2015/06/BellPolynomial/","link":"","permalink":"http://miroox.github.io/blog/2015/06/BellPolynomial/","excerpt":"x,x2+x,x3+3x2+x,x4+6x3+7x2+x,…x,x^2+x,x^3+3x^2+x,x^4+6x^3+7x^2+x,\\dotsx,x2+x,x3+3x2+x,x4+6x3+7x2+x,…这是对前一篇文章的一个补充和推广。","text":"x,x2+x,x3+3x2+x,x4+6x3+7x2+x,…x,x^2+x,x^3+3x^2+x,x^4+6x^3+7x^2+x,\\dotsx,x2+x,x3+3x2+x,x4+6x3+7x2+x,…这是对前一篇文章的一个补充和推广。显然，令其中的 x=1x=1x=1 ,函数列就成为数列 1,2,5,15,…1,2,5,15,\\dots1,2,5,15,…。事实上，这一函数列来自原数列问题的推广fn(x)=∑k=0+∞knk!xkf_n(x)=\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!}x^kfn​(x)=k=0∑+∞​k!kn​xk而前几项f1(x)=xexf2(x)=(x+x2)exf3(x)=(x3+3x2+x)exf4(x)=(x4+6x3+7x2+x)ex\\begin{aligned} f_1(x)&amp;=x\\mathrm{e}^x\\\\ f_2(x)&amp;=(x+x^2)\\mathrm{e}^x\\\\ f_3(x)&amp;=(x^3+3x^2+x)\\mathrm{e}^x\\\\ f_4(x)&amp;=(x^4+6x^3+7x^2+x)\\mathrm{e}^x\\\\ \\end{aligned}f1​(x)f2​(x)f3​(x)f4​(x)​=xex=(x+x2)ex=(x3+3x2+x)ex=(x4+6x3+7x2+x)ex​显然，原数列只是其特例an=∑k=0+∞knk!=fn(1)a_n=\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!}=f_n(1)an​=k=0∑+∞​k!kn​=fn​(1)受此影响，我开始采用的是与之前一样的做法：f1(x)=∑k=0+∞kk!xk=x∑k=1+∞1(k−1)!xk−1=xexfn(x)=∑k=0+∞knk!xk=∑k=1+∞kn−1(k−1)!xk=∑k=1+∞(k−1)n−1(k−1)!xk+∑j=1n−1[(−1)j+1Cn−1j∑k=1+∞kn−j−1(k−1)!xk]=x∑k=1+∞kn−1k!xk+∑j=1n−1[(−1)j+1Cn−1j∑k=1+∞kn−jk!xk]=xfn−1(x)+∑j=1n−1[(−1)j+1Cn−1jfn−j(x)]\\begin{aligned} f_1(x)&amp;=\\sum_{k=0}^{+\\infty}\\frac{k}{k!}x^k=x\\sum_{k=1}^{+\\infty}\\frac{1}{(k-1)!}x^{k-1}=x\\mathrm{e}^x\\\\ f_n(x)&amp;=\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!}x^k\\\\ &amp;=\\sum_{k=1}^{+\\infty}\\frac{k^{n-1}}{(k-1)!}x^k\\\\ &amp;=\\sum_{k=1}^{+\\infty}\\frac{(k-1)^{n-1}}{(k-1)!}x^k+\\sum_{j=1}^{n-1}\\left[(-1)^{j+1}C_{n-1}^j\\sum_{k=1}^{+\\infty}\\frac{k^{n-j-1}}{(k-1)!}x^k \\right]\\\\ &amp;=x\\sum_{k=1}^{+\\infty}\\frac{k^{n-1}}{k!}x^k+\\sum_{j=1}^{n-1}\\left[(-1)^{j+1}C_{n-1}^j\\sum_{k=1}^{+\\infty}\\frac{k^{n-j}}{k!}x^k \\right]\\\\ &amp;=xf_{n-1}(x)+\\sum_{j=1}^{n-1}\\left[(-1)^{j+1}C_{n-1}^jf_{n-j}(x) \\right] \\end{aligned}f1​(x)fn​(x)​=k=0∑+∞​k!k​xk=xk=1∑+∞​(k−1)!1​xk−1=xex=k=0∑+∞​k!kn​xk=k=1∑+∞​(k−1)!kn−1​xk=k=1∑+∞​(k−1)!(k−1)n−1​xk+j=1∑n−1​[(−1)j+1Cn−1j​k=1∑+∞​(k−1)!kn−j−1​xk]=xk=1∑+∞​k!kn−1​xk+j=1∑n−1​[(−1)j+1Cn−1j​k=1∑+∞​k!kn−j​xk]=xfn−1​(x)+j=1∑n−1​[(−1)j+1Cn−1j​fn−j​(x)]​这样，我们原则上可以获得这一函数列的任意项（虽然很难算）。然而，很快我就发现了另一种简便许多的办法：fn+1(x)=∑k=0+∞kn+1k!xk=x∑k=0+∞kn+1k!xk−1=xddx(∑k=0+∞knk!xk)=xfn′(x)f_{n+1}(x)=\\sum_{k=0}^{+\\infty}\\frac{k^{n+1}}{k!}x^k=x\\sum_{k=0}^{+\\infty}\\frac{k^{n+1}}{k!}x^{k-1}=x\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!}x^k\\right)=xf&#x27;_n(x)fn+1​(x)=k=0∑+∞​k!kn+1​xk=xk=0∑+∞​k!kn+1​xk−1=xdxd​(k=0∑+∞​k!kn​xk)=xfn′​(x)这一递推式同样能得到这一函数列的任意项，而且计算上要简便许多。而在此基础上，，我们求原数列 an=fn(1)a_n=f_n(1)an​=fn​(1) 也比原来简便。这无疑是所谓“创造者悖论”（越宏大的计划,越有机会获得成功,多个问题也许要比一个问题容易回答,较全面的定理可能更容易证明,较普遍的题目可能更容易解答。）的一个例证。也正印证了华罗庚教授的一句话：“解题时先足够地退，退到我们最容易看清楚问题的地方，认透了，钻深了，然后再上去。”附：{fn(x)ex}\\{\\frac{f_n(x)}{\\mathrm{e}^x}\\}{exfn​(x)​} 的前几项：xx2+xx3+3x2+xx4+6x3+7x2+xx5+10x4+25x3+15x2+xx6+15x5+65x4+90x3+31x2+xx7+21x6+140x5+350x4+301x3+63x2+xx8+28x7+266x6+1050x5+1701x4+966x3+127x2+x⋮\\begin{gathered} x \\\\ x^2+x \\\\ x^3+3x^2+x \\\\ x^4+6x^3+7x^2+x \\\\ x^5+10 x^4+25 x^3+15 x^2+x \\\\ x^6+15 x^5+65 x^4+90 x^3+31 x^2+x \\\\ x^7+21 x^6+140 x^5+350 x^4+301 x^3+63 x^2+x \\\\ x^8+28 x^7+266 x^6+1050 x^5+1701 x^4+966 x^3+127 x^2+x\\\\ \\vdots \\end{gathered}xx2+xx3+3x2+xx4+6x3+7x2+xx5+10x4+25x3+15x2+xx6+15x5+65x4+90x3+31x2+xx7+21x6+140x5+350x4+301x3+63x2+xx8+28x7+266x6+1050x5+1701x4+966x3+127x2+x⋮​2020年1月18日补记：在前一篇的补记中提到，用Mathematica发现了名为BellB的函数。实际上，这个函数的完全体是 Bell 多项式，即这篇文章前面阐述的这个多项式序列。它是函数 h(t)=exp⁡[(exp⁡(t)−1)x]h(t)=\\exp[(\\exp(t)-1)x ]h(t)=exp[(exp(t)−1)x] 的生成函数。甚至这个多项式的系数序列也有专门的名称，叫第二类Stirling数。这组数跟组合理论有深刻的联系。另参见：Bell Polynomial - Wolfram MathWorldBell polynomial - Encyclopedia of MathematicsOEIS A106800","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miroox.github.io/blog/categories/%E6%95%B0%E7%90%86%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miroox.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数列","slug":"数列","permalink":"http://miroox.github.io/blog/tags/%E6%95%B0%E5%88%97/"}]},{"title":"旧作：关于数列 1,2,5,15,……","slug":"BellNumber","date":"2015-06-10T02:52:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2015/06/BellNumber/","link":"","permalink":"http://miroox.github.io/blog/2015/06/BellNumber/","excerpt":"考虑序列an=∑k=0+∞knk!a_n=\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!}an​=k=0∑+∞​k!kn​","text":"考虑序列an=∑k=0+∞knk!a_n=\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!}an​=k=0∑+∞​k!kn​我用计算器随便试了下发现a1/e=1a2/e=2a3/e=5a4/e=15 ⋮\\begin{aligned} a_1/\\mathrm{e}&amp;=1\\\\ a_2/\\mathrm{e}&amp;=2\\\\ a_3/\\mathrm{e}&amp;=5\\\\ a_4/\\mathrm{e}&amp;=15\\\\ &amp;\\ \\ \\vdots \\end{aligned}a1​/ea2​/ea3​/ea4​/e​=1=2=5=15 ⋮​它们竟都是 e\\mathrm{e}e 的整数倍，这种规律性显然不平凡。于是我便开始思索其中的计算方法。这当中， a1a_1a1​ 的计算给予了我关键的启发：a1=∑k=0+∞kk!=∑k=1+∞1(k−1)!=ea_1=\\sum_{k=0}^{+\\infty}\\frac{k}{k!}=\\sum_{k=1}^{+\\infty}\\frac{1}{(k-1)!}=\\mathrm{e}a1​=k=0∑+∞​k!k​=k=1∑+∞​(k−1)!1​=e依循这个思路，就会有an=∑k=0+∞knk!=∑k=1+∞kn−1(k−1)!=∑k=1+∞(k−1)n−1(k−1)!+∑k=1+∞Cn−11kn−2(k−1)!−∑k=1+∞Cn−12kn−3(k−1)!+⋯+(−1)n∑k=1+∞Cn−1n−11(k−1)!=∑k=1+∞(k−1)n−1(k−1)!+∑j=1n−1[(−1)j+1Cn−1j∑k=1+∞kn−j−1(k−1)!]=an−1+∑j=1n−1[(−1)j+1Cn−1jan−j]\\begin{aligned} a_n&amp;=\\sum_{k=0}^{+\\infty}\\frac{k^n}{k!}\\\\ &amp;=\\sum_{k=1}^{+\\infty}\\frac{k^{n-1}}{(k-1)!}\\\\ &amp;=\\sum_{k=1}^{+\\infty}\\frac{(k-1)^{n-1}}{(k-1)!}+\\sum_{k=1}^{+\\infty}C_{n-1}^1\\frac{k^{n-2}}{(k-1)!}-\\sum_{k=1}^{+\\infty}C_{n-1}^2\\frac{k^{n-3}}{(k-1)!}+\\cdots+(-1)^n\\sum_{k=1}^{+\\infty}C_{n-1}^{n-1}\\frac{1}{(k-1)!}\\\\ &amp;=\\sum_{k=1}^{+\\infty}\\frac{(k-1)^{n-1}}{(k-1)!}+\\sum_{j=1}^{n-1}\\left[(-1)^{j+1}C_{n-1}^j\\sum_{k=1}^{+\\infty}\\frac{k^{n-j-1}}{(k-1)!} \\right]\\\\ &amp;=a_{n-1}+\\sum_{j=1}^{n-1}\\left[(-1)^{j+1}C_{n-1}^ja_{n-j} \\right] \\end{aligned}an​​=k=0∑+∞​k!kn​=k=1∑+∞​(k−1)!kn−1​=k=1∑+∞​(k−1)!(k−1)n−1​+k=1∑+∞​Cn−11​(k−1)!kn−2​−k=1∑+∞​Cn−12​(k−1)!kn−3​+⋯+(−1)nk=1∑+∞​Cn−1n−1​(k−1)!1​=k=1∑+∞​(k−1)!(k−1)n−1​+j=1∑n−1​[(−1)j+1Cn−1j​k=1∑+∞​(k−1)!kn−j−1​]=an−1​+j=1∑n−1​[(−1)j+1Cn−1j​an−j​]​根据这个地推公式，我们可以算出任意 nnn 对应 ana_nan​ 的值。显然，所有 ana_nan​ 都会是 a1a_1a1​ 也就是 e\\mathrm{e}e 的整数倍。2020年1月18日补记：拿Mathematica的找规律函数FindSequenceFunction随便尝试了一下，居然发现了一个这样的内置函数BellB12FindSequenceFunction[&#123;1, 2, 5, 15&#125;](*Out[ ]=BellB*)在BellB的文档里也能看到完全一样的结果：看来当初的奇妙发现也不过是发掘一些别人玩剩下的。尽管按照Mathematica文档里的背景描述，其出发点不完全相同，可见下一篇的补记。","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miroox.github.io/blog/categories/%E6%95%B0%E7%90%86%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miroox.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数列","slug":"数列","permalink":"http://miroox.github.io/blog/tags/%E6%95%B0%E5%88%97/"}]},{"title":"旧作：有钱任性？没钱率性？","slug":"YouQianRenXingMeiQianShuaiXing","date":"2015-05-31T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2015/05/YouQianRenXingMeiQianShuaiXing/","link":"","permalink":"http://miroox.github.io/blog/2015/05/YouQianRenXingMeiQianShuaiXing/","excerpt":"","text":"【率性】②形：由着性子，任性。《现代汉语词典》 Α.有钱就是任性经济基础决定上层建筑。马克思“七万了。”他想。“这应该是伙骗子。”他自语，“找了这么多理由，弄了这么多附加产品，诓了我这么多钱，想来是骗子没跑了。只是……”“哔！有您的新信息。”他打开手机，瞄了一眼短信内容。“……只有这一点钱，警察不见得会管。不如干脆把事弄大一点，顺带试试他们的口才。”想着，他随手从桌边拣起一张金色的银行卡，向门外走去。 α.没钱也要率性世界是我的表象；世界是我的意志。叔本华他是一位思想者，一名艺术家。他的房间里只有一张木桌和一个书架。崭新的书本在破旧的书架里显得格格不入。这些书花去了他几乎全部的积蓄但他十分满意。不同于网上那些注水文学，他一天只写六百字，其余时间用来读书，感受生活，释放思想。他要以他毕生的精力来完成这部巨著，就在这个房间里。而他的思维已经延伸到了时空尽头。“即使被关在果壳之中，我仍自以为是无限宇宙之王。”他如是自诩。他放下笔。窗户的破口外，一抽翠嫩的新芽蕴生着几点绿意。 Β.有钱就是任性在现代社会中，资本是独立的并有其性格， 而一个活着的人是非独立的且没有性格的。马克思很奇怪。要说为什么。这次对方竟要求用寄支票的方式来付款，简直是匪夷所思。要不是十万的诱惑力，他本是打算放弃这桩生意的。“该不会……”他想。“报告老大！没有发现条子。”“是吗？那就好，东西呢？”“在这里。”“好，很好。”他接过包裹，扯出被裹得小心翼翼的支票。“好！十万！”他拿着支票，翻来覆去的看，在金额上反复摩挲。突然，他的手停下了，眼角有些濡湿。“老大，您……”支票的背面，赫然写着四个字：回·头·是·岸 β.没钱也要率性人虽然能够做他想要做的，但不能要他所想要的。叔本华“还剩多少米？”父亲问。“一两半。恐怕难熬过今天。”母亲叹了口气，望着里面紧闭的房门，“这孩子……”“不行，我得找他谈谈。”“算了吧！谈又有什么用，他那么犟，可别把你气坏了。”“……”一阵寒风扫过，屋子也不由得打了个冷战。窗户映照着皑皑的冰雪世界，不知能否再见明年的春天。","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miroox.github.io/blog/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"作文","slug":"作文","permalink":"http://miroox.github.io/blog/tags/%E4%BD%9C%E6%96%87/"}]},{"title":"旧作：筑基工，筑梦人","slug":"ZhuJiGongZhuMengRen","date":"2015-04-30T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2015/04/ZhuJiGongZhuMengRen/","link":"","permalink":"http://miroox.github.io/blog/2015/04/ZhuJiGongZhuMengRen/","excerpt":"","text":"“我仰望星空，感到一阵惊恐/如果地球失去引力，我就会变成流星，无依无附在天宇飘行/哦，不能/为了拒绝这种‘自由’，我愿变成一段树根，深深地扎进地层。”阖上书，指尖在粗糙的纸面上轻轻滑过。橘黄的灯光映照出封页上的书名——《忧天——顾城诗选集》[1]。他提上桶走出屋门，书本被搁在了床边。外面的天空一片黑暗，依稀有几点闪烁的星光。但工地上的灯火常亮。他左转右拐，一路上不时碰到一些工友，也打个招呼，唠嗑一阵。许久，终于来到工地外沿的一排水龙头前。打上一桶半浊不清的水，再返回工舍。回工舍，小小的板房里住着七八个人。大家都很累了，便没什么人聊天，只想干完活早点睡觉。他呢？他把桶里的水倒一些在盆里，将脚缓缓伸下。淤泥在水中扩散开来，沁凉的水温令他清醒不少。他顺手从桌上抽来一份报纸，消磨洗脚间的无聊时光“……上世纪80年代后，广东、浙江、山东等沿海地区城市化建设提速，一批“快餐式”楼房密集建成。按照我国《民用建筑设计通则》的规定，一般性建筑的耐久年限为50年到100年。然而，现实生活中，很多建筑的实际寿命与设计通则的要求有相当大的距离。如今，许多楼房的建设年龄已经陆续达到20年、30年。由于先天不足，后天装修过频、维护不够等原因，良莠不齐的建筑进入‘质量报复周期’……”[2]周围渐渐暗了下来，报纸上的小字在昏黄的灯光下显得格外模糊。他揉揉眼，轻轻阖上报纸，拿起自己的日记本，打开。他在床头写下：“X年X月晴 今天没有那么累了，打地基的工作已经基本完成。这是一幢大楼的基础，也是重中之重。地基不深、基础不牢，就容易形成‘豆腐渣’。我们这次把地基打到了三十米下，这样高楼大厦也会牢靠些……”“呵——”有些倦了。他停下笔，周围的一些工友已经起了鼾声。他拉上灯，躺在榻上，一天的疲惫很快将他的意识吞没，带他沉入梦乡：“我看见，我看见一座擎天的大厦，矗立在神州大地上。它是那么得高大，我看不见它的顶峰。可它脚下踩着我们筑建的基石；我看到，我看到神州大地上亿万的人民化作无数的光点。汇聚着，凝聚成了巡天的巨龙，盘绕在那大厦之颠……天边升起无尽的光芒，我知道，这是梦的颜色。”夜已深暝，天空中的星辰却愈发璀璨。注：[1]: 并没有这本书。[2]: 文段节选自《1个月5起房屋垮塌 楼盘“质量报复期”来了该咋办？》","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miroox.github.io/blog/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"作文","slug":"作文","permalink":"http://miroox.github.io/blog/tags/%E4%BD%9C%E6%96%87/"}]},{"title":"旧作：污点","slug":"Stain","date":"2015-03-31T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2015/03/Stain/","link":"","permalink":"http://miroox.github.io/blog/2015/03/Stain/","excerpt":"","text":"一张白纸。一张白纸摊开在面前“写些什么呢？”他不知道。手中的笔悬在半空中，他自言自语：“一开始，那个纯洁的婴儿呱呱坠地，所有亲友都说：‘多么纯净的孩子啊，就像一张白纸。’‘清澈的眸子里透着对善的渴望。’亲友中的一位诗人如是说。于是这个刚刚降生的小生命被赋予了‘元善’的名字。‘‘人之初，性本善’嘛’人们纷纷应和。”“小家伙很懂事，不到一岁就学会了喊‘妈妈’。之后，在父母的悉心教导下，小家伙成长为了一个知书达礼，乐于助人，惹人怜爱的好孩子。”“孩子上了中学，成绩优秀，也常帮助那些成绩不好的同学，因而很受爱戴。然而有一天……”“啪！”一记响亮的耳光，全班人的目光都集中过来。他的脸火辣辣的。他不解地望向对方，对方却回以一个轻蔑的眼神。“为什么？为什么不听我的话？我是在帮他啊！”他不明白，一股无名火却已燃上心头。“呸！没骨头的家伙。”他理智的弦终于绷断。顺手拿起窗沿上的一个花盆，向前重重砸去……“嗒。”一滴墨水滴在纸上。他有些慌乱，急急忙忙想用胶布粘去，却让墨迹扩散开来。费了九牛二虎之力，总算去除了墨迹，却发现纸张已经被他撕破了。“换一张好了。”可他没有动，他根本无纸可换。无奈，将手托在腮上，继续他的回想。“……孩子受到了处分。但在父母的恳求下，校方还是将其撤消了。如父母所愿，孩子一路顺风地毕业、升学、直至工作……”“一次工作聚餐，已经不再是孩子的他喝了酒。酩酊的他在听到一句玩笑话后想起童年不快的回忆，竟大打出手，击翻的火锅还让一名严重烧伤。”“嗒。”墨水滴下，他的手微微颤抖。“监狱的日子可不好过，因此他努力改造，成功削减了一大半的刑期，可是……”“您的简历不合格。”“对不起，本司不录用有前科的人”“……”无数次的应聘失意后，他开始混迹于酒吧、赌场、各种传销场所。几经淘洗下他已是负债累累，连老父亲也被他气得一病不起……他有些哽咽，泪水将眼角濡湿，沿着他的脸颊滑落。纸面早已被浸染成了墨色，只有上方“被告人证词”的字样依旧鲜红。","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miroox.github.io/blog/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"作文","slug":"作文","permalink":"http://miroox.github.io/blog/tags/%E4%BD%9C%E6%96%87/"}]},{"title":"旧作：微","slug":"Wei","date":"2015-02-28T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2015/02/Wei/","link":"","permalink":"http://miroox.github.io/blog/2015/02/Wei/","excerpt":"","text":"“……微分方程通常的解法是将……”台上的导师慷慨激昂地讲述晦涩难懂的知识，台下的他却是早已听得厌烦。上课未值十分钟，百无聊赖的他便拿起手机在抽屉里刷微博。“既然在上微积分的课，不如扯一些有关的段子吧。”想着，他的指尖在屏幕上飞速的敲击：“小明买东西攒积分，求原函数。”“是不是太冷了？”想着刚才的微博，他有些不满意。眼睛漫无目的地在“信息碎片”的海洋中飘荡。突然，一段微博抓住了他的视线——“高数毫无意义，未必买菜还要微积分？”“嘛～虽然也是很老的说法了……”他自语着，正准备给这句话点个赞。蓦地，他的手又停在了空中，转念一想：“我这样做岂不跟那些‘跟风狗’别无二致。不行，不行，我要独辟蹊径。”他左手端着手机，右手托住下巴，咬牙苦思起来。微茫、遐远的的声音传来，在我静若止水的精神世界里激起了一道涟漪。“唔……”我的躯骸稍稍起了一点反应。“起床了！起床了……”会是谁在唤醒我，让我自黑暗的沉眠中觉醒？是我那清丽可爱的青梅竹马？抑或是我那妖娆动人的女仆人？意识从水面下浮起。否定！Both are not。我既没有清丽可爱的青梅竹马，也并无妖娆动人的女仆人。有的只是和我一样五大三粗的室友将我从睡梦中唤起。但那残念，却向识海的深渊坠下。揉着惺忪的睡眼，在这个不足二十平米的狭小空间里，我迅速掏出手机，一边漱口，一边浏览要问国事。“这些事可以与我无关，但我决不能不管。我要表达我自己的观点。”可是，表达观点是需要时间的。对于一刻也不能停的我而言，我不得不一边行走着享用“营养丰富”的面包，一边低头飞速的用掌中的“利器”进行吐槽。就这样，在幸运地避开了所有的障碍物后，我缓缓步入了教室。微言大义，不是你一向奉行的“微时代”的基本准则吗？可笑！高数无用论又重出江湖。可叹！“百年前躺着吸鸦片；百年后卧着玩手机”却不能使你警醒。试问：你为何自甘堕落于尘俗碎片之间？你不答，却在微信中写下：“微斯人，吾谁与归？”夜色渐暗魆黑的卧室里，灯影忽微……","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miroox.github.io/blog/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"作文","slug":"作文","permalink":"http://miroox.github.io/blog/tags/%E4%BD%9C%E6%96%87/"}]},{"title":"旧作：师表","slug":"ShiBiao","date":"2015-02-21T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2015/02/ShiBiao/","link":"","permalink":"http://miroox.github.io/blog/2015/02/ShiBiao/","excerpt":"","text":"“师者，所以传道授业解惑也。”——《师说》 一“呼哧、呼哧、呼哧……”嘴里叼着包子的少年，正卖力地在操场上奔跑。“来不及了！来不及了！要迟到了！”少年边跑边想。的确，他已经来不及了。他转上走廊，看见老师在远处冷冷地望着他。“你又迟到了！”老师嫌恶地看着他。“老师，我……”他刚想说话，可立马就被老师打断:“迟到可没什么理由，你拖沓的生活习惯必定会影响你的学习效率……”老师在门口滔滔不绝地讲着，教室里读书的同学也不时望向他。他只是低着头，一言不发。 二“嗯……这个字是……就没有什么人查字典吗？以后人手要有一本字典！”老师在讲台上大声喝叱。“……”台下一片沉默。“叮铃铃——”下课铃响起。“好！今天就到这里。下课！”说罢，老师飞快地走出教室。“老师！老师！等一下！我问个问题！”他冲出教室及时拦下了老师。“嗯……这种题目，我也不可能马上答出来，先让我看一下。”两人沉默无语，都盯着那道题目。“……”“叮铃铃——”上课铃响起。老师突然一转头，说道:“你先去上课，这题我再看一下。”老师顿了顿，“不要再迟到了。”说罢，便转身走向办公室。他望着老师离开的方向，怅然若失。 三又拖堂了。他望着在讲台上涛涛不绝的老师，在心里叹息。“所以说……喂！你们说我刚才讲了哪几点问题？”老师看台下的同学们似乎都在各行其事，忍不住发了问。“……”沉默，台下一片沉默。“都给我停下手中的笔！”老师似乎生气了，用方言接道，“哪个晓得我刚才讲了么咂东西啊？”“……”沉默，依旧沉默。只有陆陆续续把笔放下的声音。沉默呵！沉默呵！不在沉默中爆发，就在沉默中灭亡。突然，另外一位老师站在门外冲着老师招手。正要爆发的老师脸色骤变，微笑地向门外走去。教室里的同学不约而门同地松了一口气，而后又纷纷拿起笔做起作业来。但他没有动，只是望着窗外，心里玩味着那句“拖沓的生活习惯只会影响你的学习效率。”须臾，老师从教室外回来，看见同学们都在埋头苦干，心中感到十分欣慰。老师拿起记事本，忽然一愣:“我刚才讲到哪儿了？”“………”","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miroox.github.io/blog/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"作文","slug":"作文","permalink":"http://miroox.github.io/blog/tags/%E4%BD%9C%E6%96%87/"}]},{"title":"旧作：盆景","slug":"Miniascape","date":"2014-12-31T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2014/12/Miniascape/","link":"","permalink":"http://miroox.github.io/blog/2014/12/Miniascape/","excerpt":"","text":"智者·Philosopher“……夫万物皆生于有，有生于无。无中混沌出，为荒、墟之所引。墟行大化之分明，荒会万物之盍一……”“够了。”皇帝举起一只手，示意朗读的文官停下：“智者，你可知罪。”“臣不知。”智者跪伏在殿阶下，沉重的镣锁令他抬不起头来。“是吗？原来这普天之下还有我们智者也不知道的事啊！”“臣知陛下以为臣之所言皆为虚妄。然臣之所言所记，字字皆实，故是无罪矣。”“噢？是吗？你说大地是圆的。可实际上，大地是方的。”“不！大地不可能是方的！它有曲率，它是个椭球形！”智者突然激动地喊了起来。“不不不”皇帝摇摇头，“我们的舰队早已抵达了海角。那里有着黑色的边界，没有人能够继续前进。”“不，陛下，请容我再称您一次陛下。”智者艰难地将头抬起，直视着皇帝的眼睛，“这个消息是真的吗？毕竟您从未亲自到过那里，又怎么确认那里真的存在一条不可逾越的边界呢？”“因为那是事实。”皇帝顿了顿，“正如我能看遍这世界上每一个角落一样。”“可……”智者正想在说点什么，一旁的监官拉紧了他颈上的锁拷。“好了，我已经厌烦了。”皇帝摆了摆手，“送他去第十八层。”“遵旨。”一旁的监官应道。“不！”智者嘶吼着，如一头伤痕累累的困兽：“你这个否认真理，泯灭人性的独裁者！你有什么资格统治万民！”看着被托向远处仍在骂骂咧咧的智者，皇帝轻声叹道：“因为……命运啊！”“这是……什么啊！”智者面朝大殿方向，在监官的拖行下远离。他不再嘶吼咆哮，却发出梦呓般的呢喃：“果真……是命运……吗？”“……绝圣弃智，民利百倍；绝仁弃义，民复孝慈……”朝堂上的仕官如是说。“……小国寡民，使有什伯之器而不用……”塾舍里的学士如是说。“……大道废，有仁义；智慧出，有大伪……”市坊间的百姓亦如是说。……今天的 Utopia 依旧和平安定。只有十八层的地下时不时传来阵阵哀嚎。 匠者·Craftsman匠者抬头，昏黄的天空仿佛要挟着晚霞覆压下来，令他的胸口气闷不已。于是他低头，继续工作，却从石砖间的缝隙中瞥见了 Euphratee 和 Tigeris。那古老文明的摇篮，在他眼中，也不及蚯蚓般大小。这里是 Babel——那些愚昧的北欧人总以为这是所谓的 Askr Yggdrasils 的枝干——因为大地是平的，所以北欧人大抵也看得到这里，尽管视觉上就像一条线一样。匠者孤零零地站在这座他家世代相承的伟大工程上。极目远眺，甚至能看见西边那片黑色的边界。匠者已经在塔上待了大半辈子了，平日里食物与工具材料都是用滑轮运送。那些信奉 Messiah 的教徒们坚持认为天空之上有 Paradise 的存在。只要建筑足够高的石塔，他们便可以启程前往天国。但匠者并没有那样的想法，他只是继承家中的旧业。相反，随着他离天空愈发接近，心中却愈加郁闷，总怀着一种不好的预感。以凡俗之力接近神的国度，这行为本身就是莫大的亵渎。这也是教会的人不愿亲自接手的原因之一。但匠者不在乎，他只是继承家中的旧业。“Gott ist tot！”匠者想起了 Nietzsche 的名言。“这可是禁语呢！”匠者告诫自己，“在离 the Lord 最近的地方亵渎，这可是重罪。”可思绪却止不住地滑向深渊，有如 Mephistopheles 的低语响起在耳边：“万一这是真的呢？万一实际上更为黑暗呢？又或者，下面出了变数，我从此失去食物的来源……”他突然感到这座通天的巨塔，就如那将 Jesus 钉死在十字架上的 Longinus，把自己钉死在这通往天国的路途上。蓦地，匠者看见极远处的“黑暗”中亮起了点点闪光。太过惊讶了！以至于忘记继续向手握的锤子施力。“Oh！Damn it！”等他回过神来，锤子已经落了下去。同时，远方的光点也迅速隐没，不见踪迹。匠者突然感到一阵乏力，他无奈地躺下，坚硬的砖石硌得他生疼。“大概可以休息一会儿了吧。”他想着，合上了双眼。随后，天空开始崩碎。 绘者·Painter“圣座，这位就是绘者。”侍者指向一旁的怪人。没错，这真是个怪人，他全身都裹藏在斗篷之中，连面部都难以辨清。“是吗。”黑暗中的声音沧桑而遒劲，“你就是那位绘者啊。我听闻你师承异门，所绘之画有着特殊的魔力。”“是的，尊敬的圣座，我能将人画进画里。”绘者颌首，双眸低垂。“哦？这不是废话吗。不能将人画进画里，又怎么能当好画师呢？”黑暗中的声音透着一点愠色。“不，尊敬的圣座，我能在完成这幅画的同时，让画中的人物从现实中消失。”绘者说着，将头低得更低了，正面看过去就如同一个套在斗篷里的人一样。“真是魔鬼的力量啊”黑暗中的声音悠悠，“说不定异端裁判局更加适合你。”“敬爱的圣座，您无须恐吓我，我自会遵守规矩。”“也罢，从帝国出发，西边的 Avalon，东边的 Utopia，你更有把握拿下哪个？”“Utopia 吧。毕竟我们的舰队从未确定过 Avalon 的位置。”“噢？你很清楚嘛。”“尊敬的圣座，我这次前来也是有所准备的。”绘者拿出了几副画卷，“这些都是我用绘卷带走的人，他们的生命已经永远停留在画中。”画卷铺开，上面有着帝国周围一些敌对国家的国王、贵族和将领，栩栩如生。“我以使节之名向他们觐见，记住了他们所有人的相貌，再用画笔将他们最后的光辉凝固在了永恒之中。算是我的一份小小的见面礼。”“侍者，他所报是否属实？”“禀圣座。据调查，这些王国的王公贵族似乎全都在一夜之间人间蒸发了。现在他们的国家都陷入了极度的恐慌与混乱之中。”沉默良久，黑暗中的人影传来一阵感叹。“很好，很好。我希望下一次见到你的时候，你能带着那位皇帝的画像回来。”“悉遵圣意。”经历了数个月的跋涉，绘者来到了 Utopia 首都的城关前。在城关的东方，有一座巨山伫立在天边。它是那样高大，云层也只在半山腰缭绕。乌青色的巨山流淌着金色的河流，在阳光的照耀下熠熠生辉。绘者看到 Utopia 是一个安定富足的国家。不同于帝国，这里的人民似乎没有压迫，而且每个有劳力的人都会得到工作，没有足够劳动能力的人则在预备着各种知识。绘者惊讶地发现，Utopia 没有老人和残疾人。但他没有闲暇在意，他只想尽早面见这个伟大国度地皇帝。然而，闭关锁国的 Utopia 似乎不打算给他这个异邦使节一点面子。绘者被守关的士兵拦下。“异邦人禁止入内。”卫兵的枪架到了绘者的鼻尖前。“我是西方帝国派遣而来的使节，向陛下进贡的。”……“异邦人禁止入内。”卫兵架着枪，声音里不带一丝情感。“噢！不！你这个疯子，我要见陛下！”绘者的声音已经带着嘶哑。“见陛下？”突然，卫兵方法复活了一般，用手指了指东边的天空，道，“看，那不就是吗。”绘者抬头，望见那泛白的天空，突然觉得眼前一黑。“尊敬的圣座。”“画呢？”黑暗中的声音透着彻骨的寒冷。“我见到了 Utopia 的皇帝”绘者裹着斗篷，匍匐在地，“但我无法画下他。”“为什么！莫非他还长了翅膀不可？”“不，如果只是那样，我还能连同他的翅膀一起将他画得栩栩如生。但是，尊贵的圣座，那位皇帝没有翅膀，却比那更可怕——他不符合透视原理。”“透视原理？那是什么？”“世界上所有的景物，在我们的视野里都是近大远小，这就是透视原理。但他不一样，那如同烙印在我的视野中，我仿佛既无法靠近他也无法远离他，这有悖于透视原理。我是西洋派画师，西洋画派遵循透视原理，所以我不可能画下他。”“有不遵循透视原理的画派吗？”“有，东方画派。敬爱的圣座，您看，那就是”绘者指向墙角的一副卷轴水墨画。突然，他的头被重重地撞在了地上，一旁的卫兵将他反手扣住，死死地压在了地上。“为……什……么”绘者艰难地吐出话语。“这不是显而易见的吗？”黑暗中的声音再度响起，“你未能达成任务。你虽未见得我真容，但留你终究是个祸患。我还听闻你的绘画技术是 Avalon 传授的。算了，这些事都交给异端裁判局去审问吧。”魆黑的地窖里。绘者低着头。铁索束缚着他的身躯，钢锥刺穿了他的筋骨。他恐怕再也无法拿起画笔了。突然，天花板上滴下一滴水，水珠顺着他的脊柱滑下。彻骨的寒冷激得他打了一个哆嗦。然后他想起了临行前智者的话语。他决意行动。“咝咝，咝咝……”狱长被一阵刺耳的摩擦声从小憩中吵醒。他循声走向绘者的牢房。“喂喂，你在干什……”狱长被眼前的画面震撼得说不出话来——绘者将伤口的鲜血和铁索上的锈水在墙面上恣意挥洒，赤与橙的色泽相互交汇，看上去似乎杂乱无章，却又蕴有磅礴之势。随着时间的流逝，绘者的身形愈发迟缓。突然，他用力摇荡，将躯体冲向壁墙。绘者用力将头撞向墙，也不知道用了什么魔法，他的头颅竟在墙面上炸裂开来，形成了一副血红的残阳。狱长终于明白。那些纷乱与杂糅的色彩，竟在这一瞬间完全统一了起来，构成了一副晚霞黄昏图。绘者倒下了，他再也不能站起来。突然，狱长似乎想起了什么，如饿狼一般向外冲去。天空碎裂。绘者用生命击穿真理之壁粉碎了盆景上的幕墙人们欢呼着冲出唯有先驱者在罗生门前摆渡笼中的鸟儿首次窥见外面的风景——大地终归是个球临行前，智者在绘者的耳边低语：『不要后悔你选择了现实，虽然它冰冷又残酷』新的时代必将到来！","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miroox.github.io/blog/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"科幻","slug":"科幻","permalink":"http://miroox.github.io/blog/tags/%E7%A7%91%E5%B9%BB/"}]},{"title":"旧作：《琵琶行》心理描写","slug":"PiPaXin","date":"2014-04-30T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2014/04/PiPaXin/","link":"","permalink":"http://miroox.github.io/blog/2014/04/PiPaXin/","excerpt":"","text":"嗟乎！余闻此音曾几何？帝京丝竹如梦隔。昔我直言犯圣怒，左迁谪卧江州戍。余意本图兴，年且少狂轻。逆耳难得君意，未料圣恶言新。宦海浮沉十余载，吾志未达道已尽。身若陷囹圄，心似无所依。凄然寻欢今日，喜闻佳音忽至。行如高山流水，动若天籁仙音。大音希声，大象无形。凄迷婉转，似诉哀心。吾感此乐忆今昔，喟然欲叹涕先行。","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"作文","slug":"作文","permalink":"http://miroox.github.io/blog/tags/%E4%BD%9C%E6%96%87/"},{"name":"文言文","slug":"文言文","permalink":"http://miroox.github.io/blog/tags/%E6%96%87%E8%A8%80%E6%96%87/"}]},{"title":"旧作：求和公式Σk·a_k","slug":"KTimesSum","date":"2014-03-31T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2014/03/KTimesSum/","link":"","permalink":"http://miroox.github.io/blog/2014/03/KTimesSum/","excerpt":"高二做题时发现的，非常trivial，但可以避开错位相减法繁琐方法。∑k=1nk⋅ak=∑k=1n∑j=knaj\\sum_{k=1}^nk\\cdot a_k=\\sum_{k=1}^n\\sum_{j=k}^na_jk=1∑n​k⋅ak​=k=1∑n​j=k∑n​aj​","text":"高二做题时发现的，非常trivial，但可以避开错位相减法繁琐方法。∑k=1nk⋅ak=∑k=1n∑j=knaj\\sum_{k=1}^nk\\cdot a_k=\\sum_{k=1}^n\\sum_{j=k}^na_jk=1∑n​k⋅ak​=k=1∑n​j=k∑n​aj​证明：∑k=1nk⋅ak ⇓1⋅a1⇒∑a1 +⇒∑+2⋅a2⇒∑a2+∑a2 +⇒∑++∑+ ⋮ ⇒ ∑⋮+ ∑⋮⋱n⋅an⇒∑an+∑an+⋯+∑an ⇒ ∑⇓+∑⇓+⋯+ ∑⇓∑k=1n∑j=knaj⇐∑j=1naj+∑j=2naj+⋯+∑j=nnaj\\begin{aligned} \\sum_{k=1}^nk\\cdot a_k\\\\ \\ \\Downarrow\\quad\\\\ 1\\cdot a_1 &amp;\\Rightarrow\\phantom{\\sum} a_1\\\\ \\ +\\quad&amp;\\phantom{\\Rightarrow}\\phantom{\\sum} + \\\\ 2\\cdot a_2 &amp;\\Rightarrow\\phantom{\\sum} a_2 +\\phantom{\\sum} a_2\\\\ \\ +\\quad&amp;\\phantom{\\Rightarrow\\phantom{\\sum}} +\\phantom{+}\\phantom{\\sum} + \\\\ \\ \\vdots\\ \\quad&amp;\\phantom{\\Rightarrow}\\ \\phantom{\\sum}\\vdots\\phantom{+}\\ \\ \\phantom{\\sum}\\vdots\\qquad\\qquad \\ddots \\\\ n\\cdot a_n &amp;\\Rightarrow \\phantom{\\sum}a_n + \\phantom{\\sum}a_n +\\cdots+\\phantom{\\sum}a_n\\\\ \\ &amp;\\phantom{\\Rightarrow}\\ \\phantom{\\sum}\\Downarrow\\phantom{+} \\phantom{\\sum}\\Downarrow \\phantom{+\\cdots+}\\ \\ \\phantom{\\sum}\\Downarrow\\\\ \\sum_{k=1}^n\\sum_{j=k}^na_j&amp;\\Leftarrow\\sum_{j=1}^na_j+\\sum_{j=2}^na_j+\\cdots+\\sum_{j=n}^na_j \\end{aligned}k=1∑n​k⋅ak​ ⇓1⋅a1​ +2⋅a2​ + ⋮ n⋅an​ k=1∑n​j=k∑n​aj​​⇒∑a1​⇒∑+⇒∑a2​+∑a2​⇒∑++∑+⇒ ∑⋮+ ∑⋮⋱⇒∑an​+∑an​+⋯+∑an​⇒ ∑⇓+∑⇓+⋯+ ∑⇓⇐j=1∑n​aj​+j=2∑n​aj​+⋯+j=n∑n​aj​​证毕。例一：∑k=1nk2k=∑k=1n∑j=kn12j=∑k=1n(12⋅1−12n−k+11−12)=∑k=1n(12k−1−12n)=2−n+22n\\sum_{k=1}^n\\frac{k}{2^k}=\\sum_{k=1}^n\\sum_{j=k}^n\\frac{1}{2^j}=\\sum_{k=1}^n\\left(\\frac{1}{2}\\cdot\\frac{1-\\frac{1}{2^{n-k+1}}}{1-\\frac{1}{2}}\\right)=\\sum_{k=1}^n\\left(\\frac{1}{2^{k-1}}-\\frac{1}{2^n}\\right)=2-\\frac{n+2}{2^n}k=1∑n​2kk​=k=1∑n​j=k∑n​2j1​=k=1∑n​(21​⋅1−21​1−2n−k+11​​)=k=1∑n​(2k−11​−2n1​)=2−2nn+2​例二：∑k=1nk2=∑k=1n∑j=knj=∑k=1n(k+n)(n−k+1)2=12∑k=1nk2+12∑k=1n(k+n+n2) ⟹ 32∑k=1nk2=12[(n+1)n2+n2(n+1)] ⟹ ∑k=1nk2=n(n+1)(2n+1)6\\begin{aligned} &amp;{}\\sum_{k=1}^nk^2=\\sum_{k=1}^n\\sum_{j=k}^nj=\\sum_{k=1}^n\\frac{(k+n)(n-k+1)}{2}=\\frac{1}{2}\\sum_{k=1}^nk^2+\\frac{1}{2}\\sum_{k=1}^n\\left(k+n+n^2\\right)\\\\ \\implies&amp;{}\\frac{3}{2}\\sum_{k=1}^nk^2=\\frac{1}{2}\\left[\\frac{(n+1)n}{2}+n^2(n+1) \\right]\\\\ \\implies&amp;{}\\sum_{k=1}^nk^2=\\frac{n(n+1)(2n+1)}{6} \\end{aligned}⟹⟹​k=1∑n​k2=k=1∑n​j=k∑n​j=k=1∑n​2(k+n)(n−k+1)​=21​k=1∑n​k2+21​k=1∑n​(k+n+n2)23​k=1∑n​k2=21​[2(n+1)n​+n2(n+1)]k=1∑n​k2=6n(n+1)(2n+1)​​","categories":[{"name":"数理科学","slug":"数理科学","permalink":"http://miroox.github.io/blog/categories/%E6%95%B0%E7%90%86%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://miroox.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数列","slug":"数列","permalink":"http://miroox.github.io/blog/tags/%E6%95%B0%E5%88%97/"}]},{"title":"旧作：奋斗","slug":"FenDou","date":"2013-07-31T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2013/07/FenDou/","link":"","permalink":"http://miroox.github.io/blog/2013/07/FenDou/","excerpt":"","text":"一、山中老人老人每天起来，挑水劈柴、浇花种菜、打打太极，时不时还吼上一两嗓子的山歌，吓得林里的鸟儿全都飞窜开去。就这样，日复一日，年复一年，过着平平淡淡又有如世外桃源般宁静闲适、悠然自得的生活。 二、店家小二小二，其实也就是服务生。在这样的小餐馆里，“小二”的称呼仍然保留着。这名年轻人在店里当服务生也有一两年了。他读的书并不多，但也知道国内外许多成功人士都是从洗碗端盘开始的。因此，他坚信，只要自己努力奋斗，终有一天可以成为一名大老板、大企业家。他端盘、送水，用业务性的完美微笑欢迎每一位来客。他是所有员工中最勤快认真的一个，虽然没有得到立即提拔，但他相信那一天终会来临。 三、从伍军人军人，神圣的职业。而他们，则是当中最为重要的长驻边疆的边防战士。他们是最伟大、最无私的一群人。在许多人眼里，他们是“疯子”。他们常驻于环境恶劣的边地哨岗上，数年也难回一次家。但他们坚定在自己的岗位上，“舍小家，保大家”的信念早已将他们包围。然而，他们心中仍有迷惘：他们不希望在此碌碌终身，因而他们会渴望战争；但他们也不想自己的家园被破坏，因而他们又憎恶战争。然而。“报告：不明空军将进入我国领海上空。”硝烟已把战火点燃，他们也将义无反顾…… 四、校内学生“教室里书声朗朗，操场上汗水飞扬。我们怀揣着不同的梦想，走进学习的殿堂。我们遨游知识的海洋，却发现前途一片迷茫。但我们坚定心中的信仰，要相信希望就在彼方。”这样一群有志青年，他们做着各自认为重要的事，他们朝着自己的目标而奋斗，但没有人能说得清他们的未来。未来的纸上一片空白，期待他们填上绚丽的色彩。 五、错误曾几何时，我希冀着这样或那样的未来而来到了这个社会。然而这社会究竟不是我们所想象的那样。我们无法选择社会，但我们仍有选择权。我们也许做过许许多多的错事，但我们绝不是错误的人。 六、征兆·征召“听说要打仗了？”墙角的一个青年说道。“那菜价肯定又要上涨了。”一旁的大妈道。“诶？那我们是不是要挖个洞藏起来比较好？”另一边的胖青年一本正经道。“笨啊！…”“欸！对不起，让一让。上菜啦！”年轻服务生保持着他那一贯的业务性微笑，对着闲谈的众人说，“嗯……血战沙场。”“这是什么古怪名字。”胖青年嘟囔。“这是……”年轻服务生正欲说明。“好了好啦！”另一个瘦小的青年不耐烦地挥挥手。那服务生到也识趣，讪笑的走开了。此时门前走来两个人，他便急忙迎过去。“……最讨厌那张臭脸，真想踩两脚……”那瘦青年用微不可闻的声音道。年轻服务生快步走到门前，继续保持业务性微笑，轻轻鞠了一躬：“欢迎光临，请问……”他突然说不下去了。他隐约听见老板娘在说“怎么不说了，继续啊！”，但那也许已经不重要了。快步进来的两人，身着军装，似乎还挂有军衔。两人无视了他，径直走到了一块空白的墙壁前，服务生抬头上前，想看一看他们在干什么。只见两人飞快地贴上了一张布告后便离开了，留下在一旁发愣的年轻服务生。“征…兵……”青年口中喃喃。宪法规定：公民应履行服兵役的义务。大学的校园里，人头攒动。一大批学生围在一张巨大的告示前，或大声喧嚷，或窃窃私语，还有一批热血青年凭着满腔的激情争先恐后地报名——参军。从高处看，应征的人群有如黑压压的蝗虫过境，整个报名的现场混沌不堪。“真是……”老人摇摇头，望着下山的方向，手里攥着一块木牌，“都什么年代了，还玩这种鬼把戏。”“爷爷，怎么了？”扯着老人的衣角，一个虎头虎脑的小孩问道。“不……没你的事，乖乖的在屋里呆着。”“哦，知道了。”“知道，你又知道些什么呢。”老人望着孙子离去的背影，攥着木牌的手已经有些泛白。木牌上，两个朱红色的大字：征兵。“唉！”老人叹了口气，转身回屋里去了。只留下青草地里，一块崭新的木牌。“征兵啊……”年轻服务生左思右想。突然，他哼了一口气，自语道：“保家卫国什么的，有我没我又有什么区别呢？还是先干出一笔事业，再把父母……”“……父母！”他好像突然想起什么似的，立马从椅子上弹起，急匆匆的奔到柜台前，对老板说：“那个，对不起，请问我能请几天假回去不？我想安顿一下家里人。”“嗯……”老板沉吟片刻，点点头，“不过要尽早回来，店里还有一大堆事……”“好！我尽量在两天之内赶回来！”说罢，就开始脱下工作服。“……等你回来我就提拔你当……”老板话没能说完，青年已经一溜烟跑走了。“……还是年轻好啊！”老板望着他离去的背影，感叹道。 七、战争战争终究还是打响了。战场上难免会有伤亡，但学生毕竟是整个社会所关注、保护的对象，因而他们能得到最迅速、最安全的撤离。在炮声与烽火中，细密的撤离队伍，却有歌声回响：“和平年代的朗朗书声一去不返/我们背离故乡/我们奔走流亡……”歌声如同灌入了魔力一般，一传十，十传百，很快就传到了前线的军队中，又有歌曰：“战争时代的硝烟炮响连绵不断/我们背井离乡/我们奔赴战场……”混沌的战场上，歌声、雨声、枪炮声，全都混杂在一起，纷乱、迷离…… 八、战后一面断墙，一片废墟。青年愣愣地站在这个自己曾经工作、奋斗的地方前。周围许多人看着他，欲言又止。“升薪、升职，还当大老板！？”青年突然出声，周围的人都不由地退了一步。他惨笑着，跪倒在了废墟上，“啊哈哈！我要笑破肚皮了！”“别开玩笑了！”他忽的又站起来，状若疯魔，“保家卫国？嘿嘿！血战沙场？呵呵！”“我为什么没有应征？”他的声音倏尔又放低。“那我又凭什么能应征？”他的声音突然高亢起来，“连这里都保不住的人，又谈什么保家卫国啊！”“全是些疯子、傻子，又有谁在保家，又有谁在卫国呐！”青年脸上没有一丝血色，惨笑着倒在了雨中。战场上回来的人，有活人，亲人却死在了战争里；有死人，那是白发人送黑发人。他们互相搀扶着，依偎着，只为眼前那微不足道的希望。有人哭天喊地、怨声载道；也有人调整心态、直面未来。但他们毕竟是活着的。活着的，便是胜利者，不是吗？那个曾经翠绿的山林也染上了一抹灰色，刺鼻的硝烟污浊了曾经新鲜的空气。山林深处，老人微微抬头，望着远处天空中弥漫的浓烟，战火并未来到这里。他长叹一声：“生有何乐，死又何哀。故人去矣，魂兮归来。” 九、歌和平年代的朗朗书声一去不返我们背离故乡我们奔走流亡我们对前路一片迷惘找不到方向我们有如无垠苦海上争渡的小船踏着战士们的尸骨启航我们何尝不想收帆返乡可战场毕竟是战场没有希望只有死亡但待硝烟尽散我们期望能回乡战争时代的硝烟炮响连绵不断我们背井离乡我们奔赴战场我们怀着坚定的信仰梦想在前方我们好似北方草原上凶恶的白狼把敌人的血肉当作食粮我们挥洒血汗斗志昂扬那黑暗中仍有光芒就是希望就是彼方纵使血流漂橹埋骨他乡又何妨","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miroox.github.io/blog/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"作文","slug":"作文","permalink":"http://miroox.github.io/blog/tags/%E4%BD%9C%E6%96%87/"}]},{"title":"旧作：沙的狂想","slug":"RhapsodyOfSand","date":"2013-07-31T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2013/07/RhapsodyOfSand/","link":"","permalink":"http://miroox.github.io/blog/2013/07/RhapsodyOfSand/","excerpt":"","text":"曾几何时，我希冀着这样或那样的未来而来到了这个社会。然而这社会究竟不是我们所想象的那样。我们无法选择社会，但我们仍有选择权。我们可以选择改变自我，让社会来选择。 一这是一片沙地，一片本只有沙子的沙地。在沙子们的社会里，个个互相承认、互相尊重。他们不在乎自己的渺小，因为这里每个成员都如此；他们不在乎别人的卑微，毕竟自己也好不到哪里去。但他们也不会互相帮助，他们是一盘散沙，只为各自的目标而奋斗。也有斗争，但很难有大规模的混乱。他们终究是散的，散漫而自由。 二但是，世间毕竟没有不变之物。当一颗珍珠莫名来到这片沙地，一切，都改变了。没有哪粒沙子知道那珍珠是何时出现又从何而来的。但他的出现，确确实实引发了一场大混乱，以及——变革。人们总是本能地趋利避害，而当中最直接的表现，就是趋炎附势。珍珠的出现让沙子们明白了自己的卑微与渺小。他们怀着无限的崇拜与敬仰想去巴结珍珠，颗珍珠又怎么会理他们。随着越来越多的沙子只认可和尊重珍珠，有一批沙子却已经无法忍受珍珠的这股傲气。于是，出现了这样的一批沙子：他们拉帮结派，互相尊重，互相认可，他们认为珍珠掠夺了他们曾受过的尊重与认可，他们是要将失去的一切给夺回来。像这样的组织与矛盾出现后，一种名为“阶级”的事物在这片沙地上诞生了。 三“我要向流星祈愿：我愿不择手段，成为一颗璀璨的明珠，受世人敬仰。”一将功成万骨枯。在这茫茫沙海之中，诞生了一个传奇：他用自己的努力与奋斗，在牺牲了数百名同胞之后，成就了万众瞩目的珍珠。成为珍珠的他仿佛忘记了身为沙子时往昔的一切。成就珍珠时，周围无数沙子的祝贺与谩骂他都视而不见。曾有一名他还是沙子时的老友迎着他笑道：“好久不见。”得来的却是冰冷的一句：“你是谁啊？别乱搭讪！”逼得对方讪讪离开。此时的他，只尊重另一颗与之对等的“原始”珍珠。他们俩有如统治这片沙地的君王，高傲地盘踞在无数沙子的头上。 四于是，一场浩浩荡荡的“珍珠养成计划”就这样展开了。毕竟，贪婪是万灵的本性。谁不想成为君王？谁不想受万人景仰？什么“要将失去的一切给夺回来”，什么“沙子们互相认可、尊重”，统统都是痴人说梦罢了。为此，沙子们开始不断残害同胞，作为成就珍珠的“祭品”。整片沙地上陷入了一片血雨腥风之中。自私、贪婪、趋炎附势……所有本性恶劣之处统统爆发出来，到处都是混乱、混乱、混乱…… 五在这乱世之中，却有一粒独立特行的沙子，他似乎有着过人的先见之明。他决定远离纷争，藏身于大量“已成就”珍珠的缝隙之中。他抱有着这样的想法：“珍珠之所以高贵是因为物以稀为贵，等他们全部变成了珍珠，那我就是‘唯一’仅剩的沙子，岂不是最高贵的啦。”因此，他认为只要躲得远远的，自己便能坐享其成。于是他等着，等着，望见沙子们越来也少，珍珠们越来越多，心里便喜逐颜开。然而有一天，他发现自己渺小的身躯被无尽的珍珠所掩埋。他看不见光亮，也看不见明天。 六纷争结束了，曾经的沙地上，现在只看得见珍珠。珍珠的巨头们开始商议停战协议。没有人听见，在无数珍珠掩埋下那小小沙粒无声的呐喊……","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"作文","slug":"作文","permalink":"http://miroox.github.io/blog/tags/%E4%BD%9C%E6%96%87/"}]},{"title":"旧作：怯","slug":"Qie","date":"2013-07-31T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2013/07/Qie/","link":"","permalink":"http://miroox.github.io/blog/2013/07/Qie/","excerpt":"","text":"老人面前是一块钻石，一块蛋黄大的钻石。这是前几天一个商人朋友送来的。这样一块价值不菲的钻石却偏生得一道裂缝，若能顺着裂纹切开，那将升值数倍。然而，此下若是失败，便是不可估量的损失。因此，许多切割师都不愿动手。可这商人又和他是老友，他在这一带也是小有名气，又怎能不帮这个忙呢？但在他稀里糊涂地答应下这桩生意后，却有些不知所措。老匠人面对钻石，从旁边拿起工具，举在空中，对准那道裂缝，仿佛就要切下去。可他的手却在微微颤抖。倏的，老人将手里的工具放下，伸出他那满布老茧的粗糙的手，轻抚那钻石上那道细细的裂纹。夜渐渐深了。老人躺在床上，辗转难眠。他一闭眼，那破碎的钻石仿佛就在眼前。可他终还是抵不住困意，沉沉地睡去了。睡梦里，他准备了无数次精密的测量，只差那关键的一刀了。他暗暗运气，切下了这凌厉的一刀。那一刹那，他如同猛虎，又好似雄鹰，岁月的痕迹仿佛已经消失，这跨越时空的一刀，五十年前与五十年后，他的勇猛，从未改变。刀落。“！”静谧的夜晚，安静得只有老人微微喘息的声音。五十年前。五十年前，当老匠人还只是个学徒的时候。他的父亲，也是他的师傅，交给了他这样的一个任务：“切开它，切开这个钻石，让他从裂缝中完美地被切开。那么你就出师了。”他是这样说的。可他失败了。那如猛虎般凌厉的一刀让钻石碎开了。只留下一脸惊愕的众人。“调整呼吸，盯紧目标，不要想它有多贵重，你只要想着那一刀而已。”父亲曾这样教导。“可为什么我失败了呢？”他不明白，他以为自己只是在想那一刀。然而，他还未来得及问出口，巨大的变动已经席卷了他的家庭。那样的一块钻石，足以令他们倾家荡产。一家人过上了颠沛流离的生活。而他，不得不在父亲死后为了归还债务而继续做切割师。直到如今，他依旧有笔债务未能还清。第二天早晨，老匠人迷茫地坐在床边，面前放着那块蛋黄大的钻石。“五十年前……”老人这么想着，忽然笑着说：“五十年前的那块，恐怕只有这个的一半大。”而后他又低低地说，“那个老滑头……”突然，老人从床上立起，心中已有了决断。他找来了徒弟，说：“今天将是你最后一次在我这里做工了。”他拿出了一些稿纸，继续道：“按这上面的方案，把那玩意剖开。”他指了指墙角的钻石，“无论成败如何，你都可以出师了。”“……要是成功了，把工钱全部给你。”但他没有说出口。“这……”徒弟惊疑不定地望着老人。“没事，去吧！”老人笑着对徒弟说，“一个赝品而已，用不着那么紧张，就当留个纪念。”于是，徒弟分毫不差地按老人的方案布置执行了。在徒弟的一声大吼中，钻石完美的分成两半。“老了，真的老了啊！”在学徒的大吼声下，老人发出一道微不可闻的叹息。在晚霞的微风中，老匠人依旧做着他的切割师，只为还清那欠了五十年的债……","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miroox.github.io/blog/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"作文","slug":"作文","permalink":"http://miroox.github.io/blog/tags/%E4%BD%9C%E6%96%87/"}]},{"title":"旧作：爱迪生于21世纪日记","slug":"EdisonIn21Century","date":"2013-07-31T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2013/07/EdisonIn21Century/","link":"","permalink":"http://miroox.github.io/blog/2013/07/EdisonIn21Century/","excerpt":"","text":"引言在发明了电灯之后，爱迪生在睡梦中偶然来到了21世纪，下面便是他“七日之游”的日记记录： 201X年某月某日（第一天）睁开双眼，呼吸着那不同于我过去浑浊而清新的空气，抬头望见鳞次栉比的高楼大厦，道路上奔流不息的机械车辆，路边的行人不仅衣着古怪，还个个手里捧着一块发亮的“方砖”，这莫不是用来砸人的？天空的光芒似乎特别璀璨，炫得我难以直视。难道说这里就是天堂？可我并没有见到插着翅膀的美丽天使出来迎接我啊。不！我还不能死，我可是要成为“发明大王”的男人，怎么能在这里死掉！ 201X年某月某日（第二天）经过一天的研究调查，大致明白了这里不是天堂（天堂怎么会有黑夜），而是一个拥有高度发达科技的世界。我至今还记得我说我是爱迪生时，旁边的路人一副见鬼了的样子，还害得我差点被送进精神疗养院去，真是太危险了。此外，我还发现人人手里所捧着的“方砖”，其实是一种名为“手机”的远程通讯工具，似乎有着类似古代神话中“千里传音”般的作用，但具体还有待明天的实地调查。 201X年某月某日（第三天）今天外面似乎格外的热，而我却来到了一个十分凉爽的房间里。没错，我来顶哦啊了一个叫“手机商店”的地方，这里有一种叫“air-condition”的机器可以用来调节温度。我本想拆开研究一下这所谓的“air-condition”，但我今天的目的毕竟不是这个。我在柜台上随手拿了一台“iPhone试用机”便操作起来。可我无奈地发现上面的按键好少，而且我按了半天居然没有什么变化，起的我几乎要把它摔在地上。好在服务员把我拉住，才避免了惨剧的发生。感情这个闪闪发光的玻璃（屏幕）也可以触摸来操作啊！最后，在服务员的悉心教导下，我终于能够使用最基本的功能了。 201X年某月某日（第四天）今天依然来到这个“手机商店”享受人生，这种名为“手机”的机器实在是太奇妙了，宛如古代炼金术师们传说的“贤者之石”一般无所不能。除了简单的音频沟通之外，还有视频、文字等种种交流方式，即使相距万里，也能方便的交流对话，真是妙不可言啊！ 201X年某月某日（第五天）今天继续在店里享受人生。尽管店员们看我已经有点不耐烦了，但我对手机的热情没有丝毫退却。这还真是一部伟大的发明，看来我“发明大王”也要“退位让贤”了！ 201X年某月某日（第六天）我今天终究是被赶了出去。看着他们那厌恶的眼神，我已经没有了丝毫的感觉。在这几天里我已经做到了“足不出户，知天下事”。于是我就在城市各处的同类商店里“打游击”，继续沉溺在手机的世界里。 201X年某月某日（最后一天）今天我在网上看见有新闻说有人玩手机玩到眼瞎，玩电脑玩到猝死。我突然明白我最近为什么迷迷糊糊的了，别说发明了，就连探求欲都没有。“我的生命正在浪费，而我对此一无所知。”于是我愤怒了，将手里的机器当着所有人的面狠狠摔下！然后呢？然后，就没有然后了。","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"作文","slug":"作文","permalink":"http://miroox.github.io/blog/tags/%E4%BD%9C%E6%96%87/"}]},{"title":"旧作：石·人","slug":"Stone-Man","date":"2011-07-31T16:00:00.000Z","updated":"2020-07-22T03:57:23.000Z","comments":true,"path":"2011/07/Stone-Man/","link":"","permalink":"http://miroox.github.io/blog/2011/07/Stone-Man/","excerpt":"","text":"鸟儿冲破了鸟笼，因为它渴望自由。 序老鸟对小鸟说：“从前啊，有一块石头……”“石头？”小鸟疑问道。“对啊。”老鸟接着说，“可突然有一天，石头炸裂，里面出来一个人。”“人？可为什么是人呢？”小鸟问。老鸟：“对啊，为什么是人呢？” 一他抬起头，迷茫地看着这个世界。眼前的世界是那么的迷茫，有所那么真切。他，大概是第一次来到这个世界吧。周围的人看着他，指指点点，议论纷纷。“这家伙长得好丑。”一个女生说。“妈妈！妈妈！”一个小女孩问道，“这个人怎么不穿衣服啊！”“这就是那个传说中从石头里蹦出来的家伙。”一个小男孩两眼冒金星，“可是，它为什么是人，而不是猴子呢？”……这，会是他所希冀的光明世界吗？对于这个思维能力尚比昆虫还低的生物而言，显然无法对这个问题自行解答。于是，他选择了“搁置”。 二这是一个偏远的小山村。高高耸立的山崖上，一块黑色的大石孤零零地摆在杂草堆中。每天，都会有一只百灵鸟，站在山崖边的树上歌唱，讲她的奇闻趣事，述她的自由翱翔。也就是那时， 原来空无一物的石头多了一丝执念，有了一颗心。虽然它听不见、看不到，但它却能从歌声中感受到那一丝欢愉。于是，它便有了想法：“祂要挣脱这黑暗，逃离这束缚，祂要进入那光明的世界。”这是一丝执念，但随着时间的流转却没有丝毫被磨灭，反而愈发壮大起来。终于有一天，伴随着一声惊天巨响，“他”诞生了。 三他终于还是被关入囚笼里，即将要送出村去展览。这一次，连武装警卫也出动了。引来了大批的记者，以及所谓的“学术专家”。“这下应该万无一失了吧。”人们如是想。突然，人群中冲出一个小女孩，手中还有一件破破烂烂的小衣裳：“大哥哥，天这么冷，我要送一件……”几乎所有人都低下了头，不愿意目睹血淋淋的惨剧在眼前发生。“嘭！”一声枪响，惊得所有人都不由地抬起头——一旁的警卫开了枪——小女孩踏过了警戒线。“衣……服……”鲜血洒向空中，小女孩如断线的风筝般倒下。他，首先是茫然，然后表情逐渐转为愤怒。“怪物”真真切切地暴走了！ 四人类，果真如蝗虫一般的一种生物，总有无畏者在冲锋陷阵。纵使你是是最强，纵使你无敌于天下，在面对涌动着的无穷无尽的“蝗虫”大军时，无休止的战斗压地他无从喘息。那么，战斗还要继续吗？于是，他屈服了。人们自以为是最先进的武器将他震慑住时，他只不过是厌倦了一边倒的屠杀而已。人们将他关押到更为坚固的铁笼中，施加了更加致命的高压电流……直到人们认为他们的囚徒不再有机会逃脱时，才中止了无谓的浪费。而他，只是日复一日地在囚笼中等待，等待永不到来的“戈多”，等着梦醒时分的到来。就这样，春去冬来，时光荏苒。直到有一天…… 五直到有一天，他的惊鸿一瞥。在前来参观的游人中，他瞥见了一名二十来岁的女子。虽然只是侧颜，但他立马笃定——就是当初那个小女孩！他从未有像此刻一般渴望自由，甚至远胜在石中度过的漫漫时光。万无一失的囚笼对他而言不过是个笑话，从未有什么可以阻止他。“啊！”伴随着惊慌的尖叫，游客们四散奔逃。如魔似神的存在，在硝烟的迷蒙中缓缓显现。不远处，那名女子并没有逃走，只是在那原地，静静地站着。突然，有机灵的警卫将枪口指向那名女子。于是，“怪物”再度爆发出神秘的伟力，一个箭步蹿到女子的面前挡下这一枪。“嘭！”枪声，来自后方。所向无敌的“怪物”不可思议地看着自己胸膛开的血洞，喃喃道：“为甚……么？”“长官，你看，我又立功了。”女人没有理他，自顾走向一旁的警官前炫耀。“最脆弱的地方，是心。”这是她给出的答案。那倒下的尸体被被炸药引起的大火所吞噬。硝烟散尽，留下的，只有一块烧得漆黑的石头。“这个石头给我们带回去研究吧。”赶来的学者说，“它说不定能破解生命的奥秘。”“不”她坚持道，“这还是放回原处好。” 六老鸟对小鸟说：“从前呐，有一个人……”“人？”小鸟疑问道。“对啊！”老鸟接着道，“可终于有一天，那人心死了，变成了石头……”","categories":[{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://miroox.github.io/blog/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"作文","slug":"作文","permalink":"http://miroox.github.io/blog/tags/%E4%BD%9C%E6%96%87/"}]}],"categories":[{"name":"代码编程","slug":"代码编程","permalink":"http://miroox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"},{"name":"杂谈散记","slug":"杂谈散记","permalink":"http://miroox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"},{"name":"翻译作品","slug":"翻译作品","permalink":"http://miroox.github.io/blog/categories/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/"},{"name":"数理科学","slug":"数理科学","permalink":"http://miroox.github.io/blog/categories/%E6%95%B0%E7%90%86%E7%A7%91%E5%AD%A6/"},{"name":"小说文艺","slug":"小说文艺","permalink":"http://miroox.github.io/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA/"}],"tags":[{"name":"元编程","slug":"元编程","permalink":"http://miroox.github.io/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"},{"name":"Julia","slug":"Julia","permalink":"http://miroox.github.io/blog/tags/Julia/"},{"name":"编程","slug":"编程","permalink":"http://miroox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C#","slug":"C","permalink":"http://miroox.github.io/blog/tags/C/"},{"name":".NET","slug":"NET","permalink":"http://miroox.github.io/blog/tags/NET/"},{"name":"LaTeX","slug":"LaTeX","permalink":"http://miroox.github.io/blog/tags/LaTeX/"},{"name":"MSBuild","slug":"MSBuild","permalink":"http://miroox.github.io/blog/tags/MSBuild/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://miroox.github.io/blog/tags/Visual-Studio/"},{"name":"年终总结","slug":"年终总结","permalink":"http://miroox.github.io/blog/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"name":"PMAC","slug":"PMAC","permalink":"http://miroox.github.io/blog/tags/PMAC/"},{"name":"FlyCapture2","slug":"FlyCapture2","permalink":"http://miroox.github.io/blog/tags/FlyCapture2/"},{"name":"Wolfram","slug":"Wolfram","permalink":"http://miroox.github.io/blog/tags/Wolfram/"},{"name":"Cloud","slug":"Cloud","permalink":"http://miroox.github.io/blog/tags/Cloud/"},{"name":"Rust","slug":"Rust","permalink":"http://miroox.github.io/blog/tags/Rust/"},{"name":"LibraryLink","slug":"LibraryLink","permalink":"http://miroox.github.io/blog/tags/LibraryLink/"},{"name":"GitHub","slug":"GitHub","permalink":"http://miroox.github.io/blog/tags/GitHub/"},{"name":"持续集成","slug":"持续集成","permalink":"http://miroox.github.io/blog/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"name":"Qt","slug":"Qt","permalink":"http://miroox.github.io/blog/tags/Qt/"},{"name":"杂谈","slug":"杂谈","permalink":"http://miroox.github.io/blog/tags/%E6%9D%82%E8%B0%88/"},{"name":"科普","slug":"科普","permalink":"http://miroox.github.io/blog/tags/%E7%A7%91%E6%99%AE/"},{"name":"Wiki","slug":"Wiki","permalink":"http://miroox.github.io/blog/tags/Wiki/"},{"name":"Web","slug":"Web","permalink":"http://miroox.github.io/blog/tags/Web/"},{"name":"踩坑","slug":"踩坑","permalink":"http://miroox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"},{"name":"符号计算","slug":"符号计算","permalink":"http://miroox.github.io/blog/tags/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/"},{"name":"功能模拟","slug":"功能模拟","permalink":"http://miroox.github.io/blog/tags/%E5%8A%9F%E8%83%BD%E6%A8%A1%E6%8B%9F/"},{"name":"Undocumented","slug":"Undocumented","permalink":"http://miroox.github.io/blog/tags/Undocumented/"},{"name":"文学编程","slug":"文学编程","permalink":"http://miroox.github.io/blog/tags/%E6%96%87%E5%AD%A6%E7%BC%96%E7%A8%8B/"},{"name":"参考","slug":"参考","permalink":"http://miroox.github.io/blog/tags/%E5%8F%82%E8%80%83/"},{"name":"语法","slug":"语法","permalink":"http://miroox.github.io/blog/tags/%E8%AF%AD%E6%B3%95/"},{"name":"Git","slug":"Git","permalink":"http://miroox.github.io/blog/tags/Git/"},{"name":"哲学","slug":"哲学","permalink":"http://miroox.github.io/blog/tags/%E5%93%B2%E5%AD%A6/"},{"name":"科学哲学","slug":"科学哲学","permalink":"http://miroox.github.io/blog/tags/%E7%A7%91%E5%AD%A6%E5%93%B2%E5%AD%A6/"},{"name":"C语言","slug":"C语言","permalink":"http://miroox.github.io/blog/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://miroox.github.io/blog/tags/C/"},{"name":"图像加密","slug":"图像加密","permalink":"http://miroox.github.io/blog/tags/%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%AF%86/"},{"name":"图像处理","slug":"图像处理","permalink":"http://miroox.github.io/blog/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"混沌","slug":"混沌","permalink":"http://miroox.github.io/blog/tags/%E6%B7%B7%E6%B2%8C/"},{"name":"算法","slug":"算法","permalink":"http://miroox.github.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"拖放","slug":"拖放","permalink":"http://miroox.github.io/blog/tags/%E6%8B%96%E6%94%BE/"},{"name":"翻译","slug":"翻译","permalink":"http://miroox.github.io/blog/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Haskell","slug":"Haskell","permalink":"http://miroox.github.io/blog/tags/Haskell/"},{"name":"程序设计","slug":"程序设计","permalink":"http://miroox.github.io/blog/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"马克思主义","slug":"马克思主义","permalink":"http://miroox.github.io/blog/tags/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89/"},{"name":"笔记","slug":"笔记","permalink":"http://miroox.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"红警","slug":"红警","permalink":"http://miroox.github.io/blog/tags/%E7%BA%A2%E8%AD%A6/"},{"name":"文件格式","slug":"文件格式","permalink":"http://miroox.github.io/blog/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"name":"数学","slug":"数学","permalink":"http://miroox.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"},{"name":"概率论","slug":"概率论","permalink":"http://miroox.github.io/blog/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"傅里叶变换","slug":"傅里叶变换","permalink":"http://miroox.github.io/blog/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"微积分","slug":"微积分","permalink":"http://miroox.github.io/blog/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"},{"name":"逻辑","slug":"逻辑","permalink":"http://miroox.github.io/blog/tags/%E9%80%BB%E8%BE%91/"},{"name":"题解","slug":"题解","permalink":"http://miroox.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"},{"name":"作文","slug":"作文","permalink":"http://miroox.github.io/blog/tags/%E4%BD%9C%E6%96%87/"},{"name":"散记","slug":"散记","permalink":"http://miroox.github.io/blog/tags/%E6%95%A3%E8%AE%B0/"},{"name":"小说","slug":"小说","permalink":"http://miroox.github.io/blog/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"科幻","slug":"科幻","permalink":"http://miroox.github.io/blog/tags/%E7%A7%91%E5%B9%BB/"},{"name":"数列","slug":"数列","permalink":"http://miroox.github.io/blog/tags/%E6%95%B0%E5%88%97/"},{"name":"文言文","slug":"文言文","permalink":"http://miroox.github.io/blog/tags/%E6%96%87%E8%A8%80%E6%96%87/"}]}