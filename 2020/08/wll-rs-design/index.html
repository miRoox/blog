<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.6.5"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>【新坑】wll-rs: 用于 Rust 的 Wolfram LibraryLink 接口 - miRoox的博客</title><meta name="keywords" content="编程,Wolfram,元编程,Rust,LibraryLink"><meta name="description" content="苦于 Wolfram LibraryLink 原本的接口使用起来过于繁琐，又受 wll-interface 的启发，近期开了一个新坑，尝试为 Wolfram LibraryLink 封装一套 Rust 的接口 wll-rs。阅读本文需要一定 Rust 以及 Wolfram LibraryLink 的基础。"><link rel="alternate" href="/blog/atom.xml" title="miRoox的博客"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="/blog/images/favicon.png"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"><link rel="stylesheet" href="/blog/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="container"><div class="wrapper"><div class="nav-sub"><p class="title"></p><ul class="switcher nav-list-h"><li><a class="s-comment fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main"><a class="title flat-box" target="_self" href="/blog/">miRoox' Blog</a><div class="menu navigation"><ul class="nav-list-h"><li><a class="flat-box" href="/blog/" id="blog"><i class="fas fa-clock fa-fw"></i>最近</a></li><li><a class="flat-box" href="/blog/archives/" rel="nofollow" id="blogarchives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box"><i class="fas fa-folder-open fa-fw"></i>分类</a><ul class="list-v"><li><a class="flat-box" href="/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B" id="blogcategoriesE4BBA3E7A081E7BC96E7A88B">代码编程</a></li><li><a class="flat-box" href="/blog/categories/%E6%95%B0%E7%90%86%E7%A7%91%E5%AD%A6" id="blogcategoriesE695B0E79086E7A791E5ADA6">数理科学</a></li><li><a class="flat-box" href="/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA" id="blogcategoriesE5B08FE8AFB4E69687E889BA">小说文艺</a></li><li><a class="flat-box" href="/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0" id="blogcategoriesE69D82E8B088E695A3E8AEB0">杂谈散记</a></li><li><a class="flat-box" href="/blog/categories/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81" id="blogcategoriesE7BFBBE8AF91E4BD9CE59381">翻译作品</a></li></ul></li><li><a class="flat-box" href="/blog/tags/" rel="nofollow" id="blogtags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/blog/friends/" rel="nofollow" id="blogfriends"><i class="fas fa-user-friends fa-fw"></i>友链</a></li><li><a class="flat-box" href="https://miroox.github.io/wiki/" rel="nofollow" id="https:mirooxgithubiowiki"><i class="fab fa-wikipedia-w fa-fw"></i>知识库</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="搜索……"></form></div><ul class="switcher nav-list-h"><li><a class="s-search fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a><ul class="menu-phone list-v navigation white-box"><li><a class="flat-box" href="/blog/" id="blog"><i class="fas fa-clock fa-fw"></i>最近</a></li><li><a class="flat-box" href="/blog/archives/" rel="nofollow" id="blogarchives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box"><i class="fas fa-folder-open fa-fw"></i>分类</a><ul class="list-v"><li><a class="flat-box" href="/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B" id="blogcategoriesE4BBA3E7A081E7BC96E7A88B">代码编程</a></li><li><a class="flat-box" href="/blog/categories/%E6%95%B0%E7%90%86%E7%A7%91%E5%AD%A6" id="blogcategoriesE695B0E79086E7A791E5ADA6">数理科学</a></li><li><a class="flat-box" href="/blog/categories/%E5%B0%8F%E8%AF%B4%E6%96%87%E8%89%BA" id="blogcategoriesE5B08FE8AFB4E69687E889BA">小说文艺</a></li><li><a class="flat-box" href="/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0" id="blogcategoriesE69D82E8B088E695A3E8AEB0">杂谈散记</a></li><li><a class="flat-box" href="/blog/categories/%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81" id="blogcategoriesE7BFBBE8AF91E4BD9CE59381">翻译作品</a></li></ul></li><li><a class="flat-box" href="/blog/tags/" rel="nofollow" id="blogtags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/blog/friends/" rel="nofollow" id="blogfriends"><i class="fas fa-user-friends fa-fw"></i>友链</a></li><li><a class="flat-box" href="https://miroox.github.io/wiki/" rel="nofollow" id="https:mirooxgithubiowiki"><i class="fab fa-wikipedia-w fa-fw"></i>知识库</a></li></ul></li></ul></div></div></div></header><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/blog/2020/08/wll-rs-design/">【新坑】wll-rs: 用于 Rust 的 Wolfram LibraryLink 接口</a></h1><div class="new-meta-box"><div class="new-meta-item author"><a href="https://miroox.github.io/" rel="nofollow"><img src="/blog/images/avatar.jpg"><p>miRoox</p></a></div><div class="new-meta-item category"><a href="/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/" rel="nofollow"><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><p>代码编程</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i><p>发布于：2020年8月29日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard fa-fw" aria-hidden="true"></i><p>字数：3k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half fa-fw" aria-hidden="true"></i><p>时长：12分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>苦于 Wolfram <a href="http://reference.wolfram.com/language/LibraryLink/tutorial/Overview.html" target="_blank" rel="noopener">LibraryLink</a> 原本的接口使用起来过于繁琐，又受 <a href="https://github.com/njpipeorgan/wll-interface" target="_blank" rel="noopener">wll-interface</a> 的启发，近期开了一个新坑，尝试为 Wolfram LibraryLink 封装一套 Rust 的接口 <a href="https://crates.io/crates/wll" target="_blank" rel="noopener">wll-rs</a>。</p><blockquote><p>阅读本文需要一定 Rust 以及 Wolfram LibraryLink 的基础。</p></blockquote><a id="more"></a><h3 id="目标和基本结构"><a class="markdownIt-Anchor" href="#目标和基本结构"></a> 目标和基本结构</h3><p>既然用上 Rust 这种高级抽象的语言，自然不可能只是做一些简单的绑定。至少要能做到两件事：</p><ol><li>提供安全便利的类型和接口封装</li><li>自动生成满足 LibraryLink 规范的导出函数格式</li></ol><p>为了让不熟悉 Wolfram LibraryLink 的读者也能了解到它使用起来有多麻烦，下面截一段官方示例中的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Include required header */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"WolframLibrary.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the version of Library Link */</span></span><br><span class="line"><span class="function">DLLEXPORT mint <span class="title">WolframLibrary_getVersion</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> WolframLibraryVersion;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize Library */</span></span><br><span class="line"><span class="function">DLLEXPORT <span class="keyword">int</span> <span class="title">WolframLibrary_initialize</span><span class="params">( WolframLibraryData libData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LIBRARY_NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Uninitialize Library */</span></span><br><span class="line"><span class="function">DLLEXPORT <span class="keyword">void</span> <span class="title">WolframLibrary_uninitialize</span><span class="params">( WolframLibraryData libData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Adds one to the input, returning the result  */</span></span><br><span class="line"><span class="function">DLLEXPORT <span class="keyword">int</span> <span class="title">demo_I_I</span><span class="params">( WolframLibraryData libData, mint Argc, MArgument *Args, MArgument Res)</span> </span>&#123;</span><br><span class="line">    mint I0;</span><br><span class="line">    mint I1;</span><br><span class="line">    I0 = MArgument_getInteger(Args[<span class="number">0</span>]);</span><br><span class="line">    I1 = I0 + <span class="number">1</span>;</span><br><span class="line">    MArgument_setInteger(Res, I1);</span><br><span class="line">    <span class="keyword">return</span> LIBRARY_NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了加载库和卸载库时所需要的初始化和反初始化函数外，函数本身的传参形式也非常奇妙，<a href="http://reference.wolfram.com/language/ref/LibraryFunction.html" target="_blank" rel="noopener"><code>LibraryFunction</code></a> 的实参通过 <code>MArgument</code> 的指针（数组）传入，实际的返回结果也在参数列表中，而函数所返回的 <code>int</code> 值则表示一个错误码。</p><p>作为目标，我们期望在 wll-rs 中实现的等效形式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.rs</span></span><br><span class="line"><span class="keyword">use</span> wll::<span class="built_in">Result</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wll::setup]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wll::teardown]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">uninit</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wll::export(demo_I_I)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>(n: <span class="built_in">isize</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">isize</span>&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(n + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即通过 <code>wll::Result</code> 表示返回值和结果状态，通过类属性宏标记函数来自动生成满足 LibraryLink 规范的导出函数。</p><p>有了基本的目标，那么大致的框架也可以确定了：</p><img src="/blog/2020/08/wll-rs-design/structure.png" title="大致框架"><ul><li><a href="https://crates.io/crates/wll-sys" target="_blank" rel="noopener">wll-sys</a> 底层接口绑定</li><li><a href="https://crates.io/crates/wll-macros" target="_blank" rel="noopener">wll-macros</a> 提供类属性过程宏（受Rust本身的限制，过程宏必须由单独的包提供）</li><li><a href="https://crates.io/crates/wll" target="_blank" rel="noopener">wll</a> 整合封装给用户使用的包</li></ul><h3 id="底层接口绑定"><a class="markdownIt-Anchor" href="#底层接口绑定"></a> 底层接口绑定</h3><p>底层接口绑定是一件很无聊的事，不过好在我们有 <a href="https://rust-lang.github.io/rust-bindgen/introduction.html" target="_blank" rel="noopener"><code>bindgen</code></a> 可以从头文件中生成对应的 Rust 文件，大大减轻了我们的工作量。具体操作流程就不再赘述了，直接看官方的文档教程即可。</p><p>稍微值得一提的是，<code>bindgen</code> 生成的文件可能不能满足我们对类型的预期，比如头文件中的宏定义和匿名枚举项，本身不具有类型描述。例如来自宏定义的 <code>True</code> 的类型并不会是 <code>mbool</code>。为了能手动转换复写它们，这里将 <code>bindgen</code> 生成的代码包含在一个 <code>mod</code> 中，再 <code>pub use</code> 导出全部符号，这时，在外部复写也不会导致符号重名的错误了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sys/src/lib.rs 节选</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> bindings &#123;</span><br><span class="line">    include!(<span class="built_in">concat!</span>(<span class="built_in">env!</span>(<span class="string">"OUT_DIR"</span>), <span class="string">"/bindings.rs"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> bindings::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> True: mbool = bindings::True <span class="keyword">as</span> mbool;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> False: mbool = bindings::False <span class="keyword">as</span> mbool;</span><br><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure><p>另外 Wolfram LibraryLink 的接口设计某种意义上是不需要链接的，几乎所有类型都是指针，用来回调的函数也是 <code>WolframLibraryData</code> 的成员函数指针。事实上，在目前的测试中，哪怕没有链接到 <code>WolframRTL</code>，编译得到的 C ABI 动态库（<code>cdylib</code>）只要满足 LibraryLink 的接口规范，一样能正常使用。</p><h3 id="参数类型适配"><a class="markdownIt-Anchor" href="#参数类型适配"></a> 参数类型适配</h3><p>底层接口绑定完成后，就可以开始进行用户层参数的适配了。</p><p>首先考虑错误处理。这里将错误码封装成更具 Rust 风格的 <code>Result</code> 和 <code>Error</code> 对象，以及和错误码之间的相互转换。而为了更友好地向用户表征错误类型，也提供了 <code>ErrorKind</code> 枚举类型，以及其到 <code>Error</code> 类型的转换（见 <a href="https://github.com/miRoox/wll-rs/blob/master/src/errors.rs" target="_blank" rel="noopener"><code>errors.rs</code></a>）。</p><p>在 LibraryLink 的接口中，所有类型的参数都通过 <code>MArgument</code> 来传递，这是一个（untagged）联合体，包含了 LibraryLink 中的各种类型。而我们的用户既不应该直接处理 <code>MArgument</code>，也通常不用直接面对 LibraryLink 的底层类型，而是使用封装后的 Rust 类型。</p><img src="/blog/2020/08/wll-rs-design/types.png" title="类型关系"><p>如图所示，为了支持函数的输入输出，需要有“Rust 类型 - LibraryLink 类型 - <code>MArgument</code>”的双向转换。这里，LibraryLink 类型是可枚举的，因此，它和 <code>MArgument</code> 之间的转换也是可枚举的，同时，从设计上看，这部分转换也是无需暴露给用户的。而对于可能的 Rust 类型，为了给予用户可扩展性，允许用户自定义 Rust 类型和 LibraryLink 类型之间的转换。并且，一旦用户自定义了 Rust 类型和 LibraryLink 类型之间的转换，那么对应的 Rust 类型和 <code>MArgument</code> 之间的转换也应该<strong>自动</strong>被实现。而为了保证最终转换的唯一性，一个 Rust 类型至多只能对应于一个 LibraryLink 类型（反之则不然）。</p><p>小结一下需求：</p><ol><li>LibraryLink 类型和 <code>MArgument</code> 之间的转换预先固定且不暴露给用户；</li><li>Rust 类型和 LibraryLink 类型之间的转换可以由用户自行扩展，但一个 Rust 类型至多只能对应于一个 LibraryLink 类型；</li><li>Rust 类型和 LibraryLink 类型之间的转换 → Rust 类型和 <code>MArgument</code> 之间的转换。</li></ol><p>一个非常平凡的想法是将所有 LibraryLink 类型包到一个 <code>enum</code> 中，毕竟 Rust 的 <code>enum</code> 也就是一种 tagged union，这样也很容易满足一个 Rust 类型至多只对应于一个 LibraryLink 类型。但问题在于这使 <code>MArgument</code> 到 LibraryLink 类型，以及更进一步的，从 <code>MArgument</code> 到 Rust 类型的转换变得困难了起来。虽然 <code>enum</code> 带有标签，但从编译时蕴含的信息上看，它和 <code>union</code> 一样，都抹平了不同类型之间的差异。当从它向 <code>MArgument</code> 转换时，由于它具有的运行时信息更丰富，因此可以实现。然而，反之则不然，如果不向这一过程注入更多类型信息的话，那么实现起来完全无从下手。可是，如果不使用 <code>enum</code> 的话，这些信息本身就存在，再额外注入不仅画蛇添足，似乎也不太符合分离耦合的思想。</p><p>在 Rust 中，我们有两种逻辑委派方法，其中一种是 <code>enum</code>，而另一种是 <code>trait</code> 对象<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。<code>enum</code> 是封闭类型，看上去更符合我们这里的情况，但由于上述原因，并不适合使用；而 <code>trait</code> 对象是开放类型，似乎也没法用在这里。当然，我们这里不需要动态性，所以只需要 <code>trait</code> 而非 <code>trait</code> 对象，但这也为我们提供了另一种可能的思路。</p><p>事实上，<em>sealed trait</em> 模式<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>让我们能将 <code>trait</code> 的实现限制在我们的模块内而无法被外部实现。简而言之，就是让我们的公开 <code>trait</code> 将一个不公开的占位 <code>trait</code> 作为父 <code>trait</code>，从而使外部实现无法满足约束，从而封闭了可能的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adaptor.rs 节选</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> private &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sealed</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MType</span></span>: private::Sealed + <span class="built_in">Sized</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> impl_mtypes &#123;</span><br><span class="line">    ($($t:ty),+) =&gt; &#123;</span><br><span class="line">        $(</span><br><span class="line">            <span class="keyword">impl</span> private::Sealed <span class="keyword">for</span> $t &#123;&#125;</span><br><span class="line">            <span class="keyword">impl</span> MType <span class="keyword">for</span> $t &#123;&#125;</span><br><span class="line">        )+</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl_mtypes!(</span><br><span class="line">    mbool,</span><br><span class="line">    mint,</span><br><span class="line">    mreal,</span><br><span class="line">    mcomplex,</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在这里，我们将所有的 LibraryLink 类型都实现为 <code>MType trait</code>。这只是一个开端，我们还需要提供它们的适配关系接口。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">InputAdaptor</span></span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Input</span></span>: MType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mtype_try_from</span></span>(input: Self::Input) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">OutputAdaptor</span></span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>: MType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_into_mtype</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到一个 Rust 类型至多只对应于一个 LibraryLink 类型。将对应的 LibraryLink 类型作为适配 <code>trait</code> 的关联类型显然是比较合适的。而为了自动实现 Rust 类型和 <code>MArgument</code> 之间的转换，可以采用所谓的 <em>blanket implementations</em><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 来传递这种转换关系。然而，不同 LibraryLink 类型对应 <code>MArgument</code> 的字段不同，需要 <em>ad-hoc</em> 实现，而同一个 <code>trait</code> 的 <em>blanket implementations</em> 不能区分具有不同关联类型的同种 <code>trait</code>。因此 <code>MArgument</code> 的转换 <code>trait</code> 必须是具有泛型类型参数的 <code>trait</code>，通过完全特化的实现来满足这种对应关系。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MArgumentGetter</span></span>&lt;T: MType&gt;: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_get_arg</span></span>(arg: MArgument) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MArgumentSetter</span></span>&lt;T: MTypeOrVoid&gt;: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_set_arg</span></span>(<span class="keyword">self</span>, arg: &amp;MArgument) -&gt; <span class="built_in">Result</span>&lt;()&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: InputAdaptor&lt;Input = mbool&gt;&gt; MArgumentGetter&lt;mbool&gt; <span class="keyword">for</span> T &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_get_arg</span></span>(arg: MArgument) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> ptr = arg.boolean;</span><br><span class="line">            <span class="keyword">if</span> ptr.is_null() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(Error::from(ErrorKind::TypeError));</span><br><span class="line">            &#125;</span><br><span class="line">            T::mtype_try_from(std::ptr::read(ptr))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: OutputAdaptor&lt;Output = mbool&gt;&gt; MArgumentSetter&lt;mbool&gt; <span class="keyword">for</span> T &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_set_arg</span></span>(<span class="keyword">self</span>, arg: &amp;MArgument) -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> ptr = arg.boolean;</span><br><span class="line">            <span class="keyword">if</span> ptr.is_null() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(Error::from(ErrorKind::TypeError));</span><br><span class="line">            &#125;</span><br><span class="line">            std::ptr::write(ptr, <span class="keyword">self</span>.try_into_mtype()?);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure><p><code>#[doc(hidden)]</code> 表明这部分不应被用户直接使用。实际的实现代码为了避免繁琐易错的复制粘贴，是通过宏完成的（见 <a href="https://github.com/miRoox/wll-rs/blob/master/src/adaptor.rs" target="_blank" rel="noopener"><code>adaptor.rs</code></a>）。</p><p>最终的类型适配关系如图所示：</p><img src="/blog/2020/08/wll-rs-design/adaptor.png" title="类型适配"><h3 id="访问-wolframlibrarydata"><a class="markdownIt-Anchor" href="#访问-wolframlibrarydata"></a> 访问 <code>WolframLibraryData</code></h3><p>由于 LibraryLink 的所有函数都是回调式的，各种函数的调用都免不了要访问当前的 <code>WolframLibraryData</code>。然而我们显然是不会希望各个函数都要带着一个 <code>WolframLibraryData</code> 的参数到处跑的，因此，一种直观的方式是使用一个全局静态对象，并在适时处设置它以实现别的函数对它的访问。不过这部分的设计尚未完全确定，在此也不多费口舌了。</p><h3 id="类属性过程宏"><a class="markdownIt-Anchor" href="#类属性过程宏"></a> 类属性过程宏</h3><p>为了便利地从 Rust 函数中创建满足 LibraryLink 的接口规范的导出函数，可以通过类属性过程宏来解决这一麻烦。</p><p>这部分实现在 <a href="https://crates.io/crates/wll-macros" target="_blank" rel="noopener">wll-macros</a>，并在 wll 设置了 <code>macros</code> feature 时会重新导出其中的宏（似乎由于 Rust 本身的限制，过程宏的重导出必须这么做）。</p><p>其中</p><ul><li><code>setup</code> 会将它标记的函数放到 <code>WolframLibrary_initialize</code> 中调用，并补上 <code>WolframLibrary_getVersion</code>；</li><li><code>teardown</code> 会将它标记的函数放到 <code>WolframLibrary_uninitialize</code> 中调用；</li><li><code>export</code> 有两种形式：<ul><li>当它不包含参数时，会给原本的函数名前面加上 <code>wll_</code> 并按 LibraryLink 的接口规范导出函数；</li><li>当它包含参数时，则按参数名作为导出函数的名称，同样按 LibraryLink 的接口规范导出。</li></ul></li></ul><p>过程宏在官方资料中描述不多，但本身又非常繁琐，因此在这里就不多赘述了，推荐观看<a href="https://www.youtube.com/watch?v=geovSK3wMB8" target="_blank" rel="noopener">视频</a>进行学习。</p><p>这里给出前述 <code>demo.rs</code> 进行宏展开后的结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cargo expand demo.rs</span></span><br><span class="line"><span class="keyword">use</span> wll::<span class="built_in">Result</span>;</span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">WolframLibrary_initialize</span></span>(</span><br><span class="line">    data: ::wll::sys::WolframLibraryData,</span><br><span class="line">) -&gt; ::wll::sys::errcode_t &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> ::std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(e) = ::wll::global::initialize_lib_data(data) &#123;</span><br><span class="line">        e.to_raw_error()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        ::wll::sys::LIBRARY_NO_ERROR</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">WolframLibrary_getVersion</span></span>() -&gt; ::wll::sys::mint &#123;</span><br><span class="line">    ::wll::sys::WolframLibraryVersion</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">uninit</span></span>() &#123;&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">WolframLibrary_uninitialize</span></span>(_: ::wll::sys::WolframLibraryData) &#123;</span><br><span class="line">    uninit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>(n: <span class="built_in">isize</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">isize</span>&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(n + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">demo_I_I</span></span>(</span><br><span class="line">    lib_data: ::wll::sys::WolframLibraryData,</span><br><span class="line">    argc: ::wll::sys::mint,</span><br><span class="line">    args: *<span class="keyword">const</span> ::wll::sys::MArgument,</span><br><span class="line">    res: ::wll::sys::MArgument,</span><br><span class="line">) -&gt; ::wll::sys::errcode_t &#123;</span><br><span class="line">    <span class="keyword">use</span> ::wll::adaptor::&#123;MArgumentGetter, MArgumentSetter&#125;;</span><br><span class="line">    <span class="keyword">let</span> _lib_data = ::wll::global::LibDataLocalizer::new(lib_data);</span><br><span class="line">    <span class="keyword">if</span> argc != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ::wll::sys::LIBRARY_TYPE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arg0 = <span class="keyword">match</span> &lt;<span class="built_in">isize</span>&gt;::try_get_arg(args.add(<span class="number">0usize</span>).read()) &#123;</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Ok</span>(val) =&gt; val,</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> err.to_raw_error(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">match</span> add_one(arg0) &#123;</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Ok</span>(val) =&gt; val,</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> err.to_raw_error(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">match</span> ret.try_set_arg(&amp;res) &#123;</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Ok</span>(()) =&gt; ::wll::sys::LIBRARY_NO_ERROR,</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(err) =&gt; err.to_raw_error(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>文章简单介绍了一下 wll 的基本设计和目前的进展。通过这个项目我也熟悉了Rust 的 bindgen、过程宏以及 <code>trait</code> 的各种高级用法。顺便 LibraryLink 的接口规范虽然繁琐，但也不失为一种具有灵活性和强兼容性的接口设计方案。不过 wll 还处于相当早期的开放阶段，虽然提供了简单的 <code>Complex&lt;T&gt;</code> 复数类型，但功能并不完整。而像 <code>MTensor</code>, <code>MNumericArray</code> 等类型对应的 Rust 高级类型和适配都尚未开始，开发完善的路途依旧漫长。</p><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.possiblerust.com/guide/enum-or-trait-object" target="_blank" rel="noopener">Enum or Trait Object</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed" target="_blank" rel="noopener">Rust API Guidelines: C-SEALED</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html" target="_blank" rel="noopener">Traits: Defining Shared Behavior</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section><div class="article_footer"><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="http://miroox.github.io/blog/2020/08/wll-rs-design/">http://miroox.github.io/blog/2020/08/wll-rs-design/</a></p></blockquote></div></section></div></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2023-03-02T00:49:53+00:00"><a class="notlink"><i class="fas fa-edit fa-fw" aria-hidden="true"></i><p>更新于：2023年3月2日</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/blog/tags/%E7%BC%96%E7%A8%8B/" rel="nofollow"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><p>编程</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/blog/tags/Wolfram/" rel="nofollow"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><p>Wolfram</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/" rel="nofollow"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><p>元编程</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/blog/tags/Rust/" rel="nofollow"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><p>Rust</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/blog/tags/LibraryLink/" rel="nofollow"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><p>LibraryLink</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" rel="external nofollow noopener noreferrer noopener" href="http://connect.qq.com/widget/shareqq/index.html?url=http://miroox.github.io/blog/2020/08/wll-rs-design/&title=【新坑】wll-rs: 用于 Rust 的 Wolfram LibraryLink 接口 - miRoox的博客&summary=苦于 Wolfram LibraryLink 原本的接口使用起来过于繁琐，又受 wll-interface 的启发，近期开了一个新坑，尝试为 Wolfram LibraryLink 封装一套 Rust 的接口 wll-rs。阅读本文需要一定 Rust 以及 Wolfram LibraryLink 的基础。" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png"> </a><a class="-mob-share-qzone" rel="external nofollow noopener noreferrer noopener" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://miroox.github.io/blog/2020/08/wll-rs-design/&title=【新坑】wll-rs: 用于 Rust 的 Wolfram LibraryLink 接口 - miRoox的博客&summary=苦于 Wolfram LibraryLink 原本的接口使用起来过于繁琐，又受 wll-interface 的启发，近期开了一个新坑，尝试为 Wolfram LibraryLink 封装一套 Rust 的接口 wll-rs。阅读本文需要一定 Rust 以及 Wolfram LibraryLink 的基础。" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png"> </a><a class="-mob-share-weibo" rel="external nofollow noopener noreferrer noopener" href="http://service.weibo.com/share/share.php?url=http://miroox.github.io/blog/2020/08/wll-rs-design/&title=【新坑】wll-rs: 用于 Rust 的 Wolfram LibraryLink 接口 - miRoox的博客&summary=苦于 Wolfram LibraryLink 原本的接口使用起来过于繁琐，又受 wll-interface 的启发，近期开了一个新坑，尝试为 Wolfram LibraryLink 封装一套 Rust 的接口 wll-rs。阅读本文需要一定 Rust 以及 Wolfram LibraryLink 的基础。" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png"></a></div></div></div></section><div class="prev-next"><a class="prev" href="/blog/2020/08/WolframURLShortenForm/"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>部署一个简单的缩略 URL 的表单</p><p class="content">最近微博好像把 github.io 下的域名屏蔽了，导致博客完全无法分享，就考虑通过短链接跳转绕开这一限制。考虑到 Mathematica 有现成的函数 URLShorten，直接使用即可。不过...</p></a><a class="next" href="/blog/2020/07/WolframGitHubViewer/"><p class="title">预览在 GitHub 上的 Wolfram 笔记本<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">不知道啥时候，Wolfram 官方偷偷上线了一个在线预览 GitHub 仓库中的笔记本的网页应用。有了这个，大家就不用花自己的 Cloud Credits 来部署笔记本，而只要把笔记本同步到 G...</p></a></div></section></article><article class="post white-box reveal comments shadow"><section class="article typo"><p ct><i class="fas fa-comments"></i> 评论</p><section id="comments"><div id="gitalk-container"></div></section><section id="comments"><div id="valine_container" class="valine_thread"><i class="fas fa-cog fa-spin fa-fw fa-2x"></i></div></section></section></article><script>window.subData={title:"【新坑】wll-rs: 用于 Rust 的 Wolfram LibraryLink 接口",tools:!0}</script></div><aside class="l_side"><section class="widget text shadow desktop mobile"><header><i class="fas fa-bell fa-fw" aria-hidden="true"></i><span class="name">布告板</span></header><div class="content"><p>博客迁移中……</p></div></section><section class="widget toc-wrapper shadow desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#目标和基本结构"><span class="toc-text">目标和基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#底层接口绑定"><span class="toc-text">底层接口绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数类型适配"><span class="toc-text">参数类型适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问-wolframlibrarydata"><span class="toc-text">访问 WolframLibraryData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类属性过程宏"><span class="toc-text">类属性过程宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></div></section></aside><footer class="clearfix"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.7" loop order="random" fixed="false" list-max-height="340px" server="netease" type="playlist" id="592343641" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/blog/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:miroox@outlook.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://weibo.com/MiFantasy000" class="social fab fa-weibo flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://twitter.com/miroox6" class="social fab fa-twitter flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://www.zhihu.com/people/lu-yong-8-79" class="social fab fa-zhihu flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/miRoox" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=415505414" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p></div><div class="copyright"><p><a href="https://miroox.github.io/">Copyright © 2017-2021 miRoox</a> Powered by the <a href="https://volantis.js.org/" target="_blank" rel="noopener">Volantis theme</a> for <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p></div></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/blog/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script><script type="text/javascript">$(function(){ScrollReveal().reveal(".l_main .reveal",{distance:"8px",duration:"800",interval:"100",scale:"1"})})</script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var a=["images/bg1.jpg","images/bg2.jpg"];!function(a){for(var r=a.length;r--;){var o=Math.floor(Math.random()*r),t=a[o];a[o]=a[r],a[r]=t}}(a),$(".cover").backstretch(a,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"72d968977988a0f2857a",clientSecret:"545b7fd3220ded515ef4b37df88eacb7a0d25387",repo:"blog",owner:"miRoox",admin:"miRoox",id:location.pathname,distractionFreeMode:!1});gitalk.render("gitalk-container")</script><script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script><script>var GUEST_INFO=["nick","mail","link"],meta="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),REQUIRED_FIELDS=["nick","mail","link"],requiredFields="nick,mail".split(",").filter(function(i){return-1<REQUIRED_FIELDS.indexOf(i)}),valine=new Valine;function emoji(i,e,a){return i+"/"+i+"-"+e+"."+a}for(var emojiMaps={},i=1;i<=54;i++)emojiMaps["tieba-"+i]=emoji("tieba",i,"png");for(i=1;i<=101;i++)emojiMaps["qq-"+i]=emoji("qq",i,"gif");for(i=1;i<=116;i++)emojiMaps["aru-"+i]=emoji("aru",i,"gif");for(i=1;i<=125;i++)emojiMaps["twemoji-"+i]=emoji("twemoji",i,"png");for(i=1;i<=4;i++)emojiMaps["weibo-"+i]=emoji("weibo",i,"png");valine.init({el:"#valine_container",meta:meta,appId:"dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",appKey:"u0NdtQ8nvHoMdJPSYqm1LRxE",placeholder:"快来评论吧~",pageSize:"10",avatar:"robohash",lang:"zh-cn",visitor:"true",highlight:"true",mathJax:"false",enableQQ:"true",requiredFields:requiredFields,emojiCDN:"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/",emojiMaps:emojiMaps})</script><script src="/blog/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.4/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script type="text/javascript" color="27,195,251" opacity="0.7" zindex="-1" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script>setLoadingBarProgress(100)</script></body></html>