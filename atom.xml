<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miRoox的博客</title>
  
  <subtitle>我唯一知道的就是我一无所知 ——苏格拉底</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://miRoox.github.io/blog/"/>
  <updated>2020-01-25T04:11:48.800Z</updated>
  <id>http://miRoox.github.io/blog/</id>
  
  <author>
    <name>miRoox</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用 GitHub Actions 自动化构建和发布 Qt 程序的一点经验</title>
    <link href="http://miRoox.github.io/blog/2019/12/AboutGitHubActionsCIQt/"/>
    <id>http://miRoox.github.io/blog/2019/12/AboutGitHubActionsCIQt/</id>
    <published>2019-12-10T14:24:54.000Z</published>
    <updated>2020-01-25T04:11:48.800Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵子 GitHub 正式发布了 <a href="https://github.com/features/actions" target="_blank" rel="noopener">Actions</a> 功能来提供内置的持续集成和持续发布。而我正好最近在利用 Qt 写<a href="https://github.com/miRoox/HIT-DigitalImageProcessing-Postgraduate" target="_blank" rel="noopener">数字图像处理的作业</a>，就想利用这个机会尝试一下基于 GitHub Actions 的持续集成。</p><a id="more"></a><p>当然，有问题首先是找轮子。很快我就找到了 <a href="https://github.com/jaredtao/HelloActions-Qt" target="_blank" rel="noopener">jaredtao/HelloActions-Qt</a>，以及相关的几篇博客文章<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。照猫画虎很快就把各个平台下的自动构建弄成了。但那篇关于自动发行的文章<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>对多配置下 <a href="https://github.com/actions/create-release" target="_blank" rel="noopener">create-release</a> 重复执行导致失败这一问题的解决方案不太令我满意，总觉得太繁琐了，而且我对其中所用的 PowerShell 也不熟。不过这个问题显然不是特殊情况，想必也曾有人就此提出了问题，而也许已经有别人回答了更好的解决方案也不一定。果不其然，早就有人在 create-release 的仓库下的 issues 中提出过这个问题，并且这个 issue 尚未关闭，也就是并没有一个非常令人满意的解答。不过，其中有一个回答<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>给我一点启发，它将使用多种配置的发布任务与创建 release 的任务分开，而通过 <a href="https://github.com/actions/upload-artifact" target="_blank" rel="noopener">upload-artifact</a> 和 <a href="https://github.com/actions/upload-artifact" target="_blank" rel="noopener">download-artifact</a> 来传递 release URL。另一个关联的仓库也有人给出了类似的思路<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">build(mac)       build(linux)        build(win)</span><br><span class="line">    │                  │                 │</span><br><span class="line">    └──────────────────┼─────────────────┘</span><br><span class="line">                       │</span><br><span class="line">                create_release()</span><br><span class="line">                       │</span><br><span class="line">    ┌──────────────────┼─────────────────┐</span><br><span class="line">    │                  │                 │</span><br><span class="line">upload(mac)       upload(linux)      upload(win)</span><br></pre></td></tr></table></figure><p>不过这种任务结构让构建和上传两个阶段的文件对应变得麻烦起来。受此启发，我想到了另一种可能——<code>create_release()</code>真的一定要在<code>build(...)</code>完成之后才能进行吗？因为我们需要创建 release 的时候一定是在发布 tag 的时候，这时我们通常已经在 commit 时检验过一遍是否通过构建/测试了，因此不妨将<code>create_release()</code>提前，于是有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                create_release()*</span><br><span class="line">                       │</span><br><span class="line">    ┌──────────────────┼─────────────────┐</span><br><span class="line">    │                  │                 │</span><br><span class="line"> build(mac)        build(linux)       build(win)</span><br><span class="line">    &amp;                  &amp;                 &amp;</span><br><span class="line">upload(mac)*      upload(linux)*     upload(win)*</span><br></pre></td></tr></table></figure><p><code>*</code>表示只在发布 tag 的时候才会进行这个步骤。这里将<code>build(...)</code>和<code>upload(...)</code>两个阶段合在同一个job中，便于传递文件。最终配置如 <a href="https://github.com/miRoox/HIT-DigitalImageProcessing-Postgraduate/blob/master/.github/workflows/build.yml" target="_blank" rel="noopener">.github/workflows/build.yml</a> 所示。</p><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://jaredtao.github.io/2019/11/19/Qt%E4%BD%BF%E7%94%A8github-Actions%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91/" target="_blank" rel="noopener">Qt使用github-Actions自动化编译</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://jaredtao.github.io/2019/12/03/Qt%E4%BD%BF%E7%94%A8github-Actions%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E8%A1%8C/" target="_blank" rel="noopener">Qt使用github-Actions自动化发行</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://github.com/actions/create-release/issues/14#issuecomment-555379810" target="_blank" rel="noopener">How to prevent creating multiple releases when using a build matrix?</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://github.com/actions/upload-release-asset/issues/16#issuecomment-561257944" target="_blank" rel="noopener">Support matrix build</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一阵子 GitHub 正式发布了 &lt;a href=&quot;https://github.com/features/actions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Actions&lt;/a&gt; 功能来提供内置的持续集成和持续发布。而我正好最近在利用 Qt 写&lt;a href=&quot;https://github.com/miRoox/HIT-DigitalImageProcessing-Postgraduate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数字图像处理的作业&lt;/a&gt;，就想利用这个机会尝试一下基于 GitHub Actions 的持续集成。&lt;/p&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="GitHub" scheme="http://miRoox.github.io/blog/tags/GitHub/"/>
    
      <category term="Qt" scheme="http://miRoox.github.io/blog/tags/Qt/"/>
    
      <category term="持续集成" scheme="http://miRoox.github.io/blog/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们需要术语——兼谈科普的危害性</title>
    <link href="http://miRoox.github.io/blog/2019/11/TerminologyAndPopularScience/"/>
    <id>http://miRoox.github.io/blog/2019/11/TerminologyAndPopularScience/</id>
    <published>2019-11-05T13:03:42.000Z</published>
    <updated>2020-01-25T04:11:48.800Z</updated>
    
    <content type="html"><![CDATA[<p>写下这篇文章的起源是在知乎上看到的一个回答<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p><blockquote><p>很简单，就是硬抬杠。</p><p>举个例子，我说偶数跟正整数一样多，你就说怎么可能，正整数包含奇数和偶数，所以肯定正整数多。</p><p>我解释说偶数跟正整数存在一个一一映射，并且都含有无穷多元素，所以一样多。你就说我听不懂什么一一映射，我只知道我是你的两倍，所以肯定比你多。</p><p>那我解释，1对应2，2对应4，3对应6，一直这样下去，每个正整数都对应一个偶数。他就是不同意，说你说话就在放屁，我给你一百块，你给我两百块，一直这样我们看看最后谁的钱多？</p><p>我说这在有限的情况下是对的，但是无穷的情况下就不一定了。你就说无穷不就是特别大的数嘛，那我大一你倍不是大你更多？</p><p>我说wdnmd吧，你就说你怎么骂人呢？</p></blockquote><p>在这个回答里，作者似乎把对于无法将无穷集合的等势理解成“一样多”的普通人思维当作抬杠。但这件事就真的只是抬杠这么肤浅吗？</p><a id="more"></a><p>需要明确的是，“一样多”是自然语言的提法，不是一个严格的数学术语。基于基数的比较方式可以在有限的时候和我们平时说的一样多是一致的，因此我们将其推广到无穷意义下的一样多。但这个对应不是唯一的，我们可以构造另一个比较方式依然满足有限意义的“一样多”，却在无限集的比较晚得到不同的结果。比如：</p><p>不妨定义区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-a,a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span> 与集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的交集的元素个数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N_A(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span> ，然后定义集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 和集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的“元素比值”为</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>a</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></munder><mfrac><mrow><msub><mi>N</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>N</mi><mi>B</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">p(A,B)=\lim_{a\to\infty}\frac{N_A(a)}{N_B(a)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-2.1em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>当“元素比值” <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p(A,B)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，则称集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的元素“一样多”。显然，这个定义在集合有限时和我们的认知依然是一致的，因此也可以作为“一样多”的一个推广。但如果拿来比较整数和偶数，结果则不会是“一样多”，而前者对后者的“元素比值”为2，似乎更符合我们的直观认识。</p><p>当然，上面这个定义显然不会是我们的数学所想要的。因为这个定义过于平凡了，以至于即使在面对像有理数集这样的可数集时也会无法定义，这与数学所追求最广泛意义上的一致性是相违背的。因而，“势”依然是对任意集合的大小进行度量的最佳方式，也是我们在数学中普遍采用的。但这一概念如果反过来作为日常用语中的“一样多”的替代，则无疑是术语的滥觞，只会令人更加迷惑，无益于辨清问题的边界。</p><p>也许一个来自数学自身的例子更能展现这种概念拓展的不唯一性：维数——我们有线性空间的维数（自由度）、拓扑维数乃至各式各样的分形维数，它们最初都来自我们日常对空间方位的直观认知。但它们都是在各自领域中抽象出来的概念，并不能简单地断言谁是一般意义上最佳的定义。</p><p>不过，概念的推广与取代在学术界内部确实广为存在，每一次取代本身可以认为是对概念更深刻的理解。虽说如此，明辨问题的边界和语境对业内人士同样重要，至少应该采取明确的上下文或者精准唯一的术语来进行描述。</p><p>如果说概念的泛化推广是抽象和发散思维的体现，那么划定专有术语和明晰边界则是具体和确定性的追求。这两点对于研究者而言都具有程度相当的重要性。如何在两者间取得平衡，对科研人员也并非易事，更遑论科普读物和它们的读者了。能把握住这当中的微妙的，大概《物理学咬文嚼字》尚且能算一个比较好的例子吧。</p><p>针对科普作品，19世纪伟大的物理学家麦克斯韦曾写下这样的忠告<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p><blockquote><p>In the popular treatise, whatever shreds of the science are allowed to appear, are exhibited in an exceedingly diffuse and attenuated form, apparently with the hope that the mental faculties of the reader, though they would reject any stronger food, may insensibly become saturated with scientific phraseology, provided it is diluted with a sufncient quantity of more familiar language. In this way, by simple reading, the student may become possessed of the phrases of the science without having been put to the trouble of thinking a single thought about it. The loss implied in such an acquisition can be estimated only by those who have been compelled to unlearn a science that they might at length begin to learn it.</p><p>The technical treatises do less harm, for no one ever reads them except under compulsion. From the establishment of the general equations to the end of the book, every page is full of symbols with indices and suffixes, so that there is not a paragraph of plain English on which the eye may rest.</p></blockquote><p>确实，科普读物对专业术语的稀释一定程度上也是对读者深入思维能力的一种伤害。进一步地，这种对术语的浅薄化，对业已进入专业行列的“原读者”乃至科普作者自身的辨析能力也会造成不经意的伤害；而这种伤害又反过来进一步拉大了科学概念与一般人之间的距离，令人以为这些被“通俗化”所粉饰的概念就一定能为大众所理解，构成现代科学版的“何不食肉糜”，不得不令人扼腕。</p><p>当然，科普工作也不尽然都是坏的。哪怕是稀释过的概念知识，倘若能抓住精要，不会因为注水过多而浅尝辄止，那么从科普中浸润的少量知识反而更能让人甘之如饴，激发探索深入的兴趣。只是，倘若能在科普中就更好的明辨当中的概念和术语，大概会减少那些因模糊的粉饰而对长远的研究道路所造成的伤害吧。</p><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.zhihu.com/question/338618946/answer/779204340" target="_blank" rel="noopener">如何激怒一位数学爱好者？ - 孙泰英的回答 - 知乎</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>MAXWELL J C. Tait’s “Thermodynamics”[J]. Nature, 1878, 17(431): 257–259. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写下这篇文章的起源是在知乎上看到的一个回答&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很简单，就是硬抬杠。&lt;/p&gt;
&lt;p&gt;举个例子，我说偶数跟正整数一样多，你就说怎么可能，正整数包含奇数和偶数，所以肯定正整数多。&lt;/p&gt;
&lt;p&gt;我解释说偶数跟正整数存在一个一一映射，并且都含有无穷多元素，所以一样多。你就说我听不懂什么一一映射，我只知道我是你的两倍，所以肯定比你多。&lt;/p&gt;
&lt;p&gt;那我解释，1对应2，2对应4，3对应6，一直这样下去，每个正整数都对应一个偶数。他就是不同意，说你说话就在放屁，我给你一百块，你给我两百块，一直这样我们看看最后谁的钱多？&lt;/p&gt;
&lt;p&gt;我说这在有限的情况下是对的，但是无穷的情况下就不一定了。你就说无穷不就是特别大的数嘛，那我大一你倍不是大你更多？&lt;/p&gt;
&lt;p&gt;我说wdnmd吧，你就说你怎么骂人呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这个回答里，作者似乎把对于无法将无穷集合的等势理解成“一样多”的普通人思维当作抬杠。但这件事就真的只是抬杠这么肤浅吗？&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈散记" scheme="http://miRoox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="杂谈" scheme="http://miRoox.github.io/blog/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="科普" scheme="http://miRoox.github.io/blog/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>如何提交函数到 Wolfram Function Repository</title>
    <link href="http://miRoox.github.io/blog/2019/10/SubmitFunctionToWFR/"/>
    <id>http://miRoox.github.io/blog/2019/10/SubmitFunctionToWFR/</id>
    <published>2019-10-12T07:23:32.000Z</published>
    <updated>2020-01-25T04:11:48.800Z</updated>
    
    <content type="html"><![CDATA[<p>首先，你需要一个 <a href="https://account.wolfram.com/" target="_blank" rel="noopener">Wolfram 账户</a>。</p><a id="more"></a><p>然后，你需要<a href="https://datarepository.wolframcloud.com/request-publisher-id" target="_blank" rel="noopener">申请一个 Publisher ID</a>，这点在许多讲述提交函数到WFR的文章中都没提到。大致的申请流程可以在<a href="https://reference.wolfram.com/language/workflow/AcquireAResourceSystemPublisherID.html" target="_blank" rel="noopener">参考文档</a>里找到。</p><p>然后在 Mathematica 中新建一个函数知识库项。按<a href="https://resources.wolframcloud.com/FunctionRepository/style-guidelines" target="_blank" rel="noopener">风格指南</a>编写函数代码和文档。</p><p>提交前要检查 Mathematica 有没有登录到你的 Wolfram 账户，可以根据 <code>$WolframID</code> 的值确认。而且应该将 <code>$PublisherID</code> 的值设置为你申请到的 Publisher ID。</p><p>当然，提交之前还应该用菜单中的“Check”按钮检查格式无误后再提交。最后点击“Submit to Repository”，接下来就等邮件吧。无论 review 有没有通过一般都会发邮件进行通知。没有通过的话往往还会附上 review comments 指导你改进，并且可以完善后再提交更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，你需要一个 &lt;a href=&quot;https://account.wolfram.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wolfram 账户&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>尝试用TiddlyWiki搭建个人维基知识库</title>
    <link href="http://miRoox.github.io/blog/2019/10/PersonalWiki/"/>
    <id>http://miRoox.github.io/blog/2019/10/PersonalWiki/</id>
    <published>2019-10-10T12:44:23.000Z</published>
    <updated>2020-01-25T04:11:48.800Z</updated>
    
    <content type="html"><![CDATA[<p>搭建一个个人维基用来整理知识的想法早已有之，但具体该使用什么方案却迟迟没能定下来。在最初的想法里，我希望满足下面的几项需求：</p><ul><li>内容与表现分离</li><li>自动化构建</li><li>可以使用自己定制的模板</li><li>词条的分类灵活，以适应知识体系的逐渐完善</li><li>方便建立知识点（词条）间的联系</li><li>需要用笔记时能快速提取</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span> 公式输入</li><li>代码块语法高亮</li></ul><a id="more"></a><p>作为参考，见过别人用 <a href="https://www.dokuwiki.org/dokuwiki" target="_blank" rel="noopener">Dokuwiki</a> 的，也有直接拿 Hexo 的 <a href="https://github.com/zthxxx/hexo-theme-Wikitten" target="_blank" rel="noopener">Wikitte</a> 主题搭建的，等等。当然，我自己也做过一些尝试，比如 <a href="https://www.zim-wiki.org/" target="_blank" rel="noopener">Zim Wiki</a> ，不过这个太简陋了，完全无法满足我的需求；甚至受 <a href="http://wuli.wiki/" target="_blank" rel="noopener">小时物理百科</a> 的影响，尝试过用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span> 构建维基，但 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span> 对于我的需求而言又稍显复杂了，而且大量交叉引用在PDF中也并不方便阅读。最后在一番比较和取舍之下选择了<a href="https://tiddlywiki.com/" target="_blank" rel="noopener">TiddlyWiki</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><p>TiddlyWiki，按官方说法是<a href="https://github.com/Jermolene/TiddlyWiki5#readme" target="_blank" rel="noopener">「一款非线性个人 Web 笔记本」</a>。相比其他笔记和 Wiki 系统，其最大的特点之一是程序本体和数据全部都在一个 html 文件内，这意味着组织和阅读多个词条可以在同一个页面内直接完成，内容的关联更加直接，方便互相比照。同时，还有着非常强大的条目管理功能和插件系统，可扩展性和可定制性都很强。</p><p>TiddlyWiki 的优点还有很多<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，这里就不多赘述了。就我而言，更想简单说一下 TiddlyWiki 是如何满足前面提到的几项需求的：</p><ul><li>内容与表现分离：<ul><li>这一项近乎是一种哲学理念，实践起来是否须要完全符合还是看具体情况。</li><li>典型地，<a href="http://www.tiddlywiki.cn/#WikiText" target="_blank" rel="noopener">WikiText</a> 就提供了很多特定语义的语法元素，还有宏、模板嵌入等各种自定义工具。</li><li>当然，经典地 HTML-CSS-JS 结构也是可以使用的。</li></ul></li><li>自动化构建：<ul><li>通过使用 Node.js 上的 <a href="http://www.tiddlywiki.cn/#Installing%20TiddlyWiki%20on%20Node.js" target="_blank" rel="noopener">TiddlyWiki</a> 服务可以在本地同步保存修改；</li><li>用 Git 和 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 实现向 Github Pages 自动部署。</li></ul></li><li>可以使用自己定制的模板：<ul><li>这一项其实是“内容与表现分离”的具体实践方法之一。</li><li>WikiText 支持模板条目和宏。</li></ul></li><li>词条的分类灵活，以适应知识体系的逐渐完善：<ul><li>TiddlyWiki 是基于标签分类的，一个词条可以分到多个标签下，这一点比许多按树状层级分类的方案要灵活得多。</li></ul></li><li>方便建立知识点（词条）间的联系：<ul><li>词条链接和词条嵌入。</li></ul></li><li>需要用笔记时能快速提取：<ul><li>能自动部署到网页上，有网就能看；</li><li>还有灵活的搜索语法。</li></ul></li><li>LaTeX公式输入：<ul><li>KaTeX插件：支持的命令较少，不过是官方提供的，安装很容易。</li><li><a href="http://mathjax-tw5.kantorsite.net/" target="_blank" rel="noopener">MathJax插件</a>：第三方提供的，比较老了，好像和新版不太兼容，需要折腾（反正我没能折腾成功）。</li></ul></li><li>代码块语法高亮<ul><li>Highlight.js插件：这也是官方提供的。</li></ul></li></ul><p>除此之外，TiddlyWiki 还有一大优点是简单，几乎所有操作都可以在网页上完成，基本不用到处配置。这对于我这种对web技术基本一无所知的人来说是一个极大的优势。</p><p>不过也因为我对web技术的不了解，导致很大的功夫都花在自动部署的配置上了，最终也只是是照猫画虎。其间主要参考了 alexashley 的个人Wiki源码<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>、JavaScript 标准参考教程（alpha）<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>、《Blog自动部署实践: Hugo + Travis CI -&gt; GitHub Pages》<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>等资料。</p><p>最终弄出来的成品在：<a href="https://miroox.github.io/wiki/">https://miroox.github.io/wiki/</a></p><hr><p>参考资料：</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="http://www.tiddlywiki.cn/" target="_blank" rel="noopener">TiddlyWiki中文网站</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="http://blog.dimpurr.com/tiddly-wiki/" target="_blank" rel="noopener">使用 TiddlyWiki 打造轻便个人 Wiki 知识库</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://github.com/alexashley/wiki" target="_blank" rel="noopener">alexashley 的个人Wiki源码</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="http://javascript.ruanyifeng.com/nodejs/packagejson.html" target="_blank" rel="noopener">package.json文件 - JavaScript 标准参考教程（alpha）</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://blog.yuantops.com/tech/hugo-travis-ci-auto-deploy-to-gh-pages/" target="_blank" rel="noopener">Blog自动部署实践: Hugo + Travis CI -&gt; GitHub Pages</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建一个个人维基用来整理知识的想法早已有之，但具体该使用什么方案却迟迟没能定下来。在最初的想法里，我希望满足下面的几项需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内容与表现分离&lt;/li&gt;
&lt;li&gt;自动化构建&lt;/li&gt;
&lt;li&gt;可以使用自己定制的模板&lt;/li&gt;
&lt;li&gt;词条的分类灵活，以适应知识体系的逐渐完善&lt;/li&gt;
&lt;li&gt;方便建立知识点（词条）间的联系&lt;/li&gt;
&lt;li&gt;需要用笔记时能快速提取&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mtext&gt;LaTeX&lt;/mtext&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\LaTeX&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.89883em;vertical-align:-0.2155em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord text&quot;&gt;&lt;span class=&quot;mord textrm&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:-0.36em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.68333em;&quot;&gt;&lt;span style=&quot;top:-2.904999em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord text&quot;&gt;&lt;span class=&quot;mord textrm sizing reset-size6 size3&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:-0.15em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord text&quot;&gt;&lt;span class=&quot;mord textrm&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:-0.1667em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.46782999999999997em;&quot;&gt;&lt;span style=&quot;top:-2.7845em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:3em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord text&quot;&gt;&lt;span class=&quot;mord textrm&quot;&gt;E&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.2155em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:-0.125em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord textrm&quot;&gt;X&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 公式输入&lt;/li&gt;
&lt;li&gt;代码块语法高亮&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Wiki" scheme="http://miRoox.github.io/blog/tags/Wiki/"/>
    
      <category term="Web" scheme="http://miRoox.github.io/blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>MatrixForm赋值问题</title>
    <link href="http://miRoox.github.io/blog/2019/09/MatrixFormProblem/"/>
    <id>http://miRoox.github.io/blog/2019/09/MatrixFormProblem/</id>
    <published>2019-09-19T12:27:34.000Z</published>
    <updated>2020-01-25T04:11:48.800Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，赋值等过程中使用 <code>MatrixForm</code> 往往会导致后续的计算失效。比如：</p><img src="/blog/2019/09/MatrixFormProblem/problem.svg" title="a = { {1, 2}, {3, 4} } // MatrixForm"><a id="more"></a><p>对于这个问题，最正统的解决办法当然是在赋值等计算过程中不使用 <code>MatrixForm</code>，而只在显示时以 <code>MatrixForm</code> 呈现<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。典型的方案是在输出部分才加上 <code>MatrixForm</code> 包装。不过对于既有代码的问题，一个个手动修改可能略显麻烦，这时可以借助 <code>EchoFunction</code> 在实现类似效果的同时保持代码结构基本不变：</p><img src="/blog/2019/09/MatrixFormProblem/solution-echo.svg" title="a = { {1, 2}, {3, 4} } // EchoFunction[MatrixForm];"><p>要将既有代码调整为这种方式，只需简单的文本替换就可以实现目标。</p><p>不过，本文要主要要谈的并不是这类传统解决方案，而是通过给 Mathematica 系统打上补丁来实现几乎零修改的解决方案。</p><p>我们知道，<code>MatrixForm</code> 这类格式封装，当它位于结果的<em>最外层</em>时，<code>Out</code> 输出历史中不会对其进行储存<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。事实上，所有在 <code>$OutputForms</code> 中的格式封装都具有这样的性质。</p><p>受此启发，我们不妨把这个性质推广到赋值的情况上来，即这类格式封装出现在赋值运算的右侧时不会将其记录到赋值中。事实上，通过重载 <code>Set</code> 的定义很容易实现这一功能：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GeneralUtilities`BlockProtected[&#123;<span class="keyword">Set</span>&#125;,</span><br><span class="line">  <span class="keyword">Set</span>[lhs_,(form:<span class="keyword">Alternatives</span>@@<span class="keyword">$OutputForms</span>)[rhs_]] := form@<span class="keyword">Set</span>[lhs,rhs]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>效果如图：</p><img src="/blog/2019/09/MatrixFormProblem/solution.svg" title="a = { {1, 2}, {3, 4} } // MatrixForm"><hr><p>参考：</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="http://people.math.umass.edu/~murray/Math_421_Eisenberg/Notes/Mathematica_Q___A/MatrixForm/matrixform.html" target="_blank" rel="noopener">Q&amp;A: Compute with MatrixForm</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://note.youdao.com/ynoteshare1/index.html?id=d0a57819857f2771ca669eb54819e3d1&amp;type=note" target="_blank" rel="noopener">为什么我的代码加了MatrixForm后就出问题了？</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，赋值等过程中使用 &lt;code&gt;MatrixForm&lt;/code&gt; 往往会导致后续的计算失效。比如：&lt;/p&gt;
&lt;img src=&quot;/blog/2019/09/MatrixFormProblem/problem.svg&quot; title=&quot;a = { {1, 2}, {3, 4} } // MatrixForm&quot;&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>基于规则的带步骤符号求导器</title>
    <link href="http://miRoox.github.io/blog/2019/07/RuleBasedStepByStepDerivative/"/>
    <id>http://miRoox.github.io/blog/2019/07/RuleBasedStepByStepDerivative/</id>
    <published>2019-07-12T14:27:17.000Z</published>
    <updated>2020-01-25T04:11:48.800Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，<a href="https://www.wolframalpha.com" target="_blank" rel="noopener">Wolfram|Alpha</a> 有一个名为 <a href="https://www.wolframalpha.com/examples/pro-features/step-by-step-solutions/" target="_blank" rel="noopener">Step-by-Step Solutions</a> 的功能，可以显示一些数学问题求解的过程。又比如，著名的 <a href="https://rulebasedintegration.org/" target="_blank" rel="noopener">Rubi</a> 可以在求解积分的同时显示积分的求解步骤。实际上，这些系统背后大抵都是基于模式匹配和规则变换而实现的，因而原则上来说自己也可以实现一个。当然，就实践而言这些系统都过于复杂了，例如 Rubi 包含了超过六千条规则，其背后的原理远非三言两语可以阐明的。不过，相比于积分，微分的运算规则要简明得多，而且对规则的应用总是简单机械的，并不像积分那样可能会运用到各种技巧。因此，本文将利用 Mathematica 的模式匹配和规则实现一个带步骤符号求导器。</p><img src="/blog/2019/07/RuleBasedStepByStepDerivative/DvsInt.JPG" title="Differentiation vs Integration"><a id="more"></a><h3 id="求导规则"><a class="markdownIt-Anchor" href="#求导规则"></a> 求导规则</h3><p>实现的核心首先在于对求导法则的代码表示。由于 Rule-Based 也是 Wolfram 语言的基本范式，因此这些规则写起来也很直观。</p><p>首先是几个基本运算规则</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">baseRules=&#123;</span><br><span class="line">  d[c_,x_]/;<span class="keyword">FreeQ</span>[c,x]:&gt;<span class="number">0</span>,</span><br><span class="line">  d[lf_Plus,x_]:&gt;<span class="keyword">Thread</span>[d[lf,x],<span class="keyword">Plus</span>],</span><br><span class="line">  d[c_*f_,x_]/;<span class="keyword">FreeQ</span>[c,x]:&gt;c*d[f,x],</span><br><span class="line">  d[f_*g_,x_]:&gt;d[f,x]g+d[g,x]f</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，使用 <code>d[f,x]</code> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">d</mi><mi>f</mi></mrow><mrow><mi mathvariant="normal">d</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\tfrac{\mathrm{d}f}{\mathrm{d}x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">d</span></span><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">d</span></span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。上述的代码表示了常数求导法则、线性求导法则和乘法求导法则的作用规则。</p><p>对于复合函数和反函数，需要一个间接的包装来表示类似 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(g(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 的情况，这里将其表示为<code>dfunc[f,gx]</code>类似的形式，其中<code>gx</code>对应于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">higherRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">InverseFunction</span>[f_][x_],x_]:&gt;<span class="number">1</span>/dfunc[f,<span class="keyword">InverseFunction</span>[f][x]],</span><br><span class="line">  d[f_[g_],x_]/;g=!=x:&gt;dfunc[f,g]d[g,x],</span><br><span class="line">  d[f_[g_,c_],x_]/;<span class="keyword">FreeQ</span>[c,x]&amp;&amp;g=!=x:&gt;dfunc[f[#,c]&amp;,g]d[g,x],</span><br><span class="line">  d[f_[c_,g_],x_]/;<span class="keyword">FreeQ</span>[c,x]&amp;&amp;g=!=x:&gt;dfunc[f[c,#]&amp;,g]d[g,x]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，为了避免问题过于复杂化，这里求导的对象都只限于初等函数。因此在考虑复合函数的链导法则时实际不包含多元函数。对于可能遇到地二元初等函数，要么其中一个参数与自变量无关，本质还是一元函数，要么可以通过变形转化成一元形式。</p><p>此外还有一点需要注意，在链式法则的规则中，模式条件<code>g=!=x</code>是必要的，否则可能陷入无限自递归的窘境。</p><p>在上面的高阶（反函数、复合函数）规则中，<code>dfunc</code>只是徒具形式的一个表示。为了确实有效地计算这种情况，还需要引入一个替换规则。即在计算得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span></span></span></span>后，再进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>→</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u\to g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>的变量替换。直接表达出来就比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;d[f[u],u]/.&#123;u-&gt;g&#125;;</span><br></pre></td></tr></table></figure><p>不过这种写法当遇到函数<code>f</code>本身蕴含名为<code>u</code>的参量时就可能会出现错误的结果。因而需要使用<code>Module</code>来引入哑元形式，即</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,d[f[u],u]/.&#123;u-&gt;g&#125;];</span><br></pre></td></tr></table></figure><p>但这是错误的。因为我们希望在计算出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>后再做变量替换。但上面的实现中，<code>d[f[u],u]</code>本身并不会求值，而是通过应用这些规则进行替换而得到的计算结果，从而导致替换发生在计算导数之前，那样就没有意义了。因此需要一个<code>d</code>的立即求值版，命名为<code>dEval</code>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,dEval[f[u],u]/.&#123;u-&gt;g&#125;];</span><br></pre></td></tr></table></figure><p>关于<code>dEval</code>的实现，一个粗浅的想法是在完成全部规则的定义后，对输入按这些规则进行<code>ReplaceRepeated</code>。当然，这其中还需要一些细节，我们这里暂且按下不表，留待后面再讨论。</p><p>接下来就是对具体函数的求导规则进行列举，比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>[d[<span class="keyword">IgnoringInactive</span>[<span class="keyword">Exp</span>[x_]],x_]]:&gt;<span class="keyword">Exp</span>[x],</span><br><span class="line">  <span class="keyword">HoldPattern</span>[d[<span class="keyword">IgnoringInactive</span>[<span class="keyword">Log</span>[x_]],x_]]:&gt;<span class="number">1</span>/x,</span><br><span class="line">  <span class="keyword">HoldPattern</span>[d[<span class="keyword">IgnoringInactive</span>[<span class="keyword">Sin</span>[x_]],x_]]:&gt;<span class="keyword">Cos</span>[x],</span><br><span class="line">  <span class="keyword">HoldPattern</span>[d[<span class="keyword">IgnoringInactive</span>[<span class="keyword">Cos</span>[x_]],x_]]:&gt;-<span class="keyword">Sin</span>[x]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一个个手动枚举也比较繁琐，因此我们不妨利用 Mathematica 既有的求导功能来生成结果</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">functionRules=<span class="keyword">Table</span>[</span><br><span class="line">  <span class="keyword">With</span>[&#123;f=f&#125;,<span class="keyword">HoldPattern</span>@d[<span class="keyword">IgnoringInactive</span>@f[x_],x_]]-&gt;D[f[x],x],</span><br><span class="line">  &#123;f,&#123;</span><br><span class="line">    <span class="keyword">Sqrt</span>,<span class="keyword">CubeRoot</span>,<span class="keyword">RealAbs</span>,</span><br><span class="line">    <span class="keyword">Exp</span>,<span class="keyword">Log</span>,<span class="keyword">Log2</span>,<span class="keyword">Log10</span>,</span><br><span class="line">    <span class="keyword">Sin</span>,<span class="keyword">Cos</span>,<span class="keyword">Tan</span>,<span class="keyword">Cot</span>,<span class="keyword">Sec</span>,<span class="keyword">Csc</span>,</span><br><span class="line">    <span class="keyword">ArcSin</span>,<span class="keyword">ArcCos</span>,<span class="keyword">ArcTan</span>,<span class="keyword">ArcCot</span>,<span class="keyword">ArcSec</span>,<span class="keyword">ArcCsc</span>,</span><br><span class="line">    <span class="keyword">Sinh</span>,<span class="keyword">Cosh</span>,<span class="keyword">Tanh</span>,<span class="keyword">Coth</span>,<span class="keyword">Sech</span>,<span class="keyword">Csch</span>,</span><br><span class="line">    <span class="keyword">ArcSinh</span>,<span class="keyword">ArcCosh</span>,<span class="keyword">ArcTanh</span>,<span class="keyword">ArcCoth</span>,<span class="keyword">ArcSech</span>,<span class="keyword">ArcCsch</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]/.&#123;<span class="keyword">Rule</span>-&gt;<span class="keyword">RuleDelayed</span>&#125;;</span><br></pre></td></tr></table></figure><p>除了这些可以直接表示的一元函数，还有一些形式上是二元函数的一元函数情况，这里简单列举一下</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">functionExtRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[x_^a_.,x_]/;<span class="keyword">FreeQ</span>[a,x]:&gt;a x^(a<span class="number">-1</span>),</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[a_^x_,x_]/;<span class="keyword">FreeQ</span>[a,x]:&gt;a^x <span class="keyword">Log</span>[a],</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">IgnoringInactive</span>@<span class="keyword">Surd</span>[x_,n_],x_]/;<span class="keyword">FreeQ</span>[n,x]:&gt;<span class="number">1</span>/(n <span class="keyword">Surd</span>[x,n]^(n<span class="number">-1</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>稍微值得一提的是，由于<code>Power</code>的<code>OneIdentity</code>属性，模式<code>x_^a_.</code>也会直接匹配<code>x</code>这种情况。</p><p>除此之外，还有一些二元函数可以通过变形得到上述一元函数的组合</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transferRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">IgnoringInactive</span>[f_^g_],x_]/;!(<span class="keyword">FreeQ</span>[f,x]||<span class="keyword">FreeQ</span>[g,x]):&gt;d[<span class="keyword">Inactive</span>[<span class="keyword">Exp</span>][<span class="keyword">Log</span>[f]g],x],</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">IgnoringInactive</span>@<span class="keyword">Log</span>[f_,g_],x_]:&gt;d[<span class="keyword">Log</span>[g]/<span class="keyword">Log</span>[f],x]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>Inactive[Exp]</code>是为了抑制指数函数的内置化简规则。也正是为了方面使用<code>Inactive</code>控制变形的方向，前面的函数求导规则的模式中都包含了<code>IgnoringInactive</code>。</p><p>这样，一个囊括了初等函数的符号求导规则就全部完成了。<br>最后将所有规则整合到一起</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allRules=<span class="keyword">Flatten</span>@&#123;</span><br><span class="line">  transferRules,</span><br><span class="line">  baseRules,</span><br><span class="line">  functionRules,</span><br><span class="line">  functionExtRules,</span><br><span class="line">  substRules,</span><br><span class="line">  higherRules</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果只需要进行求导计算，那么直接对输入按这些规则进行替换即可</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dEval[f_,x_]:=d[f,x]//.allRules</span><br></pre></td></tr></table></figure><p>举一个简单的例子测试一下</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(dEval==D)[(x^<span class="keyword">Sin</span>[x]+<span class="number">3</span>x+<span class="keyword">ArcTan</span>[x])^<span class="number">2</span>/(x^<span class="number">4</span><span class="number">-3</span><span class="keyword">Surd</span>[x^<span class="number">5</span>,<span class="number">3</span>]<span class="keyword">RealAbs</span>@<span class="keyword">Log</span>[x]+<span class="number">2</span>),x]//<span class="keyword">Through</span>//<span class="keyword">Simplify</span></span><br><span class="line"><span class="comment">(*Out: True*)</span></span><br></pre></td></tr></table></figure><p>也就是说利用这些规则已经可以实现对初等函数的求导运算了。然而，假如输入的待求导函数不只包含初等函数，那么<code>dEval</code>就无法完全计算，得到的结果中会包含错误的形式。诚然，我们的目标只在解决初等函数的求导，对于初等函数以外的情况无法解决也是正常的，不过从健壮性的角度考虑，这里最好再增加一个条件以避免某些可能出现的潜在问题。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,</span><br><span class="line">  <span class="keyword">With</span>[&#123;df=dEval[f[u],u]&#125;,</span><br><span class="line">    (df/.&#123;u-&gt;g&#125;)/;<span class="keyword">FreeQ</span>[df,_d|_dfunc]</span><br><span class="line">  ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>这里利用作用域里的条件模式来保证遇到<code>dEval</code>无法解决的情况时会保持既有的<code>dfunc</code>形式不变。可以试试下面的代码测试一下效果</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dEval[<span class="keyword">Erf</span>[<span class="keyword">Sin</span>[x]]^<span class="number">2</span>,x]</span><br></pre></td></tr></table></figure><h3 id="步骤回显"><a class="markdownIt-Anchor" href="#步骤回显"></a> 步骤回显</h3><p>然后是对计算步骤的输出显示。我们希望将替换的每一步都显示出来，因此不能直接使用<code>//.</code>，而应该使用<code>NestWhile</code>之类的方式对每次替换获得更精确的控制。在输出显示上，用<code>CellPrint</code>比较方便，也比单纯的<code>Print</code>好控制格式。</p><p>首先，对于输出步骤的每个单元，我们希望前面有一个<code>=</code>标记，就像<code>Echo</code>产生的单元前的<code>&gt;&gt;</code>标志符一样。这一点可以利用<code>CellDingbat</code>实现：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echoStep[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[removeLabels@expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellDingbat</span>-&gt;<span class="keyword">Cell</span>[<span class="string">"="</span>,<span class="string">"EchoLabel"</span>]];</span><br><span class="line">  expr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后，与之类似地，还需要一个函数输出显示最初地状态作为等式的起点。需要注意的是，为了比较好地对齐，需要对两者使用不同的边距：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echoStep0[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>, <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br><span class="line">echoStep[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellDingbat</span>-&gt;<span class="keyword">Cell</span>[<span class="string">"="</span>,<span class="string">"EchoLabel"</span>],</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>, <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>进一步地，考虑到复合函数求导时需要转入对其它函数求导的过程，这将打断正在进行的求导步骤间的顺叙关系，从逻辑上进入更深的层级。为了表现这种层级关系，这里同样通过调整边距实现。引入一个层级标志量<code>$dDepth</code>：每当计算<code>dEval</code>时都增加这一标志量，结束时就将其还原；同时利用<code>$dDepth</code>控制边距以实现对边距的适应调整。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$dDepth=<span class="number">0</span>;</span><br><span class="line">echoStep0[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>($dDepth<span class="number">-1</span>), <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br><span class="line">echoStep[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellDingbat</span>-&gt;<span class="keyword">Cell</span>[<span class="string">"="</span>,<span class="string">"EchoLabel"</span>],</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>$dDepth, <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dEval[f_,x_]:=<span class="keyword">Block</span>[&#123;$dDepth=$dDepth+<span class="number">1</span>&#125;,dEvalR[f,x]]</span><br><span class="line">dEvalR[f_,x_]:=<span class="keyword">NestWhile</span>[echoStep@*<span class="keyword">ReplaceAll</span>[allRules],echoStep0[d[f,x]],!<span class="keyword">FreeQ</span>[#<span class="number">2</span>,_d|_dfunc]&amp;&amp;<span class="keyword">UnsameQ</span>[##]&amp;,<span class="number">2</span>]</span><br><span class="line">stepD[f_,x_]:=<span class="keyword">With</span>[&#123;eval=dEval[f,x]&#125;,eval/;<span class="keyword">FreeQ</span>[eval,_d|_dfunc]]</span><br></pre></td></tr></table></figure><p>这里将具体的求导运算过程委托到<code>dEvalR</code>函数上，利用以是否存在未完成的求导形式为基本判据，同时辅以不变性作为无法完成时的终止条件。再把<code>stepD</code>作为封装的外部接口，通过条件模式限制，在失败时保持输入形式，避免内部<code>dfunc</code>等内部符号暴露到输出中。</p><p>测试一下</p><img src="/blog/2019/07/RuleBasedStepByStepDerivative/echo-step.svg" title="DiffereEcho Step"><h3 id="润色外观"><a class="markdownIt-Anchor" href="#润色外观"></a> 润色外观</h3><p>可以看到步骤显示中的输出形式很难看。为了增加步骤的可读性，我们可以通过自定义显示格式来润色外观。考虑我们本身使用的代码结构，将公式输出为Leibniz符号的形式比较方便。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">d/:<span class="keyword">MakeBoxes</span>[d[f_,x_],<span class="keyword">TraditionalForm</span>]:=<span class="keyword">Module</span>[&#123;boxes&#125;,</span><br><span class="line">  boxes=<span class="keyword">MakeBoxes</span>[f, <span class="keyword">TraditionalForm</span>];</span><br><span class="line">  <span class="keyword">If</span>[<span class="keyword">Precedence</span>[<span class="keyword">Plus</span>]&gt;=<span class="keyword">Precedence</span>[boxes,<span class="keyword">TraditionalForm</span>],boxes=<span class="keyword">RowBox</span>[&#123;<span class="string">"("</span>, boxes, <span class="string">")"</span>&#125;]];</span><br><span class="line">  <span class="keyword">RowBox</span>[&#123;<span class="keyword">FractionBox</span>[<span class="string">"\[DifferentialD]"</span>, <span class="keyword">RowBox</span>[&#123;<span class="string">"\[DifferentialD]"</span>, <span class="keyword">MakeBoxes</span>[x, <span class="keyword">TraditionalForm</span>]&#125;]], boxes&#125;]</span><br><span class="line">]</span><br><span class="line">dfunc/:<span class="keyword">MakeBoxes</span>[dfunc[f_, g_], <span class="keyword">TraditionalForm</span>]:=<span class="keyword">Module</span>[&#123;fboxes, gboxes&#125;,</span><br><span class="line">  fboxes=<span class="keyword">ToBoxes</span>[f[g], <span class="keyword">TraditionalForm</span>]; gboxes=<span class="keyword">ToBoxes</span>[g, <span class="keyword">TraditionalForm</span>];</span><br><span class="line">  <span class="keyword">If</span>[<span class="keyword">Precedence</span>[<span class="keyword">Plus</span>]&gt;=<span class="keyword">Precedence</span>[fboxes, <span class="keyword">TraditionalForm</span>],fboxes=<span class="keyword">RowBox</span>[&#123;<span class="string">"("</span>, fboxes, <span class="string">")"</span>&#125;]];</span><br><span class="line">  <span class="keyword">If</span>[<span class="keyword">Precedence</span>[<span class="keyword">Plus</span>]&gt;=<span class="keyword">Precedence</span>[gboxes, <span class="keyword">TraditionalForm</span>],gboxes=<span class="keyword">RowBox</span>[&#123;<span class="string">"("</span>, gboxes, <span class="string">")"</span>&#125;]];</span><br><span class="line">  <span class="keyword">FractionBox</span>[<span class="keyword">RowBox</span>[&#123;<span class="string">"\[DifferentialD]"</span>, fboxes&#125;], <span class="keyword">RowBox</span>[&#123;<span class="string">"\[DifferentialD]"</span>, gboxes&#125;]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后对于被<code>Module</code>局域化符号的显示，像<code>u$nnn</code>这样的形式显然不太好看，在这里也可以给出一个美化模板，它将这类符号的输出形式显示为首字母</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeXForm[sym_Symbol]:=sym/:<span class="keyword">MakeBoxes</span>[sym,<span class="keyword">TraditionalForm</span>]=<span class="keyword">ToBoxes</span>[<span class="keyword">Symbol</span>[<span class="keyword">StringPart</span>[<span class="keyword">SymbolName</span>[sym],<span class="number">1</span>]],<span class="keyword">TraditionalForm</span>]</span><br></pre></td></tr></table></figure><p>再用在替换规则中</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,</span><br><span class="line">  makeXForm[u];</span><br><span class="line">  <span class="keyword">With</span>[&#123;df=dEval[f[u],u]&#125;,</span><br><span class="line">    (df/.&#123;u-&gt;g&#125;)/;<span class="keyword">FreeQ</span>[df,_d|_dfunc]</span><br><span class="line">  ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>得到的结果就更接近于数学中的写法了</p><img src="/blog/2019/07/RuleBasedStepByStepDerivative/format.svg" title="DiffereEcho Format"><h3 id="标注步骤"><a class="markdownIt-Anchor" href="#标注步骤"></a> 标注步骤</h3><p>最后，我们还希望给每一步中所使用的特殊规则标注名称，方便理解各个步骤到底做了什么。比如 “乘法法则” “链式法则” 这样的注解。我们首先将这些注解都标记在求导的规则中</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">baseRules=&#123;</span><br><span class="line">  d[c_,x_]/;<span class="keyword">FreeQ</span>[c,x]:&gt;dLabeled[<span class="number">0</span>,<span class="string">"Constant Rule"</span>],</span><br><span class="line">  d[lf_Plus,x_]:&gt;dLabeled[<span class="keyword">Thread</span>[d[lf,x],<span class="keyword">Plus</span>],<span class="string">"Linearity Rule"</span>],</span><br><span class="line">  d[c_*f_,x_]/;<span class="keyword">FreeQ</span>[c,x]:&gt;dLabeled[c*d[f,x],<span class="string">"Linearity Rule"</span>],</span><br><span class="line">  d[f_*g_,x_]:&gt;dLabeled[d[f,x]g+d[g,x]f,<span class="string">"Product Rule"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">higherRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">InverseFunction</span>[f_][x_],x_]:&gt;dLabeled[<span class="number">1</span>/dfunc[f,<span class="keyword">InverseFunction</span>[f][x]],<span class="string">"Inverse Function Rule"</span>],</span><br><span class="line">  d[f_[g_],x_]/;g=!=x:&gt;dLabeled[dfunc[f,g]d[g,x],<span class="string">"Chain Rule"</span>],</span><br><span class="line">  d[f_[g_,c_],x_]/;<span class="keyword">FreeQ</span>[c,x]&amp;&amp;g=!=x:&gt;dLabeled[dfunc[f[#,c]&amp;,g]d[g,x],<span class="string">"Chain Rule"</span>],</span><br><span class="line">  d[f_[c_,g_],x_]/;<span class="keyword">FreeQ</span>[c,x]&amp;&amp;g=!=x:&gt;dLabeled[dfunc[f[c,#]&amp;,g]d[g,x],<span class="string">"Chain Rule"</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有链式法则使用时，替换后的变元原本指代的是什么也应该标记出来，以方便阅读和理解。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,</span><br><span class="line">  makeXForm[u];</span><br><span class="line">  <span class="keyword">With</span>[</span><br><span class="line">    &#123;df=dEval[dLabeled[f[u],<span class="keyword">Row</span>@&#123;<span class="string">"where "</span>,<span class="keyword">TraditionalForm</span>[u==g]&#125;],u]&#125;,</span><br><span class="line">    (df/.&#123;u-&gt;g&#125;)/;<span class="keyword">FreeQ</span>[df,_d|_dfunc]</span><br><span class="line">  ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>有了规则中的标记，我们就需要能够从表达式里将标记都提取出来的方法。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getLabels[expr_]:=<span class="keyword">With</span>[</span><br><span class="line">  &#123;lbs=<span class="keyword">DeleteDuplicates</span>@<span class="keyword">Cases</span>[expr,dLabeled[_,lb_]:&gt;lb,&#123;<span class="number">0</span>,<span class="keyword">Infinity</span>&#125;]&#125;,</span><br><span class="line">  <span class="keyword">Row</span>@<span class="keyword">Flatten</span>@&#123;<span class="string">"("</span>,<span class="keyword">Riffle</span>[lbs,<span class="string">"; "</span>],<span class="string">")"</span>&#125;/;lbs=!=&#123;&#125;</span><br><span class="line">]</span><br><span class="line">getLabels[_]=<span class="string">""</span>;</span><br></pre></td></tr></table></figure><p>注意一步计算可以会运用多个规则，输出应该为分割得到的一组。同时，对于重复项最好也应该删除。</p><p>而这些<code>dLabeled</code>标记形式本身不应出现在求导的过程中，所以应该在每步计算完成后移除</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeLabels[expr_]:=expr/.&#123;dLabeled[e_,_]:&gt;e&#125;</span><br></pre></td></tr></table></figure><p>然后在输出时，注解通过<code>CellFrameLabels</code>显示在每个单元的右侧。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">echoStep0[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[removeLabels@expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>($dDepth<span class="number">-1</span>), <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;,</span><br><span class="line">    <span class="keyword">CellFrameLabels</span>-&gt;&#123;&#123;<span class="keyword">None</span>,<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>@<span class="keyword">ToBoxes</span>@getLabels[expr],<span class="string">"MessageText"</span>]&#125;,&#123;<span class="keyword">None</span>,<span class="keyword">None</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br><span class="line">echoStep[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[removeLabels@expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellDingbat</span>-&gt;<span class="keyword">Cell</span>[<span class="string">"="</span>,<span class="string">"EchoLabel"</span>],</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>$dDepth, <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;,</span><br><span class="line">    <span class="keyword">CellFrameLabels</span>-&gt;&#123;&#123;<span class="keyword">None</span>,<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>@<span class="keyword">ToBoxes</span>@getLabels[expr],<span class="string">"MessageText"</span>]&#125;,&#123;<span class="keyword">None</span>,<span class="keyword">None</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最后将这些过程添加到计算的每一步中</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dEvalR[f_,x_]:=<span class="keyword">NestWhile</span>[</span><br><span class="line">  removeLabels@*echoStep@*<span class="keyword">ReplaceAll</span>[allRules],</span><br><span class="line">  removeLabels@echoStep0[d[f,x]],</span><br><span class="line">  !<span class="keyword">FreeQ</span>[#<span class="number">2</span>,_d|_dfunc]&amp;&amp;<span class="keyword">UnsameQ</span>[##]&amp;,<span class="number">2</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>就大功告成了。</p><p>简单测试一下</p><img src="/blog/2019/07/RuleBasedStepByStepDerivative/label.svg" title="DiffereEcho Label"><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>最终整理得到的完整代码放在 <a href="https://github.com/miRoox/DStep/blob/master/DStep.wl" target="_blank" rel="noopener">Github</a> 上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，&lt;a href=&quot;https://www.wolframalpha.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wolfram|Alpha&lt;/a&gt; 有一个名为 &lt;a href=&quot;https://www.wolframalpha.com/examples/pro-features/step-by-step-solutions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Step-by-Step Solutions&lt;/a&gt; 的功能，可以显示一些数学问题求解的过程。又比如，著名的 &lt;a href=&quot;https://rulebasedintegration.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rubi&lt;/a&gt; 可以在求解积分的同时显示积分的求解步骤。实际上，这些系统背后大抵都是基于模式匹配和规则变换而实现的，因而原则上来说自己也可以实现一个。当然，就实践而言这些系统都过于复杂了，例如 Rubi 包含了超过六千条规则，其背后的原理远非三言两语可以阐明的。不过，相比于积分，微分的运算规则要简明得多，而且对规则的应用总是简单机械的，并不像积分那样可能会运用到各种技巧。因此，本文将利用 Mathematica 的模式匹配和规则实现一个带步骤符号求导器。&lt;/p&gt;
&lt;img src=&quot;/blog/2019/07/RuleBasedStepByStepDerivative/DvsInt.JPG&quot; title=&quot;Differentiation vs Integration&quot;&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="符号计算" scheme="http://miRoox.github.io/blog/tags/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>关于LaTeX插入矢量图的格式问题</title>
    <link href="http://miRoox.github.io/blog/2019/07/FormatOfVectorInLaTeX/"/>
    <id>http://miRoox.github.io/blog/2019/07/FormatOfVectorInLaTeX/</id>
    <published>2019-07-09T06:51:22.000Z</published>
    <updated>2020-01-25T04:11:48.800Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，外部插入矢量图图尽量使用 PDF 格式，以避免生成时的转换。</p><blockquote><p><strong>只要输出介质为pdf，那么使用PSTricks和eps插图都是陋习。</strong></p><p><strong>如果输出介质为pdf，那么所有eps都需要转换为pdf后插入。</strong></p><p>之所以需要转换，是因为pdfTeX/LuaTeX不带任何PostScript解释器，所以一定要转换成pdf才能插图。而pTeX/XeTeX，则通常需要使用dvipdfmx输出pdf，在用到PostScript代码的时候，即PSTricks和eps图，都会通过管道使用GhostScript转换，这也是拖慢dvipdfmx的一个主要原因。</p><p>当然，很多编辑部的期刊模板都要求是eps图，甚至是png都要求转成eps（里面其实还是点阵图）。这时候，eps文件留给他们解决，自己该用什么用什么。</p><p>这都2018年了，别想不开老是用eps图。</p></blockquote><p>来自 <a href="https://www.zhihu.com/question/284593369/answer/438941492" target="_blank" rel="noopener">为什么 用TeXstudio在 XeLaTeX下eps图片不显示, pdflatex下反而可以 ? - 李阿玲的回答 - 知乎</a></p>]]></content>
    
    <summary type="html">
    
      只要输出介质为pdf，就不要使用 eps 和 PSTricks 插图
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="LaTeX" scheme="http://miRoox.github.io/blog/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>如何在Wolfram语言里造一个Wolfram语言风格的对象</title>
    <link href="http://miRoox.github.io/blog/2019/05/WLStyleObject/"/>
    <id>http://miRoox.github.io/blog/2019/05/WLStyleObject/</id>
    <published>2019-05-06T14:27:17.000Z</published>
    <updated>2020-01-25T04:11:48.796Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做 <a href="https://github.com/miRoox/ComputationalOptics" target="_blank" rel="noopener">ComputationalOptics包</a> 的时候为了把 <a href="https://github.com/miRoox/ComputationalOptics/blob/1197dbf20758271c93acdbc4f780913443847b95/ComputationalOptics/Kernel/LightField.m" target="_blank" rel="noopener"><code>LightField</code></a> 实现为一个比较典型的Wolfram语言风格的对象，使用了很多undocumented方法，这里主要是做一下记录。</p><p>需要注意的是，这里的“对象”不是指“面向对象”里所说的对象（虽然也有点关系），而是类似于 <a href="http://reference.wolfram.com/language/ref/Entity.html" target="_blank" rel="noopener"><code>Entity</code></a> 或者 <a href="http://reference.wolfram.com/language/ref/TemporalData.html" target="_blank" rel="noopener"><code>TemporalData</code></a> 这类的对象。</p><a id="more"></a><p>这里就以前面提到的<code>LightField</code>为例说明一下如何造一个WL风格的对象。首先，分析需求，来看看预期要实现的效果：</p><img src="/blog/2019/05/WLStyleObject/result.png" title="result"><p>首先能看到的是<code>LightField</code>对象在输出时显示为一个类似于<a href="http://reference.wolfram.com/language/ref/SparseArray.html" target="_blank" rel="noopener"><code>SparseArray</code></a>那样的一个摘要框；然后，对象的属性可以通过函数参数的形式读写访问，而且对写入数据参数还会进行检查，这一点应该是WL风格的对象最核心的特征；最后，对象是能被认为是一个原子对象，这点实质是一种封装，可以避免直接用表达式的部分操作来访问对象内容，同样类似<code>SparseArray</code>。</p><p>进行具体实现前，最基本的，<code>LightField</code>对象数据的组织结构需要确定下来。这里采用的是<code>LightField[type_String, props_Association]</code>的模式，主要是考虑到这种表达式结构在表达光场信息的时候能具有较好的泛化能力。上面的<code>type</code>用来标记光场描述的类型（比如单色平面复振幅），而<code>props</code>则是描述光场所需的具体属性，以关联容器的方式组织数据内容。当然，这些含义对本文而言并不是重点，但也是对象设计和实现中最基本最重要的一步。</p><p>然后是对属性的读写的实现。单纯的读操作实现起来并不困难，不过需要注意的一点是我们接下来还要将对象转化为原子的，因此不能直接将问题变为利用<code>[[]]</code>提取部分。</p><p>我们知道，复数<code>Complex</code>也是原子的，它虽然不能直接对部分进行提取，但可以利用模式匹配来获得实部和虚部。基于同样的原理，读属性的核心实现长这样</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getProperty[<span class="keyword">HoldPattern</span>@LightField[_,props_],prop_]:=<span class="keyword">Lookup</span>[</span><br><span class="line">  props,prop,</span><br><span class="line">  <span class="keyword">Message</span>[LightField::ptprop,prop];<span class="keyword">Missing</span>[<span class="string">"NotAvailable"</span>,prop]</span><br><span class="line">]</span><br><span class="line">(obj_LightField?LightFieldQ)[prop_]:=getProperty[obj,prop]</span><br></pre></td></tr></table></figure><p>这其中，<code>LightFieldQ</code>是一个基于模式匹配判断输入是否为格式正确的<code>LightField</code>对象的函数。毕竟，如果基本格式都不正确的话，后面的模式匹配获取部分也无从谈起。</p><p>而写方法在wolfram语言寻常的语法上就非常困难了，因为WL概念上并不存在引用或者指针这一类东西，符号本身几乎总是充当引用的作用，但在形如<code>a[&quot;Wavelength&quot;] = xxx</code>的表达式里，左侧表达式并不是一个符号，而这种形式常常会将定义关联到符号<code>a</code>的下值中，也就是我们常见的函数定义方式。那么怎么让计算上述形式表达式的时候把它当做一个类似于部分赋值的方式进行处理呢？</p><p>一个非常自然地想法可能是对<code>LightField</code>赋予上值，不过很遗憾的是这种方案必然是不可行的，因为可变性意味着参数必须以保持的形式传递符号，那么在模式匹配的阶段必然没有机会接触到需要匹配的<code>LightField</code>，这样上值的关联就无法成立。</p><p>另一种想法则是<code>Unprotect[Set]</code>后添加赋值规则，比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>[(sym_Symbol?LightFieldQ)[prop_],val_]:=...</span><br></pre></td></tr></table></figure><p>这的确不失为一种解决办法，但这一方法实在有些太笨重了。这会导致所有满足模式<code>sym_Symbol[prop_]=val_</code>的代码都还要用<code>LightFieldQ</code>检查一遍，无论<code>sym</code>中是否隐含着<code>LightField</code>。</p><p>尝试下面的代码，感受一下鬼畜的效果</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gQ[_g]:=(<span class="keyword">Print</span>[<span class="string">"Ok"</span>];<span class="keyword">True</span>)</span><br><span class="line">gQ[_]:=(<span class="keyword">Print</span>[<span class="string">"Oops"</span>];<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">Unprotect</span>[<span class="keyword">Set</span>];</span><br><span class="line"><span class="keyword">Set</span>[(sym_Symbol?gQ)[prop_],val_]:=(<span class="keyword">Print</span>[<span class="keyword">Unevaluated</span>[sym[prop]],<span class="string">"="</span>,val])</span><br><span class="line"><span class="keyword">Protect</span>[<span class="keyword">Set</span>];</span><br><span class="line"><span class="keyword">Do</span>[a[<span class="number">1</span>]=<span class="number">1</span>,&#123;a,&#123;<span class="number">1</span>,&lt;||&gt;,g[]&#125;&#125;]</span><br></pre></td></tr></table></figure><p>（记得清除<code>Set</code>的附加定义）</p><p>因而我们需要一个更好的解决办法，这就是<code>Language`SetMutationHandler</code>，它的基本用法可以参见下面的相关资料，基本上照葫芦画瓢就行。作为对照，这里给一个与前述<code>Unprotect</code>方法完全类似测试代码</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fQ[_f]:=(<span class="keyword">Print</span>[<span class="string">"Ok"</span>];<span class="keyword">True</span>)</span><br><span class="line">fQ[_]:=(<span class="keyword">Print</span>[<span class="string">"Oops"</span>];<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">SetAttributes</span>[mutationHandler,<span class="keyword">HoldAllComplete</span>]</span><br><span class="line">mutationHandler[<span class="keyword">Set</span>[(sym_Symbol?fQ)[prop_],val_]]:=(<span class="keyword">Print</span>[<span class="keyword">Unevaluated</span>[sym[prop]],<span class="string">"="</span>,val])</span><br><span class="line"><span class="keyword">Language</span>`SetMutationHandler[f,mutationHandler]</span><br><span class="line"><span class="keyword">Do</span>[a[<span class="number">1</span>]=<span class="number">1</span>,&#123;a,&#123;<span class="number">1</span>,&lt;||&gt;,f[]&#125;&#125;]</span><br></pre></td></tr></table></figure><p>从输出中可以看到，只有当<code>a</code>的值变为<code>f[]</code>时，上面的匹配测试才会触发。完美符合要求。</p><p>在具体实现上，还有一些细节，比如对非属性参数检查和报错，对属性值的检查其实是由<code>LightFieldQ</code>对改变后的临时结果整体进行的检查，还有对失败结果需要<code>Language`MutationFallthrough</code>传递到正常的处理流程中，以及<code>Protect[LightField]</code>来避免fallthrough后干扰到<code>LightField</code>自身的定义等等，下面摘取了其中主要的部分</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SetAttributes</span>[setProperty,<span class="keyword">HoldFirst</span>]</span><br><span class="line">setProperty[sym_Symbol,prop_,val_]:=<span class="keyword">Block</span>[</span><br><span class="line">  &#123;tmp=sym,tmpprops&#125;,</span><br><span class="line">  tmpprops=getProperty[tmp,<span class="keyword">All</span>];</span><br><span class="line">  <span class="keyword">If</span>[<span class="keyword">KeyExistsQ</span>[tmpprops,prop],</span><br><span class="line">    tmpprops[prop]=val;</span><br><span class="line">    tmp=<span class="keyword">Replace</span>[tmp,<span class="keyword">HoldPattern</span>@LightField[type_,props_]:&gt;LightField[type,tmpprops]];</span><br><span class="line">    <span class="keyword">If</span>[LightFieldQ[tmp],</span><br><span class="line">      sym=tmp;val,</span><br><span class="line">      <span class="keyword">Message</span>[LightField::setptvp,val,prop];</span><br><span class="line">      <span class="keyword">$Failed</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="keyword">Message</span>[LightField::setptp,prop];</span><br><span class="line">    <span class="keyword">$Failed</span></span><br><span class="line">  ]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">SetAttributes</span>[mutationHandler,<span class="keyword">HoldAllComplete</span>]</span><br><span class="line">mutationHandler[<span class="keyword">Set</span>[(sym_Symbol?LightFieldQ)[prop_],val_]]:=<span class="keyword">With</span>[</span><br><span class="line">  &#123;result=setProperty[sym,prop,val]&#125;,</span><br><span class="line">  result/;!<span class="keyword">FailureQ</span>[result]</span><br><span class="line">]</span><br><span class="line">mutationHandler[_]:=<span class="keyword">Language</span>`MutationFallthrough</span><br><span class="line"><span class="keyword">Language</span>`SetMutationHandler[LightField,mutationHandler]</span><br></pre></td></tr></table></figure><p>对象的原子化则是利用<code>System`Private`SetNoEntry</code>系列的函数，同样，下面的相关资料里有很详细的介绍。这个系列的函数在不少内部对象的实现里也可以见到，比如<code>Dataset</code>，我们不妨照着做一个。利用神器<code>GeneralUtilities`PrintDefinitions</code>获得其定义，抛开那些无关的，很容易找到下面的内容</p><img src="/blog/2019/05/WLStyleObject/Dataset.png" title="Dataset"><p>中间有一些<code>Dataset</code>内部使用的注册机制，抛开那些不看，无非就是<code>System`Private`SetNoEntry</code>原子化后，利用<code>System`Private`NoEntryQ</code>检查防止无限自递归，注意两处的<code>Unevaluated</code>也是防止无限自递归的一环。在相关资料里我们看到10.4以后又引入了几个更便利的函数，于是依葫芦画瓢就可以写成</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(obj_LightField?holdLightFieldQ)/;System`Private`HoldEntryQ[obj]:=<span class="keyword">With</span>[</span><br><span class="line">  &#123;valid=System`Private`HoldSetNoEntry[obj]&#125;,</span><br><span class="line">  valid</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中<code>holdLightFieldQ</code>就是个保持版的<code>LightFieldQ</code>，作用当然也就不言而喻了。</p><p>最后是摘要框，这部分其实完全没有必要，不过说到Mathematica，优雅和颜值也是非常重要的一环，而且同样也用到了一套undocumented函数。这部分可以参考下面的相关资料，也可以用神器<code>GeneralUtilities`PrintDefinitions</code>来hack既有摘要框的对象，比如<code>SparseArray</code></p><img src="/blog/2019/05/WLStyleObject/SparseArray.png" title="SparseArray"><p>其核心无非就是<code>BoxForm`ArrangeSummaryBox</code>，中间量的命名也非常直白，即使不看参考资料也不难猜出使用方法。</p><p>这三部分都完成了以后，也算是有了一点Wolfram语言风格对象的神韵了。尽管为了这样优雅的使用对象，付出不少丑陋肮脏的实现代码，不过上面看到的一些官方的实现同样也丑陋无比，这倒也算是Wolfram语言的传统艺能了（</p><hr><p>相关资料：</p><ul><li><a href="https://mathematica.stackexchange.com/a/165910/63369" target="_blank" rel="noopener"><code>Language`*</code> documentation project - <code>Language`*Mutation*</code></a></li><li><a href="https://mathematica.stackexchange.com/a/139974/63369" target="_blank" rel="noopener">What are some useful, undocumented Mathematica functions? - <code>System`Private`*Entry*</code> functions</a></li><li><a href="https://mathematica.stackexchange.com/q/77658/63369" target="_blank" rel="noopener">How to create expanding summary boxes like the ones displayed for <code>InterpolatingFunction</code>, <code>NearestFunction</code>, etc.?</a></li><li><a href="https://mresources.github.io/tutorial/mathematica-programming/assorted-tricks/object-oriented-programming.html" target="_blank" rel="noopener">Object Oriented Programming</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做 &lt;a href=&quot;https://github.com/miRoox/ComputationalOptics&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ComputationalOptics包&lt;/a&gt; 的时候为了把 &lt;a href=&quot;https://github.com/miRoox/ComputationalOptics/blob/1197dbf20758271c93acdbc4f780913443847b95/ComputationalOptics/Kernel/LightField.m&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;LightField&lt;/code&gt;&lt;/a&gt; 实现为一个比较典型的Wolfram语言风格的对象，使用了很多undocumented方法，这里主要是做一下记录。&lt;/p&gt;
&lt;p&gt;需要注意的是，这里的“对象”不是指“面向对象”里所说的对象（虽然也有点关系），而是类似于 &lt;a href=&quot;http://reference.wolfram.com/language/ref/Entity.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Entity&lt;/code&gt;&lt;/a&gt; 或者 &lt;a href=&quot;http://reference.wolfram.com/language/ref/TemporalData.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;TemporalData&lt;/code&gt;&lt;/a&gt; 这类的对象。&lt;/p&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="Undocumented" scheme="http://miRoox.github.io/blog/tags/Undocumented/"/>
    
  </entry>
  
  <entry>
    <title>记Mathematica求导的一些坑</title>
    <link href="http://miRoox.github.io/blog/2019/05/TrapAboutDerivativeInMma/"/>
    <id>http://miRoox.github.io/blog/2019/05/TrapAboutDerivativeInMma/</id>
    <published>2019-05-01T08:02:10.000Z</published>
    <updated>2020-01-25T04:11:48.796Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是记录一下在回答贴吧上<a href="http://tieba.baidu.com/p/6111508459" target="_blank" rel="noopener">这个问题</a>时所发现的关于Mathematica求导的一些坑。</p><p>原问题虽然没有明说，但我推测问题背景应该是波特图之类的问题，具体问题如下：</p><blockquote><p>对这个函数的幅角求导，代入一个数值为什么求出了个复数值啊，实函数求导应该是实数啊。声明了一下x是实数后好像也不行。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f[x_] := <span class="keyword">Arg</span>[(-(x - <span class="number">1</span>)^<span class="number">2</span> + <span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span> - <span class="number">3</span> x^<span class="number">2</span> - x^<span class="number">4</span>))/((x - <span class="number">1</span>)^<span class="number">2</span> + <span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span> - <span class="number">3</span> x^<span class="number">2</span> - x^<span class="number">4</span>) - <span class="number">4</span>*I*(x^<span class="number">3</span> - <span class="number">3</span> x^<span class="number">2</span> + <span class="number">2</span> x))]</span><br><span class="line">f'[<span class="number">5</span>]</span><br><span class="line"><span class="comment">(*Out: (513125/13791752+(342351 I)/3447938) Arg'[2499/2626-(765 I)/2626]*)</span></span><br><span class="line">N[(<span class="number">513125</span>/<span class="number">13791752</span>+(<span class="number">342351</span> I)/<span class="number">3447938</span>) <span class="keyword">Arg</span>'[<span class="number">2499</span>/<span class="number">2626</span>-(<span class="number">765</span> I)/<span class="number">2626</span>]]</span><br><span class="line"><span class="comment">(*Out: 0.0109427 + 0.0292034 I*)</span></span><br></pre></td></tr></table></figure><p>这是程序，我觉得可能是程序表达的问题，那么该怎么去写这个程序呢？新手上路，老哥请指点</p></blockquote><a id="more"></a><p>这段程序恰好碰到了Mathematica在求导问题上的两个坑：</p><ol><li>Mathematica总是假设链式求导法则是有效的，但这里遇到的<code>Arg</code>本身是一个<em>不可导</em>的函数，链导法则是不成立的。这一点是一个非常常见的坑。</li><li>然后Mathematica的数值导数设计的也欠合理，在遇到符号求导失效的情况时，Mathematica在计算函数导数时会利用其沿着<em>实轴</em>方向的变化率来近似求导（事实上<code>Arg</code>沿复平面不同方向的变化率通常不相等），而<code>Arg</code>本身总是实数，这样一来得到的<code>Arg'[...]</code>的结果就总是一个实数，然而前面根据链导法则乘出的那一坨又是个复数，自然得到的最终结果也是复数。</li></ol><p>针对这个问题，可以提出两种解决办法：</p><ol><li><p>一个很自然的想法是直接绕开<code>Arg</code>这个不可导的函数，即可以将通过<code>ComplexExpand</code>其转化为<code>ArcTan</code>形式，再去求导就不会有这些问题了：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[x_]=<span class="keyword">ComplexExpand</span>[<span class="keyword">Arg</span>[(-(x<span class="number">-1</span>)^<span class="number">2</span>+<span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>-x^<span class="number">4</span>))/((x<span class="number">-1</span>)^<span class="number">2</span>+<span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>-x^<span class="number">4</span>)<span class="number">-4</span>*I*(x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>+<span class="number">2</span> x))],<span class="keyword">TargetFunctions</span>-&gt;&#123;<span class="keyword">Re</span>,<span class="keyword">Im</span>&#125;];</span><br><span class="line">f'[<span class="number">5</span>]</span><br><span class="line"><span class="comment">(*Out: 1117/10504*)</span></span><br></pre></td></tr></table></figure></li><li><p>还可以反过来利用上述数值导数的坑来解决：因为这里就是要求<code>f</code>沿实轴方向的导数，所以我们不妨利用数值导数始终沿实轴发生这一特性，先从<code>f</code>上就避免符号计算引入错误的链导法则，然后直接让Mathematica对<code>f</code>进行数值求导，于是可以这么写：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Clear</span>[f]</span><br><span class="line">f[x_?<span class="keyword">NumericQ</span>]:=<span class="keyword">Arg</span>[(-(x<span class="number">-1</span>)^<span class="number">2</span>+<span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>-x^<span class="number">4</span>))/((x<span class="number">-1</span>)^<span class="number">2</span>+<span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>-x^<span class="number">4</span>)<span class="number">-4</span>*I*(x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>+<span class="number">2</span> x))]</span><br><span class="line">f'[<span class="number">5.</span>]</span><br><span class="line"><span class="comment">(*Out: 0.10634*)</span></span><br></pre></td></tr></table></figure><p>如果只需要近似的数值值得话，同样可以解决问题。</p></li></ol><hr><p>相关链接：</p><ul><li><a href="http://tieba.baidu.com/p/6111508459" target="_blank" rel="noopener">来个老哥抬一手~</a></li><li><a href="https://mathematica.stackexchange.com/questions/196998/why-does-arg1-i-return-0-5" target="_blank" rel="noopener">Why does Arg’[1. + I] return -0.5?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是记录一下在回答贴吧上&lt;a href=&quot;http://tieba.baidu.com/p/6111508459&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个问题&lt;/a&gt;时所发现的关于Mathematica求导的一些坑。&lt;/p&gt;
&lt;p&gt;原问题虽然没有明说，但我推测问题背景应该是波特图之类的问题，具体问题如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;对这个函数的幅角求导，代入一个数值为什么求出了个复数值啊，实函数求导应该是实数啊。声明了一下x是实数后好像也不行。&lt;/p&gt;
&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;f[x_] := &lt;span class=&quot;keyword&quot;&gt;Arg&lt;/span&gt;[(-(x - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; x^&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; x^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - x^&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;))/((x - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; x^&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; x^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - x^&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;) - &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;*I*(x^&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; x^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; x))]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f&#39;[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;(*Out: (513125/13791752+(342351 I)/3447938) Arg&#39;[2499/2626-(765 I)/2626]*)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;N[(&lt;span class=&quot;number&quot;&gt;513125&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;13791752&lt;/span&gt;+(&lt;span class=&quot;number&quot;&gt;342351&lt;/span&gt; I)/&lt;span class=&quot;number&quot;&gt;3447938&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;Arg&lt;/span&gt;&#39;[&lt;span class=&quot;number&quot;&gt;2499&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;2626&lt;/span&gt;-(&lt;span class=&quot;number&quot;&gt;765&lt;/span&gt; I)/&lt;span class=&quot;number&quot;&gt;2626&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;(*Out: 0.0109427 + 0.0292034 I*)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是程序，我觉得可能是程序表达的问题，那么该怎么去写这个程序呢？新手上路，老哥请指点&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>Mathematica写作自动化技巧</title>
    <link href="http://miRoox.github.io/blog/2019/04/MmaAutoLiterature/"/>
    <id>http://miRoox.github.io/blog/2019/04/MmaAutoLiterature/</id>
    <published>2019-04-07T14:45:31.000Z</published>
    <updated>2020-01-25T04:11:48.796Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Mathematica的笔记本的过程中，我们常常希望将它的代码和文档功能结合起来，例如自动将符号计算的公式、图形以文档的书写习惯展示出来，同时隐藏生成代码，使文档显示自然协调。</p><a id="more"></a><p>为了达到这一目的，首先需要的是将输入自动隐藏。我们知道，即使在自然状态下，双击输出单元的单元括号<code>]</code>即可隐藏输入单元。这一操作实际相当于选中输出单元后执行了前端令牌<a href="https://reference.wolfram.com/language/ref/frontendobject/SelectionCloseUnselectedCells.html" target="_blank" rel="noopener">&quot;SelectionCloseUnselectedCells&quot;</a>，因此，可以将其写作程序代码</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SelectionMove</span>[<span class="keyword">EvaluationNotebook</span>[],<span class="keyword">All</span>,<span class="keyword">GeneratedCell</span>];</span><br><span class="line"><span class="keyword">FrontEndTokenExecute</span>[<span class="string">"SelectionCloseUnselectedCells"</span>];</span><br></pre></td></tr></table></figure><p>在输入单元最后加入上述代码即可在执行后自动折叠隐藏输入单元。</p><p>不过，当我们需要展示公式时，我们往往希望使用<code>DisplayFormula</code>或者<code>DisplayFormulaNumbered</code>等公式样式。但直接使用<code>CellPrint</code>以此样式输出的话，则因为输入单元与输出的公式单元不会自动编组而无法通过上述方式折叠。所幸单元也支持应用多个样式，将公式样式与<code>Output</code>样式同时应用即可解决。例如：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CellPrint</span>[<span class="keyword">ExpressionCell</span>[D[x^<span class="number">2</span>,x],<span class="string">"Output"</span>,<span class="string">"DisplayFormulaNumbered"</span>]];</span><br><span class="line"><span class="keyword">SelectionMove</span>[<span class="keyword">EvaluationNotebook</span>[],<span class="keyword">All</span>,<span class="keyword">GeneratedCell</span>];</span><br><span class="line"><span class="keyword">FrontEndTokenExecute</span>[<span class="string">"SelectionCloseUnselectedCells"</span>];</span><br></pre></td></tr></table></figure><p>我们也可以将这些功能都整合进样式表中，在<code>CellEpilog</code>中添加折叠单元代码，在<code>GeneratedCellStyles</code>中改变输出单元的样式。例如，我们可以通过在样式表中添加如下内容来自定义一个<code>FormulaGenerator</code>样式</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Cell</span>[<span class="keyword">StyleData</span>[<span class="string">"FormulaGenerator"</span>, <span class="keyword">StyleDefinitions</span> -&gt; <span class="keyword">StyleData</span>[<span class="string">"Input"</span>]],</span><br><span class="line"> <span class="keyword">CellEpilog</span>:&gt;(<span class="keyword">SelectionMove</span>[</span><br><span class="line">    <span class="keyword">EvaluationNotebook</span>[], <span class="keyword">All</span>, <span class="keyword">GeneratedCell</span>]; </span><br><span class="line">  <span class="keyword">FrontEndTokenExecute</span>[<span class="string">"SelectionCloseUnselectedCells"</span>]),</span><br><span class="line"> GeneratedCellStyles-&gt;&#123;<span class="string">"Output"</span>-&gt;&#123;<span class="string">"Output"</span>, <span class="string">"DisplayFormulaNumbered"</span>&#125;&#125;,</span><br><span class="line"> <span class="keyword">MenuSortingValue</span>-&gt;<span class="number">10000</span>]</span><br></pre></td></tr></table></figure><p>这样，使用<code>FormulaGenerator</code>样式的输入单元在计算后就会生成一个带标号的公式单元并自动隐藏起来。</p><hr><p>参见：</p><ul><li><a href="http://reference.wolfram.com/language/workflow/HideInputInANotebook.html" target="_blank" rel="noopener">隐藏笔记本的输入</a></li><li><a href="https://mathematica.stackexchange.com/questions/680/how-to-keep-input-cells-hidden-after-evaluating-notebook" target="_blank" rel="noopener">How to Keep Input Cells Hidden After Evaluating Notebook</a></li><li><a href="https://mathematica.stackexchange.com/questions/70185/how-to-set-the-output-be-generated-in-a-cell-different-from-output" target="_blank" rel="noopener">How to set the output be generated in a cell different from “Output”</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Mathematica的笔记本的过程中，我们常常希望将它的代码和文档功能结合起来，例如自动将符号计算的公式、图形以文档的书写习惯展示出来，同时隐藏生成代码，使文档显示自然协调。&lt;/p&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="文学编程" scheme="http://miRoox.github.io/blog/tags/%E6%96%87%E5%AD%A6%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Mathematica通用工具包参考（一）：宏</title>
    <link href="http://miRoox.github.io/blog/2019/02/WLGeneralUtilitiesMacro/"/>
    <id>http://miRoox.github.io/blog/2019/02/WLGeneralUtilitiesMacro/</id>
    <published>2019-02-27T15:00:13.000Z</published>
    <updated>2020-01-25T04:11:48.796Z</updated>
    
    <content type="html"><![CDATA[<p><code>GeneralUtilities`</code> 是Mathematica从版本10开始新加入的一个上下文。其中提供了大量的实用函数，包括代码生成、调试、静态分析、迭代器对象等各个领域，一定程度上弥补了Mathematica基础设施不足的状况。</p><p>这个工具包内包含的函数十分繁杂，在当前版本11.3下，可以通过<code>Names[&quot;GeneralUtilities`*&quot;]//Length</code>看到其共包含了514个符号。这篇文章简单介绍与宏有关的部分。</p><p>“宏”在编程领域往往作为一种代码生成技术使用，例如在一些编译型语言中，宏展开往往发生在编译或预编译阶段。而在<code>GeneralUtilities`</code>的语境下，宏默认在定义时自动展开，同样也是一种代码生成技术。</p><a id="more"></a><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Needs</span>[<span class="string">"GeneralUtilities`"</span>]</span><br></pre></td></tr></table></figure><hr><p>下面介绍<code>GeneralUtilities`</code>中的一些实用宏</p><h3 id="scopemodulescope"><a class="markdownIt-Anchor" href="#scopemodulescope"></a> <code>Scope</code>/<code>ModuleScope</code></h3><p>我们知道，Mathematica中的局部符号往往需要显式地引入，而不像很多语言在函数体内自动带有作用域。这在使用大量局部变量的时候会带来一些麻烦。而<code>Scope</code>给出了一个解决办法，它自动解析<code>Scope[body]</code>内部的赋值语句，提取与之相关联的符号自动局域化。通过<code>?GeneralUtilities`Scope</code>可以看到它的用法如下：</p><blockquote><p><code>Scope[body]</code> is a macro that expands to a <code>Block</code> with automatically populated local variable list.</p><ul><li>Variables are detected syntactically by the presence of <code>=</code> and <code>:=</code> within <code>body</code>.</li><li><code>^=</code> and <code>^:=</code> can be used to avoid this localization.</li><li><code>{sym1,sym2,...} = rhs</code> will localize <code>sym1,sym2,...</code>.</li><li><code>sym := rhs</code> will localize <code>sym</code>.</li><li>Local functions definitions <code>head[...] := rhs</code> do not cause localizalization of <code>head</code>.</li></ul></blockquote><p>而且它作为一个宏，使用在定义中，则展开发生在定义阶段，从而可以避免调用时因解析和变换带来的额外开销。例如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[x_]:=Scope[a=x;b^=a;c:=a++;&#123;d,e&#125;=&#123;b,c&#125;;a]</span><br><span class="line"><span class="keyword">Definition</span>[f]</span><br><span class="line"><span class="comment">(*Out[*]= f[x_]:=Block[&#123;a,c,d,e&#125;,a=x;b=a;c:=a++;&#123;d,e&#125;=&#123;b,c&#125;;a]*)</span></span><br></pre></td></tr></table></figure><p>可以看到<code>f</code>的定义中，<code>Scope</code>已经转换成了<code>Block</code>作用域，并自动将需要局域化的符号按<code>Block</code>的规则列出了。</p><p>类似的，<code>ModuleScope</code>自动展开成<code>Module</code>作用域结构。</p><h3 id="memoized"><a class="markdownIt-Anchor" href="#memoized"></a> <code>Memoized</code></h3><blockquote><p><code>Memoized[body]</code> specifies that <code>body</code> should be evaluted but cached so that subsequent calls with the same value for any bound symbol use the cached value.<br><br><code>Memoized[body,Method-&gt;method]</code> can be used, where <code>method</code> is one of <code>{&quot;Association&quot;, &quot;Symbol&quot;, &quot;Inline&quot;, &quot;SystemCache&quot;}</code>, to choose a specific caching method.</p></blockquote><p>即所谓的<a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="noopener">记忆化</a>手法，可以实现空间换时间的优化目的。例如对于Mathematica中一个比较经典的记忆化案例</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fib[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">fib[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">fib[n_]:=fib[n]=fib[n<span class="number">-1</span>]+fib[n<span class="number">-2</span>]</span><br></pre></td></tr></table></figure><p>利用<code>Memoized</code>可以等价地写成</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fib[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">fib[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">fib[n_]:=Memoized[fib[n<span class="number">-1</span>]+fib[n<span class="number">-2</span>],<span class="keyword">Method</span>-&gt;<span class="string">"Inline"</span>]</span><br></pre></td></tr></table></figure><p>除了<code>&quot;Inline&quot;</code>，<code>Memoized</code>还提供了其它几种记忆化的实现手段，包括默认的<code>&quot;SystemCache&quot;</code>、基于关联<code>&quot;Association&quot;</code>和面向符号的<code>&quot;Symbol&quot;</code>，这里不多赘述了。不过似乎目前的<code>&quot;Symbol&quot;</code>方法的实现有问题，无法应用于函数定义中。</p><h3 id="setupteardown"><a class="markdownIt-Anchor" href="#setupteardown"></a> <code>SetupTeardown</code></h3><blockquote><p><code>SetupTeardown[setup,body,teardown]</code> evaluates <code>setup</code>, then <code>body</code>, and then <code>teardown</code>, even if an <code>Abort</code> or <code>Throw</code> occurs during evaluation.</p></blockquote><p><code>SetupTeardown</code>是一个确保“初始化-主体-清理”执行顺序的封装，哪怕其中某部分中断或者抛出也会确保其余部分顺序进行。</p><p>举一个简单的例子</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[]:=SetupTeardown[<span class="keyword">Print</span>[<span class="string">"setup"</span>],<span class="keyword">Print</span>[<span class="string">"before"</span>];<span class="keyword">Abort</span>[];<span class="keyword">Print</span>[<span class="string">"after"</span>],<span class="keyword">Print</span>[<span class="string">"teardown"</span>]]</span><br></pre></td></tr></table></figure><p>调用<code>f[]</code>，可以看到即使<code>Abort[]</code>中断计算后，依然继续进行了<code>Print[&quot;teardown&quot;]</code>的计算。</p><p>这个宏可以用于在计算流程中确保资源的获取和释放，不过实际在Mathematica中应用比较少。</p><h3 id="matchstringmatch"><a class="markdownIt-Anchor" href="#matchstringmatch"></a> <code>Match</code>/<code>StringMatch</code></h3><blockquote><p><code>Match[value,patt<sub>1</sub>:&gt;val<sub>1</sub>,patt<sub>2</sub>:&gt;val<sub>2</sub>,…,default]</code> matches the value to the <code>patt<sub>i</sub></code> in turn and gives the corresponding <code>val<sub>i</sub></code>, or evaluates <code>default</code> if none matched.<br><br><code>Match[value,patts...,...]</code> panics if none of the <code>patts</code> matched.<br><br><code>Match[patts]</code> is the operator form of <code>Match</code>.</p></blockquote><p>长得像Rust的<a href="https://doc.rust-lang.org/book/match.html" target="_blank" rel="noopener"><code>match</code></a>，用法大抵类似<code>Switch</code>，实际只是<code>Replace</code>的一个封装。</p><p><code>StringMatch</code>无非是<code>StringReplace</code>的一个封装。</p><h3 id="catchfailurecatchfailureasmessage"><a class="markdownIt-Anchor" href="#catchfailurecatchfailureasmessage"></a> <code>CatchFailure</code>/<code>CatchFailureAsMessage</code></h3><blockquote><p><code>CatchFailure[body]</code> is a macro evaluates <code>body</code>, but returns a <code>Failure[...]</code> object if a <code>ThrowFailure[...]</code> occurred during evaluation. The current function is automatically used as the message head.<br><br><code>CatchFailure[head,body]</code> explicitly uses <code>head</code> as the message head for the failure message.</p></blockquote><blockquote><p><code>CatchFailureAsMessage[body]</code> is a macro evaluates <code>body</code>, but issues a message if a <code>ThrowFailure[...]</code> occurred during evaluation. The current function is automatically used as the message head.<br><br><code>CatchFailureAsMessage[head,body]</code> explicitly uses <code>head</code> as the message head for the failure message.</p></blockquote><p>需要配合<code>ThrowFailure</code>一起使用，语义比较清晰的错误捕获。</p><h3 id="unpackassociationunpackoptions"><a class="markdownIt-Anchor" href="#unpackassociationunpackoptions"></a> <code>UnpackAssociation</code>/<code>UnpackOptions</code></h3><blockquote><p><code>UnpackAssociation[assoc,“Name<sub>1</sub>”,“Name<sub>2</sub>”,…]</code> extracts the given keys from the association and sets variables named <code>Name<sub>i</sub></code>.<br><br><code>UnpackAssociation[assoc,symbol<sub>1</sub>,symbol<sub>2</sub>,…]</code> uppercases the first letter of the symbol name to get the key. <br><br><code>UnpackAssociation[assoc,symbol<sub>1</sub>:“Name<sub>1</sub>”,…]</code> gives an explicit name for each symbol.</p></blockquote><blockquote><p><code>UnpackOptions[sym<sub>1</sub>,sym<sub>2</sub>,…]</code> extracts options with names <code>“Sym<sub>1</sub>”, “Sym<sub>1</sub>”, …</code> and assigns them to the <code>sym<sub>i</sub></code>, where the keys are the title cased version of the symbol names.</p></blockquote><p>用法说明已经介绍得比较详细了，下面给一个简单的用例</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Options</span>[f] = &#123;<span class="string">"A"</span> -&gt; <span class="number">1</span>, <span class="string">"Op"</span> -&gt; <span class="number">2</span>&#125;;</span><br><span class="line">f[<span class="keyword">OptionsPattern</span>[]]:=Scope[UnpackOptions[a,op];&#123;a,op&#125;]</span><br><span class="line">&#123;f[], f[<span class="string">"A"</span> -&gt; <span class="number">17</span>], f[<span class="string">"Op"</span> -&gt; <span class="number">18</span>], f[<span class="string">"A"</span> -&gt; <span class="number">16</span>, <span class="string">"Op"</span> -&gt; <span class="number">19</span>]&#125;</span><br><span class="line"><span class="comment">(*Out[*]= &#123;&#123;1,2&#125;,&#123;17,2&#125;,&#123;1,18&#125;,&#123;16,19&#125;&#125;*)</span></span><br></pre></td></tr></table></figure><h3 id="collectto"><a class="markdownIt-Anchor" href="#collectto"></a> <code>CollectTo</code></h3><p><code>CollectTo</code>需要配合<code>BagInsert</code>使用，实际是<code>Internal`Bag</code>相关函数的封装，目前来看意义不大，不过这个宏没有用法说明，也可能尚未完善。</p><p>根据定义，可以大致推测<code>CollectTo[{x,y,...},body]</code>可以通过在<code>body</code>部分使用<code>BagInsert[x,val]</code>或者<code>BagInsert[x,val,index]</code>的方式高效地将<code>val</code>添加或插入到动态列表<code>x</code>中。</p><p>下面给一个简单的用例说明一下用法</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1[n_]:=Scope[CollectTo[&#123;x&#125;,<span class="keyword">Do</span>[BagInsert[x,i],&#123;i,n&#125;]];x]</span><br><span class="line">f2[n_]:=Scope[x=&#123;&#125;;<span class="keyword">Do</span>[<span class="keyword">AppendTo</span>[x,i],&#123;i,n&#125;];x]</span><br><span class="line">BenchmarkPlot[&#123;f1,f2&#125;,<span class="keyword">Identity</span>]</span><br></pre></td></tr></table></figure><p>我的电脑上给出的结果为：</p><img src="/blog/2019/02/WLGeneralUtilitiesMacro/CollectTo.png" title="CollectTo"><p>可以看到<code>Bag</code>的添加效率基本是普通列表的好几倍。</p><h3 id="dowhile"><a class="markdownIt-Anchor" href="#dowhile"></a> <code>DoWhile</code></h3><p><code>DoWhile[body,test]</code>就像C语言之类的一样，先计算<code>body</code>，再计算<code>test</code>并决定是否循环，<br>实际上就等价于<code>While[body;test]</code>。</p><h3 id="excise"><a class="markdownIt-Anchor" href="#excise"></a> <code>Excise</code></h3><blockquote><p><code>Excise[args...]</code> evaluates to an empty sequence, effectively removing its arguments without evaluation.</p></blockquote><p>个人认为没什么用，注释可以做到同样的事，甚至用途更广（<code>Excise</code>只能在使用宏的情况下工作）。</p><h3 id="usemacros"><a class="markdownIt-Anchor" href="#usemacros"></a> <code>UseMacros</code></h3><blockquote><p><code>UseMacros[body]</code> does nothing more than trigger macro expansion, use it if you want to use macros in a function but don’t need <code>Scope</code>.</p></blockquote><p>在不了解<code>GeneralUtilities`</code>中宏的作用机理的情况下，这个宏的作用可能会令人困惑。事实上，在默认条件下，上述各种宏的自动展开只会发生在赋值等号右边的最外层使用了宏的时候发生。这一事实可以在上述各种的定义中一窥究竟，以<code>Scope</code>为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scope /: HoldPattern[s:Set[_, _Scope]] := MacroEvaluate @ s;</span><br><span class="line">Scope /: HoldPattern[sd:SetDelayed[_, _Scope]] := MacroEvaluate @ sd;</span><br><span class="line">Scope /: HoldPattern[tsd:TagSetDelayed[_, _, _Scope]] := MacroEvaluate @ tsd;</span><br></pre></td></tr></table></figure><p>同样，<code>UseMacros</code>位于赋值等号右边的最外层时会触发宏自动展开，从而可以解决在内层使用宏无法展开的问题。</p><hr><p><code>GeneralUtilities`</code>除了提供上述宏之外，还提供了一些计算和生成宏的辅助工具。</p><h3 id="quoted"><a class="markdownIt-Anchor" href="#quoted"></a> <code>Quoted</code></h3><blockquote><p><code>Quoted[code]</code> is the inert body of <code>code</code> for the purposes of macro expansion.</p></blockquote><p>一个代码封装，作用基本和<code>HoldComplete</code>一样，不过使用了一个漂亮的方式输出显示代码。</p><p>在宏的实现中大量使用。</p><h3 id="macroexpandmacroexpandlist"><a class="markdownIt-Anchor" href="#macroexpandmacroexpandlist"></a> <code>MacroExpand</code>/<code>MacroExpandList</code></h3><blockquote><p><code>MacroExpand[expr]</code> evaluates all macros present in <code>expr</code> and returns the result in a <code>Quoted</code> expression.<br>Anywhere in a macro, <code>'</code> can be used to inject <code>EchoRaw</code> calls, <code>''</code> to inject <code>EchoHold</code> calls, and <code>'''</code> to wrap a function in <code>Tap</code>.</p></blockquote><blockquote><p><code>MacroExpandList[expr]</code> expands all macros that occur in <code>expr</code>, returning a list of <code>Quoted</code> expressions that give the intermediate results after each expansion step.</p></blockquote><p><code>MacroExpand</code>展开宏，但是不计算，可以用来预览宏使用的效果。而<code>MacroExpandList</code>列出展开宏的每一步。</p><h3 id="macroevaluate"><a class="markdownIt-Anchor" href="#macroevaluate"></a> <code>MacroEvaluate</code></h3><blockquote><p><code>MacroEvaluate[expr]</code> evaluates all macros present in <code>expr</code> and then evaluates the result.</p></blockquote><p>展开宏并计算。</p><p>可以尝试令<code>$Pre=MacroEvaluate</code>，这样每次计算都会尝试展开宏，从而也就不需要<code>UseMacros</code>来触发展开了。</p><h3 id="macrorules"><a class="markdownIt-Anchor" href="#macrorules"></a> <code>MacroRules</code></h3><blockquote><p><code>MacroRules[symbol]</code> gives all the macro application rules associated with the head <code>symbol</code>.</p></blockquote><p>可以通过<code>PrintDefinitions[MacroRules]</code>hack得到已定义的函数宏和变换规则。</p><h3 id="defineliteralmacrodefinemacrodefinealias"><a class="markdownIt-Anchor" href="#defineliteralmacrodefinemacrodefinealias"></a> <code>DefineLiteralMacro</code>/<code>DefineMacro</code>/<code>DefineAlias</code></h3><blockquote><p><code>DefineLiteralMacro[symbol,lhs:=rhs,...]</code> defines a literal macro such that when <code>lhs</code> it is substituted for <code>rhs</code> without evaluation.<br>The same replacement is attached to symbol for use outside a macro context.</p></blockquote><blockquote><p><code>DefineAlias[newsymbol,oldsymbol]</code> does what it says on the tin.</p></blockquote><p>这三者都用来实现自定义宏，但使用和效果上略有不同：</p><ul><li><code>DefineLiteralMacro[symbol,lhs:=rhs,...]</code> 定义的是一个字面宏，在替换展开的过程中并不会计算<code>rhs</code>。</li><li><code>DefineMacro[symbol,lhs:=rhs,...]</code> 定义的宏则会在展开时计算<code>rhs</code>。</li><li><code>DefineAlias[newsymbol,oldsymbol]</code> 定义符号的别名，只对符号有效，而且其展开发生在其它宏展开之前。</li></ul><p>尝试下面的例子以便更直观地认识到这三者间的联系和区别：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DefineMacro[fac1, fac1[x_]:=x!];</span><br><span class="line">DefineLiteralMacro[fac2, fac2[x_]:=x!];</span><br><span class="line">DefineAlias[fac3, <span class="keyword">Factorial</span>];</span><br><span class="line"></span><br><span class="line">MacroExpand[fac1[<span class="number">3</span>]]</span><br><span class="line">MacroExpand[fac2[<span class="number">3</span>]]</span><br><span class="line">MacroExpand[fac3[<span class="number">3</span>]]</span><br><span class="line">MacroExpand[fac2[]]</span><br><span class="line">MacroExpand[fac3[]]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;GeneralUtilities`&lt;/code&gt; 是Mathematica从版本10开始新加入的一个上下文。其中提供了大量的实用函数，包括代码生成、调试、静态分析、迭代器对象等各个领域，一定程度上弥补了Mathematica基础设施不足的状况。&lt;/p&gt;
&lt;p&gt;这个工具包内包含的函数十分繁杂，在当前版本11.3下，可以通过&lt;code&gt;Names[&amp;quot;GeneralUtilities`*&amp;quot;]//Length&lt;/code&gt;看到其共包含了514个符号。这篇文章简单介绍与宏有关的部分。&lt;/p&gt;
&lt;p&gt;“宏”在编程领域往往作为一种代码生成技术使用，例如在一些编译型语言中，宏展开往往发生在编译或预编译阶段。而在&lt;code&gt;GeneralUtilities`&lt;/code&gt;的语境下，宏默认在定义时自动展开，同样也是一种代码生成技术。&lt;/p&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="参考" scheme="http://miRoox.github.io/blog/tags/%E5%8F%82%E8%80%83/"/>
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="Undocumented" scheme="http://miRoox.github.io/blog/tags/Undocumented/"/>
    
  </entry>
  
  <entry>
    <title>在Wolfram语言中模拟指针语义</title>
    <link href="http://miRoox.github.io/blog/2019/01/PointerInWolfram/"/>
    <id>http://miRoox.github.io/blog/2019/01/PointerInWolfram/</id>
    <published>2019-01-18T15:15:37.000Z</published>
    <updated>2020-01-25T04:11:48.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景和问题的引入"><a class="markdownIt-Anchor" href="#背景和问题的引入"></a> 背景和问题的引入</h3><p>众所周知，Wolfram语言作为一个极为“高级”的编程语言，并没有提供指针这类较为底层的内存管理手段。而符号本身几乎总是充当了类似引用的作用，比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set[sym_Symbol]:=sym=<span class="number">1</span></span><br><span class="line">b=a;</span><br><span class="line">set[b];</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>可以看到符号<code>a</code>的值通过<code>set[b]</code>赋为了<code>1</code>。在这里<code>b</code>形式上充当了类似其它语言中的引用的作用。但这种方式并不通用，只要<code>a</code>已经具有值了，这种平凡的方式就不能起作用了。有的读者可能会想到<code>:=</code>或者<code>Hold</code>封装，不过单靠这些也不能简单地对已具有本值的符号进行修改。因此，本文试图提出一种具有类似其它语言中指针语义的封装，实现对符号的间接操作。</p><a id="more"></a><h3 id="预期的目标"><a class="markdownIt-Anchor" href="#预期的目标"></a> 预期的目标</h3><p>这里想实现一种具有类似C语言用法的指针（引用）封装。当然，由于Mathematica没有直接访问内存的手法，所有引用都是针对<em>符号</em>展开的。具体而言，应该可以实现下面的效果：</p><p>解引用：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=ref[a];</span><br><span class="line">deref@b</span><br></pre></td></tr></table></figure><p>得到<code>1</code>；</p><p>左值语义：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=ref[a];</span><br><span class="line">deref@b=<span class="number">2</span>;</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>得到<code>2</code>；</p><p>更复杂的左值：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">b=ref[a];</span><br><span class="line">deref[b][[<span class="number">2</span>]]=<span class="number">4</span>;</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>得到<code>{1,4,3}</code>；</p><p>多重引用：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=ref[a];</span><br><span class="line">c=ref[b];</span><br><span class="line">deref@deref@c=<span class="number">2</span>;</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>得到<code>2</code>。</p><p>这里只是举几个例子，文章毕竟不是测试集，也就不再赘述。</p><p>当然，我们希望能更接近C语言指针的语义。在这里，<code>ref</code>相当于C语言中的<code>&amp;</code>单目运算符，而<code>deref</code>则相当于C语言的<code>*</code>单目运算符。</p><h3 id="思路与实现"><a class="markdownIt-Anchor" href="#思路与实现"></a> 思路与实现</h3><p>考虑我们需要保有符号，才可能对符号进行引用，因此首先<code>ref</code>必须具有<code>HoldFirst</code>属性。然后<code>deref</code>能在计算时解引用，也就是</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deref[ref[sym_]] := sym</span><br></pre></td></tr></table></figure><p>然后我们需要重载<code>Set</code>以获得左值语义。由于<code>deref</code>可能出现在很深的层次中，单靠<a href="http://reference.wolfram.com/language/ref/TagSetDelayed.html" target="_blank" rel="noopener"><code>TagSetDelayed</code></a>不能覆盖重载的各种情况。但需要重载的情况必定含有<code>deref</code>，因此可以利用条件模式决定重载策略</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Unprotect</span>[<span class="keyword">Set</span>];</span><br><span class="line"><span class="keyword">Set</span>[lhs_, rhs_] /; <span class="keyword">MemberQ</span>[<span class="keyword">Unevaluated</span>[lhs], _deref, &#123;<span class="number">0</span>, <span class="keyword">Infinity</span>&#125;] := &lt;&lt;具体实现&gt;&gt;</span><br><span class="line"><span class="keyword">Protect</span>[<span class="keyword">Set</span>];</span><br></pre></td></tr></table></figure><p>由于引用在这里总是保有着符号，因此左值语义在这里更类似一个宏展开，将<code>=</code>左侧的所有直接或隐含的<code>deref[ref[sym]]</code>结构展开成对应的<code>sym</code>。为了达到这个目的，首先需要保护<code>=</code>的左侧不进行计算，这里只需要一个简单的<code>Hold</code>封装即可。然后上面的所说的“宏展开”细节上应该分两步进行：</p><p>一是将“隐含”转换为“显含”：直观上来说，可能大家会写成这样的替换规则：<code>deref[r_]:&gt;deref[Evaluate[r]]</code>，但这是不对的。由于<code>Hold</code>封装的存在，需要用到一个名为<a href="https://mathematica.stackexchange.com/questions/29317/replacement-inside-held-expression" target="_blank" rel="noopener">Trott-Strzebonski</a>的技巧，而且由于前面已经定义了<code>deref[ref[sym_]]:=sym</code>，因此这里必须借助<code>Block</code>局部地清除这个定义才行，另一方面，为了处理多重引用，还需要排除<code>deref[deref[xxx]]</code>这种模式被直接展开。</p><p>二是对显式结构进行替换：这部分比较简单，直接使用<code>deref@ref[sym_Symbol]:&gt;sym</code>即可。同样也是因为<code>Hold</code>封装的存在，符号<code>sym</code>即使有本值也不会计算。</p><p>最后将展开的结果还原为赋值表达式即可。</p><p>综合一下，我们可以得到一个比较完整的代码</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SetAttributes</span>[ref, <span class="keyword">HoldFirst</span>]</span><br><span class="line">deref[ref[sym_]] := sym</span><br><span class="line"><span class="keyword">Unprotect</span>[<span class="keyword">Set</span>];</span><br><span class="line"><span class="keyword">Set</span>[lhs_, rhs_] /; <span class="keyword">MemberQ</span>[<span class="keyword">Unevaluated</span>[lhs], _deref, &#123;<span class="number">0</span>, <span class="keyword">Infinity</span>&#125;] :=</span><br><span class="line"> <span class="keyword">With</span>[&#123;</span><br><span class="line">   lhs1 = <span class="keyword">Block</span>[&#123;deref&#125;,</span><br><span class="line">     <span class="keyword">Hold</span>[lhs] //. &#123;</span><br><span class="line">       deref@ref[sym_Symbol] :&gt; sym,</span><br><span class="line">       deref[r : <span class="keyword">Except</span>[_deref]] :&gt;  <span class="keyword">With</span>[&#123;eval = deref[r]&#125;, eval /; <span class="keyword">True</span>] <span class="comment">(*Trott-Strzebonski*)</span></span><br><span class="line">       &#125;]&#125;,</span><br><span class="line">  <span class="keyword">Replace</span>[<span class="keyword">Hold</span>[<span class="keyword">Set</span>[lhs1, rhs]], <span class="keyword">Hold</span>[<span class="keyword">Set</span>[<span class="keyword">Hold</span>[lhs2_], rhs2_]] :&gt; <span class="keyword">Set</span>[lhs2, rhs2]]</span><br><span class="line"> ]</span><br><span class="line"><span class="keyword">Protect</span>[<span class="keyword">Set</span>];</span><br></pre></td></tr></table></figure><p>当然，对于一个真正实用的模块而言，还需要一些诸如错误处理之类的细节，但如果只考虑正确使用的话，实现指针语义的核心部分都已经列在这里了。一个相对实用的版本可以在 <a href="https://github.com/miRoox/LValueRef" target="_blank" rel="noopener">https://github.com/miRoox/LValueRef</a> 找到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景和问题的引入&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景和问题的引入&quot;&gt;&lt;/a&gt; 背景和问题的引入&lt;/h3&gt;
&lt;p&gt;众所周知，Wolfram语言作为一个极为“高级”的编程语言，并没有提供指针这类较为底层的内存管理手段。而符号本身几乎总是充当了类似引用的作用，比如&lt;/p&gt;
&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;set[sym_Symbol]:=sym=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b=a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set[b];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到符号&lt;code&gt;a&lt;/code&gt;的值通过&lt;code&gt;set[b]&lt;/code&gt;赋为了&lt;code&gt;1&lt;/code&gt;。在这里&lt;code&gt;b&lt;/code&gt;形式上充当了类似其它语言中的引用的作用。但这种方式并不通用，只要&lt;code&gt;a&lt;/code&gt;已经具有值了，这种平凡的方式就不能起作用了。有的读者可能会想到&lt;code&gt;:=&lt;/code&gt;或者&lt;code&gt;Hold&lt;/code&gt;封装，不过单靠这些也不能简单地对已具有本值的符号进行修改。因此，本文试图提出一种具有类似其它语言中指针语义的封装，实现对符号的间接操作。&lt;/p&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="功能模拟" scheme="http://miRoox.github.io/blog/tags/%E5%8A%9F%E8%83%BD%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>Mathematica黑魔法：符号沙盒</title>
    <link href="http://miRoox.github.io/blog/2019/01/SymbolSandbox/"/>
    <id>http://miRoox.github.io/blog/2019/01/SymbolSandbox/</id>
    <published>2019-01-17T15:02:13.000Z</published>
    <updated>2020-01-25T04:11:48.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题的引入"><a class="markdownIt-Anchor" href="#问题的引入"></a> 问题的引入</h3><p><code>ValueQ</code>是Matheamtica中的一个非常有趣的函数，它判断一个表达式是否会进行求值，而且这种判断有时可以做到无副作用，哪怕求值本身是具有副作用的。比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>;</span><br><span class="line">y:=++x</span><br><span class="line">v=<span class="keyword">ValueQ</span>[y];</span><br><span class="line">&#123;v,x&#125;</span><br></pre></td></tr></table></figure><p>会得到<code>{True,0}</code>的结果。这里的<code>ValueQ[y]</code>显然并没有真正对<code>y</code>求值就作出了判断。不过很遗憾的是这其中哪怕只有略微的改动也会使其作用发生变化，例如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>;</span><br><span class="line">y:=++x</span><br><span class="line">v=<span class="keyword">ValueQ</span>[y+<span class="number">0</span>];</span><br><span class="line">&#123;v,x&#125;</span><br></pre></td></tr></table></figure><p>则会得到<code>{True,1}</code>。</p><a id="more"></a><p>具有<a href="http://reference.wolfram.com/language/tutorial/ManipulatingValueLists.html" target="_blank" rel="noopener">值集</a>知识的读者可能很容易猜想<code>ValueQ</code>可能具有类似下面的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Attributes[ValueQ] = &#123;HoldAll, Protected, ReadProtected&#125;</span><br><span class="line">ValueQ[sym_Symbol]:=Hold[sym]=!=Hold[sym]/.OwnValues[sym]</span><br><span class="line">ValueQ[expr_]:=Unevaluated[expr]=!=expr</span><br></pre></td></tr></table></figure><p>因而具有上面那样的行为也是可以理解的。</p><p>不过这种不一致性总归让人觉得别扭，尽管这种不一致性本质上来源于Wolfram语言求值策略的复杂性，尤其是<a href="http://reference.wolfram.com/language/ref/Condition.html" target="_blank" rel="noopener"><code>Condition</code></a>的灵活性，使得上面这种策略注定无法真正消除副作用。哪怕是现在这种状况，我们依然可以让<code>ValueQ</code>对符号作用时产生副作用，<br>例如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>;</span><br><span class="line">y:=<span class="keyword">With</span>[&#123;e=++x&#125;, e/;<span class="keyword">True</span>]</span><br><span class="line">v=<span class="keyword">ValueQ</span>[y];</span><br><span class="line">&#123;v,x&#125;</span><br></pre></td></tr></table></figure><p>也会得到<code>{True,1}</code>。这里用到的技巧叫<a href="https://mathematica.stackexchange.com/questions/29317/replacement-inside-held-expression" target="_blank" rel="noopener">Trott-Strzebonski</a>，是一种常用的元编程技巧，不过这里不做赘述，对于理解<code>Condition</code>的工作方式的读者想必并不复杂。</p><p>因此，这里想介绍另一种消去副作用的思路，也就是所谓的“符号沙盒”。</p><h3 id="思路与实现"><a class="markdownIt-Anchor" href="#思路与实现"></a> 思路与实现</h3><p>如果说<code>ValueQ</code>的思路是尽可能避免求值来消去副作用的话，那么接下来的处理方式则是尽可能将副作用局域化，就好像在沙盒环境中一样。而这也正是标题由来。</p><p>事实上，<code>Block</code>动态作用域就具有类似的效果。不过直接使用<code>Block</code>的话则略显繁琐，我们希望有一个能自动分析需要局域化的符号并且能继承既有定义的动态作用域。幸运的是，Mathematica中既有的函数足以覆盖我们的需求：<code>Internal`EmbeddedSymbols</code>和<code>Internal`InheritedBlock</code>。尽管这两者都是没有文档的“内部函数”，不过通过测试和分析可以推测他们的功能：</p><ul><li><code>Internal`EmbeddedSymbols</code>：可以获取一个表达式<strong>所有</strong>直接或<em>间接</em>使用的符号</li><li><code>Internal`InheritedBlock</code>：继承符号既有定义的动态作用域</li></ul><p>组合这两者不难得到</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SetAttributes</span>[&#123;embeddedUserSymbols,symbolSandbox&#125;,<span class="keyword">HoldFirst</span>]</span><br><span class="line">embeddedUserSymbols[expr_]:=</span><br><span class="line"> <span class="keyword">Select</span>[Internal`EmbeddedSymbols[expr],</span><br><span class="line">  <span class="keyword">Function</span>[sym,<span class="keyword">ContainsNone</span>[<span class="keyword">Attributes</span>[sym],&#123;<span class="keyword">Locked</span>,<span class="keyword">Protected</span>&#125;],<span class="keyword">HoldAll</span>]</span><br><span class="line"> ]/. &#123;<span class="keyword">Hold</span>[syms___]:&gt;<span class="keyword">Hold</span>[&#123;syms&#125;]&#125;</span><br><span class="line">symbolSandbox[expr_]:=<span class="keyword">With</span>[&#123;syms=<span class="keyword">Unevaluated</span>@@embeddedUserSymbols[expr]&#125;,</span><br><span class="line">  Internal`InheritedBlock[syms,expr]</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p>这里需要注意的是<code>Internal`EmbeddedSymbols</code>获得的符号不能全部局域化，因此加入了<code>Select</code>滤过具有<code>Locked</code>和<code>Protected</code>属性的符号。</p><p>然后我们可以给出一个更“安全”的<code>ValueQ</code></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SetAttributes</span>[valueQ,<span class="keyword">HoldFirst</span>]</span><br><span class="line">valueQ[expr_]:=<span class="keyword">Unevaluated</span>[expr]=!=symbolSandbox[expr]</span><br></pre></td></tr></table></figure><p>此时</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>;</span><br><span class="line">y:=++x</span><br><span class="line">v=valueQ[y+<span class="number">0</span>];</span><br><span class="line">&#123;v,x&#125;</span><br></pre></td></tr></table></figure><p>会给出<code>{True, 0}</code>的结果，<code>x</code>因对<code>y</code>的求值而产生的改变被限制在<code>valueQ</code>的计算过程中。</p><p>不过这种局域化仅限于符号，并不能限制诸如文件IO等其它方式的副作用，因此只能叫“符号沙盒”。</p><hr><p><strong>补充：</strong><br>经过更多测试，发现<code>Internal`EmbeddedSymbols</code>似乎有不太稳定，有时会导致内核崩溃，而且似乎<strong>不能</strong>完全获取有关的符号。这部分可能有待改进。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题的引入&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题的引入&quot;&gt;&lt;/a&gt; 问题的引入&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ValueQ&lt;/code&gt;是Matheamtica中的一个非常有趣的函数，它判断一个表达式是否会进行求值，而且这种判断有时可以做到无副作用，哪怕求值本身是具有副作用的。比如&lt;/p&gt;
&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y:=++x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v=&lt;span class=&quot;keyword&quot;&gt;ValueQ&lt;/span&gt;[y];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;v,x&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;会得到&lt;code&gt;{True,0}&lt;/code&gt;的结果。这里的&lt;code&gt;ValueQ[y]&lt;/code&gt;显然并没有真正对&lt;code&gt;y&lt;/code&gt;求值就作出了判断。不过很遗憾的是这其中哪怕只有略微的改动也会使其作用发生变化，例如&lt;/p&gt;
&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y:=++x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v=&lt;span class=&quot;keyword&quot;&gt;ValueQ&lt;/span&gt;[y+&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;v,x&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;则会得到&lt;code&gt;{True,1}&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="Undocumented" scheme="http://miRoox.github.io/blog/tags/Undocumented/"/>
    
  </entry>
  
  <entry>
    <title>Mathematica下标赋值问题补遗</title>
    <link href="http://miRoox.github.io/blog/2019/01/SubcriptInMma-Addendum/"/>
    <id>http://miRoox.github.io/blog/2019/01/SubcriptInMma-Addendum/</id>
    <published>2019-01-16T06:55:47.000Z</published>
    <updated>2020-01-25T04:11:48.796Z</updated>
    
    <content type="html"><![CDATA[<p>我曾经写过一篇关于Mathematica中下标与赋值问题的<a href="https://miroox.github.io/2018/08/SubscriptAndDerivateInMma/">文章</a>，不过那篇文章重点解决的是符号关联的问题。但有时，我们可能会遇到另一种问题，比如</p><img src="/blog/2019/01/SubcriptInMma-Addendum/Subscript.png" title="Subscript"><a id="more"></a><p>也就是定义了符号的本值之后又想定义带有同样符号的下标值。当然，我们是不推荐这么写的，这会使符号的含义很含混。<br>不过单从实用的角度考虑，让上面的代码正常工作并不困难，只需要对<code>Subscript</code>添加<code>HoldFirst</code>属性即可。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SetAttributes</span>[<span class="keyword">Subscript</span>,<span class="keyword">HoldFirst</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我曾经写过一篇关于Mathematica中下标与赋值问题的&lt;a href=&quot;https://miroox.github.io/2018/08/SubscriptAndDerivateInMma/&quot;&gt;文章&lt;/a&gt;，不过那篇文章重点解决的是符号关联的问题。但有时，我们可能会遇到另一种问题，比如&lt;/p&gt;
&lt;img src=&quot;/blog/2019/01/SubcriptInMma-Addendum/Subscript.png&quot; title=&quot;Subscript&quot;&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>突然发现部分Wolfram演示项目支持在线运行了</title>
    <link href="http://miRoox.github.io/blog/2018/12/WolframOnlineDemo/"/>
    <id>http://miRoox.github.io/blog/2018/12/WolframOnlineDemo/</id>
    <published>2018-12-01T12:09:39.000Z</published>
    <updated>2020-01-25T04:11:48.796Z</updated>
    
    <content type="html"><![CDATA[<p>如题，已经有<strong>部分</strong>Wolfram演示项目支持在线运行，尽管这个功能貌似还在测试中。</p><a id="more"></a><p>甚至还支持以内联框架的形式嵌入网页。比如下面这个例子就来自 <a href="https://demonstrations.wolfram.com/FraunhoferDiffractionThroughARectangularAperture" target="_blank" rel="noopener">https://demonstrations.wolfram.com/FraunhoferDiffractionThroughARectangularAperture</a>。</p><iframe src="https://www.wolframcloud.com/objects/demonstrations/FraunhoferDiffractionThroughARectangularAperture?_view=EMBED" width="420" height="480" frameborder="0" allowfullscreen></iframe><p>不过这个在线运行机制似乎是基于 <a href="https://www.wolfram.com/cloud/" target="_blank" rel="noopener">Wolfram Cloud</a> 实现的，而不是 <a href="https://webassembly.org/" target="_blank" rel="noopener">Web Assembly</a> 之类的本地计算，因此响应速度会有点慢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如题，已经有&lt;strong&gt;部分&lt;/strong&gt;Wolfram演示项目支持在线运行，尽管这个功能貌似还在测试中。&lt;/p&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>解决CurrentValue等动态刷新无法控制的问题</title>
    <link href="http://miRoox.github.io/blog/2018/11/FixCurrentValueRefresh/"/>
    <id>http://miRoox.github.io/blog/2018/11/FixCurrentValueRefresh/</id>
    <published>2018-11-28T15:09:13.000Z</published>
    <updated>2020-01-25T04:11:48.796Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>All problems in computer science can be solved by another level of indirection. <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p></blockquote><p>最近在拿Mathematica做一些小东西的时候发现<code>CurrentValue</code>等函数在动态中刷新不受<code>Refresh</code>等方式影响。比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dynamic</span>[<span class="keyword">Refresh</span>[<span class="keyword">CurrentValue</span>[<span class="string">"MousePosition"</span>], <span class="keyword">None</span>]]</span><br></pre></td></tr></table></figure><p>输出会不断刷新，并不受<code>Refresh[□, None]</code>结构控制。</p><a id="more"></a><p>另一方面，同样被设计为“过分敏感”的<code>Clock</code>则受<code>Refresh</code>控制，</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dynamic</span>[<span class="keyword">Refresh</span>[<span class="keyword">Clock</span>[]], <span class="keyword">None</span>]]</span><br></pre></td></tr></table></figure><p>其输出则不会更新。</p><p>鉴于文档中并没有提到过这个问题，我个人认为这是一个<em>bug</em>。不过几个<code>Current</code>开头的函数都有这个问题，包括<code>CurrentImage</code>、<code>CurrentNotebookImage</code>、<code>CurrentScreenImage</code>，或许这其实是这类函数的一个<em>feature</em>也说不定。然而，出于某些应用场合的需求，我希望这些函数能像其它动态一样受控，这篇文章也因此而来。</p><p>当然，前面的例子太过“平凡”了，直接使用静态输出就没有那么多事了。如果我们考虑一个定时刷新的光标位置，那么按照一般的写法，可能写成</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dynamic</span>[<span class="keyword">CurrentValue</span>[<span class="string">"MousePosition"</span>], <span class="keyword">UpdateInterval</span> -&gt; <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>但正如前面指出的，上面这段代码并不能正常地工作。要解决这个问题，实际要引入一个受控的中间层，来间接表示<code>CurrentValue[&quot;MousePosition&quot;]</code>。正如<a href="http://reference.wolfram.com/language/workflow/PutAutoupdatingDynamicContentInANotebook.html" target="_blank" rel="noopener">文档</a>中所提到的，通过组合<code>TrackedSymbols</code>和<code>UpdateInterval</code>，我们可以精确控制只受符号变化影响的动态更新。再借助<code>DynamicWrapper</code>同步受控符号与<code>CurrentValue</code>表达式即可。最终我们得到</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DynamicModule</span>[&#123;p&#125;,</span><br><span class="line"> <span class="keyword">DynamicWrapper</span>[</span><br><span class="line">  <span class="keyword">Dynamic</span>[p, <span class="keyword">UpdateInterval</span> -&gt; <span class="number">1</span>, <span class="keyword">TrackedSymbols</span> :&gt; &#123;&#125;],</span><br><span class="line">  p = <span class="keyword">CurrentValue</span>[<span class="string">"MousePosition"</span>]</span><br><span class="line"> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>至此，<code>CurrentValue</code>等动态刷新无法控制的问题圆满解决。</p><hr><p><em><strong>2019年1月22日补充</strong></em>：<br>这大概确实是一个bug，在<a href="https://mathematica.stackexchange.com/questions/127454/currentvalue-and-mouseposition-do-not-respect-dynamics-options" target="_blank" rel="noopener">SE上的这个问题</a>中作者表示已经将这一情况向Wolfram公司提出了。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www2.dmst.aueb.gr/dds/pubs/inbook/beautiful_code/html/Spi07g.html" target="_blank" rel="noopener">https://www2.dmst.aueb.gr/dds/pubs/inbook/beautiful_code/html/Spi07g.html</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;All problems in computer science can be solved by another level of indirection. &lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在拿Mathematica做一些小东西的时候发现&lt;code&gt;CurrentValue&lt;/code&gt;等函数在动态中刷新不受&lt;code&gt;Refresh&lt;/code&gt;等方式影响。比如&lt;/p&gt;
&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Dynamic&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;Refresh&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;CurrentValue&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;&quot;MousePosition&quot;&lt;/span&gt;], &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出会不断刷新，并不受&lt;code&gt;Refresh[□, None]&lt;/code&gt;结构控制。&lt;/p&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>如何方便快捷地查看Mathematica中的符号定义？</title>
    <link href="http://miRoox.github.io/blog/2018/10/PrintDefinitions/"/>
    <id>http://miRoox.github.io/blog/2018/10/PrintDefinitions/</id>
    <published>2018-10-07T05:50:12.000Z</published>
    <updated>2020-01-25T04:11:48.796Z</updated>
    
    <content type="html"><![CDATA[<p>使用</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GeneralUtilities`PrintDefinitions[symbol]</span><br></pre></td></tr></table></figure><p>即可，如下图</p><img src="/blog/2018/10/PrintDefinitions/usage.png" title="usage"><a id="more"></a><hr><p>不过就这么结束了好像也不太好，再补充几点：</p><ul><li>生成的笔记本文档中的符号可以通过点击打开其定义，就好像许多其它语言的IDE中的“Jump to Definition”功能一样。</li><li>有许多内置函数的定义是看不到的，因为它们的实现可能不是通过Wolfram语言完成的。这时你可能只能看到<code>&lt;&lt;kernel function&gt;&gt;</code>的字样。</li><li>有些包里的符号可能没有预先加载，也许在第一次调用的时候只会得到一个空的笔记本，这时，你可能需要再运行一次才能得到正确的结果。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用&lt;/p&gt;
&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GeneralUtilities`PrintDefinitions[symbol]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;即可，如下图&lt;/p&gt;
&lt;img src=&quot;/blog/2018/10/PrintDefinitions/usage.png&quot; title=&quot;usage&quot;&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>Mathematica下标与导数赋值问题的解决方法</title>
    <link href="http://miRoox.github.io/blog/2018/08/SubscriptAndDerivateInMma/"/>
    <id>http://miRoox.github.io/blog/2018/08/SubscriptAndDerivateInMma/</id>
    <published>2018-08-23T07:22:43.000Z</published>
    <updated>2020-01-25T04:11:48.796Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，Mathematica中虽然使用下标形式非常方便，但如果对下标结构进行直接赋值，它将关联到内部符号<code>Subscript</code>上。这样，在我们大量清理符号定义的时候可能会漏掉一些定义。类似地，导数<code>Derivative</code>有同样的问题，比如对于</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f'=df</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Clear</span>[f]</span><br><span class="line"><span class="keyword">Clear</span>[<span class="string">"`*"</span>]</span><br></pre></td></tr></table></figure><p>并不能清除<code>f'</code>的定义。</p><a id="more"></a><p>虽说将直接赋值改为用<code>UpSet</code>或者<code>TagSet</code>替代可以将赋值关联到符号<code>f</code>上而不是别的，比如下面的代码。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f/:f'=df</span><br></pre></td></tr></table></figure><p>但每次多打一些东西总归是不方便，我们总会想找一个一劳永逸的办法。</p><p>官方文档中提到的对<a href="http://reference.wolfram.com/language/tutorial/DefiningNumericalValues.html" target="_blank" rel="noopener">数量值</a>的处理给了我启发。</p><blockquote><p>在Wolfram语言中，数量值的处理与上值类似，当定义了<code>f</code>的数量值以后，Wolfram语言就象求值运算<code>N</code>中<code>f</code>的上值一样来输入这一定义.</p></blockquote><p>下标的情况相对比较容易处理，类似<code><span>a</span><sub>n</sub></code>的结构在Wolfram语言中实质就是<code>Subscript[a,n]</code>，我们只要把普通的赋值转化为<code>TagSet</code>即可，就如下面的代码所示</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Subscript</span> /: <span class="keyword">Set</span>[<span class="keyword">Subscript</span>[a_Symbol, rest__], val_] := </span><br><span class="line"> <span class="keyword">TagSet</span>[a, <span class="keyword">Subscript</span>[a, rest], val]</span><br><span class="line"><span class="keyword">Subscript</span> /: <span class="keyword">SetDelayed</span>[<span class="keyword">Subscript</span>[a_Symbol, rest__], val_] := </span><br><span class="line"> <span class="keyword">TagSetDelayed</span>[a, <span class="keyword">Subscript</span>[a, rest], val]</span><br></pre></td></tr></table></figure><p><code>Derivative</code>的情况相对要复杂一些，因为即使看上去非常简单的<code>f'[x]</code>在Wolfram语言内部也会表示为<code>Derivative[1][f][x]</code>，我们认为的主要符号<code>f</code>在这个表达式中层次太深，无法直接将<code>TagSet</code>应用在上面，因此只能采取一些迂回的办法。</p><p>值得庆幸的是，Mathematica也支持纯函数式的导数，例如<code>Sin'</code>会得到<code>Cos[#1]&amp;</code>。而在<code>Derivative[1][f]</code>结构中，<code>f</code>是可以通过<code>TagSet</code>赋予上值的。对于这种情况，采用和前面类似的方法就能解决。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Derivative</span> /: <span class="keyword">Set</span>[<span class="keyword">Derivative</span>[ns__Integer][f_Symbol], val_] := </span><br><span class="line"> <span class="keyword">TagSet</span>[f, <span class="keyword">Derivative</span>[ns][f], val]</span><br><span class="line"><span class="keyword">Derivative</span> /: <span class="keyword">SetDelayed</span>[<span class="keyword">Derivative</span>[ns__Integer][f_Symbol], val_] := </span><br><span class="line"> <span class="keyword">TagSetDelayed</span>[f, <span class="keyword">Derivative</span>[ns][f], val]</span><br></pre></td></tr></table></figure><p>而对于类似<code>Derivative[1][f][x]</code>的情况，虽然我们无法直接对其使用<code>TagSet</code>，但我们可以考虑将其转换为纯函数的情况。</p><p>动手前先分析，例如<code>f'[x_]:=x</code>我们希望将其转换为<code>f':=Function[{x},x]</code>，为了达到这个目的，需要去掉原本赋值中的模式结构<code>:_</code>。<br>我们知道，像<code>x_</code>的完整形式是<code>Pattern[x,Blanck[]]</code>。因此，提取<code>x_</code>的<code>x</code>只要将其第一部分提取出来即可。综合一下可以写成如下的代码</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Derivative</span> /: </span><br><span class="line"> <span class="keyword">Set</span>[<span class="keyword">Derivative</span>[ns__Integer][f_Symbol][args__Pattern], val_] := </span><br><span class="line"> <span class="keyword">Set</span>[<span class="keyword">Derivative</span>[ns][f], <span class="keyword">Evaluate</span>[<span class="keyword">First</span> /@ &#123;args&#125;] \[<span class="keyword">Function</span>] val]</span><br><span class="line"><span class="keyword">Derivative</span> /: </span><br><span class="line"> <span class="keyword">SetDelayed</span>[<span class="keyword">Derivative</span>[ns__Integer][f_Symbol][args__Pattern], val_] := </span><br><span class="line"> <span class="keyword">Set</span>[<span class="keyword">Derivative</span>[ns][f], <span class="keyword">Evaluate</span>[<span class="keyword">First</span> /@ &#123;args&#125;] \[<span class="keyword">Function</span>] val]</span><br></pre></td></tr></table></figure><p>其中，<code>Evaluate</code>是为了解决<code>Function</code>的<code>HoldAll</code>属性的。</p><p>除此之外，还有一点值得注意。像<code>Derivative[1]</code>和<code>Derivative[1,0]</code>是不同的，<code>Derivative</code>的参数个数应该与被求导函数的参数个数匹配。<br>考虑了这个问题后，可以将上面的代码改成下面这样，以避免出现类似<code>f'[x_,y_]:=df[x,y]</code>错误形式。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Derivative</span> /: </span><br><span class="line"> <span class="keyword">Set</span>[<span class="keyword">Derivative</span>[ns__Integer][f_Symbol][x__Pattern], val_] := </span><br><span class="line"> <span class="keyword">If</span>[<span class="keyword">Length</span>@&#123;ns&#125; == <span class="keyword">Length</span>@&#123;x&#125;, </span><br><span class="line">  <span class="keyword">Set</span>[<span class="keyword">Derivative</span>[ns][f], </span><br><span class="line">   <span class="keyword">Evaluate</span>[<span class="keyword">First</span> /@ &#123;x&#125;] \[<span class="keyword">Function</span>] val], <span class="keyword">$Failed</span>]</span><br><span class="line"><span class="keyword">Derivative</span> /: </span><br><span class="line"> <span class="keyword">SetDelayed</span>[<span class="keyword">Derivative</span>[ns__Integer][f_Symbol][x__Pattern], val_] := </span><br><span class="line"> <span class="keyword">If</span>[<span class="keyword">Length</span>@&#123;ns&#125; == <span class="keyword">Length</span>@&#123;x&#125;, </span><br><span class="line">  <span class="keyword">Set</span>[<span class="keyword">Derivative</span>[ns][f], </span><br><span class="line">   <span class="keyword">Evaluate</span>[<span class="keyword">First</span> /@ &#123;x&#125;] \[<span class="keyword">Function</span>] val], <span class="keyword">$Failed</span>]</span><br></pre></td></tr></table></figure><p>当然，这种方法不能应对类似<code>f'[1]=0</code>这样的单点导数赋值。但这种基于模式的单点导数定义本身也不是很合适的做法，比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f'[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">f'[x_]:=x</span><br><span class="line">D[f[x],x]</span><br></pre></td></tr></table></figure><p>其结果是无法体现出<code>f'[1]=0</code>的。</p><p>因此对于一个函数的某阶导数，应该避免重载。如果有需要，也应该使用<code>Piecewise</code>之类的手段整合成一个函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，Mathematica中虽然使用下标形式非常方便，但如果对下标结构进行直接赋值，它将关联到内部符号&lt;code&gt;Subscript&lt;/code&gt;上。这样，在我们大量清理符号定义的时候可能会漏掉一些定义。类似地，导数&lt;code&gt;Derivative&lt;/code&gt;有同样的问题，比如对于&lt;/p&gt;
&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;f&#39;=df&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Clear&lt;/span&gt;[f]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Clear&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;&quot;`*&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;并不能清除&lt;code&gt;f&#39;&lt;/code&gt;的定义。&lt;/p&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>Mathematica程序包的中文与Unicode处理</title>
    <link href="http://miRoox.github.io/blog/2018/08/UnicodeCharInMmaPackage/"/>
    <id>http://miRoox.github.io/blog/2018/08/UnicodeCharInMmaPackage/</id>
    <published>2018-08-08T04:28:23.000Z</published>
    <updated>2020-01-25T04:11:48.796Z</updated>
    
    <content type="html"><![CDATA[<p>Mathematica在处理字符时默认总会将所有字符转换为ASCII字符表示，例如<code>π</code>会转化为<code>\[Pi]</code>，而像汉字<code>仪</code>这样的一般字符会转化为<code>\:4eea</code>。</p><p>这种设计固然可以避免某些环境对非ASCII字符不支持的困难，而且在Mathematica环境下会自动转换成原本的字符，但对于一般的文本阅读环境而言，尤其是在代码中使用一些中文文本或者注释时，这样的内容阅读起来根本无法理解。</p><p>为了方便在没有Mathematica的环境下也能方便的阅读程序包中的非ASCII的一般字符，下面脚本提供了将<code>\:nnnn</code>形式的转义序列转换为UTF-8编码下对应的Unicode字符的简单方法</p><a id="more"></a><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env wolframscript</span><br><span class="line"></span><br><span class="line">fileName=<span class="keyword">Last</span>[<span class="keyword">$ScriptCommandLine</span>];</span><br><span class="line">in=<span class="keyword">Import</span>[fileName,<span class="string">"Text"</span>];</span><br><span class="line">out=<span class="keyword">StringReplace</span>[in,(<span class="string">"\\:"</span>~~(n:<span class="keyword">Repeated</span>[<span class="keyword">HexadecimalCharacter</span>,&#123;<span class="number">4</span>&#125;])):&gt;<span class="keyword">FromCharacterCode</span>[<span class="keyword">FromDigits</span>[n,<span class="number">16</span>],<span class="string">"UTF-8"</span>]];</span><br><span class="line"><span class="keyword">Export</span>[fileName,out,<span class="string">"Text"</span>,<span class="keyword">CharacterEncoding</span>-&gt;<span class="string">"UTF-8"</span>];</span><br></pre></td></tr></table></figure><p>经过处理的文件用Mathematica也可以正常打开显示，只是每次保存时又会重新使用转义序列表示非ASCII字符，因而每次修改都应该重新运行脚本。</p><p>对于程序包，如果在代码正文中也使用了中文等非ASCII字符的话，在使用<code>Get</code>等方式导入包时，可能需要添加选项<code>CharacterEncoding-&gt;&quot;UTF-8&quot;</code>才能正确地显示其中的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mathematica在处理字符时默认总会将所有字符转换为ASCII字符表示，例如&lt;code&gt;π&lt;/code&gt;会转化为&lt;code&gt;\[Pi]&lt;/code&gt;，而像汉字&lt;code&gt;仪&lt;/code&gt;这样的一般字符会转化为&lt;code&gt;\:4eea&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这种设计固然可以避免某些环境对非ASCII字符不支持的困难，而且在Mathematica环境下会自动转换成原本的字符，但对于一般的文本阅读环境而言，尤其是在代码中使用一些中文文本或者注释时，这样的内容阅读起来根本无法理解。&lt;/p&gt;
&lt;p&gt;为了方便在没有Mathematica的环境下也能方便的阅读程序包中的非ASCII的一般字符，下面脚本提供了将&lt;code&gt;\:nnnn&lt;/code&gt;形式的转义序列转换为UTF-8编码下对应的Unicode字符的简单方法&lt;/p&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>Wolfram语言中的作用域结构</title>
    <link href="http://miRoox.github.io/blog/2018/08/ScopeInWolframLang/"/>
    <id>http://miRoox.github.io/blog/2018/08/ScopeInWolframLang/</id>
    <published>2018-08-06T03:06:12.000Z</published>
    <updated>2020-01-25T04:11:48.796Z</updated>
    
    <content type="html"><![CDATA[<p>Wolfram语言中的作用域结构主要有如下5种:</p><ul><li><code>Module</code></li><li><code>Block</code></li><li><code>With</code></li><li><code>DynamicModule</code></li><li>命名空间</li></ul><a id="more"></a><h3 id="module"><a class="markdownIt-Anchor" href="#module"></a> <a href="http://reference.wolfram.com/language/ref/Module.html" target="_blank" rel="noopener">Module</a></h3><p>按照<a href="http://reference.wolfram.com/language/tutorial/BlocksComparedWithModules.html" target="_blank" rel="noopener">文档</a>中的说法，<code>Module</code>提供变量的词法(lexical)定界。它使范围内的变量具有类似C语言中局部变量的行为。</p><p>然而，和C语言等不同，Wolfram语言没有对变量的名称和对象的区分，同样的名称总是用于指代同一变量。因此，<code>Module</code>在创建局部变量时，实际是创建新的符号并进行替换，比如运行下面的代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Module</span>[&#123;x&#125;, x]</span><br></pre></td></tr></table></figure><p>从输出结果中可以看到形如<code>x$nnn</code>的局部变量。</p><p>正如前面提到的，<code>Module</code>提供的是变量的<em>词法</em>定界。因此，只有显式出现在作用域中的变量会被局部化。偶尔，这可能带来一些意想不到的结果。典型地，下面的代码</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = i^<span class="number">2</span>;</span><br><span class="line"><span class="keyword">Module</span>[&#123;i = a&#125;, i + m]</span><br></pre></td></tr></table></figure><p>会输出<code>a+i<sup>2</sup></code>。</p><p>为了有效地实现定界，<code>Module</code>创建的变量都有<a href="http://reference.wolfram.com/language/ref/Temporary.html" target="_blank" rel="noopener"><code>Temporary</code></a>属性来控制变量的生存期。它采用类似引用计数的方式来考察一个变量是否还在使用，并决定是否要将变量移除。因此，我们基本不需要考虑可能的变量冲突。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Module</span>[&#123;x&#125;, <span class="keyword">Print</span>[x]; <span class="keyword">Attributes</span>[x]]</span><br><span class="line"><span class="keyword">Names</span>[<span class="string">"x*"</span>]</span><br></pre></td></tr></table></figure><p>多数时候，我们可能喜欢使用<code>Module</code>，因为它确实会如我们期望地那样创建新的变量。但它毕竟不是万能的，只有始终明确它的含义和适用的场合，才能保证正确地使用它。</p><p><strong>思考题1</strong>：<br>下面的程序会输出什么？</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">Module</span>[&#123;x = <span class="number">2</span>&#125;,</span><br><span class="line"> <span class="keyword">Print</span>[x];</span><br><span class="line"> <span class="keyword">Print</span>[<span class="keyword">Symbol</span>[<span class="string">"x"</span>]];</span><br><span class="line">]</span><br><span class="line"><span class="keyword">Print</span>[x]</span><br></pre></td></tr></table></figure><p><strong>延伸阅读</strong>：<br><a href="http://reference.wolfram.com/language/tutorial/ModulesAndLocalVariables.html" target="_blank" rel="noopener">模块和局部变量</a>、<a href="http://reference.wolfram.com/language/tutorial/HowModulesWork.html" target="_blank" rel="noopener">模块工作方式</a></p><h3 id="block"><a class="markdownIt-Anchor" href="#block"></a> <a href="http://reference.wolfram.com/language/ref/Block.html" target="_blank" rel="noopener">Block</a></h3><p>与<code>Module</code>不同，<code>Block</code>提供变量的动态定界。它不产生新的变量，只是在作用域内临时地修改变量的值。因此，前面的例子如果用<code>Block</code>改写</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = i^<span class="number">2</span>;</span><br><span class="line"><span class="keyword">Block</span>[&#123;i = a&#125;, i + m]</span><br></pre></td></tr></table></figure><p>则会输出<code>a+a<sup>2</sup></code>。</p><p>基于这种特性，<code>Block</code>经常被用在将副作用局域化的场合。</p><p>比如，局部地进行深度递归</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cl[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">cl[n_Integer?<span class="keyword">EvenQ</span>] := cl[n/<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">cl[n_Integer?<span class="keyword">OddQ</span>] := cl[<span class="number">3</span> n + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">Block</span>[&#123;<span class="keyword">$RecursionLimit</span> = <span class="keyword">Infinity</span>&#125;, cl[<span class="number">9780657630</span>]]</span><br></pre></td></tr></table></figure><p>又比如，局部地清除值</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">Block</span>[&#123;x&#125;, <span class="keyword">Print</span>[<span class="keyword">Expand</span>[(<span class="number">1</span> + x)^<span class="number">3</span>]]]</span><br></pre></td></tr></table></figure><p>值得注意的是，上面使用了<code>Print</code>直接输出来避免从<code>Block</code>返回的值再被计算。如果普通地从<code>Block</code>返回值，则其中的表达式会由于<code>x=0</code>而重新计算，从而输出<code>1</code>。利用<code>Trace</code>我们可以看到这其中的过程</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">Block</span>[&#123;x&#125;, <span class="keyword">Expand</span>[(<span class="number">1</span> + x)^<span class="number">3</span>]] // <span class="keyword">Trace</span> // <span class="keyword">Column</span></span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Block</span>[&#123;x&#125;,<span class="keyword">Expand</span>[(<span class="number">1</span>+x)^<span class="number">3</span>]]</span><br><span class="line">&#123;<span class="keyword">Expand</span>[(<span class="number">1</span>+x)^<span class="number">3</span>],<span class="number">1</span>+<span class="number">3</span> x+<span class="number">3</span> x^<span class="number">2</span>+x^<span class="number">3</span>&#125;</span><br><span class="line"><span class="number">1</span>+<span class="number">3</span> x+<span class="number">3</span> x^<span class="number">2</span>+x^<span class="number">3</span></span><br><span class="line">&#123;&#123;x,<span class="number">0</span>&#125;,<span class="number">3</span> <span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#123;&#123;&#123;x,<span class="number">0</span>&#125;,<span class="number">0</span>^<span class="number">2</span>,<span class="number">0</span>&#125;,<span class="number">3</span> <span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#123;&#123;x,<span class="number">0</span>&#125;,<span class="number">0</span>^<span class="number">3</span>,<span class="number">0</span>&#125;</span><br><span class="line"><span class="number">1</span>+<span class="number">0</span>+<span class="number">0</span>+<span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>Block</code>虽然很便利，但“成也动态定界败也动态定界”，它所带来副作用往往不是显然的，更容易引入一些潜在的错误。另一点值得注意的是，像<code>Table</code>、<code>Plot</code>之类的函数在运算时使用与Block相同的方式局部化变量的值。这意味着使用这些函数时必须同使用<code>Block</code>一样小心</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[x_] := i*x</span><br><span class="line"><span class="keyword">Table</span>[f[i], &#123;i, <span class="number">5</span>&#125;]</span><br><span class="line"><span class="keyword">Table</span>[f[j], &#123;j, <span class="number">5</span>&#125;]</span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;i, <span class="number">2</span> i, <span class="number">3</span> i, <span class="number">4</span> i, <span class="number">5</span> i&#125;</span><br></pre></td></tr></table></figure><p>另一方面，这个特性在使用<code>EvaluationMonitor</code>之类的监视器时会带来很大的方便。比如下面的代码可以直接追踪出求根过程中的步骤</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FindRoot</span>[x^<span class="number">2</span> - <span class="number">2</span>, &#123;x, <span class="number">1</span>&#125;, <span class="keyword">EvaluationMonitor</span> :&gt; <span class="keyword">Print</span>[<span class="string">"x="</span>, x, <span class="string">" Bias:"</span>, <span class="keyword">Abs</span>[x^<span class="number">2</span> - <span class="number">2</span>]]]</span><br></pre></td></tr></table></figure><p><strong>思考题2</strong>：<br>下面的程序会输出什么？与<code>Module</code>时的情况进行比较。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">Block</span>[&#123;x = <span class="number">2</span>&#125;,</span><br><span class="line"> <span class="keyword">Print</span>[x];</span><br><span class="line"> <span class="keyword">Print</span>[<span class="keyword">Symbol</span>[<span class="string">"x"</span>]];</span><br><span class="line">]</span><br><span class="line"><span class="keyword">Print</span>[x]</span><br></pre></td></tr></table></figure><p><strong>延伸阅读</strong>：<br><a href="http://reference.wolfram.com/language/tutorial/BlocksComparedWithModules.html" target="_blank" rel="noopener">块与模块的比较</a>、<a href="http://reference.wolfram.com/language/tutorial/BlocksAndLocalValues.html" target="_blank" rel="noopener">块和局部值</a></p><h3 id="with"><a class="markdownIt-Anchor" href="#with"></a> <a href="http://reference.wolfram.com/language/ref/With.html" target="_blank" rel="noopener">With</a></h3><p><code>With</code>的目的是实现局部常量，但它实质上不过是一个替换罢了。在大多数情况下</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">With</span>[&#123;x = x0, y = y0&#125;, expr]</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Unevaluated</span>[expr] /. &#123;<span class="keyword">HoldPattern</span>[x] -&gt; x0, <span class="keyword">HoldPattern</span>[y] -&gt; y0&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>With</code>并不会创建变量，相反，在替换的过程中往往还会减少变量。这个性质往往非常有用。比如，它可以把值插入到保持(held)表达式中：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Table</span>[<span class="keyword">With</span>[&#123;i = i&#125;, <span class="keyword">Hold</span>[i]], &#123;i, <span class="number">5</span>&#125;]</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">Hold</span>[<span class="number">1</span>], <span class="keyword">Hold</span>[<span class="number">2</span>], <span class="keyword">Hold</span>[<span class="number">3</span>], <span class="keyword">Hold</span>[<span class="number">4</span>], <span class="keyword">Hold</span>[<span class="number">5</span>]&#125;</span><br></pre></td></tr></table></figure><p>但如果不借助<code>With</code>传递一下的话</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Table</span>[<span class="keyword">Hold</span>[i], &#123;i, <span class="number">5</span>&#125;]</span><br></pre></td></tr></table></figure><p>输出结果则会是</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">Hold</span>[i], <span class="keyword">Hold</span>[i], <span class="keyword">Hold</span>[i], <span class="keyword">Hold</span>[i], <span class="keyword">Hold</span>[i]&#125;</span><br></pre></td></tr></table></figure><p>在下面的延伸阅读中的“How To”主题里，可以看到有关这种性质更实际的用法。</p><p><strong>思考题3</strong>：<br>下面的程序会输出什么？</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">With</span>[&#123;x = y&#125;,</span><br><span class="line"> x = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">Evaluate</span>[<span class="keyword">Symbol</span>[<span class="string">"x"</span>]] = <span class="number">2</span>;</span><br><span class="line">]</span><br><span class="line">&lt;|<span class="string">"x"</span> -&gt; x, <span class="string">"y"</span> -&gt; y|&gt;</span><br></pre></td></tr></table></figure><p><strong>思考题4</strong>：<br>前面提到<code>With</code>可以将值插入保持表达式，考虑如果将<code>With</code>替换为<code>Module</code>或者<code>Block</code>是否能实现同样的效果？为什么？</p><p><strong>思考题5</strong>：<br>前面提到，<em>大多数情况</em>下，<code>With</code>可以等价于一个替换。那么，在什么情况下不能简单地进行替换？比较下面两段程序，思考造成差异的原因，<br>并考虑<code>With</code>的适用范围。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">With</span>[&#123;y = x + a&#125;, <span class="keyword">Function</span>[&#123;x&#125;, x + y]]</span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Unevaluated</span>[<span class="keyword">Function</span>[&#123;x&#125;, x + y]] /. &#123;<span class="keyword">HoldPattern</span>[y] -&gt; x + a&#125;</span><br></pre></td></tr></table></figure><p><strong>延伸阅读</strong>：<br><a href="http://reference.wolfram.com/language/tutorial/LocalConstants.html" target="_blank" rel="noopener">局部常量</a>、<a href="http://reference.wolfram.com/language/howto/EvaluateExpressionsInsideDynamicOrManipulate.html" target="_blank" rel="noopener">How To | 在 Dynamic 或 Manipulate 内部计算表达式</a>、<a href="http://reference.wolfram.com/language/tutorial/VariablesInPureFunctionsAndRules.html" target="_blank" rel="noopener">纯函数和规则中的变量</a></p><h3 id="dynamicmodule"><a class="markdownIt-Anchor" href="#dynamicmodule"></a> <a href="http://reference.wolfram.com/language/ref/DynamicModule.html" target="_blank" rel="noopener">DynamicModule</a></h3><p>与<code>Module</code>类似，<code>DynamicModule</code>也建立变量的词法作用域，但两者又有不同：如果说<code>Module</code>将变量局域在一个<em>时间段</em>的话，那么<code>DynamicModule</code>将变量局域在其输出的一个<em>空间区域</em>上。而为了实现这一点，<code>Module</code>对变量的局域化发生在内核中，而<code>DynamicModule</code>对变量的局域化发生在前端。这也可以通过运行下面两段代码验证</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Module</span>[&#123;x&#125;, <span class="keyword">Slider</span>[<span class="keyword">Dynamic</span>[x]]] // <span class="keyword">FullForm</span></span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DynamicModule</span>[&#123;x&#125;, <span class="keyword">Slider</span>[<span class="keyword">Dynamic</span>[x]]] // <span class="keyword">FullForm</span></span><br></pre></td></tr></table></figure><p>从输出结果中可以看到DynamicModule在内核中是以不计算的方式保持着原本的形式，实际上<code>DynamicModule</code>在前端产生一个<code>DynamicModuleBox</code>的框符结构，它虽然不会像<code>ButtonBox</code>或者<code>RowBox</code>之类的显示成一个控件或者布局，但前端会根据它来对内部的变量局域化。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DynamicModule</span>[&#123;x&#125;, <span class="keyword">Slider</span>[<span class="keyword">Dynamic</span>[x]]]</span><br></pre></td></tr></table></figure><p>复制上面代码的输出，在后面加上 <code>//ToBoxes</code> 并计算，得到其框符表示。滑动滑动条，再次计算，可以看到滑动条的值其实是由<code>DynamicModuleBox</code>结构所记录的。这也正是<code>DynamicModule</code>内的状态能保存在文件中，并在跨越不同的内核会话时保持一致的原因。</p><p>相对地，<code>Module</code>就没有这个能力，比如下面这段代码</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Module</span>[&#123;x&#125;, <span class="keyword">Slider</span>[<span class="keyword">Dynamic</span>[x]]]</span><br></pre></td></tr></table></figure><p>由其得到的滑动条，随意滑动一下，如果关闭文件并退出内核的话，再次打开文件它会回到初始的位置上；而如果不关闭文件直接退出内核的话，甚至会出现拖动滑动条却无法将其移动的情况。对后一种情况，个人猜测是由于前端和内核重新连接后，前端原有控件没能和内核中的变量关联上的缘故。</p><p><strong>思考题6</strong>：<br>分别将由<code>DynamicModule</code>和<code>Module</code>得到的滑动条复制到其它地方，拖动滑动条，观察其现象，思考造成这种现象的原因。</p><p><strong>延伸阅读</strong>：<br><a href="http://reference.wolfram.com/language/tutorial/IntroductionToDynamic.html" target="_blank" rel="noopener">动态简介</a>、<a href="http://reference.wolfram.com/language/tutorial/AdvancedDynamicFunctionality.html" target="_blank" rel="noopener">高级动态功能</a></p><h3 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> <a href="http://reference.wolfram.com/language/guide/NamespaceManagement.html" target="_blank" rel="noopener">命名空间</a></h3><p>命名空间也被称作上下文。顾名思义，它可以看作一段程序执行的语境，它影响符号的含义。</p><p>附带的笔记本中，在不同单元中多次出现符号<code>x</code>，但它们之间没有任何关联，也不会互相干扰。这是由于该笔记本默认在每个单元编组都使用独立的上下文。通过计算<code>$Context</code>获取当前上下文，可以得到一个形如<code>Cell$$nnnn`</code>的上下文名称。</p><p>事实上，Wolfram语言中任何符号的全名都包括两个部分：上下文和短名。全名的典型形式是<code>context`short</code>。其中，符号<code>`</code>在Wolfram语言中被称为上下文标记，它是符号全名的一部分，在使用时又有些类似文件系统中的路径分隔符<code>/</code>或<code>\</code>。</p><p>正如我们在命令行环境下键入程序不需要完整的路径，系统会自动在<code>PATH</code>环境变量指定的路径中搜索，在Wolfram语言中的如果只键入符号短名的话，系统首先会在<code>$ContextPath</code>指定的上下文中搜索，如果在既有上下文中找不到该符号，才会在当前上下文中创建一个以此为短名的新符号。</p><p>上下文的应用通常和程序包联系在一起，以减少不同程序包间可能的符号冲突。因而在Wolfram语言中有两组典型的方式来开启一个上下文环境：<br>一组是<code>Begin[&quot;context`&quot;]</code>和<code>End[]</code>；另一组是<code>BeginPackage[&quot;context`&quot;]</code>和<code>EndPackage[]</code>。下面的代码简单演示了两者对上下文环境的作用</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Print</span>[<span class="string">"0:"</span>, <span class="keyword">$Context</span>, <span class="string">"|"</span>, <span class="keyword">$ContextPath</span>]</span><br><span class="line"><span class="keyword">BeginPackage</span>[<span class="string">"test`"</span>];</span><br><span class="line">    <span class="keyword">Print</span>[<span class="string">"1:"</span>, <span class="keyword">$Context</span>, <span class="string">"|"</span>, <span class="keyword">$ContextPath</span>]</span><br><span class="line">    <span class="keyword">Begin</span>[<span class="string">"test1`"</span>];</span><br><span class="line">        <span class="keyword">Print</span>[<span class="string">"2:"</span>, <span class="keyword">$Context</span>, <span class="string">"|"</span>, <span class="keyword">$ContextPath</span>]</span><br><span class="line">    <span class="keyword">End</span>[];</span><br><span class="line">    <span class="keyword">Print</span>[<span class="string">"3:"</span>, <span class="keyword">$Context</span>, <span class="string">"|"</span>, <span class="keyword">$ContextPath</span>]</span><br><span class="line">    <span class="keyword">Begin</span>[<span class="string">"`test2`"</span>];</span><br><span class="line">        <span class="keyword">Print</span>[<span class="string">"4:"</span>, <span class="keyword">$Context</span>, <span class="string">"|"</span>, <span class="keyword">$ContextPath</span>]</span><br><span class="line">    <span class="keyword">End</span>[];</span><br><span class="line">    <span class="keyword">Print</span>[<span class="string">"5:"</span>, <span class="keyword">$Context</span>, <span class="string">"|"</span>, <span class="keyword">$ContextPath</span>]</span><br><span class="line"><span class="keyword">EndPackage</span>[];</span><br><span class="line"><span class="keyword">Print</span>[<span class="string">"6:"</span>, <span class="keyword">$Context</span>, <span class="string">"|"</span>, <span class="keyword">$ContextPath</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0:Cell$$nnnn`|&#123;Cell$$nnnn`,System`&#125;</span><br><span class="line"></span><br><span class="line">1:test`|&#123;test`,System`&#125;</span><br><span class="line"></span><br><span class="line">2:test1`|&#123;test`,System`&#125;</span><br><span class="line"></span><br><span class="line">3:test`|&#123;test`,System`&#125;</span><br><span class="line"></span><br><span class="line">4:test`test2`|&#123;test`,System`&#125;</span><br><span class="line"></span><br><span class="line">5:test`|&#123;test`,System`&#125;</span><br><span class="line"></span><br><span class="line">6:Cell$$nnnn`|&#123;test`,Cell$$nnnn`,System`&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>Begin</code>-<code>End</code>所产生的作用比较纯粹，就是在其作用的范围内改变当前上下文<code>$Context</code>，而对<code>$ContextPath</code>毫无影响。相对地，<code>BeginPackage</code>-<code>EndPackage</code>则有几项副作用，它除了在作用范围内改变<code>$Context</code>和<code>$ContextPath</code>外，在使用<code>EndPackage[]</code>离开其作用范围时不仅将<code>$Context</code>和<code>$ContextPath</code>复原，而且会将还原前的上下文添加到<code>$ContextPath</code>中，从而方便我们直接使用导入包中的符号。</p><p>在实际的程序包开发中，这两种结构一般都会用到。比如在Mathematica自带示例程序包<code>ExampleData/Collatz.m</code>中有如下代码</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BeginPackage</span>[<span class="string">"Collatz`"</span>]</span><br><span class="line"></span><br><span class="line">Collatz::usage =</span><br><span class="line">        <span class="string">"Collatz[n] gives a list of the iterates in the 3n+1 problem,</span></span><br><span class="line"><span class="string">        starting from n. The conjecture is that this sequence always</span></span><br><span class="line"><span class="string">        terminates."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Begin</span>[<span class="string">"`Private`"</span>]</span><br><span class="line"></span><br><span class="line">Collatz[<span class="number">1</span>] := &#123;<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">Collatz[n_Integer]  := <span class="keyword">Prepend</span>[Collatz[<span class="number">3</span> n + <span class="number">1</span>], n] /; <span class="keyword">OddQ</span>[n] &amp;&amp; n &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Collatz[n_Integer] := <span class="keyword">Prepend</span>[Collatz[n/<span class="number">2</span>], n] /; <span class="keyword">EvenQ</span>[n] &amp;&amp; n &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span>[ ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">EndPackage</span>[ ]</span><br></pre></td></tr></table></figure><p>这个例子中我们可以看到一个程序包典型的上下文结构安排。<code>BeginPackage</code>-<code>EndPackage</code>主要用于引入接口性质的符号，而具体实现部分则往往置于<code>Begin</code>-<code>End</code>结构中以尽可能避免符号污染。</p><p><strong>思考题7</strong>：<br><code>x</code>和<code>`x</code>之间有什么区别？运行下面两段代码，观察结果。思考并理解<code>`</code>的含义。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">Begin</span>[<span class="string">"`test`"</span>];</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">&#123;<span class="keyword">Context</span>[], <span class="keyword">Context</span>[x]&#125;</span><br><span class="line"><span class="keyword">End</span>[];</span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">Begin</span>[<span class="string">"`test`"</span>];</span><br><span class="line">`x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">End</span>[];</span><br><span class="line">&#123;`x, `test`x&#125;</span><br></pre></td></tr></table></figure><p><strong>延伸阅读</strong>：<br><a href="http://reference.wolfram.com/language/tutorial/Contexts.html" target="_blank" rel="noopener">上下文</a>、<a href="http://reference.wolfram.com/language/tutorial/ContextsAndPackages.html" target="_blank" rel="noopener">上下文和程序包</a>、<a href="http://reference.wolfram.com/language/tutorial/SettingUpWolframLanguagePackages.html" target="_blank" rel="noopener">建立 Wolfram 语言程序包</a>、<a href="http://reference.wolfram.com/language/workflow/AutomaticallyUseSeparateContextsForDifferentNotebooks.html" target="_blank" rel="noopener">对不同的笔记本自动使用独立的上下文环境</a>、<a href="http://reference.wolfram.com/language/workflow/HandleShadowingOfSymbolNames.html" target="_blank" rel="noopener">处理符号名称遮盖的问题</a></p><hr><p>相关代码交互见 <a href="https://www.wolframcloud.com/obj/miroox/Published/ScopeInWolframLangaugae.nb" target="_blank" rel="noopener">笔记本</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Wolfram语言中的作用域结构主要有如下5种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Block&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;With&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DynamicModule&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;命名空间&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语法" scheme="http://miRoox.github.io/blog/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
</feed>
