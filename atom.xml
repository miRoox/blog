<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miRoox的博客</title>
  
  <subtitle>我唯一知道的就是我一无所知 ——苏格拉底</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://miroox.github.io/blog/"/>
  <updated>2022-01-03T15:47:37.000Z</updated>
  <id>http://miroox.github.io/blog/</id>
  
  <author>
    <name>miRoox</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021年终总结</title>
    <link href="http://miroox.github.io/blog/2022/01/Summary2021/"/>
    <id>http://miroox.github.io/blog/2022/01/Summary2021/</id>
    <published>2022-01-03T15:48:13.000Z</published>
    <updated>2022-01-03T15:47:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>又到了该写年终总结的时候。2021年可以说又是人生的一个转折点，或者说是把上一年的转~~~折给勾勒完成的过程。这一年虽然忙碌，但远没有前一年那么跌宕起伏。简而言之，前半年努力毕业逃离科研圈，后半年入职工作适应新环境。</p><a id="more"></a><p>大概去年被 Intel 录了之后有点儿飘，寒假期间核酸检测软件的重写方案被我完全独断地敲定了。现在看来，既没有好好 schedule，又空想了太多可能性造成了 overdesign，把新版弄成了一个几乎不可能完成的任务。在期间，所里老师提出一些新的小需求被我直接在旧版软件上进行 workaround，大需求则直接推到新版中。任务越垒越困难，结果寒假结束后还有大半没完成。</p><p>然而开学之后三周就即将迎来毕业论文的中期检查，可沉迷重写核酸软件的我几乎没有花时间在原定的课题上。眼看答辩的日子逐渐逼近，课题还一筹莫展，和几位同学探讨之后，本着早死早超生的精神，跟导师摊牌提出换题，打算直接换成核酸检测软件。导师沉吟许久，还是提到了论文学术性的问题，毕竟当初定课题时就有打算以这个软件作为课题，但那时就因为缺乏学术性不适合毕业论文而否决了。不过这次考虑到要扩展检测分析规则，需要内置一套 DSL，我就想着能不能硬凑一些 PL 相关的知识。导师对此不置可否，却说要不在前两章加一些生物知识。不过无论如何，既然原本的课题不可能在中期前达到标准了，换题这件事也就不得不敲定了。</p><p>中期检查结束之后，接下来的日子乏善可陈，基本上是不停地写代码看论文糊论文，经过若干个深夜与白天，砍掉了许多无所谓的功能，熬掉了不知多少头发，直到六月底才勉强踩线（其实已经有点超过 deadline 了）熬完。下午的答辩，早上9点才勉强弄完幻灯片，匆忙赶去研究所，半路上又发现论文没印够，又赶回去找打印店，最终错过了正常的答辩时间，顺延到了晚上场。因为缺乏休息和进食，也没有事前准备，答辩的时候甚至有点语无伦次。结局也不出意料地（非正式）延毕了一个月，好在这一个月毕业证是先发下来了，也允许我们离校改论文。不过除我外还有三位延毕的难兄难弟，据说因为咱们院想保住两年制硕士的制度，今年卡得比较严，全院（非正式）延毕率高达8%。所谓非正式延毕，就是赶在论文最终提交前让人再好好改改，卡着学位证不放而已。</p><p>7月2日毕业离校，7月5日入职，一毕业就马不停蹄地就赶往上海。为了避免出现找不到房子地窘境，6月中旬就到上海未雨绸缪提前订好了合租的房子。上班的第一个月，除了在家继续修缮论文之外，主要就是在各种培训，学习，以及搭环境中度过的。组里目前主要是做 <a href="https://github.com/thesofproject" target="_blank" rel="noopener">SOF</a>，围绕着音频固件和驱动展开，对我来说基本是完全陌生的领域。因此，manager 的想法是让我从 validation 和 CI 开始，熟悉整个项目后再慢慢过渡到驱动或固件的开发上去。这期间，在 manager 的建议下，还加入了公司的 toastmaster club，尽管我这半年下来也没去几次。同事们对我也都很友好，过着愉快的朝九晚五生活。</p><p>七月底把论文交了之后，开始正式干一些简单的 validation 工作，基本上就是分析 log 或者 bisect 之类的活。到八月中，才开始第一份比较正式的任务：为 <a href="https://github.com/thesofproject/sof-test/blob/main/tools/tplgtool.py" target="_blank" rel="noopener">tplgtool</a> 添加一个新的功能来显示各个 component 的 core。不过由于旧代码充斥着过多的 magic number 和一些冗余的意义不明的代码，因此我提出重写一份更合理的，manager 看了看原来的对此表示赞同。然而，由于我的重写需要给程序引入一个新的依赖——<a href="http://construct.readthedocs.org/" target="_blank" rel="noopener">Construct</a>——这是一个 breaking change，在经过和 reviewer 的一阵激情对线后，整个重写以及新功能到九月底才基本完成。而在业余时间，我又筹划着自己拿 Julia 仿制一个像 Construct 那样的包，于是又开了一个坑 <a href="https://github.com/miRoox/Constructs.jl" target="_blank" rel="noopener">Constructs.jl</a>。</p><p>十一假期父母说要来玩，还是自驾一路从湖南游到上海。大概是感受到某种紧迫性，我趁着九月下旬，尝试了一下心念念已久的激光脱毛，没有想象中那么痛，但也没有想象中那么立竿见影。而十一的第一天，则是去听了因疫情变化鸽了两次的幻奏盛宴/乐景。然而由于我没仔细看票，把17点误记成了7点，导致匆匆忙忙赶去听乐景的时候，已经演完半场多了，而演奏途中是不让进的，在外面等完了一套漫长的钢琴组曲才进去听了最后1/4场。经过一天短暂的休息，到3日又乘高铁去婺源与父母汇合，旅游路线为：婺源-宏村-乌镇-绍兴，基本上就是古镇、古镇、还是古镇，可这古镇除了外貌，基本也没啥古色古香的。唯一值得一提的是绍兴的“鲁镇社戏”，貌似实我迄今看过的唯一一次舞台剧，音画效果和舞台手法对我这个外行来说都挺有新意的。十一之后没多久，又有公司组织的鸟类保护活动，来崇明岛做了个鸟屋，然后拿着望远镜看鸟，可惜博物方面我实在是个大外行，除了鸭子好像啥也认不出来。</p><p>到十一月十二月，除了对之前 topology tool 增补一些新功能外，我们 CI 小分队筹划了一个巨大的 CI Refinement 计划——打算逐步重写原来那个臃肿难懂的 CI 系统。这是个比较长期的计划，直到现在也只能说初步完成了其中的第一步。这期间到也积累了不少原来不曾有过的合作开发同一个任务的经验。</p><p>如果是2020年是上一段人生的收尾，那2021年可以说是下一段人生的新起点。不过上班之后，从博客的更新量和开新坑的数目来看，业余时间显然更加咸鱼了。而今2022已经过去将近3天了，新的一年里还是希望自己能保持挖坑的热情和填坑的毅力吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又到了该写年终总结的时候。2021年可以说又是人生的一个转折点，或者说是把上一年的转~~~折给勾勒完成的过程。这一年虽然忙碌，但远没有前一年那么跌宕起伏。简而言之，前半年努力毕业逃离科研圈，后半年入职工作适应新环境。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈散记" scheme="http://miRoox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="年终总结" scheme="http://miRoox.github.io/blog/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>在Julia中实现一个简单的不求值表达式类型获取</title>
    <link href="http://miroox.github.io/blog/2021/10/Julia-unevaltypeof/"/>
    <id>http://miroox.github.io/blog/2021/10/Julia-unevaltypeof/</id>
    <published>2021-10-31T15:58:08.000Z</published>
    <updated>2021-11-06T04:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Julia中，<a href="https://docs.juliacn.com/latest/base/base/#Core.typeof" target="_blank" rel="noopener"><code>typeof</code></a> 可以获取对象类型，但和C++中的 <a href="https://zh.cppreference.com/w/cpp/language/decltype" target="_blank" rel="noopener"><code>decltype</code></a> 不同，它获取的是对象的运行时类型，需要对表达式完成求值才能得到。然而有时我们可能希望不求值就得到表达式的类型，这在Julia中并没有<strong>直接</strong>提供内置方法来实现。</p><a id="more"></a><p>但是，我们注意到 <a href="https://docs.juliacn.com/latest/stdlib/Test/#Test.@inferred" target="_blank" rel="noopener"><code>Tests.@inferred</code></a> 可以对推导出的类型和实际的运行时类型进行比较。显然，Julia其实提供了相应的方法获取推导的类型的。阅读<a href="https://github.com/JuliaLang/julia/blob/master/stdlib/Test/src/Test.jl#L1601" target="_blank" rel="noopener">其代码</a>不难发现 <code>Base.return_types</code> 方法是推导类型的关键所在。这一方法在文档中并没有具体介绍，仅在手册中介绍方法分派的<a href="https://docs.juliacn.com/latest/manual/methods/#%E8%BE%93%E5%87%BA%E7%B1%BB%E5%9E%8B%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">输出类型计算</a>时作为一个反面例子出现。根据文档中的简单用例以及 <code>@inferred</code> 中的实现推断，可以知道它的签名类似</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base.return_types(f, types::<span class="built_in">Tuple</span>&#123;<span class="built_in">Vararg</span>&#123;<span class="built_in">DataType</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>即根据函数 <code>f</code> 以及给定参数类型的元组 <code>types</code> 来得到可能的返回值类型。注意这个函数会返回一个类型数组，分别对应于<strong>可能</strong>匹配到方法的不同实例的返回类型。例如</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; f(x::<span class="built_in">Int</span>) = x^<span class="number">2</span></span><br><span class="line">&gt; f(x::<span class="built_in">Integer</span>) = x</span><br><span class="line">&gt; Base.return_types(f, (<span class="built_in">Int</span>,))</span><br><span class="line"><span class="number">1</span>-element <span class="built_in">Vector</span>&#123;<span class="built_in">Any</span>&#125;:</span><br><span class="line"> <span class="built_in">Int64</span></span><br><span class="line">&gt; Base.return_types(f, (<span class="built_in">Integer</span>,))</span><br><span class="line"><span class="number">2</span>-element <span class="built_in">Vector</span>&#123;<span class="built_in">Any</span>&#125;:</span><br><span class="line"> <span class="built_in">Int64</span></span><br><span class="line"> <span class="built_in">Integer</span></span><br></pre></td></tr></table></figure><p>不过 <code>Base.return_types</code> 的调用方式显然不太直观，毕竟Julia不能直接改变方法调用的求值顺序。但我们可以通过宏来对其“转译”一下，将普通的函数调用表达式转换成满足参数格式要求的结构。</p><p>一个粗浅的想法是直接照搬 <code>@inferred</code> 的实现，但由于 <code>@inferred</code> 的应用目标相对较窄，只处理了恰好是单个函数调用的情况，而对于内部的参数依然还是会进行求值。如果要进行推广，最简单的方式是递归地插入获取类型的代码。然而 <code>Base.return_types</code> 返回值是一个数组，需要将结果进行合并，则还要 <a href="https://docs.juliacn.com/latest/base/base/#Base.typejoin" target="_blank" rel="noopener"><code>typejoin</code></a> 和 <a href="https://docs.juliacn.com/latest/base/collections/#Base.reduce-Tuple%7BAny,%20Any%7D" target="_blank" rel="noopener"><code>reduce</code></a> 完成类型的合并，使调用即类似于</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(typejoin, Base.return_types(f, types))</span><br></pre></td></tr></table></figure><p>而对于非函数调用的叶子（参数）节点，通常的 <code>typeof</code> 固然可以，但是考虑到存在类似 <a href="https://docs.juliacn.com/latest/base/numbers/#Base.parse" target="_blank" rel="noopener"><code>parse</code></a> 的类型选择器，<code>typeof</code> 为每个类型都返回 <a href="https://docs.juliacn.com/latest/manual/types/#man-declared-types" target="_blank" rel="noopener"><code>DataType</code></a> 就显得有些模糊。因此，不妨自己定义一个更精确的 <code>typeof</code>：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exacttypeof(::T) <span class="keyword">where</span> &#123;T&#125; = T</span><br><span class="line">exacttypeof(::<span class="built_in">Type</span>&#123;T&#125;) <span class="keyword">where</span> &#123;T&#125; = <span class="built_in">Type</span>&#123;T&#125;</span><br></pre></td></tr></table></figure><p>在此基础上，加上简单的封装和宏展开基本就大功告成了</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> uneval_typeof_impl(expr)</span><br><span class="line">    <span class="keyword">if</span> expr <span class="keyword">isa</span> <span class="built_in">Expr</span></span><br><span class="line">        <span class="keyword">if</span> expr.head == :call</span><br><span class="line">            eargs = map(uneval_typeof_impl, expr.args[<span class="number">2</span>:<span class="keyword">end</span>])</span><br><span class="line">            :(reduce(typejoin, Base.return_types($(esc(expr.args[<span class="number">1</span>])), tuple($(eargs...)))))</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error(<span class="string">"invalid syntax: @uneval_typeof must be used with a expression."</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment"># leaf</span></span><br><span class="line">        :(exacttypeof($(esc(expr))))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">macro</span> uneval_typeof(expr)</span><br><span class="line">    uneval_typeof_impl(macroexpand(<span class="meta">@__MODULE__</span>, expr))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>简单试一下：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@uneval_typeof</span> <span class="number">1</span>+<span class="number">2</span>*<span class="number">3</span></span><br><span class="line"><span class="built_in">Int64</span></span><br><span class="line">&gt; <span class="meta">@uneval_typeof</span> <span class="number">1</span>//<span class="number">2</span>+<span class="number">3.0</span>*<span class="number">0x45</span></span><br><span class="line"><span class="built_in">Float64</span></span><br><span class="line">&gt; <span class="meta">@uneval_typeof</span> parse(<span class="built_in">Int</span>, <span class="string">"123"</span>)</span><br><span class="line"><span class="built_in">Int64</span></span><br><span class="line">&gt; <span class="keyword">function</span> f(x)</span><br><span class="line">  println(x)</span><br><span class="line">  <span class="number">2</span>x</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&gt; x=<span class="number">5</span>;</span><br><span class="line">&gt; <span class="meta">@uneval_typeof</span> f(x)</span><br><span class="line"><span class="built_in">Int64</span></span><br><span class="line">&gt; <span class="meta">@uneval_typeof</span> f(x+f(<span class="number">1</span>//<span class="number">2</span>))</span><br><span class="line"><span class="built_in">Rational</span>&#123;<span class="built_in">Int64</span>&#125;</span><br></pre></td></tr></table></figure><p>不过这个方法只适用于简单的函数调用表达式，对于包含表达式块或者生成器等不能简单表示为单个函数调用组合的情况则会出错。<br>而且，<code>Base.return_types</code> 也不适用于内置的函数（例如，<code>===</code>、<code>Core.sizeof</code>等），因此也无法处理包含这些函数的表达式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Julia中，&lt;a href=&quot;https://docs.juliacn.com/latest/base/base/#Core.typeof&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/a&gt; 可以获取对象类型，但和C++中的 &lt;a href=&quot;https://zh.cppreference.com/w/cpp/language/decltype&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;decltype&lt;/code&gt;&lt;/a&gt; 不同，它获取的是对象的运行时类型，需要对表达式完成求值才能得到。然而有时我们可能希望不求值就得到表达式的类型，这在Julia中并没有&lt;strong&gt;直接&lt;/strong&gt;提供内置方法来实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="元编程" scheme="http://miRoox.github.io/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Julia" scheme="http://miRoox.github.io/blog/tags/Julia/"/>
    
  </entry>
  
  <entry>
    <title>关于C#9中仅初始化的属性设置器</title>
    <link href="http://miroox.github.io/blog/2021/05/Initonly-Setter-CSharp/"/>
    <id>http://miroox.github.io/blog/2021/05/Initonly-Setter-CSharp/</id>
    <published>2021-05-01T12:46:12.000Z</published>
    <updated>2021-10-25T15:18:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>C# 9 引入了<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-9.0/init" target="_blank" rel="noopener">仅初始化的属性设置器</a>，这使我们可以定义一个只能在构造函数或者初始化设定项中进行设置的属性：</p><a id="more"></a><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> InitOnlyProperty &#123; <span class="keyword">get</span>; init; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sample = <span class="keyword">new</span> Sample</span><br><span class="line">    &#123;</span><br><span class="line">        InitOnlyProperty = <span class="string">"init"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/ 编译错误：只能在对象初始值设定项中或在实例构造函数或 "init" 访问器中的 "this" 或 "base" 上分配 init-only 属性或索引器 "Program.Sample.InitOnlyProperty"。</span></span><br><span class="line">    <span class="comment">// sample.InitOnlyProperty = "modified";</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这既能保证属性的不可变性，又能避免出现需要定义具有大量参数的构造函数的情况。C# 9 还进一步地引入了<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-9.0/records" target="_blank" rel="noopener">记录类型和 <code>with</code> 表达式</a>来简化不可变引用类型的构造。而这一语法糖的实现方式同样基于仅初始化的设置器。</p><p>然而，在低于 .NET 5 的目标框架下，我们没法直接使用这一语言特性。哪怕指定了 C# 9 作为编译语言版本，依然会产生如下编译错误：</p><blockquote><p>预定义类型“System.Runtime.CompilerServices.IsExternalInit”未定义或导入</p></blockquote><p>当然，基于缺啥补啥的原则，我们直接看 .NET 的源码中<a href="https://github.com/dotnet/runtime/blob/d273780b850cfd35a2c084d60d5e3a193268b7e7/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/IsExternalInit.cs" target="_blank" rel="noopener"><code>System.Runtime.CompilerServices.IsExternalInit</code></a>的部分，加上编译条件，照抄一份到我们的项目中：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> NET5_0_OR_GREATER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">System.Runtime.CompilerServices</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Reserved to be used by the compiler for tracking metadata. This class should not be used by developers in source code.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">EditorBrowsable(EditorBrowsableState.Never)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">IsExternalInit</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>就可以解决了。</p><p>不过，我们本着知其然也要知其所以然的学习态度，不妨试试（用ildasm）对前面的代码反编译一下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title">auto</span> <span class="title">ansi</span> <span class="title">nested</span> <span class="title">public</span> <span class="title">beforefieldinit</span> <span class="title">Sample</span></span><br><span class="line">        extends [System.Runtime]System.Object</span><br><span class="line">&#123;</span><br><span class="line">  .field <span class="keyword">private</span> initonly <span class="keyword">string</span> <span class="string">'&lt;InitOnlyProperty&gt;k__BackingField'</span></span><br><span class="line">  .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) </span><br><span class="line">  .custom instance void [System.Runtime]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [System.Runtime]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) </span><br><span class="line">  .method <span class="keyword">public</span> hidebysig specialname </span><br><span class="line">          <span class="function">instance <span class="keyword">string</span>  <span class="title">get_InitOnlyProperty</span>(<span class="params"></span>) cil managed</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) </span><br><span class="line">    <span class="comment">// 代码大小       7 (0x7)</span></span><br><span class="line">    .maxstack  <span class="number">8</span></span><br><span class="line">    IL_0000:  ldarg<span class="number">.0</span></span><br><span class="line">    IL_0001:  ldfld      string InitOnlyProperty.Program/Sample::'&lt;InitOnlyProperty&gt;k__BackingField'</span><br><span class="line">    IL_0006:  ret</span><br><span class="line">  &#125; <span class="comment">// end of method Sample::get_InitOnlyProperty</span></span><br><span class="line"></span><br><span class="line">  .method <span class="keyword">public</span> hidebysig specialname </span><br><span class="line">          <span class="function">instance <span class="keyword">void</span> <span class="title">modreq</span>(<span class="params">[System.Runtime]System.Runtime.CompilerServices.IsExternalInit</span>) </span></span><br><span class="line"><span class="function">          <span class="title">set_InitOnlyProperty</span>(<span class="params"><span class="keyword">string</span> <span class="string">'value'</span></span>) cil managed</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) </span><br><span class="line">    <span class="comment">// 代码大小       8 (0x8)</span></span><br><span class="line">    .maxstack  <span class="number">8</span></span><br><span class="line">    IL_0000:  ldarg<span class="number">.0</span></span><br><span class="line">    IL_0001:  ldarg<span class="number">.1</span></span><br><span class="line">    IL_0002:  stfld      string InitOnlyProperty.Program/Sample::'&lt;InitOnlyProperty&gt;k__BackingField'</span><br><span class="line">    IL_0007:  ret</span><br><span class="line">  &#125; <span class="comment">// end of method Sample::set_InitOnlyProperty</span></span><br><span class="line"></span><br><span class="line">  .method <span class="keyword">public</span> hidebysig specialname rtspecialname </span><br><span class="line">          instance <span class="keyword">void</span>  .ctor() cil managed</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 代码大小       8 (0x8)</span></span><br><span class="line">    .maxstack  <span class="number">8</span></span><br><span class="line">    IL_0000:  ldarg<span class="number">.0</span></span><br><span class="line">    IL_0001:  call       instance void [System.Runtime]System.Object::.ctor()</span><br><span class="line">    IL_0006:  nop</span><br><span class="line">    IL_0007:  ret</span><br><span class="line">  &#125; <span class="comment">// end of method Sample::.ctor</span></span><br><span class="line"></span><br><span class="line">  .<span class="function">property instance <span class="keyword">string</span> <span class="title">InitOnlyProperty</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    .get instance string InitOnlyProperty.Program/Sample::get_InitOnlyProperty()</span><br><span class="line">    .<span class="function"><span class="keyword">set</span> instance <span class="keyword">void</span> <span class="title">modreq</span>(<span class="params">[System.Runtime]System.Runtime.CompilerServices.IsExternalInit</span>) InitOnlyProperty.Program/Sample::<span class="title">set_InitOnlyProperty</span>(<span class="params"><span class="keyword">string</span></span>)</span></span><br><span class="line"><span class="function">  &#125; <span class="comment">// end of property Sample::InitOnlyProperty</span></span></span><br><span class="line"><span class="function">&#125; <span class="comment">// end of class Sample</span></span></span><br></pre></td></tr></table></figure><p>可以看到 <code>InitOnlyProperty</code> 的设置访问器 <code>set_InitOnlyProperty(string)</code> 被 <code>modreq([System.Runtime]System.Runtime.CompilerServices.IsExternalInit)</code> 所修饰，那么缺少所需的自定义修饰符类型 <code>System.Runtime.CompilerServices.IsExternalInit</code> 自然会导致编译无法通过。</p><p>事实上，在规范建议的设计文档里，包含 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-9.0/init#modreqs-vs-attributes" target="_blank" rel="noopener">Modreqs 与属性</a>一节，阐述了 <code>init</code> 属性访问器的生成策略中为何选取了必需修饰符（modreq）而不是属性作为元数据进行标记。简而言之，由于 modreq 的必需性，无法理解 <code>init</code> 的编译器（如较早版本的编译器）应当会直接忽略对应的对应的属性设置访问器，从而可以避免将属性当成是可写的。</p><p>尽管如此，这种保护也不是完全安全的。文档中指出了三种不会保护的情况：</p><ol><li>对（公共）成员的反射</li><li>使用 <code>dynamic</code></li><li>不识别 modreq 的编译器</li></ol><p>文档后面还讨论了其它几种设计和它们的利弊，这里就不多加赘述了。</p><p>不过，借助这一生成策略，我们也可以自己编写函数，通过反射来确认一个属性是否是仅初始化的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PropertyExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 检查属性是否是仅初始化的。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="property"&gt;</span>要检查的属性元信息。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>若该属性的设置访问器是仅初始化的，则为<span class="doctag">&lt;see langword="true"/&gt;</span>；否则，为<span class="doctag">&lt;see langword="false"/&gt;</span>。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsInitOnly</span>(<span class="params"><span class="keyword">this</span> PropertyInfo property</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MethodInfo? setMethod = property.SetMethod;</span><br><span class="line">        <span class="keyword">if</span> (setMethod == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> setMethod.ReturnParameter</span><br><span class="line">            .GetRequiredCustomModifiers()</span><br><span class="line">            .Contains(<span class="keyword">typeof</span>(System.Runtime.CompilerServices.IsExternalInit));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C# 9 引入了&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-9.0/init&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仅初始化的属性设置器&lt;/a&gt;，这使我们可以定义一个只能在构造函数或者初始化设定项中进行设置的属性：&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="元编程" scheme="http://miRoox.github.io/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="http://miRoox.github.io/blog/tags/C/"/>
    
      <category term=".NET" scheme="http://miRoox.github.io/blog/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>在MSBuild中构建LaTeX文档</title>
    <link href="http://miroox.github.io/blog/2021/01/MSBuild-LaTeXDoc/"/>
    <id>http://miroox.github.io/blog/2021/01/MSBuild-LaTeXDoc/</id>
    <published>2021-01-28T12:12:12.000Z</published>
    <updated>2021-10-25T15:18:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，LaTeX 便于实现专业级的排版效果，而且内容与样式分离的设计也使文档格式易于调整修改；同时，其源文件作为一种纯文本格式的文件，对于 git 这类版本控制系统也更为友好，利于开发过程中的协作工作。因此，LaTeX 相比 Word 更适合用于制作软件的用户手册。</p><a id="more"></a><p>Visual Studio 本身当然没有提供 LaTeX 的构建工具，但作为其构建系统的 MSBuild 提供了自定义目标和任务的方式。而我们在编写 LaTeX 文档时，也常常会使用 LaTeX 自己的构建工具（如：latexmk、Arara）。方便起见，我们直接用 <a href="https://docs.microsoft.com/zh-cn/visualstudio/msbuild/exec-task" target="_blank" rel="noopener">Exec 任务</a>调用 latexmk 构建 LaTeX 文档，已避免处理交叉引用等问题面临的多次编译排版的麻烦。</p><p>这里就略过 LaTeX 文档本身如何编写了，只讲 MSBuild 的配置。</p><p>首先，在文本编辑器下打开项目文件，通过属性设置好文档的目录和文档的文件名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ManualFile</span>&gt;</span>manual.pdf<span class="tag">&lt;/<span class="name">ManualFile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ManualDir</span>&gt;</span>$(SolutionDir)doc/manual/<span class="tag">&lt;/<span class="name">ManualDir</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里，我们要生成的手册文档所在的路径是相对于解决方案路径的 <code>doc/manual</code>，而排版输出的 PDF 文档其文件名是 <code>manual.pdf</code>。</p><p>然后添加构建文档的目标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">"BuildManual"</span> <span class="attr">AfterTargets</span>=<span class="string">"PostBuildEvent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Exec</span> <span class="attr">Command</span>=<span class="string">"latexmk"</span> <span class="attr">WorkingDirectory</span>=<span class="string">"$(ManualDir)"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Copy</span> <span class="attr">SourceFiles</span>=<span class="string">"$(ManualDir)$(ManualFile)"</span> <span class="attr">DestinationFolder</span>=<span class="string">"$(OutDir)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">"PublishManual"</span> <span class="attr">AfterTargets</span>=<span class="string">"Publish"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Copy</span> <span class="attr">SourceFiles</span>=<span class="string">"$(ManualDir)$(ManualFile)"</span> <span class="attr">DestinationFolder</span>=<span class="string">"$(PublishDir)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，latexmk 想要正常工作的话，要将工作目录和 LaTeX 源文件设置为同一个，尤其是在设置了 <code>latexmkrc</code> 来调整 latexmk 的行为的情况下。</p><p>另外，除了在构建时需要将输出的 PDF 文档复制到软件的输出目录下之外，不要忘记发布时同样需要将其复制到发布目录下。</p><p>然而，如果设置了多种 <code>TargetFrameworks</code> 时，上面这种组织目标的方式可能就不太合适，因为构建时几种目标框架会同时进行构建，很可能导致 latexmk 在同一时间段调用多次，而其所需的文件资源互相抢占，最终构建失败。当然，这样的问题总有前人踩过类似的坑，比如 SO 上的 <a href="https://stackoverflow.com/questions/46675782/how-to-make-an-msbuild-target-that-only-runs-once-instead-of-once-before-target" target="_blank" rel="noopener">How to make an MSBuild Target that only runs once instead of once, before Targets that run once per framework in the TargetFrameworks tag?</a>，告诉我们可以使用 <code>BeforeTargets=&quot;DispatchToInnerBuilds&quot;</code> 在进入目标框架构建之前执行目标，于是我们的文档构建-输出-发布可以改写成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">"BuildManual"</span> <span class="attr">BeforeTargets</span>=<span class="string">"DispatchToInnerBuilds"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Exec</span> <span class="attr">Command</span>=<span class="string">"latexmk"</span> <span class="attr">WorkingDirectory</span>=<span class="string">"$(ManualSource)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">"CopyManual"</span> <span class="attr">DependsOnTargets</span>=<span class="string">"BuildManual"</span> <span class="attr">AfterTargets</span>=<span class="string">"PostBuildEvent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Copy</span> <span class="attr">SourceFiles</span>=<span class="string">"$(ManualSource)$(ManualFile)"</span> <span class="attr">DestinationFolder</span>=<span class="string">"$(OutDir)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">"PublishManual"</span> <span class="attr">DependsOnTargets</span>=<span class="string">"BuildManual"</span> <span class="attr">AfterTargets</span>=<span class="string">"Publish"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Copy</span> <span class="attr">SourceFiles</span>=<span class="string">"$(ManualSource)$(ManualFile)"</span> <span class="attr">DestinationFolder</span>=<span class="string">"$(PublishDir)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，为了方便重新构建，也不要忘记在清理目标时同时清理 LaTeX 文档：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">"CleanManual"</span> <span class="attr">AfterTargets</span>=<span class="string">"Clean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Exec</span> <span class="attr">Command</span>=<span class="string">"latexmk -c"</span> <span class="attr">WorkingDirectory</span>=<span class="string">"$(ManualDir)"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Delete</span> <span class="attr">Files</span>=<span class="string">"$(OutDir)$(ManualFile)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，LaTeX 便于实现专业级的排版效果，而且内容与样式分离的设计也使文档格式易于调整修改；同时，其源文件作为一种纯文本格式的文件，对于 git 这类版本控制系统也更为友好，利于开发过程中的协作工作。因此，LaTeX 相比 Word 更适合用于制作软件的用户手册。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LaTeX" scheme="http://miRoox.github.io/blog/tags/LaTeX/"/>
    
      <category term="MSBuild" scheme="http://miRoox.github.io/blog/tags/MSBuild/"/>
    
      <category term="Visual Studio" scheme="http://miRoox.github.io/blog/tags/Visual-Studio/"/>
    
  </entry>
  
  <entry>
    <title>2020年终总结</title>
    <link href="http://miroox.github.io/blog/2020/12/Summary2020/"/>
    <id>http://miroox.github.io/blog/2020/12/Summary2020/</id>
    <published>2020-12-31T15:32:13.000Z</published>
    <updated>2020-12-31T15:32:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>今年大概是我第一次写年终总结。</p><p>不得不说，2020 年是充满变数的一年，开年席卷而来的新冠病毒肺炎打破了大多数人的正常生活，我当然也不例外。</p><a id="more"></a><p>封锁刚开始的时候还是比较闲的，毕竟作为一个真正的死宅，在家里待着比到处去走亲访友要愉快多了。而在闲着的时候找点事干也算是我为数不多的长处之一了，除了日常补补动画漫画之外，还把博客逐渐迁移到 Hexo 上，然后又开了一些新坑，例如：<a href="https://space.bilibili.com/3940132/channel/detail?cid=107350" target="_blank" rel="noopener">Wolfram 语言的视频教程</a>、<a href="https://github.com/miRoox/LazyList" target="_blank" rel="noopener">Wolfram 语言实现的惰性列表</a>以及一个轻量的 Wolfram 语言解释器。然而这几个坑挖了也都没能好好填上：视频教程开了个引言就一直鸽着；惰性列表算是完成度比较高的一个，也留着大量基础设施在 TODO list 里；解释器就更惨了，以我这三脚猫的编译原理基础，折腾了一个月连词法分析都没弄对，也就没好意思拿出来开源。</p><p>不过，空闲的日子并没有持续多久。寒假还没结束，导师就把所里的项目拉来让我们做，而且这项目还是紧跟热点的“新冠病毒核酸自动化快速检测平台”。虽然名字起得高大上，但实质上我们课题组负责的也就是一个自动数据处理报表的软件，作为“新冠病毒核酸快速检测一体化设备与试剂”的中间环节。或许是为了减轻其它同学的开发学习负担，导师让我们使用 C# 进行开发。而我这个初学者只好边学边做，却没想到借着其它语言的基础，轻松碾压咱这帮纯业余的师兄师姐们，一跃成为项目的唯一主力开发。另一方面，因为紧跟时事，项目的进程自然也催得很紧，需求变化也很快，程序也就翻来覆去地改。整个春季的多数时间都消磨在这个项目上了，甚至还因此不小心错过了春季学期的选课。期间又有各种事情，断断续续到八月份交了一个不甚完善的版本才算暂且告一段落。</p><p>不过，项目拖着拖着没过一段时间就不怎么催了。到五月份后，除了上上网课，敲敲代码，闲暇的生活又再次回归了。然后，怀抱着ドキドキ的心情，我久违地(?)尝试了女装，体验意外地还不错`(*&gt;﹏&lt;*)′，顺带也让我蹭了一下 <a href="https://github.com/komeiji-satori/Dress" target="_blank" rel="noopener">15K+ star 的传说级 repo</a>。</p><p>伴随着哈工大百年校庆的接近，美国政府加大了对中国的制裁打击。其结果不仅让我们学校告别了正版 MATLAB，也让我加入 <a href="https://www.wolfram.com/company/careers/ambassador/" target="_blank" rel="noopener">Wolfram 学生大使</a>为简历充门面的计划成功泡汤了。</p><p>很快到了七月返校的时间。因为在学校时常连不上 GitHub 而一怒之下买了 v2ray 的节点，顺便注册了个 twitter。于是在种种机缘巧合下认识了 <a href="https://raptazure.github.io/" target="_blank" rel="noopener">Raptazure</a>，并受邀加入了 <a href="https://github.com/h1trust" target="_blank" rel="noopener">h1trust</a>。不过手里没有一个拿得出手的 Rust 项目的话感觉还是受之有愧，于是又开了一个新坑——<a href="https://crates.io/crates/wll" target="_blank" rel="noopener">用于 Rust 的 Wolfram LibraryLink 接口</a>。</p><p>差不多同一时间段，看到了<a href="https://www.cryfeifei.cn/" target="_blank" rel="noopener">张小飞</a>大佬<a href="https://zhuanlan.zhihu.com/p/158983195" target="_blank" rel="noopener">在招募社区成员翻译 Qt 文档</a>，作为一个 Qt 的老用户，我也凑热闹翻译了<a href="https://github.com/QtDocumentCN/QtDocumentCN/commits?author=miRoox" target="_blank" rel="noopener">其中的几篇</a>。</p><p>随着正式开学的逐渐迫近，读博还是工作的选择也愈发紧迫起来。曾经我以为这件事上并没有多少变数，毕竟当初选择导师的时候我就答应了要去读博，本着诚实守信的原则，原本想着最多也就是换一个地方读博。不过，一年多的科研时光让我多少产生了一些犹豫，答应导师要写的论文已经鸽了一年了（嗯，现在还鸽着），做的东西感觉也不过是在生产学术垃圾。而咨询了一些师兄师姐之后，他们也都劝我要三思，毕竟真陷进去的话想要再出来就很困难了。再三考虑下，我意识到读博多半恐怕无法实现我理想中的那种“纯粹的科研”。为了不浪费国家的科研经费，也为了不让自己顶着可能肄业的压力和风险，我最终决定去<del>当民科</del>找工作。</p><p>毫无疑问，到八月这个时间点才开始准备找工作，在各个层面上都非常不利。不过既然决定了也就不能瞻前顾后，八月底到整个九月，我的精力都放在了找工作和毕业论文开题上。然而准备不足加上我这个阴郁的性格，结果基本是不停碰壁。</p><p>而到了十月，从天而降的拼接仪（准确说叫“焦面像元几何精度精密标定设备”）项目又让我再次陷入泥淖。就像之前<a href="https://miroox.github.io/blog/2020/10/TrapInSplicerProject/">吐槽</a>的那样，这玩意纯粹是一个坑，508 所去年就已经拿着一个空壳子去验收过一次了，到今年实在等不及了才催着做实际的验收。该吐的槽之前的文章基本也吐过了，好在这会儿我有了 C# 基础和之前的经验，东拼西凑最后还是在十一月中旬弄得差不多交去验收了。</p><p>同样在十月期间，终于有公司肯收留我了。由于留给我考虑时间并不宽裕，而多数公司都杳无音讯，只好选择了一个其貌不扬的苏州同元软控。他们号称要做国产 Simulink/MATLAB，在这个中美贸易战的背景下，大概能拿不少国家的补贴；而且他们的软件开发也很大程度上基于 Qt，并且想做 Julia 语言的互操作，和我现有的技术栈也勉强算合得来。于是在十月底完成了三方签约。</p><p>时间转到十一月，出乎我意料的是，没隔几周，金山办公和 Intel 陆续给我发了 offer，于是难得地体验了一把左右横跳。这么跳来跳去感觉还是非常愧对前面两个公司的，不过还是架不住 Intel 传说中的性价比。Intel 录我的是系统软件工程部，然而我对系统软件这个领域我基本是一无所知，想着抽空大致学一下，于是开始照着 <a href="https://os.phil-opp.com/" target="_blank" rel="noopener">Writing an OS in Rust</a> 学着写写<a href="https://github.com/miRoox/myx_os" target="_blank" rel="noopener">一个简单的操作系统</a>。</p><p>十一月意味着一学期已经过去一半了，想着也该把课题捡起来做一做了。作为一个 MATLAB 黑，很多科研需要的基础设施都只能自己造，于是就先撸了一个<a href="https://hit-uoi-sr.github.io/OpticalPropagation.jl/stable/" target="_blank" rel="noopener">衍射计算的 Julia 程序包</a>，顺带还开了<a href="https://github.com/HIT-UOI-SR/PhaseRetrieval.jl" target="_blank" rel="noopener">相位恢复</a>和<a href="https://github.com/HIT-UOI-SR/Ptychography.jl" target="_blank" rel="noopener">叠成成像</a>程序包的坑。</p><p>然而课题还没有多少进展，十二月初，核酸检测软件又需要交付使用了。在看完现在的版本后，生命学院那边还提出了若干个新需求，一下把软件的自由度和扩展性提升了好几倍。我寻思着这下重构还不如重写了，于是换到 .NET Core 从头进行开发，就这么一直做到现在。<del>也不知道这次做完能不能赶上第二波疫情反弹。</del></p><p>2020 年是充满变数的一年，或者用我党的惯用说法可以称之为机遇与挑战并存的一年。在这一年，我放弃了人生的一条道路，开始尝试走向另一条道路；在这一年，我付出了许多额外的辛劳，也收获了不少意外之喜；在这一年，我似乎更清楚地认识了自己，又似乎依旧在原地踏步。我只知道这大概是我人生中重要的一年，当然，也可能意外地不那么重要。毕竟，谁也不知道未来是怎样。不过，在现在，在此时此刻，我们也许只需要鼓起勇气，平和地迈向新的一年。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年大概是我第一次写年终总结。&lt;/p&gt;&lt;p&gt;不得不说，2020 年是充满变数的一年，开年席卷而来的新冠病毒肺炎打破了大多数人的正常生活，我当然也不例外。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈散记" scheme="http://miRoox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="年终总结" scheme="http://miRoox.github.io/blog/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Julia包开发基本指南</title>
    <link href="http://miroox.github.io/blog/2020/11/JuliaPkgGuide/"/>
    <id>http://miroox.github.io/blog/2020/11/JuliaPkgGuide/</id>
    <published>2020-11-30T15:58:23.000Z</published>
    <updated>2020-12-02T10:27:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期试着做了一些 Julia 的程序包，并注册到了官方的 General Registry 上。不得不说，Julia 程序包功能完善，而开发的流程也不复杂。这里简单记录一下，以飨后人。</p><a id="more"></a><h3 id="包的基本结构"><a class="markdownIt-Anchor" href="#包的基本结构"></a> 包的基本结构</h3><p>在Juia中，一个完整的程序包除了有项目本身的程序之外，往往还包含测试、文档等部分。因此，在开始讲程序包开发之前，先看一下一个典型程序包的基本结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MyPackage</span><br><span class="line">|-- docs</span><br><span class="line">| |-- src</span><br><span class="line">| | |-- index.md</span><br><span class="line">| | &#96;-- ...</span><br><span class="line">| |-- Manifest.toml</span><br><span class="line">| |-- Project.toml</span><br><span class="line">| &#96;-- make.jl</span><br><span class="line">|-- src</span><br><span class="line">| |-- MyPackage.jl</span><br><span class="line">| &#96;-- ...</span><br><span class="line">|-- test</span><br><span class="line">| |-- Manifest.toml</span><br><span class="line">| |-- Project.toml</span><br><span class="line">| |-- runtests.jl</span><br><span class="line">| &#96;-- ...</span><br><span class="line">|-- LICENSE</span><br><span class="line">|-- Project.toml</span><br><span class="line">|-- README.md</span><br><span class="line">&#96;-- ...</span><br></pre></td></tr></table></figure><p>可以看到，这里有三个文件夹 <code>docs</code>、<code>src</code>、<code>test</code> 分别对应文档、项目源码、测试代码。根据用途的不同，有时也会包含存放示例的 <code>example</code>、存放模板的 <code>templates</code> 等文件夹。</p><p>这里，最不可或缺的就是项目源码 <code>src/MyPackage.jl</code>，当我们使用 <code>using MyPackage</code> 或者 <code>import MyPackage</code> 时，加载的就是这个文件。当然，同样不可或缺的还有项目文件 <code>Project.toml</code>，它包含了项目的名称、UUID、作者、依赖等元数据。通常，一个项目还会包含一个 <code>Manifest.toml</code> 的清单文件，用来描述完整的依赖关系图、每个包的确切版本以及项目使用的库。但对于一个需要发布的包而言，我们通常会在版本控制系统中将其忽略（如添加在 <code>.gitignore</code> 中），因为我们一般不会希望完全固定一个包的依赖版本，而是指示一个兼容的范围（这可以在 <code>Project.toml</code> 中通过 <code>[compat]</code> 指定）来允许更自由的安装依赖。</p><p>此外，代码测试也非常重要，是否有良好的代码测试显著影响着代码的质量，因而 Julia 在<a href="https://docs.juliacn.com/latest/stdlib/Test/" target="_blank" rel="noopener">标准库</a>中内置了对代码测试的支持，在包管理器下执行 <code>test</code> 则会运行 <code>test/runtests.jl</code>。值得注意的是，在 <code>test</code> 目录下，我们还有一个 <code>Project.toml</code> 和一个 <code>Manifest.toml</code>，这意味着，<code>test</code> 其实是另一个项目，清单文件的存在，保证了测试所处环境的一致性，从而更能保证测试的可复现性。不过这个机制在 Julia 1.2 之前是通过 <code>[extras]</code> 和 <code>[targets]</code> 实现的，因此如果要兼容早期版本，需要使用之前的机制，见 <a href="https://julialang.github.io/Pkg.jl/v1/creating-packages/#Test-specific-dependencies-in-Julia-1.0-and-1.1" target="_blank" rel="noopener">Test-specific dependencies in Julia 1.0 and 1.1</a>。</p><p>另一个重要的内容则是文档，完善的文档让程序包更易理解和使用。除了将内置的 <a href="https://docs.juliacn.com/latest/manual/documentation/" target="_blank" rel="noopener">docstring</a> 作为文档之外，我们也可能希望发布的程序包附带一份内容更完善的在线部署文档。<code>docs</code> 中的内容就是为了实现这一目的而准备的，它依托 <a href="https://juliadocs.github.io/Documenter.jl/stable/" target="_blank" rel="noopener">Documenter.jl</a> 进行文档生成与发布部署。同样，文档目录也是独立的项目，使整个文档生成工作在独立的环境中，不干扰源项目本身。</p><h3 id="包开发"><a class="markdownIt-Anchor" href="#包开发"></a> 包开发</h3><p>在包开发的过程中，首先要进行的是包的命名。需要注意的是，待注册的包应当遵循 <a href="https://julialang.github.io/Pkg.jl/v1/creating-packages/#Package-naming-guidelines" target="_blank" rel="noopener">Julia 包命名方针</a>：</p><ol><li>尽量避免缩写，除非是广为人知的缩写；</li><li>避免使用 <code>Ju</code> 开头；</li><li>主要功能是关于特定类型的话，应该使用复数；</li><li>使用清晰的命名，哪怕这会让名字看起来长了点；</li><li>用于某个领域的不同实现方式之一的包，可能适合不太系统的名字；</li><li>包装了外部库或程序的包应该命名为对应的库或程序。</li></ol><p>在前一节，我们看到，Julia 包的结构还是有些复杂的，但格式基本相对固定。为了避免在开发初期被繁琐的配置困扰，社区已经有大佬开发了 <a href="https://invenia.github.io/PkgTemplates.jl/stable/" target="_blank" rel="noopener">PkgTemplates.jl</a>，提供了自动化和可定制的包生成机制。下面是一个模板配置的例子：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Template(</span><br><span class="line">    julia=<span class="string">v"1.2.0"</span>,</span><br><span class="line">    plugins=[</span><br><span class="line">        Tests(; project=<span class="literal">true</span>),</span><br><span class="line">        Git(; ssh=<span class="literal">true</span>),</span><br><span class="line">        CompatHelper(),</span><br><span class="line">        TagBot(),</span><br><span class="line">        GitHubActions(),</span><br><span class="line">        Codecov(),</span><br><span class="line">        Documenter&#123;GitHubActions&#125;(),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到除了前一节提到的部分，还有基于 <a href="https://github.com/features/actions" target="_blank" rel="noopener">GitHub Actions</a> 的持续集成，<a href="https://codecov.io/" target="_blank" rel="noopener">Codecov</a> 覆盖率监测、<a href="https://github.com/JuliaRegistries/CompatHelper.jl" target="_blank" rel="noopener">CompatHelper</a>、<a href="https://github.com/JuliaRegistries/TagBot" target="_blank" rel="noopener">TagBot</a> 等一系列附加工具。详情还是去看 PkgTemplates.jl 的文档吧。</p><p>另外，Documenter 在部署文档时，需要在托管环境中配置 SSH 部署密钥，而为了生成密钥，还需要 <a href="https://github.com/JuliaDocs/DocumenterTools.jl" target="_blank" rel="noopener">DocumenterTools.jl</a>，然后分别将公钥和私钥放在 GitHub 具有仓库写权限的 deploy key 和名为 <code>DOCUMENTER_KEY</code> 的环境变量中。这部分详见 <a href="https://juliadocs.github.io/Documenter.jl/stable/man/hosting/#travis-ssh" target="_blank" rel="noopener">Authentication: SSH Deploy Keys</a>。</p><h3 id="包注册"><a class="markdownIt-Anchor" href="#包注册"></a> 包注册</h3><p>包注册其实非常简单。不过注册前还需要检查一下注册需要满足的条件，包括是否有开源许可协议，是否所有依赖都有有限区间的 <code>[compat]</code> 入口，以及前面提过的命名要求等。这些条件详见 <a href="https://github.com/JuliaRegistries/General#registering-a-package-in-general" target="_blank" rel="noopener">Registering a package in General</a>。</p><p>至于注册，只需要在更新了项目文件中的 <code>version</code> 后，在对应的提交下评论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@JuliaRegistrator register</span><br></pre></td></tr></table></figure><p>即可发出注册请求，它会自动在 <a href="https://github.com/JuliaRegistries/General" target="_blank" rel="noopener">JuliaRegistries/General</a> 中创建一个对应的 pull request。对于新注册的包，会公示三天，如果没有问题，则会自动合并；对于已存在的包的新版本，等待5分钟就会自动合并。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期试着做了一些 Julia 的程序包，并注册到了官方的 General Registry 上。不得不说，Julia 程序包功能完善，而开发的流程也不复杂。这里简单记录一下，以飨后人。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Julia" scheme="http://miRoox.github.io/blog/tags/Julia/"/>
    
  </entry>
  
  <entry>
    <title>吐槽：这些天在拼接仪项目上踩的坑</title>
    <link href="http://miroox.github.io/blog/2020/10/TrapInSplicerProject/"/>
    <id>http://miroox.github.io/blog/2020/10/TrapInSplicerProject/</id>
    <published>2020-10-31T14:56:23.000Z</published>
    <updated>2020-10-31T14:56:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文以倒苦水为主。</em></p><a id="more"></a><hr><p>那是一个平和的中午，我刚吃完午饭，正准备回寝室休息。然而，一个突如其来的微信消息打破了宁静的一天……</p><p>嗯，就是导师突然拉上我们组好几个人来开会，讨论如何在甲方要求的验收时间——国庆节后——之前把这个项目的软件部分给做出来。然而，这个项目虽然启动已经有至少三年之久了，可之前基本没啥进展，硬件那边不知道为啥一直没完成，咱们软件也就没好好做，并且之前负责这个项目的两个师兄都已经毕业了。最终，这颗定时炸弹轮到咱们手里终于还是炸了。</p><p>不过，更离谱的是我们没人明白这个东西到底要做成啥样。手头只有一份上一代留下来的不清不楚的说明书。而导师的核心指示就是要把界面做得和原来一样，至于里面的功能，很大程度上只能自己去猜了。</p><p>整个项目粗浅的理解就是在一个多自由度的位移台上放了一个红外相机，软件则要控制位移台的运动以及相机的拍摄，并可以运用自动聚焦的方式寻找焦面的最佳位置。你要问我这里哪里体现了“拼接仪”，我也说不清，只能说和我们软件部分的工作无关。</p><h3 id="位移台控制"><a class="markdownIt-Anchor" href="#位移台控制"></a> 位移台控制</h3><p>最初给我分配的任务就是位移台控制。在这里，位移台是通过 PMAC 驱动的。PMAC (Programmable Multi-Axis Controller) 可编程多轴运动控制器，是美国 Delta Tau Data System 公司推出的PC机平台上的运动控制器。不过，想要用 PMAC 实现上位机编程控制，首先还需要安装 <a href="http://www.deltatau.com/DT_Products/SoftwareDetails.aspx?CatID=500-PMAC%20EXECUTIVE%20PRO2%20SUITE" target="_blank" rel="noopener">PMAC EXECUTIVE PRO2 SUITE</a>，然后通过它的互操作库 <code>Interop.PCOMMSERVERLib</code> 来调用命令，实现对电机的控制。</p><p>然而，我们一上手就遇到了一个难题，<code>Interop.PCOMMSERVERLib</code> 似乎是基于 .NET Framework 3.x 开发的，将它引入引用后，如果目标框架是 .NET Framework 3.5 就没有问题，而如果用 .NET Framework 4 及以上，就会出现诸如“无法嵌入互操作类型 “PmacDeviceClass”，请改用合适的接口”的问题。然而，<code>Windows.Forms.DataVisualization</code> 又是 .NET Framework 4 才引入的，没用它的话，要绘制自动聚焦评价函数的曲线又显得麻烦起来。</p><p>几经波折，总算在公司的官方论坛上找到了一个<a href="http://forums.deltatau.com/showthread.php?tid=234" target="_blank" rel="noopener">解决方法</a>。按照他的指示，将引用属性里的“嵌入互操作类型”的值改为 <code>false</code>，就可以避免出现编译错误了。按我的理解，这避开了编译时对 COM 类型的解析。而另一方面，得益于 COM 组件强大的兼容性，这么做在运行时似乎并不会有问题。</p><p>除此之外，还有各种其它问题到工厂里调试才逐渐凸显，于是项目的开发毫无疑问的超期了，变成了一场漫长而琐碎拉锯战。</p><h3 id="相机控制"><a class="markdownIt-Anchor" href="#相机控制"></a> 相机控制</h3><p>相机用的是 FLIR 的工业相机，为了通过编程控制，需要使用 <a href="https://www.flir.com/products/flycapture-sdk/" target="_blank" rel="noopener">FlyCapture2</a> 套件进行开发。</p><p>事实上，这部分之前的一个师兄应该已经尝试过了，然而，他在移交代码的时候并没有找全所有依赖，导致移交的程序虽然能通过编译，但一旦启动就会发生 <code>FileNotFoundException</code>。不过好在开发套件中还包含一些demo的源码，那就编译跑跑试试？幸运的是，demo在我的机器上可以跑起来。既然如此，那就好办了，找到输出目录，把里面的东西一股脑的都复制过来……额，好像有点多。那就先用暴力排除法，在程序启动的时候试着把路径里的文件一个个删掉，没有操作权限的文件就是必要的依赖。不过后来想想这个方法还是太笨太低效了，于是又去找查找依赖项的工具，得到了 <a href="https://github.com/lucasg/Dependencies" target="_blank" rel="noopener">Dependencies</a>，不过这是后话了。</p><p>既然找到依赖了，最好还能在构建的时候一把梭把依赖全部自动复制到输出目录。在研究了一下demo的项目文件后，又根据目标平台和配置写了一个<code>PostBuildEvent</code>脚本，中间还顺带学习了一下 PowerShell，一晃就到了凌晨三点半。</p><p>结果第二天师兄跟我说在他那儿还是会触发 <code>BadImageFormatException</code>，不过此时我已经备好了 Dependencies 作为武器。分析一下 Dependencies 给出缺失的库，基本都 <code>api-ms-win-</code> 开头，<code>d</code> 结尾的一些动态库，这就意识到估计跟 Debug 模式有关，而且是微软官方的 VC++ 运行时库。于是先让师兄换成 Release，成功跑起来。再让他给 Visual Studio 安装 C++ 桌面开发的相关组件，才解决。</p><p>然而还有漫长的痛苦发生在去工厂调试之后。我们的目标工控机跑的是古老的 Windows XP 32位系统，然而我们用的这个库是64位（其实有32位的，不过32位的好像缺依赖，在我自己的机器上都跑不了demo）。好在机器的硬件是64位的，于是又抱着主机到有网的地方重装一个64位系统。除了系统之外，还有各种 VC 运行时库、.NET Framework 要安装。</p><p>好不容易搞定了基本环境，启动后却检测不到相机。看设备管理器里的提示，似乎跟驱动程序的证书有关，可找遍各种资料也没明白应该怎么修复，找相机售后也没得出个所以然来。不过这段时间我正好有一些工作面试之类的，也没太管。事后，听说师兄们祭出了终极绝招360管家，把所有系统漏洞都修复了就好使了……而问题的准确原因也就成了一个谜。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>做这么一个项目的过程中虽然踩了不少坑，碰了不少壁，不过“凡不能毁灭我的，必使我强大”，要说收获，可能也不少。不过项目虽然已经进入后期，但踩坑之路还没有断绝。到了现在，看这项目最大的隐患可能就是各个精度指标提的有些离谱，什么自动聚焦图像采集间隔 10μm，用<strong>拟合</strong>得到的最佳焦面位置判定精度却要达到1μm之类的，实在是过于奇幻了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本文以倒苦水为主。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈散记" scheme="http://miRoox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="http://miRoox.github.io/blog/tags/C/"/>
    
      <category term="PMAC" scheme="http://miRoox.github.io/blog/tags/PMAC/"/>
    
      <category term="FlyCapture2" scheme="http://miRoox.github.io/blog/tags/FlyCapture2/"/>
    
  </entry>
  
  <entry>
    <title>部署一个简单的缩略 URL 的表单</title>
    <link href="http://miroox.github.io/blog/2020/08/WolframURLShortenForm/"/>
    <id>http://miroox.github.io/blog/2020/08/WolframURLShortenForm/</id>
    <published>2020-08-30T13:33:21.000Z</published>
    <updated>2020-08-31T06:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近微博好像把 <code>github.io</code> 下的域名屏蔽了，导致博客完全无法分享，就考虑通过短链接跳转绕开这一限制。考虑到 Mathematica 有现成的函数 <a href="http://reference.wolfram.com/language/ref/URLShorten.html" target="_blank" rel="noopener"><code>URLShorten</code></a>，直接使用即可。不过闲着无聊，就顺便部署了一个简单的缩略 URL 的表单: <a href="https://www.wolframcloud.com/obj/miroox/url-shorten" target="_blank" rel="noopener">https://www.wolframcloud.com/obj/miroox/url-shorten</a>。</p><a id="more"></a><iframe src="https://www.wolframcloud.com/obj/miroox/url-shorten?_embed=iframe" width="600" height="400" frameborder="0" loading="lazy" allowfullscreen></iframe><p>本来想支持复制按钮的，然而 <a href="http://reference.wolfram.com/language/ref/CopyToClipboard.html" target="_blank" rel="noopener"><code>CopyToClipboard</code></a> 在网页上不起作用，自己写 js 支持又出乎意料的麻烦，遂放弃。</p><p>部署用的代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CloudDeploy</span>[</span><br><span class="line"> <span class="keyword">FormPage</span>[</span><br><span class="line">  &#123;<span class="string">"url"</span>, <span class="string">"URL:"</span>&#125; -&gt; &lt;|</span><br><span class="line">    <span class="string">"Interpreter"</span> -&gt; <span class="string">"URL"</span>,</span><br><span class="line">    <span class="string">"Hint"</span> -&gt; <span class="string">"Enter the URL to be shortened"</span></span><br><span class="line">    |&gt;,</span><br><span class="line">  <span class="keyword">Row</span>@&#123;<span class="string">"Short URL: "</span>, <span class="keyword">Hyperlink</span>@ <span class="keyword">URLShorten</span>[#url]&#125; &amp;,</span><br><span class="line">  <span class="keyword">AppearanceRules</span> -&gt; &lt;|</span><br><span class="line">    <span class="string">"Title"</span> -&gt; <span class="string">"Shorten your URL"</span></span><br><span class="line">    |&gt;</span><br><span class="line">  ],</span><br><span class="line"> <span class="string">"url-shorten"</span>,</span><br><span class="line"> <span class="keyword">Permissions</span> -&gt; <span class="string">"Public"</span></span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近微博好像把 &lt;code&gt;github.io&lt;/code&gt; 下的域名屏蔽了，导致博客完全无法分享，就考虑通过短链接跳转绕开这一限制。考虑到 Mathematica 有现成的函数 &lt;a href=&quot;http://reference.wolfram.com/language/ref/URLShorten.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;URLShorten&lt;/code&gt;&lt;/a&gt;，直接使用即可。不过闲着无聊，就顺便部署了一个简单的缩略 URL 的表单: &lt;a href=&quot;https://www.wolframcloud.com/obj/miroox/url-shorten&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.wolframcloud.com/obj/miroox/url-shorten&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="Cloud" scheme="http://miRoox.github.io/blog/tags/Cloud/"/>
    
  </entry>
  
  <entry>
    <title>【新坑】wll-rs: 用于 Rust 的 Wolfram LibraryLink 接口</title>
    <link href="http://miroox.github.io/blog/2020/08/wll-rs-design/"/>
    <id>http://miroox.github.io/blog/2020/08/wll-rs-design/</id>
    <published>2020-08-29T15:40:21.000Z</published>
    <updated>2021-10-25T15:18:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>苦于 Wolfram <a href="http://reference.wolfram.com/language/LibraryLink/tutorial/Overview.html" target="_blank" rel="noopener">LibraryLink</a> 原本的接口使用起来过于繁琐，又受 <a href="https://github.com/njpipeorgan/wll-interface" target="_blank" rel="noopener">wll-interface</a> 的启发，近期开了一个新坑，尝试为 Wolfram LibraryLink 封装一套 Rust 的接口 <a href="https://crates.io/crates/wll" target="_blank" rel="noopener">wll-rs</a>。</p><blockquote><p>阅读本文需要一定 Rust 以及 Wolfram LibraryLink 的基础。</p></blockquote><a id="more"></a><h3 id="目标和基本结构"><a class="markdownIt-Anchor" href="#目标和基本结构"></a> 目标和基本结构</h3><p>既然用上 Rust 这种高级抽象的语言，自然不可能只是做一些简单的绑定。至少要能做到两件事：</p><ol><li>提供安全便利的类型和接口封装</li><li>自动生成满足 LibraryLink 规范的导出函数格式</li></ol><p>为了让不熟悉 Wolfram LibraryLink 的读者也能了解到它使用起来有多麻烦，下面截一段官方示例中的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Include required header */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"WolframLibrary.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the version of Library Link */</span></span><br><span class="line"><span class="function">DLLEXPORT mint <span class="title">WolframLibrary_getVersion</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> WolframLibraryVersion;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize Library */</span></span><br><span class="line"><span class="function">DLLEXPORT <span class="keyword">int</span> <span class="title">WolframLibrary_initialize</span><span class="params">( WolframLibraryData libData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LIBRARY_NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Uninitialize Library */</span></span><br><span class="line"><span class="function">DLLEXPORT <span class="keyword">void</span> <span class="title">WolframLibrary_uninitialize</span><span class="params">( WolframLibraryData libData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Adds one to the input, returning the result  */</span></span><br><span class="line"><span class="function">DLLEXPORT <span class="keyword">int</span> <span class="title">demo_I_I</span><span class="params">( WolframLibraryData libData, mint Argc, MArgument *Args, MArgument Res)</span> </span>&#123;</span><br><span class="line">    mint I0;</span><br><span class="line">    mint I1;</span><br><span class="line">    I0 = MArgument_getInteger(Args[<span class="number">0</span>]);</span><br><span class="line">    I1 = I0 + <span class="number">1</span>;</span><br><span class="line">    MArgument_setInteger(Res, I1);</span><br><span class="line">    <span class="keyword">return</span> LIBRARY_NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了加载库和卸载库时所需要的初始化和反初始化函数外，函数本身的传参形式也非常奇妙，<a href="http://reference.wolfram.com/language/ref/LibraryFunction.html" target="_blank" rel="noopener"><code>LibraryFunction</code></a> 的实参通过 <code>MArgument</code> 的指针（数组）传入，实际的返回结果也在参数列表中，而函数所返回的 <code>int</code> 值则表示一个错误码。</p><p>作为目标，我们期望在 wll-rs 中实现的等效形式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.rs</span></span><br><span class="line"><span class="keyword">use</span> wll::<span class="built_in">Result</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wll::setup]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wll::teardown]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">uninit</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wll::export(demo_I_I)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>(n: <span class="built_in">isize</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">isize</span>&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(n + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即通过 <code>wll::Result</code> 表示返回值和结果状态，通过类属性宏标记函数来自动生成满足 LibraryLink 规范的导出函数。</p><p>有了基本的目标，那么大致的框架也可以确定了：</p><img src="/blog/2020/08/wll-rs-design/structure.png" title="大致框架"><ul><li><a href="https://crates.io/crates/wll-sys" target="_blank" rel="noopener">wll-sys</a> 底层接口绑定</li><li><a href="https://crates.io/crates/wll-macros" target="_blank" rel="noopener">wll-macros</a> 提供类属性过程宏（受Rust本身的限制，过程宏必须由单独的包提供）</li><li><a href="https://crates.io/crates/wll" target="_blank" rel="noopener">wll</a> 整合封装给用户使用的包</li></ul><h3 id="底层接口绑定"><a class="markdownIt-Anchor" href="#底层接口绑定"></a> 底层接口绑定</h3><p>底层接口绑定是一件很无聊的事，不过好在我们有 <a href="https://rust-lang.github.io/rust-bindgen/introduction.html" target="_blank" rel="noopener"><code>bindgen</code></a> 可以从头文件中生成对应的 Rust 文件，大大减轻了我们的工作量。具体操作流程就不再赘述了，直接看官方的文档教程即可。</p><p>稍微值得一提的是，<code>bindgen</code> 生成的文件可能不能满足我们对类型的预期，比如头文件中的宏定义和匿名枚举项，本身不具有类型描述。例如来自宏定义的 <code>True</code> 的类型并不会是 <code>mbool</code>。为了能手动转换复写它们，这里将 <code>bindgen</code> 生成的代码包含在一个 <code>mod</code> 中，再 <code>pub use</code> 导出全部符号，这时，在外部复写也不会导致符号重名的错误了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sys/src/lib.rs 节选</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> bindings &#123;</span><br><span class="line">    include!(<span class="built_in">concat!</span>(<span class="built_in">env!</span>(<span class="string">"OUT_DIR"</span>), <span class="string">"/bindings.rs"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> bindings::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> True: mbool = bindings::True <span class="keyword">as</span> mbool;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> False: mbool = bindings::False <span class="keyword">as</span> mbool;</span><br><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure><p>另外 Wolfram LibraryLink 的接口设计某种意义上是不需要链接的，几乎所有类型都是指针，用来回调的函数也是 <code>WolframLibraryData</code> 的成员函数指针。事实上，在目前的测试中，哪怕没有链接到 <code>WolframRTL</code>，编译得到的 C ABI 动态库（<code>cdylib</code>）只要满足 LibraryLink 的接口规范，一样能正常使用。</p><h3 id="参数类型适配"><a class="markdownIt-Anchor" href="#参数类型适配"></a> 参数类型适配</h3><p>底层接口绑定完成后，就可以开始进行用户层参数的适配了。</p><p>首先考虑错误处理。这里将错误码封装成更具 Rust 风格的 <code>Result</code> 和 <code>Error</code> 对象，以及和错误码之间的相互转换。而为了更友好地向用户表征错误类型，也提供了 <code>ErrorKind</code> 枚举类型，以及其到 <code>Error</code> 类型的转换（见 <a href="https://github.com/miRoox/wll-rs/blob/master/src/errors.rs" target="_blank" rel="noopener"><code>errors.rs</code></a>）。</p><p>在 LibraryLink 的接口中，所有类型的参数都通过 <code>MArgument</code> 来传递，这是一个（untagged）联合体，包含了 LibraryLink 中的各种类型。而我们的用户既不应该直接处理 <code>MArgument</code>，也通常不用直接面对 LibraryLink 的底层类型，而是使用封装后的 Rust 类型。</p><img src="/blog/2020/08/wll-rs-design/types.png" title="类型关系"><p>如图所示，为了支持函数的输入输出，需要有“Rust 类型 - LibraryLink 类型 - <code>MArgument</code>”的双向转换。这里，LibraryLink 类型是可枚举的，因此，它和 <code>MArgument</code> 之间的转换也是可枚举的，同时，从设计上看，这部分转换也是无需暴露给用户的。而对于可能的 Rust 类型，为了给予用户可扩展性，允许用户自定义 Rust 类型和 LibraryLink 类型之间的转换。并且，一旦用户自定义了 Rust 类型和 LibraryLink 类型之间的转换，那么对应的 Rust 类型和 <code>MArgument</code> 之间的转换也应该<strong>自动</strong>被实现。而为了保证最终转换的唯一性，一个 Rust 类型至多只能对应于一个 LibraryLink 类型（反之则不然）。</p><p>小结一下需求：</p><ol><li>LibraryLink 类型和 <code>MArgument</code> 之间的转换预先固定且不暴露给用户；</li><li>Rust 类型和 LibraryLink 类型之间的转换可以由用户自行扩展，但一个 Rust 类型至多只能对应于一个 LibraryLink 类型；</li><li>Rust 类型和 LibraryLink 类型之间的转换 → Rust 类型和 <code>MArgument</code> 之间的转换。</li></ol><p>一个非常平凡的想法是将所有 LibraryLink 类型包到一个 <code>enum</code> 中，毕竟 Rust 的 <code>enum</code> 也就是一种 tagged union，这样也很容易满足一个 Rust 类型至多只对应于一个 LibraryLink 类型。但问题在于这使 <code>MArgument</code> 到 LibraryLink 类型，以及更进一步的，从 <code>MArgument</code> 到 Rust 类型的转换变得困难了起来。虽然 <code>enum</code> 带有标签，但从编译时蕴含的信息上看，它和 <code>union</code> 一样，都抹平了不同类型之间的差异。当从它向 <code>MArgument</code> 转换时，由于它具有的运行时信息更丰富，因此可以实现。然而，反之则不然，如果不向这一过程注入更多类型信息的话，那么实现起来完全无从下手。可是，如果不使用 <code>enum</code> 的话，这些信息本身就存在，再额外注入不仅画蛇添足，似乎也不太符合分离耦合的思想。</p><p>在 Rust 中，我们有两种逻辑委派方法，其中一种是 <code>enum</code>，而另一种是 <code>trait</code> 对象<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。<code>enum</code> 是封闭类型，看上去更符合我们这里的情况，但由于上述原因，并不适合使用；而 <code>trait</code> 对象是开放类型，似乎也没法用在这里。当然，我们这里不需要动态性，所以只需要 <code>trait</code> 而非 <code>trait</code> 对象，但这也为我们提供了另一种可能的思路。</p><p>事实上，<em>sealed trait</em> 模式<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>让我们能将 <code>trait</code> 的实现限制在我们的模块内而无法被外部实现。简而言之，就是让我们的公开 <code>trait</code> 将一个不公开的占位 <code>trait</code> 作为父 <code>trait</code>，从而使外部实现无法满足约束，从而封闭了可能的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adaptor.rs 节选</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> private &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sealed</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MType</span></span>: private::Sealed + <span class="built_in">Sized</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> impl_mtypes &#123;</span><br><span class="line">    ($($t:ty),+) =&gt; &#123;</span><br><span class="line">        $(</span><br><span class="line">            <span class="keyword">impl</span> private::Sealed <span class="keyword">for</span> $t &#123;&#125;</span><br><span class="line">            <span class="keyword">impl</span> MType <span class="keyword">for</span> $t &#123;&#125;</span><br><span class="line">        )+</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl_mtypes!(</span><br><span class="line">    mbool,</span><br><span class="line">    mint,</span><br><span class="line">    mreal,</span><br><span class="line">    mcomplex,</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在这里，我们将所有的 LibraryLink 类型都实现为 <code>MType trait</code>。这只是一个开端，我们还需要提供它们的适配关系接口。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">InputAdaptor</span></span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Input</span></span>: MType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mtype_try_from</span></span>(input: Self::Input) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">OutputAdaptor</span></span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>: MType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_into_mtype</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到一个 Rust 类型至多只对应于一个 LibraryLink 类型。将对应的 LibraryLink 类型作为适配 <code>trait</code> 的关联类型显然是比较合适的。而为了自动实现 Rust 类型和 <code>MArgument</code> 之间的转换，可以采用所谓的 <em>blanket implementations</em><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 来传递这种转换关系。然而，不同 LibraryLink 类型对应 <code>MArgument</code> 的字段不同，需要 <em>ad-hoc</em> 实现，而同一个 <code>trait</code> 的 <em>blanket implementations</em> 不能区分具有不同关联类型的同种 <code>trait</code>。因此 <code>MArgument</code> 的转换 <code>trait</code> 必须是具有泛型类型参数的 <code>trait</code>，通过完全特化的实现来满足这种对应关系。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MArgumentGetter</span></span>&lt;T: MType&gt;: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_get_arg</span></span>(arg: MArgument) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MArgumentSetter</span></span>&lt;T: MTypeOrVoid&gt;: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_set_arg</span></span>(<span class="keyword">self</span>, arg: &amp;MArgument) -&gt; <span class="built_in">Result</span>&lt;()&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: InputAdaptor&lt;Input = mbool&gt;&gt; MArgumentGetter&lt;mbool&gt; <span class="keyword">for</span> T &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_get_arg</span></span>(arg: MArgument) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> ptr = arg.boolean;</span><br><span class="line">            <span class="keyword">if</span> ptr.is_null() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(Error::from(ErrorKind::TypeError));</span><br><span class="line">            &#125;</span><br><span class="line">            T::mtype_try_from(std::ptr::read(ptr))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: OutputAdaptor&lt;Output = mbool&gt;&gt; MArgumentSetter&lt;mbool&gt; <span class="keyword">for</span> T &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_set_arg</span></span>(<span class="keyword">self</span>, arg: &amp;MArgument) -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> ptr = arg.boolean;</span><br><span class="line">            <span class="keyword">if</span> ptr.is_null() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(Error::from(ErrorKind::TypeError));</span><br><span class="line">            &#125;</span><br><span class="line">            std::ptr::write(ptr, <span class="keyword">self</span>.try_into_mtype()?);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure><p><code>#[doc(hidden)]</code> 表明这部分不应被用户直接使用。实际的实现代码为了避免繁琐易错的复制粘贴，是通过宏完成的（见 <a href="https://github.com/miRoox/wll-rs/blob/master/src/adaptor.rs" target="_blank" rel="noopener"><code>adaptor.rs</code></a>）。</p><p>最终的类型适配关系如图所示：</p><img src="/blog/2020/08/wll-rs-design/adaptor.png" title="类型适配"><h3 id="访问-wolframlibrarydata"><a class="markdownIt-Anchor" href="#访问-wolframlibrarydata"></a> 访问 <code>WolframLibraryData</code></h3><p>由于 LibraryLink 的所有函数都是回调式的，各种函数的调用都免不了要访问当前的 <code>WolframLibraryData</code>。然而我们显然是不会希望各个函数都要带着一个 <code>WolframLibraryData</code> 的参数到处跑的，因此，一种直观的方式是使用一个全局静态对象，并在适时处设置它以实现别的函数对它的访问。不过这部分的设计尚未完全确定，在此也不多费口舌了。</p><h3 id="类属性过程宏"><a class="markdownIt-Anchor" href="#类属性过程宏"></a> 类属性过程宏</h3><p>为了便利地从 Rust 函数中创建满足 LibraryLink 的接口规范的导出函数，可以通过类属性过程宏来解决这一麻烦。</p><p>这部分实现在 <a href="https://crates.io/crates/wll-macros" target="_blank" rel="noopener">wll-macros</a>，并在 wll 设置了 <code>macros</code> feature 时会重新导出其中的宏（似乎由于 Rust 本身的限制，过程宏的重导出必须这么做）。</p><p>其中</p><ul><li><code>setup</code> 会将它标记的函数放到 <code>WolframLibrary_initialize</code> 中调用，并补上 <code>WolframLibrary_getVersion</code>；</li><li><code>teardown</code> 会将它标记的函数放到 <code>WolframLibrary_uninitialize</code> 中调用；</li><li><code>export</code> 有两种形式：<ul><li>当它不包含参数时，会给原本的函数名前面加上 <code>wll_</code> 并按 LibraryLink 的接口规范导出函数；</li><li>当它包含参数时，则按参数名作为导出函数的名称，同样按 LibraryLink 的接口规范导出。</li></ul></li></ul><p>过程宏在官方资料中描述不多，但本身又非常繁琐，因此在这里就不多赘述了，推荐观看<a href="https://www.youtube.com/watch?v=geovSK3wMB8" target="_blank" rel="noopener">视频</a>进行学习。</p><p>这里给出前述 <code>demo.rs</code> 进行宏展开后的结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cargo expand demo.rs</span></span><br><span class="line"><span class="keyword">use</span> wll::<span class="built_in">Result</span>;</span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">WolframLibrary_initialize</span></span>(</span><br><span class="line">    data: ::wll::sys::WolframLibraryData,</span><br><span class="line">) -&gt; ::wll::sys::errcode_t &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> ::std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(e) = ::wll::global::initialize_lib_data(data) &#123;</span><br><span class="line">        e.to_raw_error()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        ::wll::sys::LIBRARY_NO_ERROR</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">WolframLibrary_getVersion</span></span>() -&gt; ::wll::sys::mint &#123;</span><br><span class="line">    ::wll::sys::WolframLibraryVersion</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">uninit</span></span>() &#123;&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">WolframLibrary_uninitialize</span></span>(_: ::wll::sys::WolframLibraryData) &#123;</span><br><span class="line">    uninit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>(n: <span class="built_in">isize</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">isize</span>&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(n + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">demo_I_I</span></span>(</span><br><span class="line">    lib_data: ::wll::sys::WolframLibraryData,</span><br><span class="line">    argc: ::wll::sys::mint,</span><br><span class="line">    args: *<span class="keyword">const</span> ::wll::sys::MArgument,</span><br><span class="line">    res: ::wll::sys::MArgument,</span><br><span class="line">) -&gt; ::wll::sys::errcode_t &#123;</span><br><span class="line">    <span class="keyword">use</span> ::wll::adaptor::&#123;MArgumentGetter, MArgumentSetter&#125;;</span><br><span class="line">    <span class="keyword">let</span> _lib_data = ::wll::global::LibDataLocalizer::new(lib_data);</span><br><span class="line">    <span class="keyword">if</span> argc != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ::wll::sys::LIBRARY_TYPE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arg0 = <span class="keyword">match</span> &lt;<span class="built_in">isize</span>&gt;::try_get_arg(args.add(<span class="number">0usize</span>).read()) &#123;</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Ok</span>(val) =&gt; val,</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> err.to_raw_error(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">match</span> add_one(arg0) &#123;</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Ok</span>(val) =&gt; val,</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> err.to_raw_error(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">match</span> ret.try_set_arg(&amp;res) &#123;</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Ok</span>(()) =&gt; ::wll::sys::LIBRARY_NO_ERROR,</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(err) =&gt; err.to_raw_error(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>文章简单介绍了一下 wll 的基本设计和目前的进展。通过这个项目我也熟悉了Rust 的 bindgen、过程宏以及 <code>trait</code> 的各种高级用法。顺便 LibraryLink 的接口规范虽然繁琐，但也不失为一种具有灵活性和强兼容性的接口设计方案。不过 wll 还处于相当早期的开放阶段，虽然提供了简单的 <code>Complex&lt;T&gt;</code> 复数类型，但功能并不完整。而像 <code>MTensor</code>, <code>MNumericArray</code> 等类型对应的 Rust 高级类型和适配都尚未开始，开发完善的路途依旧漫长。</p><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.possiblerust.com/guide/enum-or-trait-object" target="_blank" rel="noopener">Enum or Trait Object</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed" target="_blank" rel="noopener">Rust API Guidelines: C-SEALED</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html" target="_blank" rel="noopener">Traits: Defining Shared Behavior</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苦于 Wolfram &lt;a href=&quot;http://reference.wolfram.com/language/LibraryLink/tutorial/Overview.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LibraryLink&lt;/a&gt; 原本的接口使用起来过于繁琐，又受 &lt;a href=&quot;https://github.com/njpipeorgan/wll-interface&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wll-interface&lt;/a&gt; 的启发，近期开了一个新坑，尝试为 Wolfram LibraryLink 封装一套 Rust 的接口 &lt;a href=&quot;https://crates.io/crates/wll&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wll-rs&lt;/a&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;阅读本文需要一定 Rust 以及 Wolfram LibraryLink 的基础。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="元编程" scheme="http://miRoox.github.io/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Rust" scheme="http://miRoox.github.io/blog/tags/Rust/"/>
    
      <category term="LibraryLink" scheme="http://miRoox.github.io/blog/tags/LibraryLink/"/>
    
  </entry>
  
  <entry>
    <title>预览在 GitHub 上的 Wolfram 笔记本</title>
    <link href="http://miroox.github.io/blog/2020/07/WolframGitHubViewer/"/>
    <id>http://miroox.github.io/blog/2020/07/WolframGitHubViewer/</id>
    <published>2020-07-31T13:29:21.000Z</published>
    <updated>2020-08-01T14:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.wolframcloud.com/obj/github-cloud/form/BadgeCreation" target="_blank" rel="noopener"><img src="https://www.wolframcloud.com/obj/github-cloud/notebookviewersource/Images/github_header.png" alt="Make A Wolfram GitHub Viewer Badge"></a></p><a id="more"></a><p>不知道啥时候，Wolfram 官方偷偷上线了一个在线预览 GitHub 仓库中的笔记本的网页应用。有了这个，大家就不用花自己的 Cloud Credits 来部署笔记本，而只要把笔记本同步到 GitHub 上就可以从浏览器访问云上的笔记本了。</p><p>以 <a href="https://github.com/wjxway" target="_blank" rel="noopener">@wjxway</a> 大佬的<a href="https://github.com/wjxway/Realistic_Blackhole_Accretion_Disk" target="_blank" rel="noopener">黑洞吸积盘模拟</a>为例，按表单的提示输入即可：</p><ol><li>输入 GitHub 用户名<br><img src="/blog/2020/07/WolframGitHubViewer/github_id.png" title="github id"></li><li>输入要预览的 GitHub 仓库名和分支，分支默认为 master<br><img src="/blog/2020/07/WolframGitHubViewer/github_repo-branch.png" title="github repo-branch"></li><li>得到一个Markdown格式的徽章链接代码 <a href="https://wolfr.am/OphS2N6z" target="_blank" rel="noopener"><img src="https://wolfr.am/HAAhzkRq" alt="View notebooks"></a><br><img src="/blog/2020/07/WolframGitHubViewer/markdown_badge.png" title="markdown badge"></li><li>复制徽章代码到 Markdown 文件（通常是 <code>README.md</code>），在预览中点击徽章即可打开笔记本<br><img src="/blog/2020/07/WolframGitHubViewer/notebook.png" title="notebook"></li></ol><p>目前的坑：</p><ol><li>文件名中不能包含中文</li><li>Cloud 访问可能比较慢</li></ol><hr><p>补记：关于在 git 和 GitHub 上的笔记本的编写保存</p><p>写笔记本的时候建议使用 <a href="https://resources.wolframcloud.com/FunctionRepository/resources/SaveReadableNotebook" target="_blank" rel="noopener"><code>ResourceFunction[&quot;SaveReadableNotebook&quot;]</code></a> 或者 <a href="https://github.com/JP-Ellis/mathematica-notebook-filter" target="_blank" rel="noopener"><code>mathematica-notebook-filter</code></a> 得到干净的笔记本文件，避免提交一些乱七八糟的cache到git中：</p><ul><li>小文件推荐使用 <code>ResourceFunction[&quot;SaveReadableNotebook&quot;]</code>，也推荐使用我的 <a href="https://github.com/miRoox/MirooxUtils" target="_blank" rel="noopener"><code>MirooxUtils</code></a> 包附带的一个面板来一键快速保存为可读笔记本。</li><li>大文件，尤其是包含大量图片或者动态的文件，还是推荐使用 <code>mathematica-notebook-filter</code>（但要注意它还会滤掉输出单元），否则文件大小可能回膨胀地非常大，并且 <code>ResourceFunction[&quot;SaveReadableNotebook&quot;]</code> 对动态的处理存在一定Bug，可能导致文件损坏。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.wolframcloud.com/obj/github-cloud/form/BadgeCreation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://www.wolframcloud.com/obj/github-cloud/notebookviewersource/Images/github_header.png&quot; alt=&quot;Make A Wolfram GitHub Viewer Badge&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="GitHub" scheme="http://miRoox.github.io/blog/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>一个适用于 Wolfram 语言的 GitHub Action</title>
    <link href="http://miroox.github.io/blog/2020/01/GitHubActionForWolframLanguage/"/>
    <id>http://miroox.github.io/blog/2020/01/GitHubActionForWolframLanguage/</id>
    <published>2020-01-30T14:23:21.000Z</published>
    <updated>2020-08-28T12:01:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年 GitHub 推出了 <a href="https://github.com/features/actions" target="_blank" rel="noopener">Actions</a>，以提供内置的持续集成能力。同样是在去年，Wolfram Research 也推出了<a href="https://www.wolfram.com/engine/" target="_blank" rel="noopener">免费的开发者 Wolfram 引擎</a>，让我们有机会免费运行 Wolfram 语言代码。那么，两件快乐事情重合在一起。而这两份快乐，又给我带来多的快乐。得到的……没错，就是我们期待已久的对 Wolfram 语言程序的持续集成。</p><a id="more"></a><h3 id="配置经历趟过的坑"><a class="markdownIt-Anchor" href="#配置经历趟过的坑"></a> 配置经历（趟过的坑）</h3><p>当然，天下代码一大抄，照猫画虎首先也需要一个参考对象。这里参照的是 <a href="https://github.com/xu-cheng/latex-action" target="_blank" rel="noopener">xu-cheng/latex-action</a>，因为这是一个基于 Docker 容器的 Actions。而现成的 <a href="https://hub.docker.com/r/arnoudbuzing/wolframengine" target="_blank" rel="noopener">Wolfram 引擎的 Docker 配置</a>早已经出现的 DockerHub 上了，直接拿来用就可以了。</p><p>由于缺乏经验，还是先按照 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-a-docker-container-action" target="_blank" rel="noopener">Creating a Docker container action</a> 的文档过了一遍基本的流程，了解了一下 Docker 的基本用法。</p><p>基本思路是继承 <a href="https://hub.docker.com/r/arnoudbuzing/wolframengine" target="_blank" rel="noopener">arnoudbuzing/wolframengine</a> 的 Docker 容器，然后通过入口点脚本 <code>entrypoint.sh</code> 认证激活 Wolfram 引擎，再运行输入的 Wolfram 脚本。</p><p>在这里遇到的最大的困难大概还是认证激活。</p><p>首先，认证需要对应的 <a href="https://account.wolfram.com/wolframid" target="_blank" rel="noopener">Wolfram ID</a> 账号密码登录。显然，账号密码不能要用户直接写在 Action 的配置里。GitHub 提供了 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets" target="_blank" rel="noopener">Secrets 机制</a>来避免加密内容直接出现在配置文件中，但如果直接通过参数将账号密码传递给 Docker，仍不能避免让密码内容在日志中以明文出现。参考了 <a href="https://github.com/sliteteam/github-action-git-crypt-unlock" target="_blank" rel="noopener">sliteteam/github-action-git-crypt-unlock</a> 后，尝试得知环境变量在传递过程中不会在日志中直接输出其内容。因此，账号密码在使用时都应以环境变量的方式传递。</p><p>另一方面，Wolfram 引擎通常的激活流程是初次启动时手动在 prompt 下依序键入账号密码，文档里并没有提供利用 wolframscript 自动化这一激活流程的办法，还是在我几经失败踩坑后才探索出一种合适的办法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/wolframscript -authenticate <span class="variable">$WOLFRAM_ID</span> <span class="variable">$WOLFRAM_PASS</span></span><br><span class="line">/usr/bin/wolframscript -activate</span><br></pre></td></tr></table></figure><p>解决了认证激活的问题，剩下的基本就也没什么难度了。对参数缺失以及不合法的报错处理直接按 <a href="https://github.com/xu-cheng/latex-action" target="_blank" rel="noopener">xu-cheng/latex-action</a> 照搬。其它配置也基本大同小异。</p><p>最后，将 Action 发布到了市场上，见 <a href="https://github.com/marketplace/actions/github-action-for-wolfram-language" target="_blank" rel="noopener">GitHub action for Wolfram language</a>。有什么用我也不清楚，大概可以方便推广？</p><h3 id="食用方法"><a class="markdownIt-Anchor" href="#食用方法"></a> 食用方法</h3><p>使用时将下面的内容复制到 <code>.github/workflow/main.yml</code> （或者其它名字的）配置文件里</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Wolfram</span> <span class="string">script</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">miRoox/wolfram-action@master</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">script.wl</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">WOLFRAM_ID:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.WolframID</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">WOLFRAM_PASS:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.WolframPW</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>这里，<code>script.wl</code> 即你要运行的 Wolfram 语言脚本；<code>secrets.WolframID</code> 和 <code>secrets.WolframPW</code> 分别对应你的 Wolfram 账号 ID 和密码，你需要在仓库中建立对应名称的 Secrets，操作流程见 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets" target="_blank" rel="noopener">Creating and using encrypted secrets</a>。</p><p>下面是一个完整的配置文件的例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span> <span class="string">[push]</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">run_wolfram:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Wolfram</span> <span class="string">language</span> <span class="string">code</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Wolfram</span> <span class="string">script</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">miRoox/wolfram-action@master</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">file:</span> <span class="string">script.wl</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">WOLFRAM_ID:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.WolframID</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">WOLFRAM_PASS:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.WolframPW</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h3><p>关于 Wolfram 引擎的许可证：</p><p>根据 FAQ 里的 <a href="https://www.wolfram.com/engine/faq/#can-i-use-the-free-engine-in-an-open-source-project" target="_blank" rel="noopener">“我可以在开源项目中使用免费引擎吗？”</a>：</p><blockquote><p>您可以使用免费引擎开发项目，以及<strong>演示和测试</strong>。但是，免费引擎许可证不允许终端用户使用，除非此用途<strong>用于进一步开发</strong>。对于终端用户使用，用户必须拥有 Wolfram 引擎的单独许可证。如果您拥有 Wolfram 产品（如 Wolfram|One 或 Mathematica），或者您所在的组织拥有 Wolfram 站点许可证，则您可能已拥有相应的许可证。开源项目可以<a href="https://www.wolframcloud.com/objects/forms/wolfram-engine-open-source" target="_blank" rel="noopener">申请</a>特殊的 Wolfram 引擎许可证，允许终端用户自由使用免费引擎作为他们项目用途的一部分。</p></blockquote><p>由于持续集成服务本身是“用于进一步开发”的用途，而且终端用户使用时也确实不能免除 Wolfram 引擎的单独许可证，我认为在许可上应该时没有什么风险的。</p><hr><p>关于许可证的使用次数。经测试，对于同一个 Docker image，重复使用是不会消耗许可证的。<br>而在进行了新 build 的 image 中使用才会消耗许可证。<br>这也是这个 action 相对于直接在 workflow 中使用 <code>wget</code> 下载 Wolfram Engine 再激活的一个优势。</p><hr><p>2020.08.28 补记：</p><p>最近发现 Wolfram Engine 的许可证好像可以随便用了，这个项目的意义顿时变得微妙了起来。现在在 GitHub Action 中可以直接在 Ubuntu 环境下运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://account.wolfram.com/download/public/wolfram-engine/desktop/LINUX</span><br><span class="line">sudo bash LINUX -- -auto -verbose</span><br><span class="line">rm LINUX</span><br></pre></td></tr></table></figure><p>安装 Wolfram Engine ，然后采用前述同样的命令激活。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年 GitHub 推出了 &lt;a href=&quot;https://github.com/features/actions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Actions&lt;/a&gt;，以提供内置的持续集成能力。同样是在去年，Wolfram Research 也推出了&lt;a href=&quot;https://www.wolfram.com/engine/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;免费的开发者 Wolfram 引擎&lt;/a&gt;，让我们有机会免费运行 Wolfram 语言代码。那么，两件快乐事情重合在一起。而这两份快乐，又给我带来多的快乐。得到的……没错，就是我们期待已久的对 Wolfram 语言程序的持续集成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="GitHub" scheme="http://miRoox.github.io/blog/tags/GitHub/"/>
    
      <category term="持续集成" scheme="http://miRoox.github.io/blog/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>利用 GitHub Actions 自动化构建和发布 Qt 程序的一点经验</title>
    <link href="http://miroox.github.io/blog/2019/12/AboutGitHubActionsCIQt/"/>
    <id>http://miroox.github.io/blog/2019/12/AboutGitHubActionsCIQt/</id>
    <published>2019-12-10T14:24:54.000Z</published>
    <updated>2020-07-31T13:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵子 GitHub 正式发布了 <a href="https://github.com/features/actions" target="_blank" rel="noopener">Actions</a> 功能来提供内置的持续集成和持续发布。而我正好最近在利用 Qt 写<a href="https://github.com/miRoox/HIT-DigitalImageProcessing-Postgraduate" target="_blank" rel="noopener">数字图像处理的作业</a>，就想利用这个机会尝试一下基于 GitHub Actions 的持续集成。</p><a id="more"></a><p>当然，有问题首先是找轮子。很快我就找到了 <a href="https://github.com/jaredtao/HelloActions-Qt" target="_blank" rel="noopener">jaredtao/HelloActions-Qt</a>，以及相关的几篇博客文章<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。照猫画虎很快就把各个平台下的自动构建弄成了。但那篇关于自动发行的文章<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>对多配置下 <a href="https://github.com/actions/create-release" target="_blank" rel="noopener">create-release</a> 重复执行导致失败这一问题的解决方案不太令我满意，总觉得太繁琐了，而且我对其中所用的 PowerShell 也不熟。不过这个问题显然不是特殊情况，想必也曾有人就此提出了问题，而也许已经有别人回答了更好的解决方案也不一定。果不其然，早就有人在 create-release 的仓库下的 issues 中提出过这个问题，并且这个 issue 尚未关闭，也就是并没有一个非常令人满意的解答。不过，其中有一个回答<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>给我一点启发，它将使用多种配置的发布任务与创建 release 的任务分开，而通过 <a href="https://github.com/actions/upload-artifact" target="_blank" rel="noopener">upload-artifact</a> 和 <a href="https://github.com/actions/upload-artifact" target="_blank" rel="noopener">download-artifact</a> 来传递 release URL。另一个关联的仓库也有人给出了类似的思路<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">build(mac)       build(linux)        build(win)</span><br><span class="line">    │                  │                 │</span><br><span class="line">    └──────────────────┼─────────────────┘</span><br><span class="line">                       │</span><br><span class="line">                create_release()</span><br><span class="line">                       │</span><br><span class="line">    ┌──────────────────┼─────────────────┐</span><br><span class="line">    │                  │                 │</span><br><span class="line">upload(mac)       upload(linux)      upload(win)</span><br></pre></td></tr></table></figure><p>不过这种任务结构让构建和上传两个阶段的文件对应变得麻烦起来。受此启发，我想到了另一种可能——<code>create_release()</code>真的一定要在<code>build(...)</code>完成之后才能进行吗？因为我们需要创建 release 的时候一定是在发布 tag 的时候，这时我们通常已经在 commit 时检验过一遍是否通过构建/测试了，因此不妨将<code>create_release()</code>提前，于是有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                create_release()*</span><br><span class="line">                       │</span><br><span class="line">    ┌──────────────────┼─────────────────┐</span><br><span class="line">    │                  │                 │</span><br><span class="line"> build(mac)        build(linux)       build(win)</span><br><span class="line">    &amp;                  &amp;                 &amp;</span><br><span class="line">upload(mac)*      upload(linux)*     upload(win)*</span><br></pre></td></tr></table></figure><p><code>*</code>表示只在发布 tag 的时候才会进行这个步骤。这里将<code>build(...)</code>和<code>upload(...)</code>两个阶段合在同一个job中，便于传递文件。最终配置如 <a href="https://github.com/miRoox/HIT-DigitalImageProcessing-Postgraduate/blob/master/.github/workflows/build.yml" target="_blank" rel="noopener">.github/workflows/build.yml</a> 所示。</p><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://jaredtao.github.io/2019/11/19/Qt%E4%BD%BF%E7%94%A8github-Actions%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91/" target="_blank" rel="noopener">Qt使用github-Actions自动化编译</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://jaredtao.github.io/2019/12/03/Qt%E4%BD%BF%E7%94%A8github-Actions%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E8%A1%8C/" target="_blank" rel="noopener">Qt使用github-Actions自动化发行</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://github.com/actions/create-release/issues/14#issuecomment-555379810" target="_blank" rel="noopener">How to prevent creating multiple releases when using a build matrix?</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://github.com/actions/upload-release-asset/issues/16#issuecomment-561257944" target="_blank" rel="noopener">Support matrix build</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一阵子 GitHub 正式发布了 &lt;a href=&quot;https://github.com/features/actions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Actions&lt;/a&gt; 功能来提供内置的持续集成和持续发布。而我正好最近在利用 Qt 写&lt;a href=&quot;https://github.com/miRoox/HIT-DigitalImageProcessing-Postgraduate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数字图像处理的作业&lt;/a&gt;，就想利用这个机会尝试一下基于 GitHub Actions 的持续集成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="GitHub" scheme="http://miRoox.github.io/blog/tags/GitHub/"/>
    
      <category term="Qt" scheme="http://miRoox.github.io/blog/tags/Qt/"/>
    
      <category term="持续集成" scheme="http://miRoox.github.io/blog/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们需要术语——兼谈科普的危害性</title>
    <link href="http://miroox.github.io/blog/2019/11/TerminologyAndPopularScience/"/>
    <id>http://miroox.github.io/blog/2019/11/TerminologyAndPopularScience/</id>
    <published>2019-11-05T13:03:42.000Z</published>
    <updated>2020-07-31T13:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>写下这篇文章的起源是在知乎上看到的一个回答<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p><blockquote><p>很简单，就是硬抬杠。</p><p>举个例子，我说偶数跟正整数一样多，你就说怎么可能，正整数包含奇数和偶数，所以肯定正整数多。</p><p>我解释说偶数跟正整数存在一个一一映射，并且都含有无穷多元素，所以一样多。你就说我听不懂什么一一映射，我只知道我是你的两倍，所以肯定比你多。</p><p>那我解释，1对应2，2对应4，3对应6，一直这样下去，每个正整数都对应一个偶数。他就是不同意，说你说话就在放屁，我给你一百块，你给我两百块，一直这样我们看看最后谁的钱多？</p><p>我说这在有限的情况下是对的，但是无穷的情况下就不一定了。你就说无穷不就是特别大的数嘛，那我大一你倍不是大你更多？</p><p>我说wdnmd吧，你就说你怎么骂人呢？</p></blockquote><p>在这个回答里，作者似乎把对于无法将无穷集合的等势理解成“一样多”的普通人思维当作抬杠。但这件事就真的只是抬杠这么肤浅吗？</p><a id="more"></a><p>需要明确的是，“一样多”是自然语言的提法，不是一个严格的数学术语。基于基数的比较方式可以在有限的时候和我们平时说的一样多是一致的，因此我们将其推广到无穷意义下的一样多。但这个对应不是唯一的，我们可以构造另一个比较方式依然满足有限意义的“一样多”，却在无限集的比较晚得到不同的结果。比如：</p><p>不妨定义区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-a,a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span> 与集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span> 的交集的元素个数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N_A(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span> ，然后定义集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span> 和集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span></span></span></span> 的“元素比值”为</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>a</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></munder><mfrac><mrow><msub><mi>N</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>N</mi><mi>B</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">p(A,B)=\lim_{a\to\infty}\frac{N_A(a)}{N_B(a)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-.936em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.69444em"><span style="top:-2.1em;margin-left:0"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span><span style="top:-2.7em"><span class="pstrut" style="height:2.7em"></span><span><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.7em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.05017em">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.936em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>当“元素比值” <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p(A,B)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 时，则称集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span></span></span></span> 的元素“一样多”。显然，这个定义在集合有限时和我们的认知依然是一致的，因此也可以作为“一样多”的一个推广。但如果拿来比较整数和偶数，结果则不会是“一样多”，而前者对后者的“元素比值”为2，似乎更符合我们的直观认识。</p><p>当然，上面这个定义显然不会是我们的数学所想要的。因为这个定义过于平凡了，以至于即使在面对像有理数集这样的可数集时也会无法定义，这与数学所追求最广泛意义上的一致性是相违背的。因而，“势”依然是对任意集合的大小进行度量的最佳方式，也是我们在数学中普遍采用的。但这一概念如果反过来作为日常用语中的“一样多”的替代，则无疑是术语的滥觞，只会令人更加迷惑，无益于辨清问题的边界。</p><p>也许一个来自数学自身的例子更能展现这种概念拓展的不唯一性：维数——我们有线性空间的维数（自由度）、拓扑维数乃至各式各样的分形维数，它们最初都来自我们日常对空间方位的直观认知。但它们都是在各自领域中抽象出来的概念，并不能简单地断言谁是一般意义上最佳的定义。</p><p>不过，概念的推广与取代在学术界内部确实广为存在，每一次取代本身可以认为是对概念更深刻的理解。虽说如此，明辨问题的边界和语境对业内人士同样重要，至少应该采取明确的上下文或者精准唯一的术语来进行描述。</p><p>如果说概念的泛化推广是抽象和发散思维的体现，那么划定专有术语和明晰边界则是具体和确定性的追求。这两点对于研究者而言都具有程度相当的重要性。如何在两者间取得平衡，对科研人员也并非易事，更遑论科普读物和它们的读者了。能把握住这当中的微妙的，大概《物理学咬文嚼字》尚且能算一个比较好的例子吧。</p><p>针对科普作品，19世纪伟大的物理学家麦克斯韦曾写下这样的忠告<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p><blockquote><p>In the popular treatise, whatever shreds of the science are allowed to appear, are exhibited in an exceedingly diffuse and attenuated form, apparently with the hope that the mental faculties of the reader, though they would reject any stronger food, may insensibly become saturated with scientific phraseology, provided it is diluted with a sufncient quantity of more familiar language. In this way, by simple reading, the student may become possessed of the phrases of the science without having been put to the trouble of thinking a single thought about it. The loss implied in such an acquisition can be estimated only by those who have been compelled to unlearn a science that they might at length begin to learn it.</p><p>The technical treatises do less harm, for no one ever reads them except under compulsion. From the establishment of the general equations to the end of the book, every page is full of symbols with indices and suffixes, so that there is not a paragraph of plain English on which the eye may rest.</p></blockquote><p>确实，科普读物对专业术语的稀释一定程度上也是对读者深入思维能力的一种伤害。进一步地，这种对术语的浅薄化，对业已进入专业行列的“原读者”乃至科普作者自身的辨析能力也会造成不经意的伤害；而这种伤害又反过来进一步拉大了科学概念与一般人之间的距离，令人以为这些被“通俗化”所粉饰的概念就一定能为大众所理解，构成现代科学版的“何不食肉糜”，不得不令人扼腕。</p><p>当然，科普工作也不尽然都是坏的。哪怕是稀释过的概念知识，倘若能抓住精要，不会因为注水过多而浅尝辄止，那么从科普中浸润的少量知识反而更能让人甘之如饴，激发探索深入的兴趣。只是，倘若能在科普中就更好的明辨当中的概念和术语，大概会减少那些因模糊的粉饰而对长远的研究道路所造成的伤害吧。</p><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.zhihu.com/question/338618946/answer/779204340" target="_blank" rel="noopener">如何激怒一位数学爱好者？ - 孙泰英的回答 - 知乎</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>MAXWELL J C. Tait’s “Thermodynamics”[J]. Nature, 1878, 17(431): 257–259. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写下这篇文章的起源是在知乎上看到的一个回答&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;很简单，就是硬抬杠。&lt;/p&gt;&lt;p&gt;举个例子，我说偶数跟正整数一样多，你就说怎么可能，正整数包含奇数和偶数，所以肯定正整数多。&lt;/p&gt;&lt;p&gt;我解释说偶数跟正整数存在一个一一映射，并且都含有无穷多元素，所以一样多。你就说我听不懂什么一一映射，我只知道我是你的两倍，所以肯定比你多。&lt;/p&gt;&lt;p&gt;那我解释，1对应2，2对应4，3对应6，一直这样下去，每个正整数都对应一个偶数。他就是不同意，说你说话就在放屁，我给你一百块，你给我两百块，一直这样我们看看最后谁的钱多？&lt;/p&gt;&lt;p&gt;我说这在有限的情况下是对的，但是无穷的情况下就不一定了。你就说无穷不就是特别大的数嘛，那我大一你倍不是大你更多？&lt;/p&gt;&lt;p&gt;我说wdnmd吧，你就说你怎么骂人呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在这个回答里，作者似乎把对于无法将无穷集合的等势理解成“一样多”的普通人思维当作抬杠。但这件事就真的只是抬杠这么肤浅吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈散记" scheme="http://miRoox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="杂谈" scheme="http://miRoox.github.io/blog/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="科普" scheme="http://miRoox.github.io/blog/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>如何提交函数到 Wolfram Function Repository</title>
    <link href="http://miroox.github.io/blog/2019/10/SubmitFunctionToWFR/"/>
    <id>http://miroox.github.io/blog/2019/10/SubmitFunctionToWFR/</id>
    <published>2019-10-12T07:23:32.000Z</published>
    <updated>2020-07-31T13:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，你需要一个 <a href="https://account.wolfram.com/" target="_blank" rel="noopener">Wolfram 账户</a>。</p><a id="more"></a><p>然后，你需要<a href="https://datarepository.wolframcloud.com/request-publisher-id" target="_blank" rel="noopener">申请一个 Publisher ID</a>，这点在许多讲述提交函数到WFR的文章中都没提到。大致的申请流程可以在<a href="https://reference.wolfram.com/language/workflow/AcquireAResourceSystemPublisherID.html" target="_blank" rel="noopener">参考文档</a>里找到。</p><p>然后在 Mathematica 中新建一个函数知识库项。按<a href="https://resources.wolframcloud.com/FunctionRepository/style-guidelines" target="_blank" rel="noopener">风格指南</a>编写函数代码和文档。</p><p>提交前要检查 Mathematica 有没有登录到你的 Wolfram 账户，可以根据 <code>$WolframID</code> 的值确认。而且应该将 <code>$PublisherID</code> 的值设置为你申请到的 Publisher ID。</p><p>当然，提交之前还应该用菜单中的“Check”按钮检查格式无误后再提交。最后点击“Submit to Repository”，接下来就等邮件吧。无论 review 有没有通过一般都会发邮件进行通知。没有通过的话往往还会附上 review comments 指导你改进，并且可以完善后再提交更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，你需要一个 &lt;a href=&quot;https://account.wolfram.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wolfram 账户&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>尝试用TiddlyWiki搭建个人维基知识库</title>
    <link href="http://miroox.github.io/blog/2019/10/PersonalWiki/"/>
    <id>http://miroox.github.io/blog/2019/10/PersonalWiki/</id>
    <published>2019-10-10T12:44:23.000Z</published>
    <updated>2020-07-31T13:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>搭建一个个人维基用来整理知识的想法早已有之，但具体该使用什么方案却迟迟没能定下来。在最初的想法里，我希望满足下面的几项需求：</p><ul><li>内容与表现分离</li><li>自动化构建</li><li>可以使用自己定制的模板</li><li>词条的分类灵活，以适应知识体系的逐渐完善</li><li>方便建立知识点（词条）间的联系</li><li>需要用笔记时能快速提取</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.89883em;vertical-align:-.2155em"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-.36em"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.68333em"><span style="top:-2.904999em"><span class="pstrut" style="height:2.7em"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-.15em"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-.1667em"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.46782999999999997em"><span style="top:-2.7845em"><span class="pstrut" style="height:3em"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2155em"><span></span></span></span></span><span class="mspace" style="margin-right:-.125em"></span><span class="mord textrm">X</span></span></span></span></span></span> 公式输入</li><li>代码块语法高亮</li></ul><a id="more"></a><p>作为参考，见过别人用 <a href="https://www.dokuwiki.org/dokuwiki" target="_blank" rel="noopener">Dokuwiki</a> 的，也有直接拿 Hexo 的 <a href="https://github.com/zthxxx/hexo-theme-Wikitten" target="_blank" rel="noopener">Wikitte</a> 主题搭建的，等等。当然，我自己也做过一些尝试，比如 <a href="https://www.zim-wiki.org/" target="_blank" rel="noopener">Zim Wiki</a> ，不过这个太简陋了，完全无法满足我的需求；甚至受 <a href="http://wuli.wiki/" target="_blank" rel="noopener">小时物理百科</a> 的影响，尝试过用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.89883em;vertical-align:-.2155em"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-.36em"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.68333em"><span style="top:-2.904999em"><span class="pstrut" style="height:2.7em"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-.15em"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-.1667em"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.46782999999999997em"><span style="top:-2.7845em"><span class="pstrut" style="height:3em"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2155em"><span></span></span></span></span><span class="mspace" style="margin-right:-.125em"></span><span class="mord textrm">X</span></span></span></span></span></span> 构建维基，但 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.89883em;vertical-align:-.2155em"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-.36em"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.68333em"><span style="top:-2.904999em"><span class="pstrut" style="height:2.7em"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-.15em"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-.1667em"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.46782999999999997em"><span style="top:-2.7845em"><span class="pstrut" style="height:3em"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2155em"><span></span></span></span></span><span class="mspace" style="margin-right:-.125em"></span><span class="mord textrm">X</span></span></span></span></span></span> 对于我的需求而言又稍显复杂了，而且大量交叉引用在PDF中也并不方便阅读。最后在一番比较和取舍之下选择了<a href="https://tiddlywiki.com/" target="_blank" rel="noopener">TiddlyWiki</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><p>TiddlyWiki，按官方说法是<a href="https://github.com/Jermolene/TiddlyWiki5#readme" target="_blank" rel="noopener">「一款非线性个人 Web 笔记本」</a>。相比其他笔记和 Wiki 系统，其最大的特点之一是程序本体和数据全部都在一个 html 文件内，这意味着组织和阅读多个词条可以在同一个页面内直接完成，内容的关联更加直接，方便互相比照。同时，还有着非常强大的条目管理功能和插件系统，可扩展性和可定制性都很强。</p><p>TiddlyWiki 的优点还有很多<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，这里就不多赘述了。就我而言，更想简单说一下 TiddlyWiki 是如何满足前面提到的几项需求的：</p><ul><li>内容与表现分离：<ul><li>这一项近乎是一种哲学理念，实践起来是否须要完全符合还是看具体情况。</li><li>典型地，<a href="http://www.tiddlywiki.cn/#WikiText" target="_blank" rel="noopener">WikiText</a> 就提供了很多特定语义的语法元素，还有宏、模板嵌入等各种自定义工具。</li><li>当然，经典地 HTML-CSS-JS 结构也是可以使用的。</li></ul></li><li>自动化构建：<ul><li>通过使用 Node.js 上的 <a href="http://www.tiddlywiki.cn/#Installing%20TiddlyWiki%20on%20Node.js" target="_blank" rel="noopener">TiddlyWiki</a> 服务可以在本地同步保存修改；</li><li>用 Git 和 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 实现向 Github Pages 自动部署。</li></ul></li><li>可以使用自己定制的模板：<ul><li>这一项其实是“内容与表现分离”的具体实践方法之一。</li><li>WikiText 支持模板条目和宏。</li></ul></li><li>词条的分类灵活，以适应知识体系的逐渐完善：<ul><li>TiddlyWiki 是基于标签分类的，一个词条可以分到多个标签下，这一点比许多按树状层级分类的方案要灵活得多。</li></ul></li><li>方便建立知识点（词条）间的联系：<ul><li>词条链接和词条嵌入。</li></ul></li><li>需要用笔记时能快速提取：<ul><li>能自动部署到网页上，有网就能看；</li><li>还有灵活的搜索语法。</li></ul></li><li>LaTeX公式输入：<ul><li>KaTeX插件：支持的命令较少，不过是官方提供的，安装很容易。</li><li><a href="http://mathjax-tw5.kantorsite.net/" target="_blank" rel="noopener">MathJax插件</a>：第三方提供的，比较老了，好像和新版不太兼容，需要折腾（反正我没能折腾成功）。</li></ul></li><li>代码块语法高亮<ul><li>Highlight.js插件：这也是官方提供的。</li></ul></li></ul><p>除此之外，TiddlyWiki 还有一大优点是简单，几乎所有操作都可以在网页上完成，基本不用到处配置。这对于我这种对web技术基本一无所知的人来说是一个极大的优势。</p><p>不过也因为我对web技术的不了解，导致很大的功夫都花在自动部署的配置上了，最终也只是是照猫画虎。其间主要参考了 alexashley 的个人Wiki源码<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>、JavaScript 标准参考教程（alpha）<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>、《Blog自动部署实践: Hugo + Travis CI -&gt; GitHub Pages》<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>等资料。</p><p>最终弄出来的成品在：<a href="https://miroox.github.io/wiki/">https://miroox.github.io/wiki/</a></p><hr><p>参考资料：</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="http://www.tiddlywiki.cn/" target="_blank" rel="noopener">TiddlyWiki中文网站</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="http://blog.dimpurr.com/tiddly-wiki/" target="_blank" rel="noopener">使用 TiddlyWiki 打造轻便个人 Wiki 知识库</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://github.com/alexashley/wiki" target="_blank" rel="noopener">alexashley 的个人Wiki源码</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="http://javascript.ruanyifeng.com/nodejs/packagejson.html" target="_blank" rel="noopener">package.json文件 - JavaScript 标准参考教程（alpha）</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://blog.yuantops.com/tech/hugo-travis-ci-auto-deploy-to-gh-pages/" target="_blank" rel="noopener">Blog自动部署实践: Hugo + Travis CI -&gt; GitHub Pages</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建一个个人维基用来整理知识的想法早已有之，但具体该使用什么方案却迟迟没能定下来。在最初的想法里，我希望满足下面的几项需求：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;内容与表现分离&lt;/li&gt;&lt;li&gt;自动化构建&lt;/li&gt;&lt;li&gt;可以使用自己定制的模板&lt;/li&gt;&lt;li&gt;词条的分类灵活，以适应知识体系的逐渐完善&lt;/li&gt;&lt;li&gt;方便建立知识点（词条）间的联系&lt;/li&gt;&lt;li&gt;需要用笔记时能快速提取&lt;/li&gt;&lt;li&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mtext&gt;LaTeX&lt;/mtext&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\LaTeX&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:.89883em;vertical-align:-.2155em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord text&quot;&gt;&lt;span class=&quot;mord textrm&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:-.36em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:.68333em&quot;&gt;&lt;span style=&quot;top:-2.904999em&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord text&quot;&gt;&lt;span class=&quot;mord textrm sizing reset-size6 size3&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:-.15em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord text&quot;&gt;&lt;span class=&quot;mord textrm&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:-.1667em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:.46782999999999997em&quot;&gt;&lt;span style=&quot;top:-2.7845em&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:3em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord text&quot;&gt;&lt;span class=&quot;mord textrm&quot;&gt;E&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:.2155em&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:-.125em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord textrm&quot;&gt;X&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 公式输入&lt;/li&gt;&lt;li&gt;代码块语法高亮&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Wiki" scheme="http://miRoox.github.io/blog/tags/Wiki/"/>
    
      <category term="Web" scheme="http://miRoox.github.io/blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>MatrixForm赋值问题</title>
    <link href="http://miroox.github.io/blog/2019/09/MatrixFormProblem/"/>
    <id>http://miroox.github.io/blog/2019/09/MatrixFormProblem/</id>
    <published>2019-09-19T12:27:34.000Z</published>
    <updated>2020-07-31T13:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，赋值等过程中使用 <code>MatrixForm</code> 往往会导致后续的计算失效。比如：</p><img src="/blog/2019/09/MatrixFormProblem/problem.svg" title="a &#x3D; { {1, 2}, {3, 4} } &#x2F;&#x2F; MatrixForm"><a id="more"></a><p>对于这个问题，最正统的解决办法当然是在赋值等计算过程中不使用 <code>MatrixForm</code>，而只在显示时以 <code>MatrixForm</code> 呈现<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。典型的方案是在输出部分才加上 <code>MatrixForm</code> 包装。不过对于既有代码的问题，一个个手动修改可能略显麻烦，这时可以借助 <code>EchoFunction</code> 在实现类似效果的同时保持代码结构基本不变：</p><img src="/blog/2019/09/MatrixFormProblem/solution-echo.svg" title="a &#x3D; { {1, 2}, {3, 4} } &#x2F;&#x2F; EchoFunction[MatrixForm];"><p>要将既有代码调整为这种方式，只需简单的文本替换就可以实现目标。</p><p>不过，本文要主要要谈的并不是这类传统解决方案，而是通过给 Mathematica 系统打上补丁来实现几乎零修改的解决方案。</p><p>我们知道，<code>MatrixForm</code> 这类格式封装，当它位于结果的<em>最外层</em>时，<code>Out</code> 输出历史中不会对其进行储存<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。事实上，所有在 <code>$OutputForms</code> 中的格式封装都具有这样的性质。</p><p>受此启发，我们不妨把这个性质推广到赋值的情况上来，即这类格式封装出现在赋值运算的右侧时不会将其记录到赋值中。事实上，通过重载 <code>Set</code> 的定义很容易实现这一功能：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GeneralUtilities`BlockProtected[&#123;<span class="keyword">Set</span>&#125;,</span><br><span class="line">  <span class="keyword">Set</span>[lhs_,(form:<span class="keyword">Alternatives</span>@@<span class="keyword">$OutputForms</span>)[rhs_]] := form@<span class="keyword">Set</span>[lhs,rhs]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>效果如图：</p><img src="/blog/2019/09/MatrixFormProblem/solution.svg" title="a &#x3D; { {1, 2}, {3, 4} } &#x2F;&#x2F; MatrixForm"><hr><p>参考：</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="http://people.math.umass.edu/~murray/Math_421_Eisenberg/Notes/Mathematica_Q___A/MatrixForm/matrixform.html" target="_blank" rel="noopener">Q&amp;A: Compute with MatrixForm</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://note.youdao.com/ynoteshare1/index.html?id=d0a57819857f2771ca669eb54819e3d1&amp;type=note" target="_blank" rel="noopener">为什么我的代码加了MatrixForm后就出问题了？</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，赋值等过程中使用 &lt;code&gt;MatrixForm&lt;/code&gt; 往往会导致后续的计算失效。比如：&lt;/p&gt;&lt;img src=&quot;/blog/2019/09/MatrixFormProblem/problem.svg&quot; title=&quot;a &amp;#x3D; { {1, 2}, {3, 4} } &amp;#x2F;&amp;#x2F; MatrixForm&quot;&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>基于规则的带步骤符号求导器</title>
    <link href="http://miroox.github.io/blog/2019/07/RuleBasedStepByStepDerivative/"/>
    <id>http://miroox.github.io/blog/2019/07/RuleBasedStepByStepDerivative/</id>
    <published>2019-07-12T14:27:17.000Z</published>
    <updated>2020-07-31T13:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，<a href="https://www.wolframalpha.com" target="_blank" rel="noopener">Wolfram|Alpha</a> 有一个名为 <a href="https://www.wolframalpha.com/examples/pro-features/step-by-step-solutions/" target="_blank" rel="noopener">Step-by-Step Solutions</a> 的功能，可以显示一些数学问题求解的过程。又比如，著名的 <a href="https://rulebasedintegration.org/" target="_blank" rel="noopener">Rubi</a> 可以在求解积分的同时显示积分的求解步骤。实际上，这些系统背后大抵都是基于模式匹配和规则变换而实现的，因而原则上来说自己也可以实现一个。当然，就实践而言这些系统都过于复杂了，例如 Rubi 包含了超过六千条规则，其背后的原理远非三言两语可以阐明的。不过，相比于积分，微分的运算规则要简明得多，而且对规则的应用总是简单机械的，并不像积分那样可能会运用到各种技巧。因此，本文将利用 Mathematica 的模式匹配和规则实现一个带步骤符号求导器。</p><img src="/blog/2019/07/RuleBasedStepByStepDerivative/DvsInt.JPG" title="Differentiation vs Integration"><a id="more"></a><h3 id="求导规则"><a class="markdownIt-Anchor" href="#求导规则"></a> 求导规则</h3><p>实现的核心首先在于对求导法则的代码表示。由于 Rule-Based 也是 Wolfram 语言的基本范式，因此这些规则写起来也很直观。</p><p>首先是几个基本运算规则</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">baseRules=&#123;</span><br><span class="line">  d[c_,x_]/;<span class="keyword">FreeQ</span>[c,x]:&gt;<span class="number">0</span>,</span><br><span class="line">  d[lf_Plus,x_]:&gt;<span class="keyword">Thread</span>[d[lf,x],<span class="keyword">Plus</span>],</span><br><span class="line">  d[c_*f_,x_]/;<span class="keyword">FreeQ</span>[c,x]:&gt;c*d[f,x],</span><br><span class="line">  d[f_*g_,x_]:&gt;d[f,x]g+d[g,x]f</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，使用 <code>d[f,x]</code> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">d</mi><mi>f</mi></mrow><mrow><mi mathvariant="normal">d</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\tfrac{\mathrm{d}f}{\mathrm{d}x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.9322159999999999em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">d</span></span><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.446108em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">d</span></span><span class="mord mathdefault mtight" style="margin-right:.10764em">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。上述的代码表示了常数求导法则、线性求导法则和乘法求导法则的作用规则。</p><p>对于复合函数和反函数，需要一个间接的包装来表示类似 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(g(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 的情况，这里将其表示为<code>dfunc[f,gx]</code>类似的形式，其中<code>gx</code>对应于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">higherRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">InverseFunction</span>[f_][x_],x_]:&gt;<span class="number">1</span>/dfunc[f,<span class="keyword">InverseFunction</span>[f][x]],</span><br><span class="line">  d[f_[g_],x_]/;g=!=x:&gt;dfunc[f,g]d[g,x],</span><br><span class="line">  d[f_[g_,c_],x_]/;<span class="keyword">FreeQ</span>[c,x]&amp;&amp;g=!=x:&gt;dfunc[f[#,c]&amp;,g]d[g,x],</span><br><span class="line">  d[f_[c_,g_],x_]/;<span class="keyword">FreeQ</span>[c,x]&amp;&amp;g=!=x:&gt;dfunc[f[c,#]&amp;,g]d[g,x]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，为了避免问题过于复杂化，这里求导的对象都只限于初等函数。因此在考虑复合函数的链导法则时实际不包含多元函数。对于可能遇到地二元初等函数，要么其中一个参数与自变量无关，本质还是一元函数，要么可以通过变形转化成一元形式。</p><p>此外还有一点需要注意，在链式法则的规则中，模式条件<code>g=!=x</code>是必要的，否则可能陷入无限自递归的窘境。</p><p>在上面的高阶（反函数、复合函数）规则中，<code>dfunc</code>只是徒具形式的一个表示。为了确实有效地计算这种情况，还需要引入一个替换规则。即在计算得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span></span></span></span>后，再进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>→</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u\to g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>的变量替换。直接表达出来就比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;d[f[u],u]/.&#123;u-&gt;g&#125;;</span><br></pre></td></tr></table></figure><p>不过这种写法当遇到函数<code>f</code>本身蕴含名为<code>u</code>的参量时就可能会出现错误的结果。因而需要使用<code>Module</code>来引入哑元形式，即</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,d[f[u],u]/.&#123;u-&gt;g&#125;];</span><br></pre></td></tr></table></figure><p>但这是错误的。因为我们希望在计算出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>后再做变量替换。但上面的实现中，<code>d[f[u],u]</code>本身并不会求值，而是通过应用这些规则进行替换而得到的计算结果，从而导致替换发生在计算导数之前，那样就没有意义了。因此需要一个<code>d</code>的立即求值版，命名为<code>dEval</code>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,dEval[f[u],u]/.&#123;u-&gt;g&#125;];</span><br></pre></td></tr></table></figure><p>关于<code>dEval</code>的实现，一个粗浅的想法是在完成全部规则的定义后，对输入按这些规则进行<code>ReplaceRepeated</code>。当然，这其中还需要一些细节，我们这里暂且按下不表，留待后面再讨论。</p><p>接下来就是对具体函数的求导规则进行列举，比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>[d[<span class="keyword">IgnoringInactive</span>[<span class="keyword">Exp</span>[x_]],x_]]:&gt;<span class="keyword">Exp</span>[x],</span><br><span class="line">  <span class="keyword">HoldPattern</span>[d[<span class="keyword">IgnoringInactive</span>[<span class="keyword">Log</span>[x_]],x_]]:&gt;<span class="number">1</span>/x,</span><br><span class="line">  <span class="keyword">HoldPattern</span>[d[<span class="keyword">IgnoringInactive</span>[<span class="keyword">Sin</span>[x_]],x_]]:&gt;<span class="keyword">Cos</span>[x],</span><br><span class="line">  <span class="keyword">HoldPattern</span>[d[<span class="keyword">IgnoringInactive</span>[<span class="keyword">Cos</span>[x_]],x_]]:&gt;-<span class="keyword">Sin</span>[x]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一个个手动枚举也比较繁琐，因此我们不妨利用 Mathematica 既有的求导功能来生成结果</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">functionRules=<span class="keyword">Table</span>[</span><br><span class="line">  <span class="keyword">With</span>[&#123;f=f&#125;,<span class="keyword">HoldPattern</span>@d[<span class="keyword">IgnoringInactive</span>@f[x_],x_]]-&gt;D[f[x],x],</span><br><span class="line">  &#123;f,&#123;</span><br><span class="line">    <span class="keyword">Sqrt</span>,<span class="keyword">CubeRoot</span>,<span class="keyword">RealAbs</span>,</span><br><span class="line">    <span class="keyword">Exp</span>,<span class="keyword">Log</span>,<span class="keyword">Log2</span>,<span class="keyword">Log10</span>,</span><br><span class="line">    <span class="keyword">Sin</span>,<span class="keyword">Cos</span>,<span class="keyword">Tan</span>,<span class="keyword">Cot</span>,<span class="keyword">Sec</span>,<span class="keyword">Csc</span>,</span><br><span class="line">    <span class="keyword">ArcSin</span>,<span class="keyword">ArcCos</span>,<span class="keyword">ArcTan</span>,<span class="keyword">ArcCot</span>,<span class="keyword">ArcSec</span>,<span class="keyword">ArcCsc</span>,</span><br><span class="line">    <span class="keyword">Sinh</span>,<span class="keyword">Cosh</span>,<span class="keyword">Tanh</span>,<span class="keyword">Coth</span>,<span class="keyword">Sech</span>,<span class="keyword">Csch</span>,</span><br><span class="line">    <span class="keyword">ArcSinh</span>,<span class="keyword">ArcCosh</span>,<span class="keyword">ArcTanh</span>,<span class="keyword">ArcCoth</span>,<span class="keyword">ArcSech</span>,<span class="keyword">ArcCsch</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]/.&#123;<span class="keyword">Rule</span>-&gt;<span class="keyword">RuleDelayed</span>&#125;;</span><br></pre></td></tr></table></figure><p>除了这些可以直接表示的一元函数，还有一些形式上是二元函数的一元函数情况，这里简单列举一下</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">functionExtRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[x_^a_.,x_]/;<span class="keyword">FreeQ</span>[a,x]:&gt;a x^(a<span class="number">-1</span>),</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[a_^x_,x_]/;<span class="keyword">FreeQ</span>[a,x]:&gt;a^x <span class="keyword">Log</span>[a],</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">IgnoringInactive</span>@<span class="keyword">Surd</span>[x_,n_],x_]/;<span class="keyword">FreeQ</span>[n,x]:&gt;<span class="number">1</span>/(n <span class="keyword">Surd</span>[x,n]^(n<span class="number">-1</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>稍微值得一提的是，由于<code>Power</code>的<code>OneIdentity</code>属性，模式<code>x_^a_.</code>也会直接匹配<code>x</code>这种情况。</p><p>除此之外，还有一些二元函数可以通过变形得到上述一元函数的组合</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transferRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">IgnoringInactive</span>[f_^g_],x_]/;!(<span class="keyword">FreeQ</span>[f,x]||<span class="keyword">FreeQ</span>[g,x]):&gt;d[<span class="keyword">Inactive</span>[<span class="keyword">Exp</span>][<span class="keyword">Log</span>[f]g],x],</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">IgnoringInactive</span>@<span class="keyword">Log</span>[f_,g_],x_]:&gt;d[<span class="keyword">Log</span>[g]/<span class="keyword">Log</span>[f],x]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>Inactive[Exp]</code>是为了抑制指数函数的内置化简规则。也正是为了方面使用<code>Inactive</code>控制变形的方向，前面的函数求导规则的模式中都包含了<code>IgnoringInactive</code>。</p><p>这样，一个囊括了初等函数的符号求导规则就全部完成了。<br>最后将所有规则整合到一起</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allRules=<span class="keyword">Flatten</span>@&#123;</span><br><span class="line">  transferRules,</span><br><span class="line">  baseRules,</span><br><span class="line">  functionRules,</span><br><span class="line">  functionExtRules,</span><br><span class="line">  substRules,</span><br><span class="line">  higherRules</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果只需要进行求导计算，那么直接对输入按这些规则进行替换即可</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dEval[f_,x_]:=d[f,x]//.allRules</span><br></pre></td></tr></table></figure><p>举一个简单的例子测试一下</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(dEval==D)[(x^<span class="keyword">Sin</span>[x]+<span class="number">3</span>x+<span class="keyword">ArcTan</span>[x])^<span class="number">2</span>/(x^<span class="number">4</span><span class="number">-3</span><span class="keyword">Surd</span>[x^<span class="number">5</span>,<span class="number">3</span>]<span class="keyword">RealAbs</span>@<span class="keyword">Log</span>[x]+<span class="number">2</span>),x]//<span class="keyword">Through</span>//<span class="keyword">Simplify</span></span><br><span class="line"><span class="comment">(*Out: True*)</span></span><br></pre></td></tr></table></figure><p>也就是说利用这些规则已经可以实现对初等函数的求导运算了。然而，假如输入的待求导函数不只包含初等函数，那么<code>dEval</code>就无法完全计算，得到的结果中会包含错误的形式。诚然，我们的目标只在解决初等函数的求导，对于初等函数以外的情况无法解决也是正常的，不过从健壮性的角度考虑，这里最好再增加一个条件以避免某些可能出现的潜在问题。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,</span><br><span class="line">  <span class="keyword">With</span>[&#123;df=dEval[f[u],u]&#125;,</span><br><span class="line">    (df/.&#123;u-&gt;g&#125;)/;<span class="keyword">FreeQ</span>[df,_d|_dfunc]</span><br><span class="line">  ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>这里利用作用域里的条件模式来保证遇到<code>dEval</code>无法解决的情况时会保持既有的<code>dfunc</code>形式不变。可以试试下面的代码测试一下效果</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dEval[<span class="keyword">Erf</span>[<span class="keyword">Sin</span>[x]]^<span class="number">2</span>,x]</span><br></pre></td></tr></table></figure><h3 id="步骤回显"><a class="markdownIt-Anchor" href="#步骤回显"></a> 步骤回显</h3><p>然后是对计算步骤的输出显示。我们希望将替换的每一步都显示出来，因此不能直接使用<code>//.</code>，而应该使用<code>NestWhile</code>之类的方式对每次替换获得更精确的控制。在输出显示上，用<code>CellPrint</code>比较方便，也比单纯的<code>Print</code>好控制格式。</p><p>首先，对于输出步骤的每个单元，我们希望前面有一个<code>=</code>标记，就像<code>Echo</code>产生的单元前的<code>&gt;&gt;</code>标志符一样。这一点可以利用<code>CellDingbat</code>实现：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echoStep[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[removeLabels@expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellDingbat</span>-&gt;<span class="keyword">Cell</span>[<span class="string">"="</span>,<span class="string">"EchoLabel"</span>]];</span><br><span class="line">  expr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后，与之类似地，还需要一个函数输出显示最初地状态作为等式的起点。需要注意的是，为了比较好地对齐，需要对两者使用不同的边距：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echoStep0[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>, <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br><span class="line">echoStep[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellDingbat</span>-&gt;<span class="keyword">Cell</span>[<span class="string">"="</span>,<span class="string">"EchoLabel"</span>],</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>, <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>进一步地，考虑到复合函数求导时需要转入对其它函数求导的过程，这将打断正在进行的求导步骤间的顺叙关系，从逻辑上进入更深的层级。为了表现这种层级关系，这里同样通过调整边距实现。引入一个层级标志量<code>$dDepth</code>：每当计算<code>dEval</code>时都增加这一标志量，结束时就将其还原；同时利用<code>$dDepth</code>控制边距以实现对边距的适应调整。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$dDepth=<span class="number">0</span>;</span><br><span class="line">echoStep0[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>($dDepth<span class="number">-1</span>), <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br><span class="line">echoStep[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellDingbat</span>-&gt;<span class="keyword">Cell</span>[<span class="string">"="</span>,<span class="string">"EchoLabel"</span>],</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>$dDepth, <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dEval[f_,x_]:=<span class="keyword">Block</span>[&#123;$dDepth=$dDepth+<span class="number">1</span>&#125;,dEvalR[f,x]]</span><br><span class="line">dEvalR[f_,x_]:=<span class="keyword">NestWhile</span>[echoStep@*<span class="keyword">ReplaceAll</span>[allRules],echoStep0[d[f,x]],!<span class="keyword">FreeQ</span>[#<span class="number">2</span>,_d|_dfunc]&amp;&amp;<span class="keyword">UnsameQ</span>[##]&amp;,<span class="number">2</span>]</span><br><span class="line">stepD[f_,x_]:=<span class="keyword">With</span>[&#123;eval=dEval[f,x]&#125;,eval/;<span class="keyword">FreeQ</span>[eval,_d|_dfunc]]</span><br></pre></td></tr></table></figure><p>这里将具体的求导运算过程委托到<code>dEvalR</code>函数上，利用以是否存在未完成的求导形式为基本判据，同时辅以不变性作为无法完成时的终止条件。再把<code>stepD</code>作为封装的外部接口，通过条件模式限制，在失败时保持输入形式，避免内部<code>dfunc</code>等内部符号暴露到输出中。</p><p>测试一下</p><img src="/blog/2019/07/RuleBasedStepByStepDerivative/echo-step.svg" title="DiffereEcho Step"><h3 id="润色外观"><a class="markdownIt-Anchor" href="#润色外观"></a> 润色外观</h3><p>可以看到步骤显示中的输出形式很难看。为了增加步骤的可读性，我们可以通过自定义显示格式来润色外观。考虑我们本身使用的代码结构，将公式输出为Leibniz符号的形式比较方便。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">d/:<span class="keyword">MakeBoxes</span>[d[f_,x_],<span class="keyword">TraditionalForm</span>]:=<span class="keyword">Module</span>[&#123;boxes&#125;,</span><br><span class="line">  boxes=<span class="keyword">MakeBoxes</span>[f, <span class="keyword">TraditionalForm</span>];</span><br><span class="line">  <span class="keyword">If</span>[<span class="keyword">Precedence</span>[<span class="keyword">Plus</span>]&gt;=<span class="keyword">Precedence</span>[boxes,<span class="keyword">TraditionalForm</span>],boxes=<span class="keyword">RowBox</span>[&#123;<span class="string">"("</span>, boxes, <span class="string">")"</span>&#125;]];</span><br><span class="line">  <span class="keyword">RowBox</span>[&#123;<span class="keyword">FractionBox</span>[<span class="string">"\[DifferentialD]"</span>, <span class="keyword">RowBox</span>[&#123;<span class="string">"\[DifferentialD]"</span>, <span class="keyword">MakeBoxes</span>[x, <span class="keyword">TraditionalForm</span>]&#125;]], boxes&#125;]</span><br><span class="line">]</span><br><span class="line">dfunc/:<span class="keyword">MakeBoxes</span>[dfunc[f_, g_], <span class="keyword">TraditionalForm</span>]:=<span class="keyword">Module</span>[&#123;fboxes, gboxes&#125;,</span><br><span class="line">  fboxes=<span class="keyword">ToBoxes</span>[f[g], <span class="keyword">TraditionalForm</span>]; gboxes=<span class="keyword">ToBoxes</span>[g, <span class="keyword">TraditionalForm</span>];</span><br><span class="line">  <span class="keyword">If</span>[<span class="keyword">Precedence</span>[<span class="keyword">Plus</span>]&gt;=<span class="keyword">Precedence</span>[fboxes, <span class="keyword">TraditionalForm</span>],fboxes=<span class="keyword">RowBox</span>[&#123;<span class="string">"("</span>, fboxes, <span class="string">")"</span>&#125;]];</span><br><span class="line">  <span class="keyword">If</span>[<span class="keyword">Precedence</span>[<span class="keyword">Plus</span>]&gt;=<span class="keyword">Precedence</span>[gboxes, <span class="keyword">TraditionalForm</span>],gboxes=<span class="keyword">RowBox</span>[&#123;<span class="string">"("</span>, gboxes, <span class="string">")"</span>&#125;]];</span><br><span class="line">  <span class="keyword">FractionBox</span>[<span class="keyword">RowBox</span>[&#123;<span class="string">"\[DifferentialD]"</span>, fboxes&#125;], <span class="keyword">RowBox</span>[&#123;<span class="string">"\[DifferentialD]"</span>, gboxes&#125;]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后对于被<code>Module</code>局域化符号的显示，像<code>u$nnn</code>这样的形式显然不太好看，在这里也可以给出一个美化模板，它将这类符号的输出形式显示为首字母</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeXForm[sym_Symbol]:=sym/:<span class="keyword">MakeBoxes</span>[sym,<span class="keyword">TraditionalForm</span>]=<span class="keyword">ToBoxes</span>[<span class="keyword">Symbol</span>[<span class="keyword">StringPart</span>[<span class="keyword">SymbolName</span>[sym],<span class="number">1</span>]],<span class="keyword">TraditionalForm</span>]</span><br></pre></td></tr></table></figure><p>再用在替换规则中</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,</span><br><span class="line">  makeXForm[u];</span><br><span class="line">  <span class="keyword">With</span>[&#123;df=dEval[f[u],u]&#125;,</span><br><span class="line">    (df/.&#123;u-&gt;g&#125;)/;<span class="keyword">FreeQ</span>[df,_d|_dfunc]</span><br><span class="line">  ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>得到的结果就更接近于数学中的写法了</p><img src="/blog/2019/07/RuleBasedStepByStepDerivative/format.svg" title="DiffereEcho Format"><h3 id="标注步骤"><a class="markdownIt-Anchor" href="#标注步骤"></a> 标注步骤</h3><p>最后，我们还希望给每一步中所使用的特殊规则标注名称，方便理解各个步骤到底做了什么。比如 “乘法法则” “链式法则” 这样的注解。我们首先将这些注解都标记在求导的规则中</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">baseRules=&#123;</span><br><span class="line">  d[c_,x_]/;<span class="keyword">FreeQ</span>[c,x]:&gt;dLabeled[<span class="number">0</span>,<span class="string">"Constant Rule"</span>],</span><br><span class="line">  d[lf_Plus,x_]:&gt;dLabeled[<span class="keyword">Thread</span>[d[lf,x],<span class="keyword">Plus</span>],<span class="string">"Linearity Rule"</span>],</span><br><span class="line">  d[c_*f_,x_]/;<span class="keyword">FreeQ</span>[c,x]:&gt;dLabeled[c*d[f,x],<span class="string">"Linearity Rule"</span>],</span><br><span class="line">  d[f_*g_,x_]:&gt;dLabeled[d[f,x]g+d[g,x]f,<span class="string">"Product Rule"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">higherRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">InverseFunction</span>[f_][x_],x_]:&gt;dLabeled[<span class="number">1</span>/dfunc[f,<span class="keyword">InverseFunction</span>[f][x]],<span class="string">"Inverse Function Rule"</span>],</span><br><span class="line">  d[f_[g_],x_]/;g=!=x:&gt;dLabeled[dfunc[f,g]d[g,x],<span class="string">"Chain Rule"</span>],</span><br><span class="line">  d[f_[g_,c_],x_]/;<span class="keyword">FreeQ</span>[c,x]&amp;&amp;g=!=x:&gt;dLabeled[dfunc[f[#,c]&amp;,g]d[g,x],<span class="string">"Chain Rule"</span>],</span><br><span class="line">  d[f_[c_,g_],x_]/;<span class="keyword">FreeQ</span>[c,x]&amp;&amp;g=!=x:&gt;dLabeled[dfunc[f[c,#]&amp;,g]d[g,x],<span class="string">"Chain Rule"</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有链式法则使用时，替换后的变元原本指代的是什么也应该标记出来，以方便阅读和理解。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,</span><br><span class="line">  makeXForm[u];</span><br><span class="line">  <span class="keyword">With</span>[</span><br><span class="line">    &#123;df=dEval[dLabeled[f[u],<span class="keyword">Row</span>@&#123;<span class="string">"where "</span>,<span class="keyword">TraditionalForm</span>[u==g]&#125;],u]&#125;,</span><br><span class="line">    (df/.&#123;u-&gt;g&#125;)/;<span class="keyword">FreeQ</span>[df,_d|_dfunc]</span><br><span class="line">  ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>有了规则中的标记，我们就需要能够从表达式里将标记都提取出来的方法。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getLabels[expr_]:=<span class="keyword">With</span>[</span><br><span class="line">  &#123;lbs=<span class="keyword">DeleteDuplicates</span>@<span class="keyword">Cases</span>[expr,dLabeled[_,lb_]:&gt;lb,&#123;<span class="number">0</span>,<span class="keyword">Infinity</span>&#125;]&#125;,</span><br><span class="line">  <span class="keyword">Row</span>@<span class="keyword">Flatten</span>@&#123;<span class="string">"("</span>,<span class="keyword">Riffle</span>[lbs,<span class="string">"; "</span>],<span class="string">")"</span>&#125;/;lbs=!=&#123;&#125;</span><br><span class="line">]</span><br><span class="line">getLabels[_]=<span class="string">""</span>;</span><br></pre></td></tr></table></figure><p>注意一步计算可以会运用多个规则，输出应该为分割得到的一组。同时，对于重复项最好也应该删除。</p><p>而这些<code>dLabeled</code>标记形式本身不应出现在求导的过程中，所以应该在每步计算完成后移除</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeLabels[expr_]:=expr/.&#123;dLabeled[e_,_]:&gt;e&#125;</span><br></pre></td></tr></table></figure><p>然后在输出时，注解通过<code>CellFrameLabels</code>显示在每个单元的右侧。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">echoStep0[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[removeLabels@expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>($dDepth<span class="number">-1</span>), <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;,</span><br><span class="line">    <span class="keyword">CellFrameLabels</span>-&gt;&#123;&#123;<span class="keyword">None</span>,<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>@<span class="keyword">ToBoxes</span>@getLabels[expr],<span class="string">"MessageText"</span>]&#125;,&#123;<span class="keyword">None</span>,<span class="keyword">None</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br><span class="line">echoStep[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[removeLabels@expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellDingbat</span>-&gt;<span class="keyword">Cell</span>[<span class="string">"="</span>,<span class="string">"EchoLabel"</span>],</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>$dDepth, <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;,</span><br><span class="line">    <span class="keyword">CellFrameLabels</span>-&gt;&#123;&#123;<span class="keyword">None</span>,<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>@<span class="keyword">ToBoxes</span>@getLabels[expr],<span class="string">"MessageText"</span>]&#125;,&#123;<span class="keyword">None</span>,<span class="keyword">None</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最后将这些过程添加到计算的每一步中</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dEvalR[f_,x_]:=<span class="keyword">NestWhile</span>[</span><br><span class="line">  removeLabels@*echoStep@*<span class="keyword">ReplaceAll</span>[allRules],</span><br><span class="line">  removeLabels@echoStep0[d[f,x]],</span><br><span class="line">  !<span class="keyword">FreeQ</span>[#<span class="number">2</span>,_d|_dfunc]&amp;&amp;<span class="keyword">UnsameQ</span>[##]&amp;,<span class="number">2</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>就大功告成了。</p><p>简单测试一下</p><img src="/blog/2019/07/RuleBasedStepByStepDerivative/label.svg" title="DiffereEcho Label"><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>最终整理得到的完整代码放在 <a href="https://github.com/miRoox/DStep/blob/master/DStep.wl" target="_blank" rel="noopener">Github</a> 上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，&lt;a href=&quot;https://www.wolframalpha.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wolfram|Alpha&lt;/a&gt; 有一个名为 &lt;a href=&quot;https://www.wolframalpha.com/examples/pro-features/step-by-step-solutions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Step-by-Step Solutions&lt;/a&gt; 的功能，可以显示一些数学问题求解的过程。又比如，著名的 &lt;a href=&quot;https://rulebasedintegration.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rubi&lt;/a&gt; 可以在求解积分的同时显示积分的求解步骤。实际上，这些系统背后大抵都是基于模式匹配和规则变换而实现的，因而原则上来说自己也可以实现一个。当然，就实践而言这些系统都过于复杂了，例如 Rubi 包含了超过六千条规则，其背后的原理远非三言两语可以阐明的。不过，相比于积分，微分的运算规则要简明得多，而且对规则的应用总是简单机械的，并不像积分那样可能会运用到各种技巧。因此，本文将利用 Mathematica 的模式匹配和规则实现一个带步骤符号求导器。&lt;/p&gt;&lt;img src=&quot;/blog/2019/07/RuleBasedStepByStepDerivative/DvsInt.JPG&quot; title=&quot;Differentiation vs Integration&quot;&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="符号计算" scheme="http://miRoox.github.io/blog/tags/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>关于LaTeX插入矢量图的格式问题</title>
    <link href="http://miroox.github.io/blog/2019/07/FormatOfVectorInLaTeX/"/>
    <id>http://miroox.github.io/blog/2019/07/FormatOfVectorInLaTeX/</id>
    <published>2019-07-09T06:51:22.000Z</published>
    <updated>2020-07-31T13:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，外部插入矢量图图尽量使用 PDF 格式，以避免生成时的转换。</p><blockquote><p><strong>只要输出介质为pdf，那么使用PSTricks和eps插图都是陋习。</strong></p><p><strong>如果输出介质为pdf，那么所有eps都需要转换为pdf后插入。</strong></p><p>之所以需要转换，是因为pdfTeX/LuaTeX不带任何PostScript解释器，所以一定要转换成pdf才能插图。而pTeX/XeTeX，则通常需要使用dvipdfmx输出pdf，在用到PostScript代码的时候，即PSTricks和eps图，都会通过管道使用GhostScript转换，这也是拖慢dvipdfmx的一个主要原因。</p><p>当然，很多编辑部的期刊模板都要求是eps图，甚至是png都要求转成eps（里面其实还是点阵图）。这时候，eps文件留给他们解决，自己该用什么用什么。</p><p>这都2018年了，别想不开老是用eps图。</p></blockquote><p>来自 <a href="https://www.zhihu.com/question/284593369/answer/438941492" target="_blank" rel="noopener">为什么 用TeXstudio在 XeLaTeX下eps图片不显示, pdflatex下反而可以 ? - 李阿玲的回答 - 知乎</a></p>]]></content>
    
    <summary type="html">
    
      只要输出介质为pdf，就不要使用 eps 和 PSTricks 插图
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="LaTeX" scheme="http://miRoox.github.io/blog/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>如何在Wolfram语言里造一个Wolfram语言风格的对象</title>
    <link href="http://miroox.github.io/blog/2019/05/WLStyleObject/"/>
    <id>http://miroox.github.io/blog/2019/05/WLStyleObject/</id>
    <published>2019-05-06T14:27:17.000Z</published>
    <updated>2021-10-25T15:18:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做 <a href="https://github.com/miRoox/ComputationalOptics" target="_blank" rel="noopener">ComputationalOptics包</a> 的时候为了把 <a href="https://github.com/miRoox/ComputationalOptics/blob/1197dbf20758271c93acdbc4f780913443847b95/ComputationalOptics/Kernel/LightField.m" target="_blank" rel="noopener"><code>LightField</code></a> 实现为一个比较典型的Wolfram语言风格的对象，使用了很多undocumented方法，这里主要是做一下记录。</p><p>需要注意的是，这里的“对象”不是指“面向对象”里所说的对象（虽然也有点关系），而是类似于 <a href="http://reference.wolfram.com/language/ref/Entity.html" target="_blank" rel="noopener"><code>Entity</code></a> 或者 <a href="http://reference.wolfram.com/language/ref/TemporalData.html" target="_blank" rel="noopener"><code>TemporalData</code></a> 这类的对象。</p><a id="more"></a><p>这里就以前面提到的<code>LightField</code>为例说明一下如何造一个WL风格的对象。首先，分析需求，来看看预期要实现的效果：</p><img src="/blog/2019/05/WLStyleObject/result.png" title="result"><p>首先能看到的是<code>LightField</code>对象在输出时显示为一个类似于<a href="http://reference.wolfram.com/language/ref/SparseArray.html" target="_blank" rel="noopener"><code>SparseArray</code></a>那样的一个摘要框；然后，对象的属性可以通过函数参数的形式读写访问，而且对写入数据参数还会进行检查，这一点应该是WL风格的对象最核心的特征；最后，对象是能被认为是一个原子对象，这点实质是一种封装，可以避免直接用表达式的部分操作来访问对象内容，同样类似<code>SparseArray</code>。</p><p>进行具体实现前，最基本的，<code>LightField</code>对象数据的组织结构需要确定下来。这里采用的是<code>LightField[type_String, props_Association]</code>的模式，主要是考虑到这种表达式结构在表达光场信息的时候能具有较好的泛化能力。上面的<code>type</code>用来标记光场描述的类型（比如单色平面复振幅），而<code>props</code>则是描述光场所需的具体属性，以关联容器的方式组织数据内容。当然，这些含义对本文而言并不是重点，但也是对象设计和实现中最基本最重要的一步。</p><p>然后是对属性的读写的实现。单纯的读操作实现起来并不困难，不过需要注意的一点是我们接下来还要将对象转化为原子的，因此不能直接将问题变为利用<code>[[]]</code>提取部分。</p><p>我们知道，复数<code>Complex</code>也是原子的，它虽然不能直接对部分进行提取，但可以利用模式匹配来获得实部和虚部。基于同样的原理，读属性的核心实现长这样</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getProperty[<span class="keyword">HoldPattern</span>@LightField[_,props_],prop_]:=<span class="keyword">Lookup</span>[</span><br><span class="line">  props,prop,</span><br><span class="line">  <span class="keyword">Message</span>[LightField::ptprop,prop];<span class="keyword">Missing</span>[<span class="string">"NotAvailable"</span>,prop]</span><br><span class="line">]</span><br><span class="line">(obj_LightField?LightFieldQ)[prop_]:=getProperty[obj,prop]</span><br></pre></td></tr></table></figure><p>这其中，<code>LightFieldQ</code>是一个基于模式匹配判断输入是否为格式正确的<code>LightField</code>对象的函数。毕竟，如果基本格式都不正确的话，后面的模式匹配获取部分也无从谈起。</p><p>而写方法在wolfram语言寻常的语法上就非常困难了，因为WL概念上并不存在引用或者指针这一类东西，符号本身几乎总是充当引用的作用，但在形如<code>a[&quot;Wavelength&quot;] = xxx</code>的表达式里，左侧表达式并不是一个符号，而这种形式常常会将定义关联到符号<code>a</code>的下值中，也就是我们常见的函数定义方式。那么怎么让计算上述形式表达式的时候把它当做一个类似于部分赋值的方式进行处理呢？</p><p>一个非常自然地想法可能是对<code>LightField</code>赋予上值，不过很遗憾的是这种方案必然是不可行的，因为可变性意味着参数必须以保持的形式传递符号，那么在模式匹配的阶段必然没有机会接触到需要匹配的<code>LightField</code>，这样上值的关联就无法成立。</p><p>另一种想法则是<code>Unprotect[Set]</code>后添加赋值规则，比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>[(sym_Symbol?LightFieldQ)[prop_],val_]:=...</span><br></pre></td></tr></table></figure><p>这的确不失为一种解决办法，但这一方法实在有些太笨重了。这会导致所有满足模式<code>sym_Symbol[prop_]=val_</code>的代码都还要用<code>LightFieldQ</code>检查一遍，无论<code>sym</code>中是否隐含着<code>LightField</code>。</p><p>尝试下面的代码，感受一下鬼畜的效果</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gQ[_g]:=(<span class="keyword">Print</span>[<span class="string">"Ok"</span>];<span class="keyword">True</span>)</span><br><span class="line">gQ[_]:=(<span class="keyword">Print</span>[<span class="string">"Oops"</span>];<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">Unprotect</span>[<span class="keyword">Set</span>];</span><br><span class="line"><span class="keyword">Set</span>[(sym_Symbol?gQ)[prop_],val_]:=(<span class="keyword">Print</span>[<span class="keyword">Unevaluated</span>[sym[prop]],<span class="string">"="</span>,val])</span><br><span class="line"><span class="keyword">Protect</span>[<span class="keyword">Set</span>];</span><br><span class="line"><span class="keyword">Do</span>[a[<span class="number">1</span>]=<span class="number">1</span>,&#123;a,&#123;<span class="number">1</span>,&lt;||&gt;,g[]&#125;&#125;]</span><br></pre></td></tr></table></figure><p>（记得清除<code>Set</code>的附加定义）</p><p>因而我们需要一个更好的解决办法，这就是<code>Language`SetMutationHandler</code>，它的基本用法可以参见下面的相关资料，基本上照葫芦画瓢就行。作为对照，这里给一个与前述<code>Unprotect</code>方法完全类似测试代码</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fQ[_f]:=(<span class="keyword">Print</span>[<span class="string">"Ok"</span>];<span class="keyword">True</span>)</span><br><span class="line">fQ[_]:=(<span class="keyword">Print</span>[<span class="string">"Oops"</span>];<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">SetAttributes</span>[mutationHandler,<span class="keyword">HoldAllComplete</span>]</span><br><span class="line">mutationHandler[<span class="keyword">Set</span>[(sym_Symbol?fQ)[prop_],val_]]:=(<span class="keyword">Print</span>[<span class="keyword">Unevaluated</span>[sym[prop]],<span class="string">"="</span>,val])</span><br><span class="line"><span class="keyword">Language</span>`SetMutationHandler[f,mutationHandler]</span><br><span class="line"><span class="keyword">Do</span>[a[<span class="number">1</span>]=<span class="number">1</span>,&#123;a,&#123;<span class="number">1</span>,&lt;||&gt;,f[]&#125;&#125;]</span><br></pre></td></tr></table></figure><p>从输出中可以看到，只有当<code>a</code>的值变为<code>f[]</code>时，上面的匹配测试才会触发。完美符合要求。</p><p>在具体实现上，还有一些细节，比如对非属性参数检查和报错，对属性值的检查其实是由<code>LightFieldQ</code>对改变后的临时结果整体进行的检查，还有对失败结果需要<code>Language`MutationFallthrough</code>传递到正常的处理流程中，以及<code>Protect[LightField]</code>来避免fallthrough后干扰到<code>LightField</code>自身的定义等等，下面摘取了其中主要的部分</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SetAttributes</span>[setProperty,<span class="keyword">HoldFirst</span>]</span><br><span class="line">setProperty[sym_Symbol,prop_,val_]:=<span class="keyword">Block</span>[</span><br><span class="line">  &#123;tmp=sym,tmpprops&#125;,</span><br><span class="line">  tmpprops=getProperty[tmp,<span class="keyword">All</span>];</span><br><span class="line">  <span class="keyword">If</span>[<span class="keyword">KeyExistsQ</span>[tmpprops,prop],</span><br><span class="line">    tmpprops[prop]=val;</span><br><span class="line">    tmp=<span class="keyword">Replace</span>[tmp,<span class="keyword">HoldPattern</span>@LightField[type_,props_]:&gt;LightField[type,tmpprops]];</span><br><span class="line">    <span class="keyword">If</span>[LightFieldQ[tmp],</span><br><span class="line">      sym=tmp;val,</span><br><span class="line">      <span class="keyword">Message</span>[LightField::setptvp,val,prop];</span><br><span class="line">      <span class="keyword">$Failed</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="keyword">Message</span>[LightField::setptp,prop];</span><br><span class="line">    <span class="keyword">$Failed</span></span><br><span class="line">  ]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">SetAttributes</span>[mutationHandler,<span class="keyword">HoldAllComplete</span>]</span><br><span class="line">mutationHandler[<span class="keyword">Set</span>[(sym_Symbol?LightFieldQ)[prop_],val_]]:=<span class="keyword">With</span>[</span><br><span class="line">  &#123;result=setProperty[sym,prop,val]&#125;,</span><br><span class="line">  result/;!<span class="keyword">FailureQ</span>[result]</span><br><span class="line">]</span><br><span class="line">mutationHandler[_]:=<span class="keyword">Language</span>`MutationFallthrough</span><br><span class="line"><span class="keyword">Language</span>`SetMutationHandler[LightField,mutationHandler]</span><br></pre></td></tr></table></figure><p>对象的原子化则是利用<code>System`Private`SetNoEntry</code>系列的函数，同样，下面的相关资料里有很详细的介绍。这个系列的函数在不少内部对象的实现里也可以见到，比如<code>Dataset</code>，我们不妨照着做一个。利用神器<code>GeneralUtilities`PrintDefinitions</code>获得其定义，抛开那些无关的，很容易找到下面的内容</p><img src="/blog/2019/05/WLStyleObject/Dataset.png" title="Dataset"><p>中间有一些<code>Dataset</code>内部使用的注册机制，抛开那些不看，无非就是<code>System`Private`SetNoEntry</code>原子化后，利用<code>System`Private`NoEntryQ</code>检查防止无限自递归，注意两处的<code>Unevaluated</code>也是防止无限自递归的一环。在相关资料里我们看到10.4以后又引入了几个更便利的函数，于是依葫芦画瓢就可以写成</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(obj_LightField?holdLightFieldQ)/;System`Private`HoldEntryQ[obj]:=<span class="keyword">With</span>[</span><br><span class="line">  &#123;valid=System`Private`HoldSetNoEntry[obj]&#125;,</span><br><span class="line">  valid</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中<code>holdLightFieldQ</code>就是个保持版的<code>LightFieldQ</code>，作用当然也就不言而喻了。</p><p>最后是摘要框，这部分其实完全没有必要，不过说到Mathematica，优雅和颜值也是非常重要的一环，而且同样也用到了一套undocumented函数。这部分可以参考下面的相关资料，也可以用神器<code>GeneralUtilities`PrintDefinitions</code>来hack既有摘要框的对象，比如<code>SparseArray</code></p><img src="/blog/2019/05/WLStyleObject/SparseArray.png" title="SparseArray"><p>其核心无非就是<code>BoxForm`ArrangeSummaryBox</code>，中间量的命名也非常直白，即使不看参考资料也不难猜出使用方法。</p><p>这三部分都完成了以后，也算是有了一点Wolfram语言风格对象的神韵了。尽管为了这样优雅的使用对象，付出不少丑陋肮脏的实现代码，不过上面看到的一些官方的实现同样也丑陋无比，这倒也算是Wolfram语言的传统艺能了（</p><hr><p>相关资料：</p><ul><li><a href="https://mathematica.stackexchange.com/a/165910/63369" target="_blank" rel="noopener"><code>Language`*</code> documentation project - <code>Language`*Mutation*</code></a></li><li><a href="https://mathematica.stackexchange.com/a/139974/63369" target="_blank" rel="noopener">What are some useful, undocumented Mathematica functions? - <code>System`Private`*Entry*</code> functions</a></li><li><a href="https://mathematica.stackexchange.com/q/77658/63369" target="_blank" rel="noopener">How to create expanding summary boxes like the ones displayed for <code>InterpolatingFunction</code>, <code>NearestFunction</code>, etc.?</a></li><li><a href="https://mresources.github.io/tutorial/mathematica-programming/assorted-tricks/object-oriented-programming.html" target="_blank" rel="noopener">Object Oriented Programming</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做 &lt;a href=&quot;https://github.com/miRoox/ComputationalOptics&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ComputationalOptics包&lt;/a&gt; 的时候为了把 &lt;a href=&quot;https://github.com/miRoox/ComputationalOptics/blob/1197dbf20758271c93acdbc4f780913443847b95/ComputationalOptics/Kernel/LightField.m&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;LightField&lt;/code&gt;&lt;/a&gt; 实现为一个比较典型的Wolfram语言风格的对象，使用了很多undocumented方法，这里主要是做一下记录。&lt;/p&gt;&lt;p&gt;需要注意的是，这里的“对象”不是指“面向对象”里所说的对象（虽然也有点关系），而是类似于 &lt;a href=&quot;http://reference.wolfram.com/language/ref/Entity.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Entity&lt;/code&gt;&lt;/a&gt; 或者 &lt;a href=&quot;http://reference.wolfram.com/language/ref/TemporalData.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;TemporalData&lt;/code&gt;&lt;/a&gt; 这类的对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="功能模拟" scheme="http://miRoox.github.io/blog/tags/%E5%8A%9F%E8%83%BD%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="元编程" scheme="http://miRoox.github.io/blog/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Undocumented" scheme="http://miRoox.github.io/blog/tags/Undocumented/"/>
    
  </entry>
  
  <entry>
    <title>记Mathematica求导的一些坑</title>
    <link href="http://miroox.github.io/blog/2019/05/TrapAboutDerivativeInMma/"/>
    <id>http://miroox.github.io/blog/2019/05/TrapAboutDerivativeInMma/</id>
    <published>2019-05-01T08:02:10.000Z</published>
    <updated>2020-07-31T13:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是记录一下在回答贴吧上<a href="http://tieba.baidu.com/p/6111508459" target="_blank" rel="noopener">这个问题</a>时所发现的关于Mathematica求导的一些坑。</p><p>原问题虽然没有明说，但我推测问题背景应该是波特图之类的问题，具体问题如下：</p><a id="more"></a><blockquote><p>对这个函数的幅角求导，代入一个数值为什么求出了个复数值啊，实函数求导应该是实数啊。声明了一下x是实数后好像也不行。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f[x_] := <span class="keyword">Arg</span>[(-(x - <span class="number">1</span>)^<span class="number">2</span> + <span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span> - <span class="number">3</span> x^<span class="number">2</span> - x^<span class="number">4</span>))/((x - <span class="number">1</span>)^<span class="number">2</span> + <span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span> - <span class="number">3</span> x^<span class="number">2</span> - x^<span class="number">4</span>) - <span class="number">4</span>*I*(x^<span class="number">3</span> - <span class="number">3</span> x^<span class="number">2</span> + <span class="number">2</span> x))]</span><br><span class="line">f'[<span class="number">5</span>]</span><br><span class="line"><span class="comment">(*Out: (513125/13791752+(342351 I)/3447938) Arg'[2499/2626-(765 I)/2626]*)</span></span><br><span class="line">N[(<span class="number">513125</span>/<span class="number">13791752</span>+(<span class="number">342351</span> I)/<span class="number">3447938</span>) <span class="keyword">Arg</span>'[<span class="number">2499</span>/<span class="number">2626</span>-(<span class="number">765</span> I)/<span class="number">2626</span>]]</span><br><span class="line"><span class="comment">(*Out: 0.0109427 + 0.0292034 I*)</span></span><br></pre></td></tr></table></figure><p>这是程序，我觉得可能是程序表达的问题，那么该怎么去写这个程序呢？新手上路，老哥请指点</p></blockquote><p>这段程序恰好碰到了Mathematica在求导问题上的两个坑：</p><ol><li>Mathematica总是假设链式求导法则是有效的，但这里遇到的<code>Arg</code>本身是一个<em>不可导</em>的函数，链导法则是不成立的。这一点是一个非常常见的坑。</li><li>然后Mathematica的数值导数设计的也欠合理，在遇到符号求导失效的情况时，Mathematica在计算函数导数时会利用其沿着<em>实轴</em>方向的变化率来近似求导（事实上<code>Arg</code>沿复平面不同方向的变化率通常不相等），而<code>Arg</code>本身总是实数，这样一来得到的<code>Arg'[...]</code>的结果就总是一个实数，然而前面根据链导法则乘出的那一坨又是个复数，自然得到的最终结果也是复数。</li></ol><p>针对这个问题，可以提出两种解决办法：</p><ol><li>一个很自然的想法是直接绕开<code>Arg</code>这个不可导的函数，即可以将通过<code>ComplexExpand</code>其转化为<code>ArcTan</code>形式，再去求导就不会有这些问题了：<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[x_]=<span class="keyword">ComplexExpand</span>[<span class="keyword">Arg</span>[(-(x<span class="number">-1</span>)^<span class="number">2</span>+<span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>-x^<span class="number">4</span>))/((x<span class="number">-1</span>)^<span class="number">2</span>+<span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>-x^<span class="number">4</span>)<span class="number">-4</span>*I*(x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>+<span class="number">2</span> x))],<span class="keyword">TargetFunctions</span>-&gt;&#123;<span class="keyword">Re</span>,<span class="keyword">Im</span>&#125;];</span><br><span class="line">f'[<span class="number">5</span>]</span><br><span class="line"><span class="comment">(*Out: 1117/10504*)</span></span><br></pre></td></tr></table></figure></li><li>还可以反过来利用上述数值导数的坑来解决：因为这里就是要求<code>f</code>沿实轴方向的导数，所以我们不妨利用数值导数始终沿实轴发生这一特性，先从<code>f</code>上就避免符号计算引入错误的链导法则，然后直接让Mathematica对<code>f</code>进行数值求导，于是可以这么写：<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Clear</span>[f]</span><br><span class="line">f[x_?<span class="keyword">NumericQ</span>]:=<span class="keyword">Arg</span>[(-(x<span class="number">-1</span>)^<span class="number">2</span>+<span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>-x^<span class="number">4</span>))/((x<span class="number">-1</span>)^<span class="number">2</span>+<span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>-x^<span class="number">4</span>)<span class="number">-4</span>*I*(x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>+<span class="number">2</span> x))]</span><br><span class="line">f'[<span class="number">5.</span>]</span><br><span class="line"><span class="comment">(*Out: 0.10634*)</span></span><br></pre></td></tr></table></figure>如果只需要近似的数值值得话，同样可以解决问题。</li></ol><hr><p>相关链接：</p><ul><li><a href="http://tieba.baidu.com/p/6111508459" target="_blank" rel="noopener">来个老哥抬一手~</a></li><li><a href="https://mathematica.stackexchange.com/questions/196998/why-does-arg1-i-return-0-5" target="_blank" rel="noopener">Why does Arg’[1. + I] return -0.5?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是记录一下在回答贴吧上&lt;a href=&quot;http://tieba.baidu.com/p/6111508459&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个问题&lt;/a&gt;时所发现的关于Mathematica求导的一些坑。&lt;/p&gt;&lt;p&gt;原问题虽然没有明说，但我推测问题背景应该是波特图之类的问题，具体问题如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
</feed>
