<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miRoox的博客</title>
  
  <subtitle>我唯一知道的就是我一无所知 ——苏格拉底</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://miroox.github.io/blog/"/>
  <updated>2020-10-31T14:56:13.000Z</updated>
  <id>http://miroox.github.io/blog/</id>
  
  <author>
    <name>miRoox</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>吐槽：这些天在拼接仪项目上踩的坑</title>
    <link href="http://miroox.github.io/blog/2020/10/TrapInSplicerProject/"/>
    <id>http://miroox.github.io/blog/2020/10/TrapInSplicerProject/</id>
    <published>2020-10-31T14:56:23.000Z</published>
    <updated>2020-10-31T14:56:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文以倒苦水为主。</em></p><a id="more"></a><hr><p>那是一个平和的中午，我刚吃完午饭，正准备回寝室休息。然而，一个突如其来的微信消息打破了宁静的一天……</p><p>嗯，就是导师突然拉上我们组好几个人来开会，讨论如何在甲方要求的验收时间——国庆节后——之前把这个项目的软件部分给做出来。然而，这个项目虽然启动已经有至少三年之久了，可之前基本没啥进展，硬件那边不知道为啥一直没完成，咱们软件也就没好好做，并且之前负责这个项目的两个师兄都已经毕业了。最终，这颗定时炸弹轮到咱们手里终于还是炸了。</p><p>不过，更离谱的是我们没人明白这个东西到底要做成啥样。手头只有一份上一代留下来的不清不楚的说明书。而导师的核心指示就是要把界面做得和原来一样，至于里面的功能，很大程度上只能自己去猜了。</p><p>整个项目粗浅的理解就是在一个多自由度的位移台上放了一个红外相机，软件则要控制位移台的运动以及相机的拍摄，并可以运用自动聚焦的方式寻找焦面的最佳位置。你要问我这里哪里体现了“拼接仪”，我也说不清，只能说和我们软件部分的工作无关。</p><h3 id="位移台控制"><a class="markdownIt-Anchor" href="#位移台控制"></a> 位移台控制</h3><p>最初给我分配的任务就是位移台控制。在这里，位移台是通过 PMAC 驱动的。PMAC (Programmable Multi-Axis Controller) 可编程多轴运动控制器，是美国 Delta Tau Data System 公司推出的PC机平台上的运动控制器。不过，想要用 PMAC 实现上位机编程控制，首先还需要安装 <a href="http://www.deltatau.com/DT_Products/SoftwareDetails.aspx?CatID=500-PMAC%20EXECUTIVE%20PRO2%20SUITE" target="_blank" rel="noopener">PMAC EXECUTIVE PRO2 SUITE</a>，然后通过它的互操作库 <code>Interop.PCOMMSERVERLib</code> 来调用命令，实现对电机的控制。</p><p>然而，我们一上手就遇到了一个难题，<code>Interop.PCOMMSERVERLib</code> 似乎是基于 .NET Framework 3.x 开发的，将它引入引用后，如果目标框架是 .NET Framework 3.5 就没有问题，而如果用 .NET Framework 4 及以上，就会出现诸如“无法嵌入互操作类型 “PmacDeviceClass”，请改用合适的接口”的问题。然而，<code>Windows.Forms.DataVisualization</code> 又是 .NET Framework 4 才引入的，没用它的话，要绘制自动聚焦评价函数的曲线又显得麻烦起来。</p><p>几经波折，总算在公司的官方论坛上找到了一个<a href="http://forums.deltatau.com/showthread.php?tid=234" target="_blank" rel="noopener">解决方法</a>。按照他的指示，将引用属性里的“嵌入互操作类型”的值改为 <code>false</code>，就可以避免出现编译错误了。按我的理解，这避开了编译时对 COM 类型的解析。而另一方面，得益于 COM 组件强大的兼容性，这么做在运行时似乎并不会有问题。</p><p>除此之外，还有各种其它问题到工厂里调试才逐渐凸显，于是项目的开发毫无疑问的超期了，变成了一场漫长而琐碎拉锯战。</p><h3 id="相机控制"><a class="markdownIt-Anchor" href="#相机控制"></a> 相机控制</h3><p>相机用的是 FLIR 的工业相机，为了通过编程控制，需要使用 <a href="https://www.flir.com/products/flycapture-sdk/" target="_blank" rel="noopener">FlyCapture2</a> 套件进行开发。</p><p>事实上，这部分之前的一个师兄应该已经尝试过了，然而，他在移交代码的时候并没有找全所有依赖，导致移交的程序虽然能通过编译，但一旦启动就会发生 <code>FileNotFoundException</code>。不过好在开发套件中还包含一些demo的源码，那就编译跑跑试试？幸运的是，demo在我的机器上可以跑起来。既然如此，那就好办了，找到输出目录，把里面的东西一股脑的都复制过来……额，好像有点多。那就先用暴力排除法，在程序启动的时候试着把路径里的文件一个个删掉，没有操作权限的文件就是必要的依赖。不过后来想想这个方法还是太笨太低效了，于是又去找查找依赖项的工具，得到了 <a href="https://github.com/lucasg/Dependencies" target="_blank" rel="noopener">Dependencies</a>，不过这是后话了。</p><p>既然找到依赖了，最好还能在构建的时候一把梭把依赖全部自动复制到输出目录。在研究了一下demo的项目文件后，又根据目标平台和配置写了一个<code>PostBuildEvent</code>脚本，中间还顺带学习了一下 PowerShell，一晃就到了凌晨三点半。</p><p>结果第二天师兄跟我说在他那儿还是会触发 <code>BadImageFormatException</code>，不过此时我已经备好了 Dependencies 作为武器。分析一下 Dependencies 给出缺失的库，基本都 <code>api-ms-win-</code> 开头，<code>d</code> 结尾的一些动态库，这就意识到估计跟 Debug 模式有关，而且是微软官方的 VC++ 运行时库。于是先让师兄换成 Release，成功跑起来。再让他给 Visual Studio 安装 C++ 桌面开发的相关组件，才解决。</p><p>然而还有漫长的痛苦发生在去工厂调试之后。我们的目标工控机跑的是古老的 Windows XP 32位系统，然而我们用的这个库是64位（其实有32位的，不过32位的好像缺依赖，在我自己的机器上都跑不了demo）。好在机器的硬件是64位的，于是又抱着主机到有网的地方重装一个64位系统。除了系统之外，还有各种 VC 运行时库、.NET Framework 要安装。</p><p>好不容易搞定了基本环境，启动后却检测不到相机。看设备管理器里的提示，似乎跟驱动程序的证书有关，可找遍各种资料也没明白应该怎么修复，找相机售后也没得出个所以然来。不过这段时间我正好有一些工作面试之类的，也没太管。事后，听说师兄们祭出了终极绝招360管家，把所有系统漏洞都修复了就好使了……而问题的准确原因也就成了一个谜。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>做这么一个项目的过程中虽然踩了不少坑，碰了不少壁，不过“凡不能毁灭我的，必使我强大”，要说收获，可能也不少。不过项目虽然已经进入后期，但踩坑之路还没有断绝。到了现在，看这项目最大的隐患可能就是各个精度指标提的有些离谱，什么自动聚焦图像采集间隔 10μm，用<strong>拟合</strong>得到的最佳焦面位置判定精度却要达到1μm之类的，实在是过于奇幻了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本文以倒苦水为主。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈散记" scheme="http://miRoox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="http://miRoox.github.io/blog/tags/C/"/>
    
      <category term="PMAC" scheme="http://miRoox.github.io/blog/tags/PMAC/"/>
    
      <category term="FlyCapture2" scheme="http://miRoox.github.io/blog/tags/FlyCapture2/"/>
    
  </entry>
  
  <entry>
    <title>部署一个简单的缩略 URL 的表单</title>
    <link href="http://miroox.github.io/blog/2020/08/WolframURLShortenForm/"/>
    <id>http://miroox.github.io/blog/2020/08/WolframURLShortenForm/</id>
    <published>2020-08-30T13:33:21.000Z</published>
    <updated>2020-08-31T06:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近微博好像把 <code>github.io</code> 下的域名屏蔽了，导致博客完全无法分享，就考虑通过短链接跳转绕开这一限制。考虑到 Mathematica 有现成的函数 <a href="http://reference.wolfram.com/language/ref/URLShorten.html" target="_blank" rel="noopener"><code>URLShorten</code></a>，直接使用即可。不过闲着无聊，就顺便部署了一个简单的缩略 URL 的表单: <a href="https://www.wolframcloud.com/obj/miroox/url-shorten" target="_blank" rel="noopener">https://www.wolframcloud.com/obj/miroox/url-shorten</a>。</p><a id="more"></a><iframe src="https://www.wolframcloud.com/obj/miroox/url-shorten?_embed=iframe" width="600" height="400" frameborder="0" loading="lazy" allowfullscreen></iframe><p>本来想支持复制按钮的，然而 <a href="http://reference.wolfram.com/language/ref/CopyToClipboard.html" target="_blank" rel="noopener"><code>CopyToClipboard</code></a> 在网页上不起作用，自己写 js 支持又出乎意料的麻烦，遂放弃。</p><p>部署用的代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CloudDeploy</span>[</span><br><span class="line"> <span class="keyword">FormPage</span>[</span><br><span class="line">  &#123;<span class="string">"url"</span>, <span class="string">"URL:"</span>&#125; -&gt; &lt;|</span><br><span class="line">    <span class="string">"Interpreter"</span> -&gt; <span class="string">"URL"</span>,</span><br><span class="line">    <span class="string">"Hint"</span> -&gt; <span class="string">"Enter the URL to be shortened"</span></span><br><span class="line">    |&gt;,</span><br><span class="line">  <span class="keyword">Row</span>@&#123;<span class="string">"Short URL: "</span>, <span class="keyword">Hyperlink</span>@ <span class="keyword">URLShorten</span>[#url]&#125; &amp;,</span><br><span class="line">  <span class="keyword">AppearanceRules</span> -&gt; &lt;|</span><br><span class="line">    <span class="string">"Title"</span> -&gt; <span class="string">"Shorten your URL"</span></span><br><span class="line">    |&gt;</span><br><span class="line">  ],</span><br><span class="line"> <span class="string">"url-shorten"</span>,</span><br><span class="line"> <span class="keyword">Permissions</span> -&gt; <span class="string">"Public"</span></span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近微博好像把 &lt;code&gt;github.io&lt;/code&gt; 下的域名屏蔽了，导致博客完全无法分享，就考虑通过短链接跳转绕开这一限制。考虑到 Mathematica 有现成的函数 &lt;a href=&quot;http://reference.wolfram.com/language/ref/URLShorten.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;URLShorten&lt;/code&gt;&lt;/a&gt;，直接使用即可。不过闲着无聊，就顺便部署了一个简单的缩略 URL 的表单: &lt;a href=&quot;https://www.wolframcloud.com/obj/miroox/url-shorten&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.wolframcloud.com/obj/miroox/url-shorten&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="Cloud" scheme="http://miRoox.github.io/blog/tags/Cloud/"/>
    
  </entry>
  
  <entry>
    <title>【新坑】wll-rs: 用于 Rust 的 Wolfram LibraryLink 接口</title>
    <link href="http://miroox.github.io/blog/2020/08/wll-rs-design/"/>
    <id>http://miroox.github.io/blog/2020/08/wll-rs-design/</id>
    <published>2020-08-29T15:40:21.000Z</published>
    <updated>2020-08-31T06:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>苦于 Wolfram <a href="http://reference.wolfram.com/language/LibraryLink/tutorial/Overview.html" target="_blank" rel="noopener">LibraryLink</a> 原本的接口使用起来过于繁琐，又受 <a href="https://github.com/njpipeorgan/wll-interface" target="_blank" rel="noopener">wll-interface</a> 的启发，近期开了一个新坑，尝试为 Wolfram LibraryLink 封装一套 Rust 的接口 <a href="https://crates.io/crates/wll" target="_blank" rel="noopener">wll-rs</a>。</p><blockquote><p>阅读本文需要一定 Rust 以及 Wolfram LibraryLink 的基础。</p></blockquote><a id="more"></a><h3 id="目标和基本结构"><a class="markdownIt-Anchor" href="#目标和基本结构"></a> 目标和基本结构</h3><p>既然用上 Rust 这种高级抽象的语言，自然不可能只是做一些简单的绑定。至少要能做到两件事：</p><ol><li>提供安全便利的类型和接口封装</li><li>自动生成满足 LibraryLink 规范的导出函数格式</li></ol><p>为了让不熟悉 Wolfram LibraryLink 的读者也能了解到它使用起来有多麻烦，下面截一段官方示例中的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Include required header */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"WolframLibrary.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the version of Library Link */</span></span><br><span class="line"><span class="function">DLLEXPORT mint <span class="title">WolframLibrary_getVersion</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> WolframLibraryVersion;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize Library */</span></span><br><span class="line"><span class="function">DLLEXPORT <span class="keyword">int</span> <span class="title">WolframLibrary_initialize</span><span class="params">( WolframLibraryData libData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LIBRARY_NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Uninitialize Library */</span></span><br><span class="line"><span class="function">DLLEXPORT <span class="keyword">void</span> <span class="title">WolframLibrary_uninitialize</span><span class="params">( WolframLibraryData libData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Adds one to the input, returning the result  */</span></span><br><span class="line"><span class="function">DLLEXPORT <span class="keyword">int</span> <span class="title">demo_I_I</span><span class="params">( WolframLibraryData libData, mint Argc, MArgument *Args, MArgument Res)</span> </span>&#123;</span><br><span class="line">    mint I0;</span><br><span class="line">    mint I1;</span><br><span class="line">    I0 = MArgument_getInteger(Args[<span class="number">0</span>]);</span><br><span class="line">    I1 = I0 + <span class="number">1</span>;</span><br><span class="line">    MArgument_setInteger(Res, I1);</span><br><span class="line">    <span class="keyword">return</span> LIBRARY_NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了加载库和卸载库时所需要的初始化和反初始化函数外，函数本身的传参形式也非常奇妙，<a href="http://reference.wolfram.com/language/ref/LibraryFunction.html" target="_blank" rel="noopener"><code>LibraryFunction</code></a> 的实参通过 <code>MArgument</code> 的指针（数组）传入，实际的返回结果也在参数列表中，而函数所返回的 <code>int</code> 值则表示一个错误码。</p><p>作为目标，我们期望在 wll-rs 中实现的等效形式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.rs</span></span><br><span class="line"><span class="keyword">use</span> wll::<span class="built_in">Result</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wll::setup]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wll::teardown]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">uninit</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wll::export(demo_I_I)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>(n: <span class="built_in">isize</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">isize</span>&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(n + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即通过 <code>wll::Result</code> 表示返回值和结果状态，通过类属性宏标记函数来自动生成满足 LibraryLink 规范的导出函数。</p><p>有了基本的目标，那么大致的框架也可以确定了：</p><img src="/blog/2020/08/wll-rs-design/structure.png" title="大致框架"><ul><li><a href="https://crates.io/crates/wll-sys" target="_blank" rel="noopener">wll-sys</a> 底层接口绑定</li><li><a href="https://crates.io/crates/wll-macros" target="_blank" rel="noopener">wll-macros</a> 提供类属性过程宏（受Rust本身的限制，过程宏必须由单独的包提供）</li><li><a href="https://crates.io/crates/wll" target="_blank" rel="noopener">wll</a> 整合封装给用户使用的包</li></ul><h3 id="底层接口绑定"><a class="markdownIt-Anchor" href="#底层接口绑定"></a> 底层接口绑定</h3><p>底层接口绑定是一件很无聊的事，不过好在我们有 <a href="https://rust-lang.github.io/rust-bindgen/introduction.html" target="_blank" rel="noopener"><code>bindgen</code></a> 可以从头文件中生成对应的 Rust 文件，大大减轻了我们的工作量。具体操作流程就不再赘述了，直接看官方的文档教程即可。</p><p>稍微值得一提的是，<code>bindgen</code> 生成的文件可能不能满足我们对类型的预期，比如头文件中的宏定义和匿名枚举项，本身不具有类型描述。例如来自宏定义的 <code>True</code> 的类型并不会是 <code>mbool</code>。为了能手动转换复写它们，这里将 <code>bindgen</code> 生成的代码包含在一个 <code>mod</code> 中，再 <code>pub use</code> 导出全部符号，这时，在外部复写也不会导致符号重名的错误了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sys/src/lib.rs 节选</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> bindings &#123;</span><br><span class="line">    include!(<span class="built_in">concat!</span>(<span class="built_in">env!</span>(<span class="string">"OUT_DIR"</span>), <span class="string">"/bindings.rs"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> bindings::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> True: mbool = bindings::True <span class="keyword">as</span> mbool;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> False: mbool = bindings::False <span class="keyword">as</span> mbool;</span><br><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure><p>另外 Wolfram LibraryLink 的接口设计某种意义上是不需要链接的，几乎所有类型都是指针，用来回调的函数也是 <code>WolframLibraryData</code> 的成员函数指针。事实上，在目前的测试中，哪怕没有链接到 <code>WolframRTL</code>，编译得到的 C ABI 动态库（<code>cdylib</code>）只要满足 LibraryLink 的接口规范，一样能正常使用。</p><h3 id="参数类型适配"><a class="markdownIt-Anchor" href="#参数类型适配"></a> 参数类型适配</h3><p>底层接口绑定完成后，就可以开始进行用户层参数的适配了。</p><p>首先考虑错误处理。这里将错误码封装成更具 Rust 风格的 <code>Result</code> 和 <code>Error</code> 对象，以及和错误码之间的相互转换。而为了更友好地向用户表征错误类型，也提供了 <code>ErrorKind</code> 枚举类型，以及其到 <code>Error</code> 类型的转换（见 <a href="https://github.com/miRoox/wll-rs/blob/master/src/errors.rs" target="_blank" rel="noopener"><code>errors.rs</code></a>）。</p><p>在 LibraryLink 的接口中，所有类型的参数都通过 <code>MArgument</code> 来传递，这是一个（untagged）联合体，包含了 LibraryLink 中的各种类型。而我们的用户既不应该直接处理 <code>MArgument</code>，也通常不用直接面对 LibraryLink 的底层类型，而是使用封装后的 Rust 类型。</p><img src="/blog/2020/08/wll-rs-design/types.png" title="类型关系"><p>如图所示，为了支持函数的输入输出，需要有“Rust 类型 - LibraryLink 类型 - <code>MArgument</code>”的双向转换。这里，LibraryLink 类型是可枚举的，因此，它和 <code>MArgument</code> 之间的转换也是可枚举的，同时，从设计上看，这部分转换也是无需暴露给用户的。而对于可能的 Rust 类型，为了给予用户可扩展性，允许用户自定义 Rust 类型和 LibraryLink 类型之间的转换。并且，一旦用户自定义了 Rust 类型和 LibraryLink 类型之间的转换，那么对应的 Rust 类型和 <code>MArgument</code> 之间的转换也应该<strong>自动</strong>被实现。而为了保证最终转换的唯一性，一个 Rust 类型至多只能对应于一个 LibraryLink 类型（反之则不然）。</p><p>小结一下需求：</p><ol><li>LibraryLink 类型和 <code>MArgument</code> 之间的转换预先固定且不暴露给用户；</li><li>Rust 类型和 LibraryLink 类型之间的转换可以由用户自行扩展，但一个 Rust 类型至多只能对应于一个 LibraryLink 类型；</li><li>Rust 类型和 LibraryLink 类型之间的转换 → Rust 类型和 <code>MArgument</code> 之间的转换。</li></ol><p>一个非常平凡的想法是将所有 LibraryLink 类型包到一个 <code>enum</code> 中，毕竟 Rust 的 <code>enum</code> 也就是一种 tagged union，这样也很容易满足一个 Rust 类型至多只对应于一个 LibraryLink 类型。但问题在于这使 <code>MArgument</code> 到 LibraryLink 类型，以及更进一步的，从 <code>MArgument</code> 到 Rust 类型的转换变得困难了起来。虽然 <code>enum</code> 带有标签，但从编译时蕴含的信息上看，它和 <code>union</code> 一样，都抹平了不同类型之间的差异。当从它向 <code>MArgument</code> 转换时，由于它具有的运行时信息更丰富，因此可以实现。然而，反之则不然，如果不向这一过程注入更多类型信息的话，那么实现起来完全无从下手。可是，如果不使用 <code>enum</code> 的话，这些信息本身就存在，再额外注入不仅画蛇添足，似乎也不太符合分离耦合的思想。</p><p>在 Rust 中，我们有两种逻辑委派方法，其中一种是 <code>enum</code>，而另一种是 <code>trait</code> 对象<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。<code>enum</code> 是封闭类型，看上去更符合我们这里的情况，但由于上述原因，并不适合使用；而 <code>trait</code> 对象是开放类型，似乎也没法用在这里。当然，我们这里不需要动态性，所以只需要 <code>trait</code> 而非 <code>trait</code> 对象，但这也为我们提供了另一种可能的思路。</p><p>事实上，<em>sealed trait</em> 模式<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>让我们能将 <code>trait</code> 的实现限制在我们的模块内而无法被外部实现。简而言之，就是让我们的公开 <code>trait</code> 将一个不公开的占位 <code>trait</code> 作为父 <code>trait</code>，从而使外部实现无法满足约束，从而封闭了可能的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adaptor.rs 节选</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> private &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sealed</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MType</span></span>: private::Sealed + <span class="built_in">Sized</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> impl_mtypes &#123;</span><br><span class="line">    ($($t:ty),+) =&gt; &#123;</span><br><span class="line">        $(</span><br><span class="line">            <span class="keyword">impl</span> private::Sealed <span class="keyword">for</span> $t &#123;&#125;</span><br><span class="line">            <span class="keyword">impl</span> MType <span class="keyword">for</span> $t &#123;&#125;</span><br><span class="line">        )+</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl_mtypes!(</span><br><span class="line">    mbool,</span><br><span class="line">    mint,</span><br><span class="line">    mreal,</span><br><span class="line">    mcomplex,</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在这里，我们将所有的 LibraryLink 类型都实现为 <code>MType trait</code>。这只是一个开端，我们还需要提供它们的适配关系接口。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">InputAdaptor</span></span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Input</span></span>: MType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mtype_try_from</span></span>(input: Self::Input) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">OutputAdaptor</span></span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>: MType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_into_mtype</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到一个 Rust 类型至多只对应于一个 LibraryLink 类型。将对应的 LibraryLink 类型作为适配 <code>trait</code> 的关联类型显然是比较合适的。而为了自动实现 Rust 类型和 <code>MArgument</code> 之间的转换，可以采用所谓的 <em>blanket implementations</em><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 来传递这种转换关系。然而，不同 LibraryLink 类型对应 <code>MArgument</code> 的字段不同，需要 <em>ad-hoc</em> 实现，而同一个 <code>trait</code> 的 <em>blanket implementations</em> 不能区分具有不同关联类型的同种 <code>trait</code>。因此 <code>MArgument</code> 的转换 <code>trait</code> 必须是具有泛型类型参数的 <code>trait</code>，通过完全特化的实现来满足这种对应关系。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MArgumentGetter</span></span>&lt;T: MType&gt;: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_get_arg</span></span>(arg: MArgument) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MArgumentSetter</span></span>&lt;T: MTypeOrVoid&gt;: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_set_arg</span></span>(<span class="keyword">self</span>, arg: &amp;MArgument) -&gt; <span class="built_in">Result</span>&lt;()&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: InputAdaptor&lt;Input = mbool&gt;&gt; MArgumentGetter&lt;mbool&gt; <span class="keyword">for</span> T &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_get_arg</span></span>(arg: MArgument) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> ptr = arg.boolean;</span><br><span class="line">            <span class="keyword">if</span> ptr.is_null() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(Error::from(ErrorKind::TypeError));</span><br><span class="line">            &#125;</span><br><span class="line">            T::mtype_try_from(std::ptr::read(ptr))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: OutputAdaptor&lt;Output = mbool&gt;&gt; MArgumentSetter&lt;mbool&gt; <span class="keyword">for</span> T &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_set_arg</span></span>(<span class="keyword">self</span>, arg: &amp;MArgument) -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> ptr = arg.boolean;</span><br><span class="line">            <span class="keyword">if</span> ptr.is_null() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Err</span>(Error::from(ErrorKind::TypeError));</span><br><span class="line">            &#125;</span><br><span class="line">            std::ptr::write(ptr, <span class="keyword">self</span>.try_into_mtype()?);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure><p><code>#[doc(hidden)]</code> 表明这部分不应被用户直接使用。实际的实现代码为了避免繁琐易错的复制粘贴，是通过宏完成的（见 <a href="https://github.com/miRoox/wll-rs/blob/master/src/adaptor.rs" target="_blank" rel="noopener"><code>adaptor.rs</code></a>）。</p><p>最终的类型适配关系如图所示：</p><img src="/blog/2020/08/wll-rs-design/adaptor.png" title="类型适配"><h3 id="访问-wolframlibrarydata"><a class="markdownIt-Anchor" href="#访问-wolframlibrarydata"></a> 访问 <code>WolframLibraryData</code></h3><p>由于 LibraryLink 的所有函数都是回调式的，各种函数的调用都免不了要访问当前的 <code>WolframLibraryData</code>。然而我们显然是不会希望各个函数都要带着一个 <code>WolframLibraryData</code> 的参数到处跑的，因此，一种直观的方式是使用一个全局静态对象，并在适时处设置它以实现别的函数对它的访问。不过这部分的设计尚未完全确定，在此也不多费口舌了。</p><h3 id="类属性过程宏"><a class="markdownIt-Anchor" href="#类属性过程宏"></a> 类属性过程宏</h3><p>为了便利地从 Rust 函数中创建满足 LibraryLink 的接口规范的导出函数，可以通过类属性过程宏来解决这一麻烦。</p><p>这部分实现在 <a href="https://crates.io/crates/wll-macros" target="_blank" rel="noopener">wll-macros</a>，并在 wll 设置了 <code>macros</code> feature 时会重新导出其中的宏（似乎由于 Rust 本身的限制，过程宏的重导出必须这么做）。</p><p>其中</p><ul><li><code>setup</code> 会将它标记的函数放到 <code>WolframLibrary_initialize</code> 中调用，并补上 <code>WolframLibrary_getVersion</code>；</li><li><code>teardown</code> 会将它标记的函数放到 <code>WolframLibrary_uninitialize</code> 中调用；</li><li><code>export</code> 有两种形式：<ul><li>当它不包含参数时，会给原本的函数名前面加上 <code>wll_</code> 并按 LibraryLink 的接口规范导出函数；</li><li>当它包含参数时，则按参数名作为导出函数的名称，同样按 LibraryLink 的接口规范导出。</li></ul></li></ul><p>过程宏在官方资料中描述不多，但本身又非常繁琐，因此在这里就不多赘述了，推荐观看<a href="https://www.youtube.com/watch?v=geovSK3wMB8" target="_blank" rel="noopener">视频</a>进行学习。</p><p>这里给出前述 <code>demo.rs</code> 进行宏展开后的结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cargo expand demo.rs</span></span><br><span class="line"><span class="keyword">use</span> wll::<span class="built_in">Result</span>;</span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">WolframLibrary_initialize</span></span>(</span><br><span class="line">    data: ::wll::sys::WolframLibraryData,</span><br><span class="line">) -&gt; ::wll::sys::errcode_t &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> ::std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(e) = ::wll::global::initialize_lib_data(data) &#123;</span><br><span class="line">        e.to_raw_error()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        ::wll::sys::LIBRARY_NO_ERROR</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">WolframLibrary_getVersion</span></span>() -&gt; ::wll::sys::mint &#123;</span><br><span class="line">    ::wll::sys::WolframLibraryVersion</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">uninit</span></span>() &#123;&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">WolframLibrary_uninitialize</span></span>(_: ::wll::sys::WolframLibraryData) &#123;</span><br><span class="line">    uninit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>(n: <span class="built_in">isize</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">isize</span>&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(n + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">demo_I_I</span></span>(</span><br><span class="line">    lib_data: ::wll::sys::WolframLibraryData,</span><br><span class="line">    argc: ::wll::sys::mint,</span><br><span class="line">    args: *<span class="keyword">const</span> ::wll::sys::MArgument,</span><br><span class="line">    res: ::wll::sys::MArgument,</span><br><span class="line">) -&gt; ::wll::sys::errcode_t &#123;</span><br><span class="line">    <span class="keyword">use</span> ::wll::adaptor::&#123;MArgumentGetter, MArgumentSetter&#125;;</span><br><span class="line">    <span class="keyword">let</span> _lib_data = ::wll::global::LibDataLocalizer::new(lib_data);</span><br><span class="line">    <span class="keyword">if</span> argc != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ::wll::sys::LIBRARY_TYPE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arg0 = <span class="keyword">match</span> &lt;<span class="built_in">isize</span>&gt;::try_get_arg(args.add(<span class="number">0usize</span>).read()) &#123;</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Ok</span>(val) =&gt; val,</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> err.to_raw_error(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">match</span> add_one(arg0) &#123;</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Ok</span>(val) =&gt; val,</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> err.to_raw_error(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">match</span> ret.try_set_arg(&amp;res) &#123;</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Ok</span>(()) =&gt; ::wll::sys::LIBRARY_NO_ERROR,</span><br><span class="line">        ::std::result::<span class="built_in">Result</span>::<span class="literal">Err</span>(err) =&gt; err.to_raw_error(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>文章简单介绍了一下 wll 的基本设计和目前的进展。通过这个项目我也熟悉了Rust 的 bindgen、过程宏以及 <code>trait</code> 的各种高级用法。顺便 LibraryLink 的接口规范虽然繁琐，但也不失为一种具有灵活性和强兼容性的接口设计方案。不过 wll 还处于相当早期的开放阶段，虽然提供了简单的 <code>Complex&lt;T&gt;</code> 复数类型，但功能并不完整。而像 <code>MTensor</code>, <code>MNumericArray</code> 等类型对应的 Rust 高级类型和适配都尚未开始，开发完善的路途依旧漫长。</p><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.possiblerust.com/guide/enum-or-trait-object" target="_blank" rel="noopener">Enum or Trait Object</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed" target="_blank" rel="noopener">Rust API Guidelines: C-SEALED</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html" target="_blank" rel="noopener">Traits: Defining Shared Behavior</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苦于 Wolfram &lt;a href=&quot;http://reference.wolfram.com/language/LibraryLink/tutorial/Overview.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LibraryLink&lt;/a&gt; 原本的接口使用起来过于繁琐，又受 &lt;a href=&quot;https://github.com/njpipeorgan/wll-interface&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wll-interface&lt;/a&gt; 的启发，近期开了一个新坑，尝试为 Wolfram LibraryLink 封装一套 Rust 的接口 &lt;a href=&quot;https://crates.io/crates/wll&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wll-rs&lt;/a&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;阅读本文需要一定 Rust 以及 Wolfram LibraryLink 的基础。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="Rust" scheme="http://miRoox.github.io/blog/tags/Rust/"/>
    
      <category term="LibraryLink" scheme="http://miRoox.github.io/blog/tags/LibraryLink/"/>
    
  </entry>
  
  <entry>
    <title>预览在 GitHub 上的 Wolfram 笔记本</title>
    <link href="http://miroox.github.io/blog/2020/07/WolframGitHubViewer/"/>
    <id>http://miroox.github.io/blog/2020/07/WolframGitHubViewer/</id>
    <published>2020-07-31T13:29:21.000Z</published>
    <updated>2020-08-01T14:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.wolframcloud.com/obj/github-cloud/form/BadgeCreation" target="_blank" rel="noopener"><img src="https://www.wolframcloud.com/obj/github-cloud/notebookviewersource/Images/github_header.png" alt="Make A Wolfram GitHub Viewer Badge"></a></p><a id="more"></a><p>不知道啥时候，Wolfram 官方偷偷上线了一个在线预览 GitHub 仓库中的笔记本的网页应用。有了这个，大家就不用花自己的 Cloud Credits 来部署笔记本，而只要把笔记本同步到 GitHub 上就可以从浏览器访问云上的笔记本了。</p><p>以 <a href="https://github.com/wjxway" target="_blank" rel="noopener">@wjxway</a> 大佬的<a href="https://github.com/wjxway/Realistic_Blackhole_Accretion_Disk" target="_blank" rel="noopener">黑洞吸积盘模拟</a>为例，按表单的提示输入即可：</p><ol><li>输入 GitHub 用户名<br><img src="/blog/2020/07/WolframGitHubViewer/github_id.png" title="github id"></li><li>输入要预览的 GitHub 仓库名和分支，分支默认为 master<br><img src="/blog/2020/07/WolframGitHubViewer/github_repo-branch.png" title="github repo-branch"></li><li>得到一个Markdown格式的徽章链接代码 <a href="https://wolfr.am/OphS2N6z" target="_blank" rel="noopener"><img src="https://wolfr.am/HAAhzkRq" alt="View notebooks"></a><br><img src="/blog/2020/07/WolframGitHubViewer/markdown_badge.png" title="markdown badge"></li><li>复制徽章代码到 Markdown 文件（通常是 <code>README.md</code>），在预览中点击徽章即可打开笔记本<br><img src="/blog/2020/07/WolframGitHubViewer/notebook.png" title="notebook"></li></ol><p>目前的坑：</p><ol><li>文件名中不能包含中文</li><li>Cloud 访问可能比较慢</li></ol><hr><p>补记：关于在 git 和 GitHub 上的笔记本的编写保存</p><p>写笔记本的时候建议使用 <a href="https://resources.wolframcloud.com/FunctionRepository/resources/SaveReadableNotebook" target="_blank" rel="noopener"><code>ResourceFunction[&quot;SaveReadableNotebook&quot;]</code></a> 或者 <a href="https://github.com/JP-Ellis/mathematica-notebook-filter" target="_blank" rel="noopener"><code>mathematica-notebook-filter</code></a> 得到干净的笔记本文件，避免提交一些乱七八糟的cache到git中：</p><ul><li>小文件推荐使用 <code>ResourceFunction[&quot;SaveReadableNotebook&quot;]</code>，也推荐使用我的 <a href="https://github.com/miRoox/MirooxUtils" target="_blank" rel="noopener"><code>MirooxUtils</code></a> 包附带的一个面板来一键快速保存为可读笔记本。</li><li>大文件，尤其是包含大量图片或者动态的文件，还是推荐使用 <code>mathematica-notebook-filter</code>（但要注意它还会滤掉输出单元），否则文件大小可能回膨胀地非常大，并且 <code>ResourceFunction[&quot;SaveReadableNotebook&quot;]</code> 对动态的处理存在一定Bug，可能导致文件损坏。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.wolframcloud.com/obj/github-cloud/form/BadgeCreation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://www.wolframcloud.com/obj/github-cloud/notebookviewersource/Images/github_header.png&quot; alt=&quot;Make A Wolfram GitHub Viewer Badge&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="GitHub" scheme="http://miRoox.github.io/blog/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>一个适用于 Wolfram 语言的 GitHub Action</title>
    <link href="http://miroox.github.io/blog/2020/01/GitHubActionForWolframLanguage/"/>
    <id>http://miroox.github.io/blog/2020/01/GitHubActionForWolframLanguage/</id>
    <published>2020-01-30T14:23:21.000Z</published>
    <updated>2020-08-28T12:01:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年 GitHub 推出了 <a href="https://github.com/features/actions" target="_blank" rel="noopener">Actions</a>，以提供内置的持续集成能力。同样是在去年，Wolfram Research 也推出了<a href="https://www.wolfram.com/engine/" target="_blank" rel="noopener">免费的开发者 Wolfram 引擎</a>，让我们有机会免费运行 Wolfram 语言代码。那么，两件快乐事情重合在一起。而这两份快乐，又给我带来多的快乐。得到的……没错，就是我们期待已久的对 Wolfram 语言程序的持续集成。</p><a id="more"></a><h3 id="配置经历趟过的坑"><a class="markdownIt-Anchor" href="#配置经历趟过的坑"></a> 配置经历（趟过的坑）</h3><p>当然，天下代码一大抄，照猫画虎首先也需要一个参考对象。这里参照的是 <a href="https://github.com/xu-cheng/latex-action" target="_blank" rel="noopener">xu-cheng/latex-action</a>，因为这是一个基于 Docker 容器的 Actions。而现成的 <a href="https://hub.docker.com/r/arnoudbuzing/wolframengine" target="_blank" rel="noopener">Wolfram 引擎的 Docker 配置</a>早已经出现的 DockerHub 上了，直接拿来用就可以了。</p><p>由于缺乏经验，还是先按照 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-a-docker-container-action" target="_blank" rel="noopener">Creating a Docker container action</a> 的文档过了一遍基本的流程，了解了一下 Docker 的基本用法。</p><p>基本思路是继承 <a href="https://hub.docker.com/r/arnoudbuzing/wolframengine" target="_blank" rel="noopener">arnoudbuzing/wolframengine</a> 的 Docker 容器，然后通过入口点脚本 <code>entrypoint.sh</code> 认证激活 Wolfram 引擎，再运行输入的 Wolfram 脚本。</p><p>在这里遇到的最大的困难大概还是认证激活。</p><p>首先，认证需要对应的 <a href="https://account.wolfram.com/wolframid" target="_blank" rel="noopener">Wolfram ID</a> 账号密码登录。显然，账号密码不能要用户直接写在 Action 的配置里。GitHub 提供了 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets" target="_blank" rel="noopener">Secrets 机制</a>来避免加密内容直接出现在配置文件中，但如果直接通过参数将账号密码传递给 Docker，仍不能避免让密码内容在日志中以明文出现。参考了 <a href="https://github.com/sliteteam/github-action-git-crypt-unlock" target="_blank" rel="noopener">sliteteam/github-action-git-crypt-unlock</a> 后，尝试得知环境变量在传递过程中不会在日志中直接输出其内容。因此，账号密码在使用时都应以环境变量的方式传递。</p><p>另一方面，Wolfram 引擎通常的激活流程是初次启动时手动在 prompt 下依序键入账号密码，文档里并没有提供利用 wolframscript 自动化这一激活流程的办法，还是在我几经失败踩坑后才探索出一种合适的办法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/wolframscript -authenticate <span class="variable">$WOLFRAM_ID</span> <span class="variable">$WOLFRAM_PASS</span></span><br><span class="line">/usr/bin/wolframscript -activate</span><br></pre></td></tr></table></figure><p>解决了认证激活的问题，剩下的基本就也没什么难度了。对参数缺失以及不合法的报错处理直接按 <a href="https://github.com/xu-cheng/latex-action" target="_blank" rel="noopener">xu-cheng/latex-action</a> 照搬。其它配置也基本大同小异。</p><p>最后，将 Action 发布到了市场上，见 <a href="https://github.com/marketplace/actions/github-action-for-wolfram-language" target="_blank" rel="noopener">GitHub action for Wolfram language</a>。有什么用我也不清楚，大概可以方便推广？</p><h3 id="食用方法"><a class="markdownIt-Anchor" href="#食用方法"></a> 食用方法</h3><p>使用时将下面的内容复制到 <code>.github/workflow/main.yml</code> （或者其它名字的）配置文件里</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Wolfram</span> <span class="string">script</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">miRoox/wolfram-action@master</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">script.wl</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">WOLFRAM_ID:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.WolframID</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">WOLFRAM_PASS:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.WolframPW</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>这里，<code>script.wl</code> 即你要运行的 Wolfram 语言脚本；<code>secrets.WolframID</code> 和 <code>secrets.WolframPW</code> 分别对应你的 Wolfram 账号 ID 和密码，你需要在仓库中建立对应名称的 Secrets，操作流程见 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets" target="_blank" rel="noopener">Creating and using encrypted secrets</a>。</p><p>下面是一个完整的配置文件的例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span> <span class="string">[push]</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">run_wolfram:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Wolfram</span> <span class="string">language</span> <span class="string">code</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Wolfram</span> <span class="string">script</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">miRoox/wolfram-action@master</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">file:</span> <span class="string">script.wl</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">WOLFRAM_ID:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.WolframID</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">WOLFRAM_PASS:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.WolframPW</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h3><p>关于 Wolfram 引擎的许可证：</p><p>根据 FAQ 里的 <a href="https://www.wolfram.com/engine/faq/#can-i-use-the-free-engine-in-an-open-source-project" target="_blank" rel="noopener">“我可以在开源项目中使用免费引擎吗？”</a>：</p><blockquote><p>您可以使用免费引擎开发项目，以及<strong>演示和测试</strong>。但是，免费引擎许可证不允许终端用户使用，除非此用途<strong>用于进一步开发</strong>。对于终端用户使用，用户必须拥有 Wolfram 引擎的单独许可证。如果您拥有 Wolfram 产品（如 Wolfram|One 或 Mathematica），或者您所在的组织拥有 Wolfram 站点许可证，则您可能已拥有相应的许可证。开源项目可以<a href="https://www.wolframcloud.com/objects/forms/wolfram-engine-open-source" target="_blank" rel="noopener">申请</a>特殊的 Wolfram 引擎许可证，允许终端用户自由使用免费引擎作为他们项目用途的一部分。</p></blockquote><p>由于持续集成服务本身是“用于进一步开发”的用途，而且终端用户使用时也确实不能免除 Wolfram 引擎的单独许可证，我认为在许可上应该时没有什么风险的。</p><hr><p>关于许可证的使用次数。经测试，对于同一个 Docker image，重复使用是不会消耗许可证的。<br>而在进行了新 build 的 image 中使用才会消耗许可证。<br>这也是这个 action 相对于直接在 workflow 中使用 <code>wget</code> 下载 Wolfram Engine 再激活的一个优势。</p><hr><p>2020.08.28 补记：</p><p>最近发现 Wolfram Engine 的许可证好像可以随便用了，这个项目的意义顿时变得微妙了起来。现在在 GitHub Action 中可以直接在 Ubuntu 环境下运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://account.wolfram.com/download/public/wolfram-engine/desktop/LINUX</span><br><span class="line">sudo bash LINUX -- -auto -verbose</span><br><span class="line">rm LINUX</span><br></pre></td></tr></table></figure><p>安装 Wolfram Engine ，然后采用前述同样的命令激活。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年 GitHub 推出了 &lt;a href=&quot;https://github.com/features/actions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Actions&lt;/a&gt;，以提供内置的持续集成能力。同样是在去年，Wolfram Research 也推出了&lt;a href=&quot;https://www.wolfram.com/engine/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;免费的开发者 Wolfram 引擎&lt;/a&gt;，让我们有机会免费运行 Wolfram 语言代码。那么，两件快乐事情重合在一起。而这两份快乐，又给我带来多的快乐。得到的……没错，就是我们期待已久的对 Wolfram 语言程序的持续集成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="GitHub" scheme="http://miRoox.github.io/blog/tags/GitHub/"/>
    
      <category term="持续集成" scheme="http://miRoox.github.io/blog/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>利用 GitHub Actions 自动化构建和发布 Qt 程序的一点经验</title>
    <link href="http://miroox.github.io/blog/2019/12/AboutGitHubActionsCIQt/"/>
    <id>http://miroox.github.io/blog/2019/12/AboutGitHubActionsCIQt/</id>
    <published>2019-12-10T14:24:54.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵子 GitHub 正式发布了 <a href="https://github.com/features/actions" target="_blank" rel="noopener">Actions</a> 功能来提供内置的持续集成和持续发布。而我正好最近在利用 Qt 写<a href="https://github.com/miRoox/HIT-DigitalImageProcessing-Postgraduate" target="_blank" rel="noopener">数字图像处理的作业</a>，就想利用这个机会尝试一下基于 GitHub Actions 的持续集成。</p><a id="more"></a><p>当然，有问题首先是找轮子。很快我就找到了 <a href="https://github.com/jaredtao/HelloActions-Qt" target="_blank" rel="noopener">jaredtao/HelloActions-Qt</a>，以及相关的几篇博客文章<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。照猫画虎很快就把各个平台下的自动构建弄成了。但那篇关于自动发行的文章<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>对多配置下 <a href="https://github.com/actions/create-release" target="_blank" rel="noopener">create-release</a> 重复执行导致失败这一问题的解决方案不太令我满意，总觉得太繁琐了，而且我对其中所用的 PowerShell 也不熟。不过这个问题显然不是特殊情况，想必也曾有人就此提出了问题，而也许已经有别人回答了更好的解决方案也不一定。果不其然，早就有人在 create-release 的仓库下的 issues 中提出过这个问题，并且这个 issue 尚未关闭，也就是并没有一个非常令人满意的解答。不过，其中有一个回答<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>给我一点启发，它将使用多种配置的发布任务与创建 release 的任务分开，而通过 <a href="https://github.com/actions/upload-artifact" target="_blank" rel="noopener">upload-artifact</a> 和 <a href="https://github.com/actions/upload-artifact" target="_blank" rel="noopener">download-artifact</a> 来传递 release URL。另一个关联的仓库也有人给出了类似的思路<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">build(mac)       build(linux)        build(win)</span><br><span class="line">    │                  │                 │</span><br><span class="line">    └──────────────────┼─────────────────┘</span><br><span class="line">                       │</span><br><span class="line">                create_release()</span><br><span class="line">                       │</span><br><span class="line">    ┌──────────────────┼─────────────────┐</span><br><span class="line">    │                  │                 │</span><br><span class="line">upload(mac)       upload(linux)      upload(win)</span><br></pre></td></tr></table></figure><p>不过这种任务结构让构建和上传两个阶段的文件对应变得麻烦起来。受此启发，我想到了另一种可能——<code>create_release()</code>真的一定要在<code>build(...)</code>完成之后才能进行吗？因为我们需要创建 release 的时候一定是在发布 tag 的时候，这时我们通常已经在 commit 时检验过一遍是否通过构建/测试了，因此不妨将<code>create_release()</code>提前，于是有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                create_release()*</span><br><span class="line">                       │</span><br><span class="line">    ┌──────────────────┼─────────────────┐</span><br><span class="line">    │                  │                 │</span><br><span class="line"> build(mac)        build(linux)       build(win)</span><br><span class="line">    &amp;                  &amp;                 &amp;</span><br><span class="line">upload(mac)*      upload(linux)*     upload(win)*</span><br></pre></td></tr></table></figure><p><code>*</code>表示只在发布 tag 的时候才会进行这个步骤。这里将<code>build(...)</code>和<code>upload(...)</code>两个阶段合在同一个job中，便于传递文件。最终配置如 <a href="https://github.com/miRoox/HIT-DigitalImageProcessing-Postgraduate/blob/master/.github/workflows/build.yml" target="_blank" rel="noopener">.github/workflows/build.yml</a> 所示。</p><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://jaredtao.github.io/2019/11/19/Qt%E4%BD%BF%E7%94%A8github-Actions%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91/" target="_blank" rel="noopener">Qt使用github-Actions自动化编译</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://jaredtao.github.io/2019/12/03/Qt%E4%BD%BF%E7%94%A8github-Actions%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E8%A1%8C/" target="_blank" rel="noopener">Qt使用github-Actions自动化发行</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://github.com/actions/create-release/issues/14#issuecomment-555379810" target="_blank" rel="noopener">How to prevent creating multiple releases when using a build matrix?</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://github.com/actions/upload-release-asset/issues/16#issuecomment-561257944" target="_blank" rel="noopener">Support matrix build</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一阵子 GitHub 正式发布了 &lt;a href=&quot;https://github.com/features/actions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Actions&lt;/a&gt; 功能来提供内置的持续集成和持续发布。而我正好最近在利用 Qt 写&lt;a href=&quot;https://github.com/miRoox/HIT-DigitalImageProcessing-Postgraduate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数字图像处理的作业&lt;/a&gt;，就想利用这个机会尝试一下基于 GitHub Actions 的持续集成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="GitHub" scheme="http://miRoox.github.io/blog/tags/GitHub/"/>
    
      <category term="Qt" scheme="http://miRoox.github.io/blog/tags/Qt/"/>
    
      <category term="持续集成" scheme="http://miRoox.github.io/blog/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们需要术语——兼谈科普的危害性</title>
    <link href="http://miroox.github.io/blog/2019/11/TerminologyAndPopularScience/"/>
    <id>http://miroox.github.io/blog/2019/11/TerminologyAndPopularScience/</id>
    <published>2019-11-05T13:03:42.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>写下这篇文章的起源是在知乎上看到的一个回答<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p><blockquote><p>很简单，就是硬抬杠。</p><p>举个例子，我说偶数跟正整数一样多，你就说怎么可能，正整数包含奇数和偶数，所以肯定正整数多。</p><p>我解释说偶数跟正整数存在一个一一映射，并且都含有无穷多元素，所以一样多。你就说我听不懂什么一一映射，我只知道我是你的两倍，所以肯定比你多。</p><p>那我解释，1对应2，2对应4，3对应6，一直这样下去，每个正整数都对应一个偶数。他就是不同意，说你说话就在放屁，我给你一百块，你给我两百块，一直这样我们看看最后谁的钱多？</p><p>我说这在有限的情况下是对的，但是无穷的情况下就不一定了。你就说无穷不就是特别大的数嘛，那我大一你倍不是大你更多？</p><p>我说wdnmd吧，你就说你怎么骂人呢？</p></blockquote><p>在这个回答里，作者似乎把对于无法将无穷集合的等势理解成“一样多”的普通人思维当作抬杠。但这件事就真的只是抬杠这么肤浅吗？</p><a id="more"></a><p>需要明确的是，“一样多”是自然语言的提法，不是一个严格的数学术语。基于基数的比较方式可以在有限的时候和我们平时说的一样多是一致的，因此我们将其推广到无穷意义下的一样多。但这个对应不是唯一的，我们可以构造另一个比较方式依然满足有限意义的“一样多”，却在无限集的比较晚得到不同的结果。比如：</p><p>不妨定义区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-a,a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span> 与集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span> 的交集的元素个数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N_A(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span> ，然后定义集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span> 和集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span></span></span></span> 的“元素比值”为</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>a</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></munder><mfrac><mrow><msub><mi>N</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>N</mi><mi>B</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">p(A,B)=\lim_{a\to\infty}\frac{N_A(a)}{N_B(a)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-.936em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.69444em"><span style="top:-2.1em;margin-left:0"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span><span style="top:-2.7em"><span class="pstrut" style="height:2.7em"></span><span><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.7em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.05017em">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.936em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>当“元素比值” <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p(A,B)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 时，则称集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.05017em">B</span></span></span></span> 的元素“一样多”。显然，这个定义在集合有限时和我们的认知依然是一致的，因此也可以作为“一样多”的一个推广。但如果拿来比较整数和偶数，结果则不会是“一样多”，而前者对后者的“元素比值”为2，似乎更符合我们的直观认识。</p><p>当然，上面这个定义显然不会是我们的数学所想要的。因为这个定义过于平凡了，以至于即使在面对像有理数集这样的可数集时也会无法定义，这与数学所追求最广泛意义上的一致性是相违背的。因而，“势”依然是对任意集合的大小进行度量的最佳方式，也是我们在数学中普遍采用的。但这一概念如果反过来作为日常用语中的“一样多”的替代，则无疑是术语的滥觞，只会令人更加迷惑，无益于辨清问题的边界。</p><p>也许一个来自数学自身的例子更能展现这种概念拓展的不唯一性：维数——我们有线性空间的维数（自由度）、拓扑维数乃至各式各样的分形维数，它们最初都来自我们日常对空间方位的直观认知。但它们都是在各自领域中抽象出来的概念，并不能简单地断言谁是一般意义上最佳的定义。</p><p>不过，概念的推广与取代在学术界内部确实广为存在，每一次取代本身可以认为是对概念更深刻的理解。虽说如此，明辨问题的边界和语境对业内人士同样重要，至少应该采取明确的上下文或者精准唯一的术语来进行描述。</p><p>如果说概念的泛化推广是抽象和发散思维的体现，那么划定专有术语和明晰边界则是具体和确定性的追求。这两点对于研究者而言都具有程度相当的重要性。如何在两者间取得平衡，对科研人员也并非易事，更遑论科普读物和它们的读者了。能把握住这当中的微妙的，大概《物理学咬文嚼字》尚且能算一个比较好的例子吧。</p><p>针对科普作品，19世纪伟大的物理学家麦克斯韦曾写下这样的忠告<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p><blockquote><p>In the popular treatise, whatever shreds of the science are allowed to appear, are exhibited in an exceedingly diffuse and attenuated form, apparently with the hope that the mental faculties of the reader, though they would reject any stronger food, may insensibly become saturated with scientific phraseology, provided it is diluted with a sufncient quantity of more familiar language. In this way, by simple reading, the student may become possessed of the phrases of the science without having been put to the trouble of thinking a single thought about it. The loss implied in such an acquisition can be estimated only by those who have been compelled to unlearn a science that they might at length begin to learn it.</p><p>The technical treatises do less harm, for no one ever reads them except under compulsion. From the establishment of the general equations to the end of the book, every page is full of symbols with indices and suffixes, so that there is not a paragraph of plain English on which the eye may rest.</p></blockquote><p>确实，科普读物对专业术语的稀释一定程度上也是对读者深入思维能力的一种伤害。进一步地，这种对术语的浅薄化，对业已进入专业行列的“原读者”乃至科普作者自身的辨析能力也会造成不经意的伤害；而这种伤害又反过来进一步拉大了科学概念与一般人之间的距离，令人以为这些被“通俗化”所粉饰的概念就一定能为大众所理解，构成现代科学版的“何不食肉糜”，不得不令人扼腕。</p><p>当然，科普工作也不尽然都是坏的。哪怕是稀释过的概念知识，倘若能抓住精要，不会因为注水过多而浅尝辄止，那么从科普中浸润的少量知识反而更能让人甘之如饴，激发探索深入的兴趣。只是，倘若能在科普中就更好的明辨当中的概念和术语，大概会减少那些因模糊的粉饰而对长远的研究道路所造成的伤害吧。</p><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.zhihu.com/question/338618946/answer/779204340" target="_blank" rel="noopener">如何激怒一位数学爱好者？ - 孙泰英的回答 - 知乎</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>MAXWELL J C. Tait’s “Thermodynamics”[J]. Nature, 1878, 17(431): 257–259. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写下这篇文章的起源是在知乎上看到的一个回答&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;很简单，就是硬抬杠。&lt;/p&gt;&lt;p&gt;举个例子，我说偶数跟正整数一样多，你就说怎么可能，正整数包含奇数和偶数，所以肯定正整数多。&lt;/p&gt;&lt;p&gt;我解释说偶数跟正整数存在一个一一映射，并且都含有无穷多元素，所以一样多。你就说我听不懂什么一一映射，我只知道我是你的两倍，所以肯定比你多。&lt;/p&gt;&lt;p&gt;那我解释，1对应2，2对应4，3对应6，一直这样下去，每个正整数都对应一个偶数。他就是不同意，说你说话就在放屁，我给你一百块，你给我两百块，一直这样我们看看最后谁的钱多？&lt;/p&gt;&lt;p&gt;我说这在有限的情况下是对的，但是无穷的情况下就不一定了。你就说无穷不就是特别大的数嘛，那我大一你倍不是大你更多？&lt;/p&gt;&lt;p&gt;我说wdnmd吧，你就说你怎么骂人呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在这个回答里，作者似乎把对于无法将无穷集合的等势理解成“一样多”的普通人思维当作抬杠。但这件事就真的只是抬杠这么肤浅吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈散记" scheme="http://miRoox.github.io/blog/categories/%E6%9D%82%E8%B0%88%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="杂谈" scheme="http://miRoox.github.io/blog/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="科普" scheme="http://miRoox.github.io/blog/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>如何提交函数到 Wolfram Function Repository</title>
    <link href="http://miroox.github.io/blog/2019/10/SubmitFunctionToWFR/"/>
    <id>http://miroox.github.io/blog/2019/10/SubmitFunctionToWFR/</id>
    <published>2019-10-12T07:23:32.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，你需要一个 <a href="https://account.wolfram.com/" target="_blank" rel="noopener">Wolfram 账户</a>。</p><a id="more"></a><p>然后，你需要<a href="https://datarepository.wolframcloud.com/request-publisher-id" target="_blank" rel="noopener">申请一个 Publisher ID</a>，这点在许多讲述提交函数到WFR的文章中都没提到。大致的申请流程可以在<a href="https://reference.wolfram.com/language/workflow/AcquireAResourceSystemPublisherID.html" target="_blank" rel="noopener">参考文档</a>里找到。</p><p>然后在 Mathematica 中新建一个函数知识库项。按<a href="https://resources.wolframcloud.com/FunctionRepository/style-guidelines" target="_blank" rel="noopener">风格指南</a>编写函数代码和文档。</p><p>提交前要检查 Mathematica 有没有登录到你的 Wolfram 账户，可以根据 <code>$WolframID</code> 的值确认。而且应该将 <code>$PublisherID</code> 的值设置为你申请到的 Publisher ID。</p><p>当然，提交之前还应该用菜单中的“Check”按钮检查格式无误后再提交。最后点击“Submit to Repository”，接下来就等邮件吧。无论 review 有没有通过一般都会发邮件进行通知。没有通过的话往往还会附上 review comments 指导你改进，并且可以完善后再提交更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，你需要一个 &lt;a href=&quot;https://account.wolfram.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wolfram 账户&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>尝试用TiddlyWiki搭建个人维基知识库</title>
    <link href="http://miroox.github.io/blog/2019/10/PersonalWiki/"/>
    <id>http://miroox.github.io/blog/2019/10/PersonalWiki/</id>
    <published>2019-10-10T12:44:23.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>搭建一个个人维基用来整理知识的想法早已有之，但具体该使用什么方案却迟迟没能定下来。在最初的想法里，我希望满足下面的几项需求：</p><ul><li>内容与表现分离</li><li>自动化构建</li><li>可以使用自己定制的模板</li><li>词条的分类灵活，以适应知识体系的逐渐完善</li><li>方便建立知识点（词条）间的联系</li><li>需要用笔记时能快速提取</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.89883em;vertical-align:-.2155em"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-.36em"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.68333em"><span style="top:-2.904999em"><span class="pstrut" style="height:2.7em"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-.15em"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-.1667em"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.46782999999999997em"><span style="top:-2.7845em"><span class="pstrut" style="height:3em"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2155em"><span></span></span></span></span><span class="mspace" style="margin-right:-.125em"></span><span class="mord textrm">X</span></span></span></span></span></span> 公式输入</li><li>代码块语法高亮</li></ul><a id="more"></a><p>作为参考，见过别人用 <a href="https://www.dokuwiki.org/dokuwiki" target="_blank" rel="noopener">Dokuwiki</a> 的，也有直接拿 Hexo 的 <a href="https://github.com/zthxxx/hexo-theme-Wikitten" target="_blank" rel="noopener">Wikitte</a> 主题搭建的，等等。当然，我自己也做过一些尝试，比如 <a href="https://www.zim-wiki.org/" target="_blank" rel="noopener">Zim Wiki</a> ，不过这个太简陋了，完全无法满足我的需求；甚至受 <a href="http://wuli.wiki/" target="_blank" rel="noopener">小时物理百科</a> 的影响，尝试过用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.89883em;vertical-align:-.2155em"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-.36em"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.68333em"><span style="top:-2.904999em"><span class="pstrut" style="height:2.7em"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-.15em"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-.1667em"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.46782999999999997em"><span style="top:-2.7845em"><span class="pstrut" style="height:3em"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2155em"><span></span></span></span></span><span class="mspace" style="margin-right:-.125em"></span><span class="mord textrm">X</span></span></span></span></span></span> 构建维基，但 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.89883em;vertical-align:-.2155em"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-.36em"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.68333em"><span style="top:-2.904999em"><span class="pstrut" style="height:2.7em"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-.15em"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-.1667em"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.46782999999999997em"><span style="top:-2.7845em"><span class="pstrut" style="height:3em"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2155em"><span></span></span></span></span><span class="mspace" style="margin-right:-.125em"></span><span class="mord textrm">X</span></span></span></span></span></span> 对于我的需求而言又稍显复杂了，而且大量交叉引用在PDF中也并不方便阅读。最后在一番比较和取舍之下选择了<a href="https://tiddlywiki.com/" target="_blank" rel="noopener">TiddlyWiki</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><p>TiddlyWiki，按官方说法是<a href="https://github.com/Jermolene/TiddlyWiki5#readme" target="_blank" rel="noopener">「一款非线性个人 Web 笔记本」</a>。相比其他笔记和 Wiki 系统，其最大的特点之一是程序本体和数据全部都在一个 html 文件内，这意味着组织和阅读多个词条可以在同一个页面内直接完成，内容的关联更加直接，方便互相比照。同时，还有着非常强大的条目管理功能和插件系统，可扩展性和可定制性都很强。</p><p>TiddlyWiki 的优点还有很多<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，这里就不多赘述了。就我而言，更想简单说一下 TiddlyWiki 是如何满足前面提到的几项需求的：</p><ul><li>内容与表现分离：<ul><li>这一项近乎是一种哲学理念，实践起来是否须要完全符合还是看具体情况。</li><li>典型地，<a href="http://www.tiddlywiki.cn/#WikiText" target="_blank" rel="noopener">WikiText</a> 就提供了很多特定语义的语法元素，还有宏、模板嵌入等各种自定义工具。</li><li>当然，经典地 HTML-CSS-JS 结构也是可以使用的。</li></ul></li><li>自动化构建：<ul><li>通过使用 Node.js 上的 <a href="http://www.tiddlywiki.cn/#Installing%20TiddlyWiki%20on%20Node.js" target="_blank" rel="noopener">TiddlyWiki</a> 服务可以在本地同步保存修改；</li><li>用 Git 和 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 实现向 Github Pages 自动部署。</li></ul></li><li>可以使用自己定制的模板：<ul><li>这一项其实是“内容与表现分离”的具体实践方法之一。</li><li>WikiText 支持模板条目和宏。</li></ul></li><li>词条的分类灵活，以适应知识体系的逐渐完善：<ul><li>TiddlyWiki 是基于标签分类的，一个词条可以分到多个标签下，这一点比许多按树状层级分类的方案要灵活得多。</li></ul></li><li>方便建立知识点（词条）间的联系：<ul><li>词条链接和词条嵌入。</li></ul></li><li>需要用笔记时能快速提取：<ul><li>能自动部署到网页上，有网就能看；</li><li>还有灵活的搜索语法。</li></ul></li><li>LaTeX公式输入：<ul><li>KaTeX插件：支持的命令较少，不过是官方提供的，安装很容易。</li><li><a href="http://mathjax-tw5.kantorsite.net/" target="_blank" rel="noopener">MathJax插件</a>：第三方提供的，比较老了，好像和新版不太兼容，需要折腾（反正我没能折腾成功）。</li></ul></li><li>代码块语法高亮<ul><li>Highlight.js插件：这也是官方提供的。</li></ul></li></ul><p>除此之外，TiddlyWiki 还有一大优点是简单，几乎所有操作都可以在网页上完成，基本不用到处配置。这对于我这种对web技术基本一无所知的人来说是一个极大的优势。</p><p>不过也因为我对web技术的不了解，导致很大的功夫都花在自动部署的配置上了，最终也只是是照猫画虎。其间主要参考了 alexashley 的个人Wiki源码<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>、JavaScript 标准参考教程（alpha）<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>、《Blog自动部署实践: Hugo + Travis CI -&gt; GitHub Pages》<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>等资料。</p><p>最终弄出来的成品在：<a href="https://miroox.github.io/wiki/">https://miroox.github.io/wiki/</a></p><hr><p>参考资料：</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="http://www.tiddlywiki.cn/" target="_blank" rel="noopener">TiddlyWiki中文网站</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="http://blog.dimpurr.com/tiddly-wiki/" target="_blank" rel="noopener">使用 TiddlyWiki 打造轻便个人 Wiki 知识库</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://github.com/alexashley/wiki" target="_blank" rel="noopener">alexashley 的个人Wiki源码</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="http://javascript.ruanyifeng.com/nodejs/packagejson.html" target="_blank" rel="noopener">package.json文件 - JavaScript 标准参考教程（alpha）</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://blog.yuantops.com/tech/hugo-travis-ci-auto-deploy-to-gh-pages/" target="_blank" rel="noopener">Blog自动部署实践: Hugo + Travis CI -&gt; GitHub Pages</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建一个个人维基用来整理知识的想法早已有之，但具体该使用什么方案却迟迟没能定下来。在最初的想法里，我希望满足下面的几项需求：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;内容与表现分离&lt;/li&gt;&lt;li&gt;自动化构建&lt;/li&gt;&lt;li&gt;可以使用自己定制的模板&lt;/li&gt;&lt;li&gt;词条的分类灵活，以适应知识体系的逐渐完善&lt;/li&gt;&lt;li&gt;方便建立知识点（词条）间的联系&lt;/li&gt;&lt;li&gt;需要用笔记时能快速提取&lt;/li&gt;&lt;li&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mtext&gt;LaTeX&lt;/mtext&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\LaTeX&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:.89883em;vertical-align:-.2155em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord text&quot;&gt;&lt;span class=&quot;mord textrm&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:-.36em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:.68333em&quot;&gt;&lt;span style=&quot;top:-2.904999em&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord text&quot;&gt;&lt;span class=&quot;mord textrm sizing reset-size6 size3&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:-.15em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord text&quot;&gt;&lt;span class=&quot;mord textrm&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:-.1667em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:.46782999999999997em&quot;&gt;&lt;span style=&quot;top:-2.7845em&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:3em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord text&quot;&gt;&lt;span class=&quot;mord textrm&quot;&gt;E&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:.2155em&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:-.125em&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord textrm&quot;&gt;X&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 公式输入&lt;/li&gt;&lt;li&gt;代码块语法高亮&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Wiki" scheme="http://miRoox.github.io/blog/tags/Wiki/"/>
    
      <category term="Web" scheme="http://miRoox.github.io/blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>MatrixForm赋值问题</title>
    <link href="http://miroox.github.io/blog/2019/09/MatrixFormProblem/"/>
    <id>http://miroox.github.io/blog/2019/09/MatrixFormProblem/</id>
    <published>2019-09-19T12:27:34.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，赋值等过程中使用 <code>MatrixForm</code> 往往会导致后续的计算失效。比如：</p><img src="/blog/2019/09/MatrixFormProblem/problem.svg" title="a &#x3D; { {1, 2}, {3, 4} } &#x2F;&#x2F; MatrixForm"><a id="more"></a><p>对于这个问题，最正统的解决办法当然是在赋值等计算过程中不使用 <code>MatrixForm</code>，而只在显示时以 <code>MatrixForm</code> 呈现<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。典型的方案是在输出部分才加上 <code>MatrixForm</code> 包装。不过对于既有代码的问题，一个个手动修改可能略显麻烦，这时可以借助 <code>EchoFunction</code> 在实现类似效果的同时保持代码结构基本不变：</p><img src="/blog/2019/09/MatrixFormProblem/solution-echo.svg" title="a &#x3D; { {1, 2}, {3, 4} } &#x2F;&#x2F; EchoFunction[MatrixForm];"><p>要将既有代码调整为这种方式，只需简单的文本替换就可以实现目标。</p><p>不过，本文要主要要谈的并不是这类传统解决方案，而是通过给 Mathematica 系统打上补丁来实现几乎零修改的解决方案。</p><p>我们知道，<code>MatrixForm</code> 这类格式封装，当它位于结果的<em>最外层</em>时，<code>Out</code> 输出历史中不会对其进行储存<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。事实上，所有在 <code>$OutputForms</code> 中的格式封装都具有这样的性质。</p><p>受此启发，我们不妨把这个性质推广到赋值的情况上来，即这类格式封装出现在赋值运算的右侧时不会将其记录到赋值中。事实上，通过重载 <code>Set</code> 的定义很容易实现这一功能：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GeneralUtilities`BlockProtected[&#123;<span class="keyword">Set</span>&#125;,</span><br><span class="line">  <span class="keyword">Set</span>[lhs_,(form:<span class="keyword">Alternatives</span>@@<span class="keyword">$OutputForms</span>)[rhs_]] := form@<span class="keyword">Set</span>[lhs,rhs]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>效果如图：</p><img src="/blog/2019/09/MatrixFormProblem/solution.svg" title="a &#x3D; { {1, 2}, {3, 4} } &#x2F;&#x2F; MatrixForm"><hr><p>参考：</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="http://people.math.umass.edu/~murray/Math_421_Eisenberg/Notes/Mathematica_Q___A/MatrixForm/matrixform.html" target="_blank" rel="noopener">Q&amp;A: Compute with MatrixForm</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://note.youdao.com/ynoteshare1/index.html?id=d0a57819857f2771ca669eb54819e3d1&amp;type=note" target="_blank" rel="noopener">为什么我的代码加了MatrixForm后就出问题了？</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，赋值等过程中使用 &lt;code&gt;MatrixForm&lt;/code&gt; 往往会导致后续的计算失效。比如：&lt;/p&gt;&lt;img src=&quot;/blog/2019/09/MatrixFormProblem/problem.svg&quot; title=&quot;a &amp;#x3D; { {1, 2}, {3, 4} } &amp;#x2F;&amp;#x2F; MatrixForm&quot;&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>基于规则的带步骤符号求导器</title>
    <link href="http://miroox.github.io/blog/2019/07/RuleBasedStepByStepDerivative/"/>
    <id>http://miroox.github.io/blog/2019/07/RuleBasedStepByStepDerivative/</id>
    <published>2019-07-12T14:27:17.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，<a href="https://www.wolframalpha.com" target="_blank" rel="noopener">Wolfram|Alpha</a> 有一个名为 <a href="https://www.wolframalpha.com/examples/pro-features/step-by-step-solutions/" target="_blank" rel="noopener">Step-by-Step Solutions</a> 的功能，可以显示一些数学问题求解的过程。又比如，著名的 <a href="https://rulebasedintegration.org/" target="_blank" rel="noopener">Rubi</a> 可以在求解积分的同时显示积分的求解步骤。实际上，这些系统背后大抵都是基于模式匹配和规则变换而实现的，因而原则上来说自己也可以实现一个。当然，就实践而言这些系统都过于复杂了，例如 Rubi 包含了超过六千条规则，其背后的原理远非三言两语可以阐明的。不过，相比于积分，微分的运算规则要简明得多，而且对规则的应用总是简单机械的，并不像积分那样可能会运用到各种技巧。因此，本文将利用 Mathematica 的模式匹配和规则实现一个带步骤符号求导器。</p><img src="/blog/2019/07/RuleBasedStepByStepDerivative/DvsInt.JPG" title="Differentiation vs Integration"><a id="more"></a><h3 id="求导规则"><a class="markdownIt-Anchor" href="#求导规则"></a> 求导规则</h3><p>实现的核心首先在于对求导法则的代码表示。由于 Rule-Based 也是 Wolfram 语言的基本范式，因此这些规则写起来也很直观。</p><p>首先是几个基本运算规则</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">baseRules=&#123;</span><br><span class="line">  d[c_,x_]/;<span class="keyword">FreeQ</span>[c,x]:&gt;<span class="number">0</span>,</span><br><span class="line">  d[lf_Plus,x_]:&gt;<span class="keyword">Thread</span>[d[lf,x],<span class="keyword">Plus</span>],</span><br><span class="line">  d[c_*f_,x_]/;<span class="keyword">FreeQ</span>[c,x]:&gt;c*d[f,x],</span><br><span class="line">  d[f_*g_,x_]:&gt;d[f,x]g+d[g,x]f</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，使用 <code>d[f,x]</code> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">d</mi><mi>f</mi></mrow><mrow><mi mathvariant="normal">d</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\tfrac{\mathrm{d}f}{\mathrm{d}x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.9322159999999999em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">d</span></span><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.446108em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">d</span></span><span class="mord mathdefault mtight" style="margin-right:.10764em">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。上述的代码表示了常数求导法则、线性求导法则和乘法求导法则的作用规则。</p><p>对于复合函数和反函数，需要一个间接的包装来表示类似 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(g(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 的情况，这里将其表示为<code>dfunc[f,gx]</code>类似的形式，其中<code>gx</code>对应于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">higherRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">InverseFunction</span>[f_][x_],x_]:&gt;<span class="number">1</span>/dfunc[f,<span class="keyword">InverseFunction</span>[f][x]],</span><br><span class="line">  d[f_[g_],x_]/;g=!=x:&gt;dfunc[f,g]d[g,x],</span><br><span class="line">  d[f_[g_,c_],x_]/;<span class="keyword">FreeQ</span>[c,x]&amp;&amp;g=!=x:&gt;dfunc[f[#,c]&amp;,g]d[g,x],</span><br><span class="line">  d[f_[c_,g_],x_]/;<span class="keyword">FreeQ</span>[c,x]&amp;&amp;g=!=x:&gt;dfunc[f[c,#]&amp;,g]d[g,x]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，为了避免问题过于复杂化，这里求导的对象都只限于初等函数。因此在考虑复合函数的链导法则时实际不包含多元函数。对于可能遇到地二元初等函数，要么其中一个参数与自变量无关，本质还是一元函数，要么可以通过变形转化成一元形式。</p><p>此外还有一点需要注意，在链式法则的规则中，模式条件<code>g=!=x</code>是必要的，否则可能陷入无限自递归的窘境。</p><p>在上面的高阶（反函数、复合函数）规则中，<code>dfunc</code>只是徒具形式的一个表示。为了确实有效地计算这种情况，还需要引入一个替换规则。即在计算得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span></span></span></span>后，再进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>→</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u\to g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>的变量替换。直接表达出来就比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;d[f[u],u]/.&#123;u-&gt;g&#125;;</span><br></pre></td></tr></table></figure><p>不过这种写法当遇到函数<code>f</code>本身蕴含名为<code>u</code>的参量时就可能会出现错误的结果。因而需要使用<code>Module</code>来引入哑元形式，即</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,d[f[u],u]/.&#123;u-&gt;g&#125;];</span><br></pre></td></tr></table></figure><p>但这是错误的。因为我们希望在计算出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>后再做变量替换。但上面的实现中，<code>d[f[u],u]</code>本身并不会求值，而是通过应用这些规则进行替换而得到的计算结果，从而导致替换发生在计算导数之前，那样就没有意义了。因此需要一个<code>d</code>的立即求值版，命名为<code>dEval</code>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,dEval[f[u],u]/.&#123;u-&gt;g&#125;];</span><br></pre></td></tr></table></figure><p>关于<code>dEval</code>的实现，一个粗浅的想法是在完成全部规则的定义后，对输入按这些规则进行<code>ReplaceRepeated</code>。当然，这其中还需要一些细节，我们这里暂且按下不表，留待后面再讨论。</p><p>接下来就是对具体函数的求导规则进行列举，比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>[d[<span class="keyword">IgnoringInactive</span>[<span class="keyword">Exp</span>[x_]],x_]]:&gt;<span class="keyword">Exp</span>[x],</span><br><span class="line">  <span class="keyword">HoldPattern</span>[d[<span class="keyword">IgnoringInactive</span>[<span class="keyword">Log</span>[x_]],x_]]:&gt;<span class="number">1</span>/x,</span><br><span class="line">  <span class="keyword">HoldPattern</span>[d[<span class="keyword">IgnoringInactive</span>[<span class="keyword">Sin</span>[x_]],x_]]:&gt;<span class="keyword">Cos</span>[x],</span><br><span class="line">  <span class="keyword">HoldPattern</span>[d[<span class="keyword">IgnoringInactive</span>[<span class="keyword">Cos</span>[x_]],x_]]:&gt;-<span class="keyword">Sin</span>[x]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一个个手动枚举也比较繁琐，因此我们不妨利用 Mathematica 既有的求导功能来生成结果</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">functionRules=<span class="keyword">Table</span>[</span><br><span class="line">  <span class="keyword">With</span>[&#123;f=f&#125;,<span class="keyword">HoldPattern</span>@d[<span class="keyword">IgnoringInactive</span>@f[x_],x_]]-&gt;D[f[x],x],</span><br><span class="line">  &#123;f,&#123;</span><br><span class="line">    <span class="keyword">Sqrt</span>,<span class="keyword">CubeRoot</span>,<span class="keyword">RealAbs</span>,</span><br><span class="line">    <span class="keyword">Exp</span>,<span class="keyword">Log</span>,<span class="keyword">Log2</span>,<span class="keyword">Log10</span>,</span><br><span class="line">    <span class="keyword">Sin</span>,<span class="keyword">Cos</span>,<span class="keyword">Tan</span>,<span class="keyword">Cot</span>,<span class="keyword">Sec</span>,<span class="keyword">Csc</span>,</span><br><span class="line">    <span class="keyword">ArcSin</span>,<span class="keyword">ArcCos</span>,<span class="keyword">ArcTan</span>,<span class="keyword">ArcCot</span>,<span class="keyword">ArcSec</span>,<span class="keyword">ArcCsc</span>,</span><br><span class="line">    <span class="keyword">Sinh</span>,<span class="keyword">Cosh</span>,<span class="keyword">Tanh</span>,<span class="keyword">Coth</span>,<span class="keyword">Sech</span>,<span class="keyword">Csch</span>,</span><br><span class="line">    <span class="keyword">ArcSinh</span>,<span class="keyword">ArcCosh</span>,<span class="keyword">ArcTanh</span>,<span class="keyword">ArcCoth</span>,<span class="keyword">ArcSech</span>,<span class="keyword">ArcCsch</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]/.&#123;<span class="keyword">Rule</span>-&gt;<span class="keyword">RuleDelayed</span>&#125;;</span><br></pre></td></tr></table></figure><p>除了这些可以直接表示的一元函数，还有一些形式上是二元函数的一元函数情况，这里简单列举一下</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">functionExtRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[x_^a_.,x_]/;<span class="keyword">FreeQ</span>[a,x]:&gt;a x^(a<span class="number">-1</span>),</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[a_^x_,x_]/;<span class="keyword">FreeQ</span>[a,x]:&gt;a^x <span class="keyword">Log</span>[a],</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">IgnoringInactive</span>@<span class="keyword">Surd</span>[x_,n_],x_]/;<span class="keyword">FreeQ</span>[n,x]:&gt;<span class="number">1</span>/(n <span class="keyword">Surd</span>[x,n]^(n<span class="number">-1</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>稍微值得一提的是，由于<code>Power</code>的<code>OneIdentity</code>属性，模式<code>x_^a_.</code>也会直接匹配<code>x</code>这种情况。</p><p>除此之外，还有一些二元函数可以通过变形得到上述一元函数的组合</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transferRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">IgnoringInactive</span>[f_^g_],x_]/;!(<span class="keyword">FreeQ</span>[f,x]||<span class="keyword">FreeQ</span>[g,x]):&gt;d[<span class="keyword">Inactive</span>[<span class="keyword">Exp</span>][<span class="keyword">Log</span>[f]g],x],</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">IgnoringInactive</span>@<span class="keyword">Log</span>[f_,g_],x_]:&gt;d[<span class="keyword">Log</span>[g]/<span class="keyword">Log</span>[f],x]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>Inactive[Exp]</code>是为了抑制指数函数的内置化简规则。也正是为了方面使用<code>Inactive</code>控制变形的方向，前面的函数求导规则的模式中都包含了<code>IgnoringInactive</code>。</p><p>这样，一个囊括了初等函数的符号求导规则就全部完成了。<br>最后将所有规则整合到一起</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allRules=<span class="keyword">Flatten</span>@&#123;</span><br><span class="line">  transferRules,</span><br><span class="line">  baseRules,</span><br><span class="line">  functionRules,</span><br><span class="line">  functionExtRules,</span><br><span class="line">  substRules,</span><br><span class="line">  higherRules</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果只需要进行求导计算，那么直接对输入按这些规则进行替换即可</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dEval[f_,x_]:=d[f,x]//.allRules</span><br></pre></td></tr></table></figure><p>举一个简单的例子测试一下</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(dEval==D)[(x^<span class="keyword">Sin</span>[x]+<span class="number">3</span>x+<span class="keyword">ArcTan</span>[x])^<span class="number">2</span>/(x^<span class="number">4</span><span class="number">-3</span><span class="keyword">Surd</span>[x^<span class="number">5</span>,<span class="number">3</span>]<span class="keyword">RealAbs</span>@<span class="keyword">Log</span>[x]+<span class="number">2</span>),x]//<span class="keyword">Through</span>//<span class="keyword">Simplify</span></span><br><span class="line"><span class="comment">(*Out: True*)</span></span><br></pre></td></tr></table></figure><p>也就是说利用这些规则已经可以实现对初等函数的求导运算了。然而，假如输入的待求导函数不只包含初等函数，那么<code>dEval</code>就无法完全计算，得到的结果中会包含错误的形式。诚然，我们的目标只在解决初等函数的求导，对于初等函数以外的情况无法解决也是正常的，不过从健壮性的角度考虑，这里最好再增加一个条件以避免某些可能出现的潜在问题。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,</span><br><span class="line">  <span class="keyword">With</span>[&#123;df=dEval[f[u],u]&#125;,</span><br><span class="line">    (df/.&#123;u-&gt;g&#125;)/;<span class="keyword">FreeQ</span>[df,_d|_dfunc]</span><br><span class="line">  ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>这里利用作用域里的条件模式来保证遇到<code>dEval</code>无法解决的情况时会保持既有的<code>dfunc</code>形式不变。可以试试下面的代码测试一下效果</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dEval[<span class="keyword">Erf</span>[<span class="keyword">Sin</span>[x]]^<span class="number">2</span>,x]</span><br></pre></td></tr></table></figure><h3 id="步骤回显"><a class="markdownIt-Anchor" href="#步骤回显"></a> 步骤回显</h3><p>然后是对计算步骤的输出显示。我们希望将替换的每一步都显示出来，因此不能直接使用<code>//.</code>，而应该使用<code>NestWhile</code>之类的方式对每次替换获得更精确的控制。在输出显示上，用<code>CellPrint</code>比较方便，也比单纯的<code>Print</code>好控制格式。</p><p>首先，对于输出步骤的每个单元，我们希望前面有一个<code>=</code>标记，就像<code>Echo</code>产生的单元前的<code>&gt;&gt;</code>标志符一样。这一点可以利用<code>CellDingbat</code>实现：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echoStep[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[removeLabels@expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellDingbat</span>-&gt;<span class="keyword">Cell</span>[<span class="string">"="</span>,<span class="string">"EchoLabel"</span>]];</span><br><span class="line">  expr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后，与之类似地，还需要一个函数输出显示最初地状态作为等式的起点。需要注意的是，为了比较好地对齐，需要对两者使用不同的边距：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echoStep0[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>, <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br><span class="line">echoStep[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellDingbat</span>-&gt;<span class="keyword">Cell</span>[<span class="string">"="</span>,<span class="string">"EchoLabel"</span>],</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>, <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>进一步地，考虑到复合函数求导时需要转入对其它函数求导的过程，这将打断正在进行的求导步骤间的顺叙关系，从逻辑上进入更深的层级。为了表现这种层级关系，这里同样通过调整边距实现。引入一个层级标志量<code>$dDepth</code>：每当计算<code>dEval</code>时都增加这一标志量，结束时就将其还原；同时利用<code>$dDepth</code>控制边距以实现对边距的适应调整。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$dDepth=<span class="number">0</span>;</span><br><span class="line">echoStep0[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>($dDepth<span class="number">-1</span>), <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br><span class="line">echoStep[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellDingbat</span>-&gt;<span class="keyword">Cell</span>[<span class="string">"="</span>,<span class="string">"EchoLabel"</span>],</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>$dDepth, <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dEval[f_,x_]:=<span class="keyword">Block</span>[&#123;$dDepth=$dDepth+<span class="number">1</span>&#125;,dEvalR[f,x]]</span><br><span class="line">dEvalR[f_,x_]:=<span class="keyword">NestWhile</span>[echoStep@*<span class="keyword">ReplaceAll</span>[allRules],echoStep0[d[f,x]],!<span class="keyword">FreeQ</span>[#<span class="number">2</span>,_d|_dfunc]&amp;&amp;<span class="keyword">UnsameQ</span>[##]&amp;,<span class="number">2</span>]</span><br><span class="line">stepD[f_,x_]:=<span class="keyword">With</span>[&#123;eval=dEval[f,x]&#125;,eval/;<span class="keyword">FreeQ</span>[eval,_d|_dfunc]]</span><br></pre></td></tr></table></figure><p>这里将具体的求导运算过程委托到<code>dEvalR</code>函数上，利用以是否存在未完成的求导形式为基本判据，同时辅以不变性作为无法完成时的终止条件。再把<code>stepD</code>作为封装的外部接口，通过条件模式限制，在失败时保持输入形式，避免内部<code>dfunc</code>等内部符号暴露到输出中。</p><p>测试一下</p><img src="/blog/2019/07/RuleBasedStepByStepDerivative/echo-step.svg" title="DiffereEcho Step"><h3 id="润色外观"><a class="markdownIt-Anchor" href="#润色外观"></a> 润色外观</h3><p>可以看到步骤显示中的输出形式很难看。为了增加步骤的可读性，我们可以通过自定义显示格式来润色外观。考虑我们本身使用的代码结构，将公式输出为Leibniz符号的形式比较方便。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">d/:<span class="keyword">MakeBoxes</span>[d[f_,x_],<span class="keyword">TraditionalForm</span>]:=<span class="keyword">Module</span>[&#123;boxes&#125;,</span><br><span class="line">  boxes=<span class="keyword">MakeBoxes</span>[f, <span class="keyword">TraditionalForm</span>];</span><br><span class="line">  <span class="keyword">If</span>[<span class="keyword">Precedence</span>[<span class="keyword">Plus</span>]&gt;=<span class="keyword">Precedence</span>[boxes,<span class="keyword">TraditionalForm</span>],boxes=<span class="keyword">RowBox</span>[&#123;<span class="string">"("</span>, boxes, <span class="string">")"</span>&#125;]];</span><br><span class="line">  <span class="keyword">RowBox</span>[&#123;<span class="keyword">FractionBox</span>[<span class="string">"\[DifferentialD]"</span>, <span class="keyword">RowBox</span>[&#123;<span class="string">"\[DifferentialD]"</span>, <span class="keyword">MakeBoxes</span>[x, <span class="keyword">TraditionalForm</span>]&#125;]], boxes&#125;]</span><br><span class="line">]</span><br><span class="line">dfunc/:<span class="keyword">MakeBoxes</span>[dfunc[f_, g_], <span class="keyword">TraditionalForm</span>]:=<span class="keyword">Module</span>[&#123;fboxes, gboxes&#125;,</span><br><span class="line">  fboxes=<span class="keyword">ToBoxes</span>[f[g], <span class="keyword">TraditionalForm</span>]; gboxes=<span class="keyword">ToBoxes</span>[g, <span class="keyword">TraditionalForm</span>];</span><br><span class="line">  <span class="keyword">If</span>[<span class="keyword">Precedence</span>[<span class="keyword">Plus</span>]&gt;=<span class="keyword">Precedence</span>[fboxes, <span class="keyword">TraditionalForm</span>],fboxes=<span class="keyword">RowBox</span>[&#123;<span class="string">"("</span>, fboxes, <span class="string">")"</span>&#125;]];</span><br><span class="line">  <span class="keyword">If</span>[<span class="keyword">Precedence</span>[<span class="keyword">Plus</span>]&gt;=<span class="keyword">Precedence</span>[gboxes, <span class="keyword">TraditionalForm</span>],gboxes=<span class="keyword">RowBox</span>[&#123;<span class="string">"("</span>, gboxes, <span class="string">")"</span>&#125;]];</span><br><span class="line">  <span class="keyword">FractionBox</span>[<span class="keyword">RowBox</span>[&#123;<span class="string">"\[DifferentialD]"</span>, fboxes&#125;], <span class="keyword">RowBox</span>[&#123;<span class="string">"\[DifferentialD]"</span>, gboxes&#125;]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后对于被<code>Module</code>局域化符号的显示，像<code>u$nnn</code>这样的形式显然不太好看，在这里也可以给出一个美化模板，它将这类符号的输出形式显示为首字母</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeXForm[sym_Symbol]:=sym/:<span class="keyword">MakeBoxes</span>[sym,<span class="keyword">TraditionalForm</span>]=<span class="keyword">ToBoxes</span>[<span class="keyword">Symbol</span>[<span class="keyword">StringPart</span>[<span class="keyword">SymbolName</span>[sym],<span class="number">1</span>]],<span class="keyword">TraditionalForm</span>]</span><br></pre></td></tr></table></figure><p>再用在替换规则中</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,</span><br><span class="line">  makeXForm[u];</span><br><span class="line">  <span class="keyword">With</span>[&#123;df=dEval[f[u],u]&#125;,</span><br><span class="line">    (df/.&#123;u-&gt;g&#125;)/;<span class="keyword">FreeQ</span>[df,_d|_dfunc]</span><br><span class="line">  ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>得到的结果就更接近于数学中的写法了</p><img src="/blog/2019/07/RuleBasedStepByStepDerivative/format.svg" title="DiffereEcho Format"><h3 id="标注步骤"><a class="markdownIt-Anchor" href="#标注步骤"></a> 标注步骤</h3><p>最后，我们还希望给每一步中所使用的特殊规则标注名称，方便理解各个步骤到底做了什么。比如 “乘法法则” “链式法则” 这样的注解。我们首先将这些注解都标记在求导的规则中</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">baseRules=&#123;</span><br><span class="line">  d[c_,x_]/;<span class="keyword">FreeQ</span>[c,x]:&gt;dLabeled[<span class="number">0</span>,<span class="string">"Constant Rule"</span>],</span><br><span class="line">  d[lf_Plus,x_]:&gt;dLabeled[<span class="keyword">Thread</span>[d[lf,x],<span class="keyword">Plus</span>],<span class="string">"Linearity Rule"</span>],</span><br><span class="line">  d[c_*f_,x_]/;<span class="keyword">FreeQ</span>[c,x]:&gt;dLabeled[c*d[f,x],<span class="string">"Linearity Rule"</span>],</span><br><span class="line">  d[f_*g_,x_]:&gt;dLabeled[d[f,x]g+d[g,x]f,<span class="string">"Product Rule"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">higherRules=&#123;</span><br><span class="line">  <span class="keyword">HoldPattern</span>@d[<span class="keyword">InverseFunction</span>[f_][x_],x_]:&gt;dLabeled[<span class="number">1</span>/dfunc[f,<span class="keyword">InverseFunction</span>[f][x]],<span class="string">"Inverse Function Rule"</span>],</span><br><span class="line">  d[f_[g_],x_]/;g=!=x:&gt;dLabeled[dfunc[f,g]d[g,x],<span class="string">"Chain Rule"</span>],</span><br><span class="line">  d[f_[g_,c_],x_]/;<span class="keyword">FreeQ</span>[c,x]&amp;&amp;g=!=x:&gt;dLabeled[dfunc[f[#,c]&amp;,g]d[g,x],<span class="string">"Chain Rule"</span>],</span><br><span class="line">  d[f_[c_,g_],x_]/;<span class="keyword">FreeQ</span>[c,x]&amp;&amp;g=!=x:&gt;dLabeled[dfunc[f[c,#]&amp;,g]d[g,x],<span class="string">"Chain Rule"</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有链式法则使用时，替换后的变元原本指代的是什么也应该标记出来，以方便阅读和理解。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">substRules=dfunc[f_,g_]:&gt;<span class="keyword">Module</span>[&#123;u&#125;,</span><br><span class="line">  makeXForm[u];</span><br><span class="line">  <span class="keyword">With</span>[</span><br><span class="line">    &#123;df=dEval[dLabeled[f[u],<span class="keyword">Row</span>@&#123;<span class="string">"where "</span>,<span class="keyword">TraditionalForm</span>[u==g]&#125;],u]&#125;,</span><br><span class="line">    (df/.&#123;u-&gt;g&#125;)/;<span class="keyword">FreeQ</span>[df,_d|_dfunc]</span><br><span class="line">  ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>有了规则中的标记，我们就需要能够从表达式里将标记都提取出来的方法。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getLabels[expr_]:=<span class="keyword">With</span>[</span><br><span class="line">  &#123;lbs=<span class="keyword">DeleteDuplicates</span>@<span class="keyword">Cases</span>[expr,dLabeled[_,lb_]:&gt;lb,&#123;<span class="number">0</span>,<span class="keyword">Infinity</span>&#125;]&#125;,</span><br><span class="line">  <span class="keyword">Row</span>@<span class="keyword">Flatten</span>@&#123;<span class="string">"("</span>,<span class="keyword">Riffle</span>[lbs,<span class="string">"; "</span>],<span class="string">")"</span>&#125;/;lbs=!=&#123;&#125;</span><br><span class="line">]</span><br><span class="line">getLabels[_]=<span class="string">""</span>;</span><br></pre></td></tr></table></figure><p>注意一步计算可以会运用多个规则，输出应该为分割得到的一组。同时，对于重复项最好也应该删除。</p><p>而这些<code>dLabeled</code>标记形式本身不应出现在求导的过程中，所以应该在每步计算完成后移除</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeLabels[expr_]:=expr/.&#123;dLabeled[e_,_]:&gt;e&#125;</span><br></pre></td></tr></table></figure><p>然后在输出时，注解通过<code>CellFrameLabels</code>显示在每个单元的右侧。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">echoStep0[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[removeLabels@expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>($dDepth<span class="number">-1</span>), <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;,</span><br><span class="line">    <span class="keyword">CellFrameLabels</span>-&gt;&#123;&#123;<span class="keyword">None</span>,<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>@<span class="keyword">ToBoxes</span>@getLabels[expr],<span class="string">"MessageText"</span>]&#125;,&#123;<span class="keyword">None</span>,<span class="keyword">None</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br><span class="line">echoStep[expr_]:=(</span><br><span class="line">  <span class="keyword">CellPrint</span>@<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>[<span class="keyword">FormBox</span>[<span class="keyword">ToBoxes</span>[removeLabels@expr,<span class="keyword">TraditionalForm</span>],<span class="keyword">TraditionalForm</span>]],<span class="string">"Print"</span>,</span><br><span class="line">    <span class="keyword">CellDingbat</span>-&gt;<span class="keyword">Cell</span>[<span class="string">"="</span>,<span class="string">"EchoLabel"</span>],</span><br><span class="line">    <span class="keyword">CellMargins</span>-&gt;&#123;&#123;<span class="keyword">Inherited</span>+<span class="number">20</span>$dDepth, <span class="keyword">Inherited</span>&#125;,&#123;<span class="keyword">Inherited</span>,<span class="keyword">Inherited</span>&#125;&#125;,</span><br><span class="line">    <span class="keyword">CellFrameLabels</span>-&gt;&#123;&#123;<span class="keyword">None</span>,<span class="keyword">Cell</span>[<span class="keyword">BoxData</span>@<span class="keyword">ToBoxes</span>@getLabels[expr],<span class="string">"MessageText"</span>]&#125;,&#123;<span class="keyword">None</span>,<span class="keyword">None</span>&#125;&#125;];</span><br><span class="line">  expr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最后将这些过程添加到计算的每一步中</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dEvalR[f_,x_]:=<span class="keyword">NestWhile</span>[</span><br><span class="line">  removeLabels@*echoStep@*<span class="keyword">ReplaceAll</span>[allRules],</span><br><span class="line">  removeLabels@echoStep0[d[f,x]],</span><br><span class="line">  !<span class="keyword">FreeQ</span>[#<span class="number">2</span>,_d|_dfunc]&amp;&amp;<span class="keyword">UnsameQ</span>[##]&amp;,<span class="number">2</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>就大功告成了。</p><p>简单测试一下</p><img src="/blog/2019/07/RuleBasedStepByStepDerivative/label.svg" title="DiffereEcho Label"><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>最终整理得到的完整代码放在 <a href="https://github.com/miRoox/DStep/blob/master/DStep.wl" target="_blank" rel="noopener">Github</a> 上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，&lt;a href=&quot;https://www.wolframalpha.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wolfram|Alpha&lt;/a&gt; 有一个名为 &lt;a href=&quot;https://www.wolframalpha.com/examples/pro-features/step-by-step-solutions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Step-by-Step Solutions&lt;/a&gt; 的功能，可以显示一些数学问题求解的过程。又比如，著名的 &lt;a href=&quot;https://rulebasedintegration.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rubi&lt;/a&gt; 可以在求解积分的同时显示积分的求解步骤。实际上，这些系统背后大抵都是基于模式匹配和规则变换而实现的，因而原则上来说自己也可以实现一个。当然，就实践而言这些系统都过于复杂了，例如 Rubi 包含了超过六千条规则，其背后的原理远非三言两语可以阐明的。不过，相比于积分，微分的运算规则要简明得多，而且对规则的应用总是简单机械的，并不像积分那样可能会运用到各种技巧。因此，本文将利用 Mathematica 的模式匹配和规则实现一个带步骤符号求导器。&lt;/p&gt;&lt;img src=&quot;/blog/2019/07/RuleBasedStepByStepDerivative/DvsInt.JPG&quot; title=&quot;Differentiation vs Integration&quot;&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="符号计算" scheme="http://miRoox.github.io/blog/tags/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>关于LaTeX插入矢量图的格式问题</title>
    <link href="http://miroox.github.io/blog/2019/07/FormatOfVectorInLaTeX/"/>
    <id>http://miroox.github.io/blog/2019/07/FormatOfVectorInLaTeX/</id>
    <published>2019-07-09T06:51:22.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，外部插入矢量图图尽量使用 PDF 格式，以避免生成时的转换。</p><blockquote><p><strong>只要输出介质为pdf，那么使用PSTricks和eps插图都是陋习。</strong></p><p><strong>如果输出介质为pdf，那么所有eps都需要转换为pdf后插入。</strong></p><p>之所以需要转换，是因为pdfTeX/LuaTeX不带任何PostScript解释器，所以一定要转换成pdf才能插图。而pTeX/XeTeX，则通常需要使用dvipdfmx输出pdf，在用到PostScript代码的时候，即PSTricks和eps图，都会通过管道使用GhostScript转换，这也是拖慢dvipdfmx的一个主要原因。</p><p>当然，很多编辑部的期刊模板都要求是eps图，甚至是png都要求转成eps（里面其实还是点阵图）。这时候，eps文件留给他们解决，自己该用什么用什么。</p><p>这都2018年了，别想不开老是用eps图。</p></blockquote><p>来自 <a href="https://www.zhihu.com/question/284593369/answer/438941492" target="_blank" rel="noopener">为什么 用TeXstudio在 XeLaTeX下eps图片不显示, pdflatex下反而可以 ? - 李阿玲的回答 - 知乎</a></p>]]></content>
    
    <summary type="html">
    
      只要输出介质为pdf，就不要使用 eps 和 PSTricks 插图
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="LaTeX" scheme="http://miRoox.github.io/blog/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>如何在Wolfram语言里造一个Wolfram语言风格的对象</title>
    <link href="http://miroox.github.io/blog/2019/05/WLStyleObject/"/>
    <id>http://miroox.github.io/blog/2019/05/WLStyleObject/</id>
    <published>2019-05-06T14:27:17.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做 <a href="https://github.com/miRoox/ComputationalOptics" target="_blank" rel="noopener">ComputationalOptics包</a> 的时候为了把 <a href="https://github.com/miRoox/ComputationalOptics/blob/1197dbf20758271c93acdbc4f780913443847b95/ComputationalOptics/Kernel/LightField.m" target="_blank" rel="noopener"><code>LightField</code></a> 实现为一个比较典型的Wolfram语言风格的对象，使用了很多undocumented方法，这里主要是做一下记录。</p><p>需要注意的是，这里的“对象”不是指“面向对象”里所说的对象（虽然也有点关系），而是类似于 <a href="http://reference.wolfram.com/language/ref/Entity.html" target="_blank" rel="noopener"><code>Entity</code></a> 或者 <a href="http://reference.wolfram.com/language/ref/TemporalData.html" target="_blank" rel="noopener"><code>TemporalData</code></a> 这类的对象。</p><a id="more"></a><p>这里就以前面提到的<code>LightField</code>为例说明一下如何造一个WL风格的对象。首先，分析需求，来看看预期要实现的效果：</p><img src="/blog/2019/05/WLStyleObject/result.png" title="result"><p>首先能看到的是<code>LightField</code>对象在输出时显示为一个类似于<a href="http://reference.wolfram.com/language/ref/SparseArray.html" target="_blank" rel="noopener"><code>SparseArray</code></a>那样的一个摘要框；然后，对象的属性可以通过函数参数的形式读写访问，而且对写入数据参数还会进行检查，这一点应该是WL风格的对象最核心的特征；最后，对象是能被认为是一个原子对象，这点实质是一种封装，可以避免直接用表达式的部分操作来访问对象内容，同样类似<code>SparseArray</code>。</p><p>进行具体实现前，最基本的，<code>LightField</code>对象数据的组织结构需要确定下来。这里采用的是<code>LightField[type_String, props_Association]</code>的模式，主要是考虑到这种表达式结构在表达光场信息的时候能具有较好的泛化能力。上面的<code>type</code>用来标记光场描述的类型（比如单色平面复振幅），而<code>props</code>则是描述光场所需的具体属性，以关联容器的方式组织数据内容。当然，这些含义对本文而言并不是重点，但也是对象设计和实现中最基本最重要的一步。</p><p>然后是对属性的读写的实现。单纯的读操作实现起来并不困难，不过需要注意的一点是我们接下来还要将对象转化为原子的，因此不能直接将问题变为利用<code>[[]]</code>提取部分。</p><p>我们知道，复数<code>Complex</code>也是原子的，它虽然不能直接对部分进行提取，但可以利用模式匹配来获得实部和虚部。基于同样的原理，读属性的核心实现长这样</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getProperty[<span class="keyword">HoldPattern</span>@LightField[_,props_],prop_]:=<span class="keyword">Lookup</span>[</span><br><span class="line">  props,prop,</span><br><span class="line">  <span class="keyword">Message</span>[LightField::ptprop,prop];<span class="keyword">Missing</span>[<span class="string">"NotAvailable"</span>,prop]</span><br><span class="line">]</span><br><span class="line">(obj_LightField?LightFieldQ)[prop_]:=getProperty[obj,prop]</span><br></pre></td></tr></table></figure><p>这其中，<code>LightFieldQ</code>是一个基于模式匹配判断输入是否为格式正确的<code>LightField</code>对象的函数。毕竟，如果基本格式都不正确的话，后面的模式匹配获取部分也无从谈起。</p><p>而写方法在wolfram语言寻常的语法上就非常困难了，因为WL概念上并不存在引用或者指针这一类东西，符号本身几乎总是充当引用的作用，但在形如<code>a[&quot;Wavelength&quot;] = xxx</code>的表达式里，左侧表达式并不是一个符号，而这种形式常常会将定义关联到符号<code>a</code>的下值中，也就是我们常见的函数定义方式。那么怎么让计算上述形式表达式的时候把它当做一个类似于部分赋值的方式进行处理呢？</p><p>一个非常自然地想法可能是对<code>LightField</code>赋予上值，不过很遗憾的是这种方案必然是不可行的，因为可变性意味着参数必须以保持的形式传递符号，那么在模式匹配的阶段必然没有机会接触到需要匹配的<code>LightField</code>，这样上值的关联就无法成立。</p><p>另一种想法则是<code>Unprotect[Set]</code>后添加赋值规则，比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>[(sym_Symbol?LightFieldQ)[prop_],val_]:=...</span><br></pre></td></tr></table></figure><p>这的确不失为一种解决办法，但这一方法实在有些太笨重了。这会导致所有满足模式<code>sym_Symbol[prop_]=val_</code>的代码都还要用<code>LightFieldQ</code>检查一遍，无论<code>sym</code>中是否隐含着<code>LightField</code>。</p><p>尝试下面的代码，感受一下鬼畜的效果</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gQ[_g]:=(<span class="keyword">Print</span>[<span class="string">"Ok"</span>];<span class="keyword">True</span>)</span><br><span class="line">gQ[_]:=(<span class="keyword">Print</span>[<span class="string">"Oops"</span>];<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">Unprotect</span>[<span class="keyword">Set</span>];</span><br><span class="line"><span class="keyword">Set</span>[(sym_Symbol?gQ)[prop_],val_]:=(<span class="keyword">Print</span>[<span class="keyword">Unevaluated</span>[sym[prop]],<span class="string">"="</span>,val])</span><br><span class="line"><span class="keyword">Protect</span>[<span class="keyword">Set</span>];</span><br><span class="line"><span class="keyword">Do</span>[a[<span class="number">1</span>]=<span class="number">1</span>,&#123;a,&#123;<span class="number">1</span>,&lt;||&gt;,g[]&#125;&#125;]</span><br></pre></td></tr></table></figure><p>（记得清除<code>Set</code>的附加定义）</p><p>因而我们需要一个更好的解决办法，这就是<code>Language`SetMutationHandler</code>，它的基本用法可以参见下面的相关资料，基本上照葫芦画瓢就行。作为对照，这里给一个与前述<code>Unprotect</code>方法完全类似测试代码</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fQ[_f]:=(<span class="keyword">Print</span>[<span class="string">"Ok"</span>];<span class="keyword">True</span>)</span><br><span class="line">fQ[_]:=(<span class="keyword">Print</span>[<span class="string">"Oops"</span>];<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">SetAttributes</span>[mutationHandler,<span class="keyword">HoldAllComplete</span>]</span><br><span class="line">mutationHandler[<span class="keyword">Set</span>[(sym_Symbol?fQ)[prop_],val_]]:=(<span class="keyword">Print</span>[<span class="keyword">Unevaluated</span>[sym[prop]],<span class="string">"="</span>,val])</span><br><span class="line"><span class="keyword">Language</span>`SetMutationHandler[f,mutationHandler]</span><br><span class="line"><span class="keyword">Do</span>[a[<span class="number">1</span>]=<span class="number">1</span>,&#123;a,&#123;<span class="number">1</span>,&lt;||&gt;,f[]&#125;&#125;]</span><br></pre></td></tr></table></figure><p>从输出中可以看到，只有当<code>a</code>的值变为<code>f[]</code>时，上面的匹配测试才会触发。完美符合要求。</p><p>在具体实现上，还有一些细节，比如对非属性参数检查和报错，对属性值的检查其实是由<code>LightFieldQ</code>对改变后的临时结果整体进行的检查，还有对失败结果需要<code>Language`MutationFallthrough</code>传递到正常的处理流程中，以及<code>Protect[LightField]</code>来避免fallthrough后干扰到<code>LightField</code>自身的定义等等，下面摘取了其中主要的部分</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SetAttributes</span>[setProperty,<span class="keyword">HoldFirst</span>]</span><br><span class="line">setProperty[sym_Symbol,prop_,val_]:=<span class="keyword">Block</span>[</span><br><span class="line">  &#123;tmp=sym,tmpprops&#125;,</span><br><span class="line">  tmpprops=getProperty[tmp,<span class="keyword">All</span>];</span><br><span class="line">  <span class="keyword">If</span>[<span class="keyword">KeyExistsQ</span>[tmpprops,prop],</span><br><span class="line">    tmpprops[prop]=val;</span><br><span class="line">    tmp=<span class="keyword">Replace</span>[tmp,<span class="keyword">HoldPattern</span>@LightField[type_,props_]:&gt;LightField[type,tmpprops]];</span><br><span class="line">    <span class="keyword">If</span>[LightFieldQ[tmp],</span><br><span class="line">      sym=tmp;val,</span><br><span class="line">      <span class="keyword">Message</span>[LightField::setptvp,val,prop];</span><br><span class="line">      <span class="keyword">$Failed</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="keyword">Message</span>[LightField::setptp,prop];</span><br><span class="line">    <span class="keyword">$Failed</span></span><br><span class="line">  ]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">SetAttributes</span>[mutationHandler,<span class="keyword">HoldAllComplete</span>]</span><br><span class="line">mutationHandler[<span class="keyword">Set</span>[(sym_Symbol?LightFieldQ)[prop_],val_]]:=<span class="keyword">With</span>[</span><br><span class="line">  &#123;result=setProperty[sym,prop,val]&#125;,</span><br><span class="line">  result/;!<span class="keyword">FailureQ</span>[result]</span><br><span class="line">]</span><br><span class="line">mutationHandler[_]:=<span class="keyword">Language</span>`MutationFallthrough</span><br><span class="line"><span class="keyword">Language</span>`SetMutationHandler[LightField,mutationHandler]</span><br></pre></td></tr></table></figure><p>对象的原子化则是利用<code>System`Private`SetNoEntry</code>系列的函数，同样，下面的相关资料里有很详细的介绍。这个系列的函数在不少内部对象的实现里也可以见到，比如<code>Dataset</code>，我们不妨照着做一个。利用神器<code>GeneralUtilities`PrintDefinitions</code>获得其定义，抛开那些无关的，很容易找到下面的内容</p><img src="/blog/2019/05/WLStyleObject/Dataset.png" title="Dataset"><p>中间有一些<code>Dataset</code>内部使用的注册机制，抛开那些不看，无非就是<code>System`Private`SetNoEntry</code>原子化后，利用<code>System`Private`NoEntryQ</code>检查防止无限自递归，注意两处的<code>Unevaluated</code>也是防止无限自递归的一环。在相关资料里我们看到10.4以后又引入了几个更便利的函数，于是依葫芦画瓢就可以写成</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(obj_LightField?holdLightFieldQ)/;System`Private`HoldEntryQ[obj]:=<span class="keyword">With</span>[</span><br><span class="line">  &#123;valid=System`Private`HoldSetNoEntry[obj]&#125;,</span><br><span class="line">  valid</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中<code>holdLightFieldQ</code>就是个保持版的<code>LightFieldQ</code>，作用当然也就不言而喻了。</p><p>最后是摘要框，这部分其实完全没有必要，不过说到Mathematica，优雅和颜值也是非常重要的一环，而且同样也用到了一套undocumented函数。这部分可以参考下面的相关资料，也可以用神器<code>GeneralUtilities`PrintDefinitions</code>来hack既有摘要框的对象，比如<code>SparseArray</code></p><img src="/blog/2019/05/WLStyleObject/SparseArray.png" title="SparseArray"><p>其核心无非就是<code>BoxForm`ArrangeSummaryBox</code>，中间量的命名也非常直白，即使不看参考资料也不难猜出使用方法。</p><p>这三部分都完成了以后，也算是有了一点Wolfram语言风格对象的神韵了。尽管为了这样优雅的使用对象，付出不少丑陋肮脏的实现代码，不过上面看到的一些官方的实现同样也丑陋无比，这倒也算是Wolfram语言的传统艺能了（</p><hr><p>相关资料：</p><ul><li><a href="https://mathematica.stackexchange.com/a/165910/63369" target="_blank" rel="noopener"><code>Language`*</code> documentation project - <code>Language`*Mutation*</code></a></li><li><a href="https://mathematica.stackexchange.com/a/139974/63369" target="_blank" rel="noopener">What are some useful, undocumented Mathematica functions? - <code>System`Private`*Entry*</code> functions</a></li><li><a href="https://mathematica.stackexchange.com/q/77658/63369" target="_blank" rel="noopener">How to create expanding summary boxes like the ones displayed for <code>InterpolatingFunction</code>, <code>NearestFunction</code>, etc.?</a></li><li><a href="https://mresources.github.io/tutorial/mathematica-programming/assorted-tricks/object-oriented-programming.html" target="_blank" rel="noopener">Object Oriented Programming</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做 &lt;a href=&quot;https://github.com/miRoox/ComputationalOptics&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ComputationalOptics包&lt;/a&gt; 的时候为了把 &lt;a href=&quot;https://github.com/miRoox/ComputationalOptics/blob/1197dbf20758271c93acdbc4f780913443847b95/ComputationalOptics/Kernel/LightField.m&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;LightField&lt;/code&gt;&lt;/a&gt; 实现为一个比较典型的Wolfram语言风格的对象，使用了很多undocumented方法，这里主要是做一下记录。&lt;/p&gt;&lt;p&gt;需要注意的是，这里的“对象”不是指“面向对象”里所说的对象（虽然也有点关系），而是类似于 &lt;a href=&quot;http://reference.wolfram.com/language/ref/Entity.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Entity&lt;/code&gt;&lt;/a&gt; 或者 &lt;a href=&quot;http://reference.wolfram.com/language/ref/TemporalData.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;TemporalData&lt;/code&gt;&lt;/a&gt; 这类的对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="Undocumented" scheme="http://miRoox.github.io/blog/tags/Undocumented/"/>
    
  </entry>
  
  <entry>
    <title>记Mathematica求导的一些坑</title>
    <link href="http://miroox.github.io/blog/2019/05/TrapAboutDerivativeInMma/"/>
    <id>http://miroox.github.io/blog/2019/05/TrapAboutDerivativeInMma/</id>
    <published>2019-05-01T08:02:10.000Z</published>
    <updated>2020-03-31T07:10:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是记录一下在回答贴吧上<a href="http://tieba.baidu.com/p/6111508459" target="_blank" rel="noopener">这个问题</a>时所发现的关于Mathematica求导的一些坑。</p><p>原问题虽然没有明说，但我推测问题背景应该是波特图之类的问题，具体问题如下：</p><a id="more"></a><blockquote><p>对这个函数的幅角求导，代入一个数值为什么求出了个复数值啊，实函数求导应该是实数啊。声明了一下x是实数后好像也不行。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f[x_] := <span class="keyword">Arg</span>[(-(x - <span class="number">1</span>)^<span class="number">2</span> + <span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span> - <span class="number">3</span> x^<span class="number">2</span> - x^<span class="number">4</span>))/((x - <span class="number">1</span>)^<span class="number">2</span> + <span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span> - <span class="number">3</span> x^<span class="number">2</span> - x^<span class="number">4</span>) - <span class="number">4</span>*I*(x^<span class="number">3</span> - <span class="number">3</span> x^<span class="number">2</span> + <span class="number">2</span> x))]</span><br><span class="line">f'[<span class="number">5</span>]</span><br><span class="line"><span class="comment">(*Out: (513125/13791752+(342351 I)/3447938) Arg'[2499/2626-(765 I)/2626]*)</span></span><br><span class="line">N[(<span class="number">513125</span>/<span class="number">13791752</span>+(<span class="number">342351</span> I)/<span class="number">3447938</span>) <span class="keyword">Arg</span>'[<span class="number">2499</span>/<span class="number">2626</span>-(<span class="number">765</span> I)/<span class="number">2626</span>]]</span><br><span class="line"><span class="comment">(*Out: 0.0109427 + 0.0292034 I*)</span></span><br></pre></td></tr></table></figure><p>这是程序，我觉得可能是程序表达的问题，那么该怎么去写这个程序呢？新手上路，老哥请指点</p></blockquote><p>这段程序恰好碰到了Mathematica在求导问题上的两个坑：</p><ol><li>Mathematica总是假设链式求导法则是有效的，但这里遇到的<code>Arg</code>本身是一个<em>不可导</em>的函数，链导法则是不成立的。这一点是一个非常常见的坑。</li><li>然后Mathematica的数值导数设计的也欠合理，在遇到符号求导失效的情况时，Mathematica在计算函数导数时会利用其沿着<em>实轴</em>方向的变化率来近似求导（事实上<code>Arg</code>沿复平面不同方向的变化率通常不相等），而<code>Arg</code>本身总是实数，这样一来得到的<code>Arg'[...]</code>的结果就总是一个实数，然而前面根据链导法则乘出的那一坨又是个复数，自然得到的最终结果也是复数。</li></ol><p>针对这个问题，可以提出两种解决办法：</p><ol><li>一个很自然的想法是直接绕开<code>Arg</code>这个不可导的函数，即可以将通过<code>ComplexExpand</code>其转化为<code>ArcTan</code>形式，再去求导就不会有这些问题了：<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[x_]=<span class="keyword">ComplexExpand</span>[<span class="keyword">Arg</span>[(-(x<span class="number">-1</span>)^<span class="number">2</span>+<span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>-x^<span class="number">4</span>))/((x<span class="number">-1</span>)^<span class="number">2</span>+<span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>-x^<span class="number">4</span>)<span class="number">-4</span>*I*(x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>+<span class="number">2</span> x))],<span class="keyword">TargetFunctions</span>-&gt;&#123;<span class="keyword">Re</span>,<span class="keyword">Im</span>&#125;];</span><br><span class="line">f'[<span class="number">5</span>]</span><br><span class="line"><span class="comment">(*Out: 1117/10504*)</span></span><br></pre></td></tr></table></figure></li><li>还可以反过来利用上述数值导数的坑来解决：因为这里就是要求<code>f</code>沿实轴方向的导数，所以我们不妨利用数值导数始终沿实轴发生这一特性，先从<code>f</code>上就避免符号计算引入错误的链导法则，然后直接让Mathematica对<code>f</code>进行数值求导，于是可以这么写：<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Clear</span>[f]</span><br><span class="line">f[x_?<span class="keyword">NumericQ</span>]:=<span class="keyword">Arg</span>[(-(x<span class="number">-1</span>)^<span class="number">2</span>+<span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>-x^<span class="number">4</span>))/((x<span class="number">-1</span>)^<span class="number">2</span>+<span class="number">4</span> (<span class="number">4</span> x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>-x^<span class="number">4</span>)<span class="number">-4</span>*I*(x^<span class="number">3</span><span class="number">-3</span> x^<span class="number">2</span>+<span class="number">2</span> x))]</span><br><span class="line">f'[<span class="number">5.</span>]</span><br><span class="line"><span class="comment">(*Out: 0.10634*)</span></span><br></pre></td></tr></table></figure>如果只需要近似的数值值得话，同样可以解决问题。</li></ol><hr><p>相关链接：</p><ul><li><a href="http://tieba.baidu.com/p/6111508459" target="_blank" rel="noopener">来个老哥抬一手~</a></li><li><a href="https://mathematica.stackexchange.com/questions/196998/why-does-arg1-i-return-0-5" target="_blank" rel="noopener">Why does Arg’[1. + I] return -0.5?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是记录一下在回答贴吧上&lt;a href=&quot;http://tieba.baidu.com/p/6111508459&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个问题&lt;/a&gt;时所发现的关于Mathematica求导的一些坑。&lt;/p&gt;&lt;p&gt;原问题虽然没有明说，但我推测问题背景应该是波特图之类的问题，具体问题如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>Mathematica写作自动化技巧</title>
    <link href="http://miroox.github.io/blog/2019/04/MmaAutoLiterature/"/>
    <id>http://miroox.github.io/blog/2019/04/MmaAutoLiterature/</id>
    <published>2019-04-07T14:45:31.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Mathematica的笔记本的过程中，我们常常希望将它的代码和文档功能结合起来，例如自动将符号计算的公式、图形以文档的书写习惯展示出来，同时隐藏生成代码，使文档显示自然协调。</p><a id="more"></a><p>为了达到这一目的，首先需要的是将输入自动隐藏。我们知道，即使在自然状态下，双击输出单元的单元括号<code>]</code>即可隐藏输入单元。这一操作实际相当于选中输出单元后执行了前端令牌<a href="https://reference.wolfram.com/language/ref/frontendobject/SelectionCloseUnselectedCells.html" target="_blank" rel="noopener">&quot;SelectionCloseUnselectedCells&quot;</a>，因此，可以将其写作程序代码</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SelectionMove</span>[<span class="keyword">EvaluationNotebook</span>[],<span class="keyword">All</span>,<span class="keyword">GeneratedCell</span>];</span><br><span class="line"><span class="keyword">FrontEndTokenExecute</span>[<span class="string">"SelectionCloseUnselectedCells"</span>];</span><br></pre></td></tr></table></figure><p>在输入单元最后加入上述代码即可在执行后自动折叠隐藏输入单元。</p><p>不过，当我们需要展示公式时，我们往往希望使用<code>DisplayFormula</code>或者<code>DisplayFormulaNumbered</code>等公式样式。但直接使用<code>CellPrint</code>以此样式输出的话，则因为输入单元与输出的公式单元不会自动编组而无法通过上述方式折叠。所幸单元也支持应用多个样式，将公式样式与<code>Output</code>样式同时应用即可解决。例如：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CellPrint</span>[<span class="keyword">ExpressionCell</span>[D[x^<span class="number">2</span>,x],<span class="string">"Output"</span>,<span class="string">"DisplayFormulaNumbered"</span>]];</span><br><span class="line"><span class="keyword">SelectionMove</span>[<span class="keyword">EvaluationNotebook</span>[],<span class="keyword">All</span>,<span class="keyword">GeneratedCell</span>];</span><br><span class="line"><span class="keyword">FrontEndTokenExecute</span>[<span class="string">"SelectionCloseUnselectedCells"</span>];</span><br></pre></td></tr></table></figure><p>我们也可以将这些功能都整合进样式表中，在<code>CellEpilog</code>中添加折叠单元代码，在<code>GeneratedCellStyles</code>中改变输出单元的样式。例如，我们可以通过在样式表中添加如下内容来自定义一个<code>FormulaGenerator</code>样式</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Cell</span>[<span class="keyword">StyleData</span>[<span class="string">"FormulaGenerator"</span>, <span class="keyword">StyleDefinitions</span> -&gt; <span class="keyword">StyleData</span>[<span class="string">"Input"</span>]],</span><br><span class="line"> <span class="keyword">CellEpilog</span>:&gt;(<span class="keyword">SelectionMove</span>[</span><br><span class="line">    <span class="keyword">EvaluationNotebook</span>[], <span class="keyword">All</span>, <span class="keyword">GeneratedCell</span>]; </span><br><span class="line">  <span class="keyword">FrontEndTokenExecute</span>[<span class="string">"SelectionCloseUnselectedCells"</span>]),</span><br><span class="line"> GeneratedCellStyles-&gt;&#123;<span class="string">"Output"</span>-&gt;&#123;<span class="string">"Output"</span>, <span class="string">"DisplayFormulaNumbered"</span>&#125;&#125;,</span><br><span class="line"> <span class="keyword">MenuSortingValue</span>-&gt;<span class="number">10000</span>]</span><br></pre></td></tr></table></figure><p>这样，使用<code>FormulaGenerator</code>样式的输入单元在计算后就会生成一个带标号的公式单元并自动隐藏起来。</p><hr><p>参见：</p><ul><li><a href="http://reference.wolfram.com/language/workflow/HideInputInANotebook.html" target="_blank" rel="noopener">隐藏笔记本的输入</a></li><li><a href="https://mathematica.stackexchange.com/questions/680/how-to-keep-input-cells-hidden-after-evaluating-notebook" target="_blank" rel="noopener">How to Keep Input Cells Hidden After Evaluating Notebook</a></li><li><a href="https://mathematica.stackexchange.com/questions/70185/how-to-set-the-output-be-generated-in-a-cell-different-from-output" target="_blank" rel="noopener">How to set the output be generated in a cell different from “Output”</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Mathematica的笔记本的过程中，我们常常希望将它的代码和文档功能结合起来，例如自动将符号计算的公式、图形以文档的书写习惯展示出来，同时隐藏生成代码，使文档显示自然协调。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="文学编程" scheme="http://miRoox.github.io/blog/tags/%E6%96%87%E5%AD%A6%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Mathematica通用工具包参考（一）：宏</title>
    <link href="http://miroox.github.io/blog/2019/02/WLGeneralUtilitiesMacro/"/>
    <id>http://miroox.github.io/blog/2019/02/WLGeneralUtilitiesMacro/</id>
    <published>2019-02-27T15:00:13.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>GeneralUtilities`</code> 是Mathematica从版本10开始新加入的一个上下文。其中提供了大量的实用函数，包括代码生成、调试、静态分析、迭代器对象等各个领域，一定程度上弥补了Mathematica基础设施不足的状况。</p><p>这个工具包内包含的函数十分繁杂，在当前版本11.3下，可以通过<code>Names[&quot;GeneralUtilities`*&quot;]//Length</code>看到其共包含了514个符号。这篇文章简单介绍与宏有关的部分。</p><p>“宏”在编程领域往往作为一种代码生成技术使用，例如在一些编译型语言中，宏展开往往发生在编译或预编译阶段。而在<code>GeneralUtilities`</code>的语境下，宏默认在定义时自动展开，同样也是一种代码生成技术。</p><a id="more"></a><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Needs</span>[<span class="string">"GeneralUtilities`"</span>]</span><br></pre></td></tr></table></figure><hr><p>下面介绍<code>GeneralUtilities`</code>中的一些实用宏</p><h3 id="scopemodulescope"><a class="markdownIt-Anchor" href="#scopemodulescope"></a> <code>Scope</code>/<code>ModuleScope</code></h3><p>我们知道，Mathematica中的局部符号往往需要显式地引入，而不像很多语言在函数体内自动带有作用域。这在使用大量局部变量的时候会带来一些麻烦。而<code>Scope</code>给出了一个解决办法，它自动解析<code>Scope[body]</code>内部的赋值语句，提取与之相关联的符号自动局域化。通过<code>?GeneralUtilities`Scope</code>可以看到它的用法如下：</p><blockquote><p><code>Scope[body]</code> is a macro that expands to a <code>Block</code> with automatically populated local variable list.</p><ul><li>Variables are detected syntactically by the presence of <code>=</code> and <code>:=</code> within <code>body</code>.</li><li><code>^=</code> and <code>^:=</code> can be used to avoid this localization.</li><li><code>{sym1,sym2,...} = rhs</code> will localize <code>sym1,sym2,...</code>.</li><li><code>sym := rhs</code> will localize <code>sym</code>.</li><li>Local functions definitions <code>head[...] := rhs</code> do not cause localizalization of <code>head</code>.</li></ul></blockquote><p>而且它作为一个宏，使用在定义中，则展开发生在定义阶段，从而可以避免调用时因解析和变换带来的额外开销。例如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[x_]:=Scope[a=x;b^=a;c:=a++;&#123;d,e&#125;=&#123;b,c&#125;;a]</span><br><span class="line"><span class="keyword">Definition</span>[f]</span><br><span class="line"><span class="comment">(*Out[*]= f[x_]:=Block[&#123;a,c,d,e&#125;,a=x;b=a;c:=a++;&#123;d,e&#125;=&#123;b,c&#125;;a]*)</span></span><br></pre></td></tr></table></figure><p>可以看到<code>f</code>的定义中，<code>Scope</code>已经转换成了<code>Block</code>作用域，并自动将需要局域化的符号按<code>Block</code>的规则列出了。</p><p>类似的，<code>ModuleScope</code>自动展开成<code>Module</code>作用域结构。</p><h3 id="memoized"><a class="markdownIt-Anchor" href="#memoized"></a> <code>Memoized</code></h3><blockquote><p><code>Memoized[body]</code> specifies that <code>body</code> should be evaluted but cached so that subsequent calls with the same value for any bound symbol use the cached value.<br><br><code>Memoized[body,Method-&gt;method]</code> can be used, where <code>method</code> is one of <code>{&quot;Association&quot;, &quot;Symbol&quot;, &quot;Inline&quot;, &quot;SystemCache&quot;}</code>, to choose a specific caching method.</p></blockquote><p>即所谓的<a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="noopener">记忆化</a>手法，可以实现空间换时间的优化目的。例如对于Mathematica中一个比较经典的记忆化案例</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fib[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">fib[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">fib[n_]:=fib[n]=fib[n<span class="number">-1</span>]+fib[n<span class="number">-2</span>]</span><br></pre></td></tr></table></figure><p>利用<code>Memoized</code>可以等价地写成</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fib[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">fib[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">fib[n_]:=Memoized[fib[n<span class="number">-1</span>]+fib[n<span class="number">-2</span>],<span class="keyword">Method</span>-&gt;<span class="string">"Inline"</span>]</span><br></pre></td></tr></table></figure><p>除了<code>&quot;Inline&quot;</code>，<code>Memoized</code>还提供了其它几种记忆化的实现手段，包括默认的<code>&quot;SystemCache&quot;</code>、基于关联<code>&quot;Association&quot;</code>和面向符号的<code>&quot;Symbol&quot;</code>，这里不多赘述了。不过似乎目前的<code>&quot;Symbol&quot;</code>方法的实现有问题，无法应用于函数定义中。</p><h3 id="setupteardown"><a class="markdownIt-Anchor" href="#setupteardown"></a> <code>SetupTeardown</code></h3><blockquote><p><code>SetupTeardown[setup,body,teardown]</code> evaluates <code>setup</code>, then <code>body</code>, and then <code>teardown</code>, even if an <code>Abort</code> or <code>Throw</code> occurs during evaluation.</p></blockquote><p><code>SetupTeardown</code>是一个确保“初始化-主体-清理”执行顺序的封装，哪怕其中某部分中断或者抛出也会确保其余部分顺序进行。</p><p>举一个简单的例子</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[]:=SetupTeardown[<span class="keyword">Print</span>[<span class="string">"setup"</span>],<span class="keyword">Print</span>[<span class="string">"before"</span>];<span class="keyword">Abort</span>[];<span class="keyword">Print</span>[<span class="string">"after"</span>],<span class="keyword">Print</span>[<span class="string">"teardown"</span>]]</span><br></pre></td></tr></table></figure><p>调用<code>f[]</code>，可以看到即使<code>Abort[]</code>中断计算后，依然继续进行了<code>Print[&quot;teardown&quot;]</code>的计算。</p><p>这个宏可以用于在计算流程中确保资源的获取和释放，不过实际在Mathematica中应用比较少。</p><h3 id="matchstringmatch"><a class="markdownIt-Anchor" href="#matchstringmatch"></a> <code>Match</code>/<code>StringMatch</code></h3><blockquote><p><code>Match[value,patt<sub>1</sub>:&gt;val<sub>1</sub>,patt<sub>2</sub>:&gt;val<sub>2</sub>,…,default]</code> matches the value to the <code>patt<sub>i</sub></code> in turn and gives the corresponding <code>val<sub>i</sub></code>, or evaluates <code>default</code> if none matched.<br><br><code>Match[value,patts...,...]</code> panics if none of the <code>patts</code> matched.<br><br><code>Match[patts]</code> is the operator form of <code>Match</code>.</p></blockquote><p>长得像Rust的<a href="https://doc.rust-lang.org/book/match.html" target="_blank" rel="noopener"><code>match</code></a>，用法大抵类似<code>Switch</code>，实际只是<code>Replace</code>的一个封装。</p><p><code>StringMatch</code>无非是<code>StringReplace</code>的一个封装。</p><h3 id="catchfailurecatchfailureasmessage"><a class="markdownIt-Anchor" href="#catchfailurecatchfailureasmessage"></a> <code>CatchFailure</code>/<code>CatchFailureAsMessage</code></h3><blockquote><p><code>CatchFailure[body]</code> is a macro evaluates <code>body</code>, but returns a <code>Failure[...]</code> object if a <code>ThrowFailure[...]</code> occurred during evaluation. The current function is automatically used as the message head.<br><br><code>CatchFailure[head,body]</code> explicitly uses <code>head</code> as the message head for the failure message.</p></blockquote><blockquote><p><code>CatchFailureAsMessage[body]</code> is a macro evaluates <code>body</code>, but issues a message if a <code>ThrowFailure[...]</code> occurred during evaluation. The current function is automatically used as the message head.<br><br><code>CatchFailureAsMessage[head,body]</code> explicitly uses <code>head</code> as the message head for the failure message.</p></blockquote><p>需要配合<code>ThrowFailure</code>一起使用，语义比较清晰的错误捕获。</p><h3 id="unpackassociationunpackoptions"><a class="markdownIt-Anchor" href="#unpackassociationunpackoptions"></a> <code>UnpackAssociation</code>/<code>UnpackOptions</code></h3><blockquote><p><code>UnpackAssociation[assoc,“Name<sub>1</sub>”,“Name<sub>2</sub>”,…]</code> extracts the given keys from the association and sets variables named <code>Name<sub>i</sub></code>.<br><br><code>UnpackAssociation[assoc,symbol<sub>1</sub>,symbol<sub>2</sub>,…]</code> uppercases the first letter of the symbol name to get the key.<br><br><code>UnpackAssociation[assoc,symbol<sub>1</sub>:“Name<sub>1</sub>”,…]</code> gives an explicit name for each symbol.</p></blockquote><blockquote><p><code>UnpackOptions[sym<sub>1</sub>,sym<sub>2</sub>,…]</code> extracts options with names <code>“Sym<sub>1</sub>”, “Sym<sub>1</sub>”, …</code> and assigns them to the <code>sym<sub>i</sub></code>, where the keys are the title cased version of the symbol names.</p></blockquote><p>用法说明已经介绍得比较详细了，下面给一个简单的用例</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Options</span>[f] = &#123;<span class="string">"A"</span> -&gt; <span class="number">1</span>, <span class="string">"Op"</span> -&gt; <span class="number">2</span>&#125;;</span><br><span class="line">f[<span class="keyword">OptionsPattern</span>[]]:=Scope[UnpackOptions[a,op];&#123;a,op&#125;]</span><br><span class="line">&#123;f[], f[<span class="string">"A"</span> -&gt; <span class="number">17</span>], f[<span class="string">"Op"</span> -&gt; <span class="number">18</span>], f[<span class="string">"A"</span> -&gt; <span class="number">16</span>, <span class="string">"Op"</span> -&gt; <span class="number">19</span>]&#125;</span><br><span class="line"><span class="comment">(*Out[*]= &#123;&#123;1,2&#125;,&#123;17,2&#125;,&#123;1,18&#125;,&#123;16,19&#125;&#125;*)</span></span><br></pre></td></tr></table></figure><h3 id="collectto"><a class="markdownIt-Anchor" href="#collectto"></a> <code>CollectTo</code></h3><p><code>CollectTo</code>需要配合<code>BagInsert</code>使用，实际是<code>Internal`Bag</code>相关函数的封装，目前来看意义不大，不过这个宏没有用法说明，也可能尚未完善。</p><p>根据定义，可以大致推测<code>CollectTo[{x,y,...},body]</code>可以通过在<code>body</code>部分使用<code>BagInsert[x,val]</code>或者<code>BagInsert[x,val,index]</code>的方式高效地将<code>val</code>添加或插入到动态列表<code>x</code>中。</p><p>下面给一个简单的用例说明一下用法</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1[n_]:=Scope[CollectTo[&#123;x&#125;,<span class="keyword">Do</span>[BagInsert[x,i],&#123;i,n&#125;]];x]</span><br><span class="line">f2[n_]:=Scope[x=&#123;&#125;;<span class="keyword">Do</span>[<span class="keyword">AppendTo</span>[x,i],&#123;i,n&#125;];x]</span><br><span class="line">BenchmarkPlot[&#123;f1,f2&#125;,<span class="keyword">Identity</span>]</span><br></pre></td></tr></table></figure><p>我的电脑上给出的结果为：</p><img src="/blog/2019/02/WLGeneralUtilitiesMacro/CollectTo.png" title="CollectTo"><p>可以看到<code>Bag</code>的添加效率基本是普通列表的好几倍。</p><h3 id="dowhile"><a class="markdownIt-Anchor" href="#dowhile"></a> <code>DoWhile</code></h3><p><code>DoWhile[body,test]</code>就像C语言之类的一样，先计算<code>body</code>，再计算<code>test</code>并决定是否循环，<br>实际上就等价于<code>While[body;test]</code>。</p><h3 id="excise"><a class="markdownIt-Anchor" href="#excise"></a> <code>Excise</code></h3><blockquote><p><code>Excise[args...]</code> evaluates to an empty sequence, effectively removing its arguments without evaluation.</p></blockquote><p>个人认为没什么用，注释可以做到同样的事，甚至用途更广（<code>Excise</code>只能在使用宏的情况下工作）。</p><h3 id="usemacros"><a class="markdownIt-Anchor" href="#usemacros"></a> <code>UseMacros</code></h3><blockquote><p><code>UseMacros[body]</code> does nothing more than trigger macro expansion, use it if you want to use macros in a function but don’t need <code>Scope</code>.</p></blockquote><p>在不了解<code>GeneralUtilities`</code>中宏的作用机理的情况下，这个宏的作用可能会令人困惑。事实上，在默认条件下，上述各种宏的自动展开只会发生在赋值等号右边的最外层使用了宏的时候发生。这一事实可以在上述各种的定义中一窥究竟，以<code>Scope</code>为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scope &#x2F;: HoldPattern[s:Set[_, _Scope]] :&#x3D; MacroEvaluate @ s;</span><br><span class="line">Scope &#x2F;: HoldPattern[sd:SetDelayed[_, _Scope]] :&#x3D; MacroEvaluate @ sd;</span><br><span class="line">Scope &#x2F;: HoldPattern[tsd:TagSetDelayed[_, _, _Scope]] :&#x3D; MacroEvaluate @ tsd;</span><br></pre></td></tr></table></figure><p>同样，<code>UseMacros</code>位于赋值等号右边的最外层时会触发宏自动展开，从而可以解决在内层使用宏无法展开的问题。</p><hr><p><code>GeneralUtilities`</code>除了提供上述宏之外，还提供了一些计算和生成宏的辅助工具。</p><h3 id="quoted"><a class="markdownIt-Anchor" href="#quoted"></a> <code>Quoted</code></h3><blockquote><p><code>Quoted[code]</code> is the inert body of <code>code</code> for the purposes of macro expansion.</p></blockquote><p>一个代码封装，作用基本和<code>HoldComplete</code>一样，不过使用了一个漂亮的方式输出显示代码。</p><p>在宏的实现中大量使用。</p><h3 id="macroexpandmacroexpandlist"><a class="markdownIt-Anchor" href="#macroexpandmacroexpandlist"></a> <code>MacroExpand</code>/<code>MacroExpandList</code></h3><blockquote><p><code>MacroExpand[expr]</code> evaluates all macros present in <code>expr</code> and returns the result in a <code>Quoted</code> expression.<br>Anywhere in a macro, <code>'</code> can be used to inject <code>EchoRaw</code> calls, <code>''</code> to inject <code>EchoHold</code> calls, and <code>'''</code> to wrap a function in <code>Tap</code>.</p></blockquote><blockquote><p><code>MacroExpandList[expr]</code> expands all macros that occur in <code>expr</code>, returning a list of <code>Quoted</code> expressions that give the intermediate results after each expansion step.</p></blockquote><p><code>MacroExpand</code>展开宏，但是不计算，可以用来预览宏使用的效果。而<code>MacroExpandList</code>列出展开宏的每一步。</p><h3 id="macroevaluate"><a class="markdownIt-Anchor" href="#macroevaluate"></a> <code>MacroEvaluate</code></h3><blockquote><p><code>MacroEvaluate[expr]</code> evaluates all macros present in <code>expr</code> and then evaluates the result.</p></blockquote><p>展开宏并计算。</p><p>可以尝试令<code>$Pre=MacroEvaluate</code>，这样每次计算都会尝试展开宏，从而也就不需要<code>UseMacros</code>来触发展开了。</p><h3 id="macrorules"><a class="markdownIt-Anchor" href="#macrorules"></a> <code>MacroRules</code></h3><blockquote><p><code>MacroRules[symbol]</code> gives all the macro application rules associated with the head <code>symbol</code>.</p></blockquote><p>可以通过<code>PrintDefinitions[MacroRules]</code>hack得到已定义的函数宏和变换规则。</p><h3 id="defineliteralmacrodefinemacrodefinealias"><a class="markdownIt-Anchor" href="#defineliteralmacrodefinemacrodefinealias"></a> <code>DefineLiteralMacro</code>/<code>DefineMacro</code>/<code>DefineAlias</code></h3><blockquote><p><code>DefineLiteralMacro[symbol,lhs:=rhs,...]</code> defines a literal macro such that when <code>lhs</code> it is substituted for <code>rhs</code> without evaluation.<br>The same replacement is attached to symbol for use outside a macro context.</p></blockquote><blockquote><p><code>DefineAlias[newsymbol,oldsymbol]</code> does what it says on the tin.</p></blockquote><p>这三者都用来实现自定义宏，但使用和效果上略有不同：</p><ul><li><code>DefineLiteralMacro[symbol,lhs:=rhs,...]</code> 定义的是一个字面宏，在替换展开的过程中并不会计算<code>rhs</code>。</li><li><code>DefineMacro[symbol,lhs:=rhs,...]</code> 定义的宏则会在展开时计算<code>rhs</code>。</li><li><code>DefineAlias[newsymbol,oldsymbol]</code> 定义符号的别名，只对符号有效，而且其展开发生在其它宏展开之前。</li></ul><p>尝试下面的例子以便更直观地认识到这三者间的联系和区别：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DefineMacro[fac1, fac1[x_]:=x!];</span><br><span class="line">DefineLiteralMacro[fac2, fac2[x_]:=x!];</span><br><span class="line">DefineAlias[fac3, <span class="keyword">Factorial</span>];</span><br><span class="line"></span><br><span class="line">MacroExpand[fac1[<span class="number">3</span>]]</span><br><span class="line">MacroExpand[fac2[<span class="number">3</span>]]</span><br><span class="line">MacroExpand[fac3[<span class="number">3</span>]]</span><br><span class="line">MacroExpand[fac2[]]</span><br><span class="line">MacroExpand[fac3[]]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;GeneralUtilities`&lt;/code&gt; 是Mathematica从版本10开始新加入的一个上下文。其中提供了大量的实用函数，包括代码生成、调试、静态分析、迭代器对象等各个领域，一定程度上弥补了Mathematica基础设施不足的状况。&lt;/p&gt;&lt;p&gt;这个工具包内包含的函数十分繁杂，在当前版本11.3下，可以通过&lt;code&gt;Names[&amp;quot;GeneralUtilities`*&amp;quot;]//Length&lt;/code&gt;看到其共包含了514个符号。这篇文章简单介绍与宏有关的部分。&lt;/p&gt;&lt;p&gt;“宏”在编程领域往往作为一种代码生成技术使用，例如在一些编译型语言中，宏展开往往发生在编译或预编译阶段。而在&lt;code&gt;GeneralUtilities`&lt;/code&gt;的语境下，宏默认在定义时自动展开，同样也是一种代码生成技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="参考" scheme="http://miRoox.github.io/blog/tags/%E5%8F%82%E8%80%83/"/>
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="Undocumented" scheme="http://miRoox.github.io/blog/tags/Undocumented/"/>
    
  </entry>
  
  <entry>
    <title>在Wolfram语言中模拟指针语义</title>
    <link href="http://miroox.github.io/blog/2019/01/PointerInWolfram/"/>
    <id>http://miroox.github.io/blog/2019/01/PointerInWolfram/</id>
    <published>2019-01-18T15:15:37.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景和问题的引入"><a class="markdownIt-Anchor" href="#背景和问题的引入"></a> 背景和问题的引入</h3><p>众所周知，Wolfram语言作为一个极为“高级”的编程语言，并没有提供指针这类较为底层的内存管理手段。而符号本身几乎总是充当了类似引用的作用，比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set[sym_Symbol]:=sym=<span class="number">1</span></span><br><span class="line">b=a;</span><br><span class="line">set[b];</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>可以看到符号<code>a</code>的值通过<code>set[b]</code>赋为了<code>1</code>。在这里<code>b</code>形式上充当了类似其它语言中的引用的作用。但这种方式并不通用，只要<code>a</code>已经具有值了，这种平凡的方式就不能起作用了。有的读者可能会想到<code>:=</code>或者<code>Hold</code>封装，不过单靠这些也不能简单地对已具有本值的符号进行修改。因此，本文试图提出一种具有类似其它语言中指针语义的封装，实现对符号的间接操作。</p><a id="more"></a><h3 id="预期的目标"><a class="markdownIt-Anchor" href="#预期的目标"></a> 预期的目标</h3><p>这里想实现一种具有类似C语言用法的指针（引用）封装。当然，由于Mathematica没有直接访问内存的手法，所有引用都是针对<em>符号</em>展开的。具体而言，应该可以实现下面的效果：</p><p>解引用：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=ref[a];</span><br><span class="line">deref@b</span><br></pre></td></tr></table></figure><p>得到<code>1</code>；</p><p>左值语义：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=ref[a];</span><br><span class="line">deref@b=<span class="number">2</span>;</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>得到<code>2</code>；</p><p>更复杂的左值：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">b=ref[a];</span><br><span class="line">deref[b][[<span class="number">2</span>]]=<span class="number">4</span>;</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>得到<code>{1,4,3}</code>；</p><p>多重引用：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=ref[a];</span><br><span class="line">c=ref[b];</span><br><span class="line">deref@deref@c=<span class="number">2</span>;</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>得到<code>2</code>。</p><p>这里只是举几个例子，文章毕竟不是测试集，也就不再赘述。</p><p>当然，我们希望能更接近C语言指针的语义。在这里，<code>ref</code>相当于C语言中的<code>&amp;</code>单目运算符，而<code>deref</code>则相当于C语言的<code>*</code>单目运算符。</p><h3 id="思路与实现"><a class="markdownIt-Anchor" href="#思路与实现"></a> 思路与实现</h3><p>考虑我们需要保有符号，才可能对符号进行引用，因此首先<code>ref</code>必须具有<code>HoldFirst</code>属性。然后<code>deref</code>能在计算时解引用，也就是</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deref[ref[sym_]] := sym</span><br></pre></td></tr></table></figure><p>然后我们需要重载<code>Set</code>以获得左值语义。由于<code>deref</code>可能出现在很深的层次中，单靠<a href="http://reference.wolfram.com/language/ref/TagSetDelayed.html" target="_blank" rel="noopener"><code>TagSetDelayed</code></a>不能覆盖重载的各种情况。但需要重载的情况必定含有<code>deref</code>，因此可以利用条件模式决定重载策略</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Unprotect</span>[<span class="keyword">Set</span>];</span><br><span class="line"><span class="keyword">Set</span>[lhs_, rhs_] /; <span class="keyword">MemberQ</span>[<span class="keyword">Unevaluated</span>[lhs], _deref, &#123;<span class="number">0</span>, <span class="keyword">Infinity</span>&#125;] := &lt;&lt;具体实现&gt;&gt;</span><br><span class="line"><span class="keyword">Protect</span>[<span class="keyword">Set</span>];</span><br></pre></td></tr></table></figure><p>由于引用在这里总是保有着符号，因此左值语义在这里更类似一个宏展开，将<code>=</code>左侧的所有直接或隐含的<code>deref[ref[sym]]</code>结构展开成对应的<code>sym</code>。为了达到这个目的，首先需要保护<code>=</code>的左侧不进行计算，这里只需要一个简单的<code>Hold</code>封装即可。然后上面的所说的“宏展开”细节上应该分两步进行：</p><p>一是将“隐含”转换为“显含”：直观上来说，可能大家会写成这样的替换规则：<code>deref[r_]:&gt;deref[Evaluate[r]]</code>，但这是不对的。由于<code>Hold</code>封装的存在，需要用到一个名为<a href="https://mathematica.stackexchange.com/questions/29317/replacement-inside-held-expression" target="_blank" rel="noopener">Trott-Strzebonski</a>的技巧，而且由于前面已经定义了<code>deref[ref[sym_]]:=sym</code>，因此这里必须借助<code>Block</code>局部地清除这个定义才行，另一方面，为了处理多重引用，还需要排除<code>deref[deref[xxx]]</code>这种模式被直接展开。</p><p>二是对显式结构进行替换：这部分比较简单，直接使用<code>deref@ref[sym_Symbol]:&gt;sym</code>即可。同样也是因为<code>Hold</code>封装的存在，符号<code>sym</code>即使有本值也不会计算。</p><p>最后将展开的结果还原为赋值表达式即可。</p><p>综合一下，我们可以得到一个比较完整的代码</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SetAttributes</span>[ref, <span class="keyword">HoldFirst</span>]</span><br><span class="line">deref[ref[sym_]] := sym</span><br><span class="line"><span class="keyword">Unprotect</span>[<span class="keyword">Set</span>];</span><br><span class="line"><span class="keyword">Set</span>[lhs_, rhs_] /; <span class="keyword">MemberQ</span>[<span class="keyword">Unevaluated</span>[lhs], _deref, &#123;<span class="number">0</span>, <span class="keyword">Infinity</span>&#125;] :=</span><br><span class="line"> <span class="keyword">With</span>[&#123;</span><br><span class="line">   lhs1 = <span class="keyword">Block</span>[&#123;deref&#125;,</span><br><span class="line">     <span class="keyword">Hold</span>[lhs] //. &#123;</span><br><span class="line">       deref@ref[sym_Symbol] :&gt; sym,</span><br><span class="line">       deref[r : <span class="keyword">Except</span>[_deref]] :&gt;  <span class="keyword">With</span>[&#123;eval = deref[r]&#125;, eval /; <span class="keyword">True</span>] <span class="comment">(*Trott-Strzebonski*)</span></span><br><span class="line">       &#125;]&#125;,</span><br><span class="line">  <span class="keyword">Replace</span>[<span class="keyword">Hold</span>[<span class="keyword">Set</span>[lhs1, rhs]], <span class="keyword">Hold</span>[<span class="keyword">Set</span>[<span class="keyword">Hold</span>[lhs2_], rhs2_]] :&gt; <span class="keyword">Set</span>[lhs2, rhs2]]</span><br><span class="line"> ]</span><br><span class="line"><span class="keyword">Protect</span>[<span class="keyword">Set</span>];</span><br></pre></td></tr></table></figure><p>当然，对于一个真正实用的模块而言，还需要一些诸如错误处理之类的细节，但如果只考虑正确使用的话，实现指针语义的核心部分都已经列在这里了。一个相对实用的版本可以在 <a href="https://github.com/miRoox/LValueRef" target="_blank" rel="noopener">https://github.com/miRoox/LValueRef</a> 找到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景和问题的引入&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景和问题的引入&quot;&gt;&lt;/a&gt; 背景和问题的引入&lt;/h3&gt;&lt;p&gt;众所周知，Wolfram语言作为一个极为“高级”的编程语言，并没有提供指针这类较为底层的内存管理手段。而符号本身几乎总是充当了类似引用的作用，比如&lt;/p&gt;&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;set[sym_Symbol]:=sym=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b=a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set[b];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;可以看到符号&lt;code&gt;a&lt;/code&gt;的值通过&lt;code&gt;set[b]&lt;/code&gt;赋为了&lt;code&gt;1&lt;/code&gt;。在这里&lt;code&gt;b&lt;/code&gt;形式上充当了类似其它语言中的引用的作用。但这种方式并不通用，只要&lt;code&gt;a&lt;/code&gt;已经具有值了，这种平凡的方式就不能起作用了。有的读者可能会想到&lt;code&gt;:=&lt;/code&gt;或者&lt;code&gt;Hold&lt;/code&gt;封装，不过单靠这些也不能简单地对已具有本值的符号进行修改。因此，本文试图提出一种具有类似其它语言中指针语义的封装，实现对符号的间接操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="功能模拟" scheme="http://miRoox.github.io/blog/tags/%E5%8A%9F%E8%83%BD%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>Mathematica黑魔法：符号沙盒</title>
    <link href="http://miroox.github.io/blog/2019/01/SymbolSandbox/"/>
    <id>http://miroox.github.io/blog/2019/01/SymbolSandbox/</id>
    <published>2019-01-17T15:02:13.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题的引入"><a class="markdownIt-Anchor" href="#问题的引入"></a> 问题的引入</h3><p><code>ValueQ</code>是Matheamtica中的一个非常有趣的函数，它判断一个表达式是否会进行求值，而且这种判断有时可以做到无副作用，哪怕求值本身是具有副作用的。比如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>;</span><br><span class="line">y:=++x</span><br><span class="line">v=<span class="keyword">ValueQ</span>[y];</span><br><span class="line">&#123;v,x&#125;</span><br></pre></td></tr></table></figure><p>会得到<code>{True,0}</code>的结果。这里的<code>ValueQ[y]</code>显然并没有真正对<code>y</code>求值就作出了判断。不过很遗憾的是这其中哪怕只有略微的改动也会使其作用发生变化，例如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>;</span><br><span class="line">y:=++x</span><br><span class="line">v=<span class="keyword">ValueQ</span>[y+<span class="number">0</span>];</span><br><span class="line">&#123;v,x&#125;</span><br></pre></td></tr></table></figure><p>则会得到<code>{True,1}</code>。</p><a id="more"></a><p>具有<a href="http://reference.wolfram.com/language/tutorial/ManipulatingValueLists.html" target="_blank" rel="noopener">值集</a>知识的读者可能很容易猜想<code>ValueQ</code>可能具有类似下面的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Attributes[ValueQ] &#x3D; &#123;HoldAll, Protected, ReadProtected&#125;</span><br><span class="line">ValueQ[sym_Symbol]:&#x3D;Hold[sym]&#x3D;!&#x3D;Hold[sym]&#x2F;.OwnValues[sym]</span><br><span class="line">ValueQ[expr_]:&#x3D;Unevaluated[expr]&#x3D;!&#x3D;expr</span><br></pre></td></tr></table></figure><p>因而具有上面那样的行为也是可以理解的。</p><p>不过这种不一致性总归让人觉得别扭，尽管这种不一致性本质上来源于Wolfram语言求值策略的复杂性，尤其是<a href="http://reference.wolfram.com/language/ref/Condition.html" target="_blank" rel="noopener"><code>Condition</code></a>的灵活性，使得上面这种策略注定无法真正消除副作用。哪怕是现在这种状况，我们依然可以让<code>ValueQ</code>对符号作用时产生副作用，<br>例如</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>;</span><br><span class="line">y:=<span class="keyword">With</span>[&#123;e=++x&#125;, e/;<span class="keyword">True</span>]</span><br><span class="line">v=<span class="keyword">ValueQ</span>[y];</span><br><span class="line">&#123;v,x&#125;</span><br></pre></td></tr></table></figure><p>也会得到<code>{True,1}</code>。这里用到的技巧叫<a href="https://mathematica.stackexchange.com/questions/29317/replacement-inside-held-expression" target="_blank" rel="noopener">Trott-Strzebonski</a>，是一种常用的元编程技巧，不过这里不做赘述，对于理解<code>Condition</code>的工作方式的读者想必并不复杂。</p><p>因此，这里想介绍另一种消去副作用的思路，也就是所谓的“符号沙盒”。</p><h3 id="思路与实现"><a class="markdownIt-Anchor" href="#思路与实现"></a> 思路与实现</h3><p>如果说<code>ValueQ</code>的思路是尽可能避免求值来消去副作用的话，那么接下来的处理方式则是尽可能将副作用局域化，就好像在沙盒环境中一样。而这也正是标题由来。</p><p>事实上，<code>Block</code>动态作用域就具有类似的效果。不过直接使用<code>Block</code>的话则略显繁琐，我们希望有一个能自动分析需要局域化的符号并且能继承既有定义的动态作用域。幸运的是，Mathematica中既有的函数足以覆盖我们的需求：<code>Internal`EmbeddedSymbols</code>和<code>Internal`InheritedBlock</code>。尽管这两者都是没有文档的“内部函数”，不过通过测试和分析可以推测他们的功能：</p><ul><li><code>Internal`EmbeddedSymbols</code>：可以获取一个表达式<strong>所有</strong>直接或<em>间接</em>使用的符号</li><li><code>Internal`InheritedBlock</code>：继承符号既有定义的动态作用域</li></ul><p>组合这两者不难得到</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SetAttributes</span>[&#123;embeddedUserSymbols,symbolSandbox&#125;,<span class="keyword">HoldFirst</span>]</span><br><span class="line">embeddedUserSymbols[expr_]:=</span><br><span class="line"> <span class="keyword">Select</span>[Internal`EmbeddedSymbols[expr],</span><br><span class="line">  <span class="keyword">Function</span>[sym,<span class="keyword">ContainsNone</span>[<span class="keyword">Attributes</span>[sym],&#123;<span class="keyword">Locked</span>,<span class="keyword">Protected</span>&#125;],<span class="keyword">HoldAll</span>]</span><br><span class="line"> ]/. &#123;<span class="keyword">Hold</span>[syms___]:&gt;<span class="keyword">Hold</span>[&#123;syms&#125;]&#125;</span><br><span class="line">symbolSandbox[expr_]:=<span class="keyword">With</span>[&#123;syms=<span class="keyword">Unevaluated</span>@@embeddedUserSymbols[expr]&#125;,</span><br><span class="line">  Internal`InheritedBlock[syms,expr]</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p>这里需要注意的是<code>Internal`EmbeddedSymbols</code>获得的符号不能全部局域化，因此加入了<code>Select</code>滤过具有<code>Locked</code>和<code>Protected</code>属性的符号。</p><p>然后我们可以给出一个更“安全”的<code>ValueQ</code></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SetAttributes</span>[valueQ,<span class="keyword">HoldFirst</span>]</span><br><span class="line">valueQ[expr_]:=<span class="keyword">Unevaluated</span>[expr]=!=symbolSandbox[expr]</span><br></pre></td></tr></table></figure><p>此时</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>;</span><br><span class="line">y:=++x</span><br><span class="line">v=valueQ[y+<span class="number">0</span>];</span><br><span class="line">&#123;v,x&#125;</span><br></pre></td></tr></table></figure><p>会给出<code>{True, 0}</code>的结果，<code>x</code>因对<code>y</code>的求值而产生的改变被限制在<code>valueQ</code>的计算过程中。</p><p>不过这种局域化仅限于符号，并不能限制诸如文件IO等其它方式的副作用，因此只能叫“符号沙盒”。</p><hr><p><strong>补充：</strong><br>经过更多测试，发现<code>Internal`EmbeddedSymbols</code>似乎有不太稳定，有时会导致内核崩溃，而且似乎<strong>不能</strong>完全获取有关的符号。这部分可能有待改进。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题的引入&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题的引入&quot;&gt;&lt;/a&gt; 问题的引入&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ValueQ&lt;/code&gt;是Matheamtica中的一个非常有趣的函数，它判断一个表达式是否会进行求值，而且这种判断有时可以做到无副作用，哪怕求值本身是具有副作用的。比如&lt;/p&gt;&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y:=++x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v=&lt;span class=&quot;keyword&quot;&gt;ValueQ&lt;/span&gt;[y];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;v,x&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;会得到&lt;code&gt;{True,0}&lt;/code&gt;的结果。这里的&lt;code&gt;ValueQ[y]&lt;/code&gt;显然并没有真正对&lt;code&gt;y&lt;/code&gt;求值就作出了判断。不过很遗憾的是这其中哪怕只有略微的改动也会使其作用发生变化，例如&lt;/p&gt;&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y:=++x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v=&lt;span class=&quot;keyword&quot;&gt;ValueQ&lt;/span&gt;[y+&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;v,x&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;则会得到&lt;code&gt;{True,1}&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
      <category term="Undocumented" scheme="http://miRoox.github.io/blog/tags/Undocumented/"/>
    
  </entry>
  
  <entry>
    <title>Mathematica下标赋值问题补遗</title>
    <link href="http://miroox.github.io/blog/2019/01/SubcriptInMma-Addendum/"/>
    <id>http://miroox.github.io/blog/2019/01/SubcriptInMma-Addendum/</id>
    <published>2019-01-16T06:55:47.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>我曾经写过一篇关于Mathematica中下标与赋值问题的<a href="https://miroox.github.io/2018/08/SubscriptAndDerivateInMma/">文章</a>，不过那篇文章重点解决的是符号关联的问题。但有时，我们可能会遇到另一种问题，比如</p><img src="/blog/2019/01/SubcriptInMma-Addendum/Subscript.png" title="Subscript"><a id="more"></a><p>也就是定义了符号的本值之后又想定义带有同样符号的下标值。当然，我们是不推荐这么写的，这会使符号的含义很含混。<br>不过单从实用的角度考虑，让上面的代码正常工作并不困难，只需要对<code>Subscript</code>添加<code>HoldFirst</code>属性即可。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SetAttributes</span>[<span class="keyword">Subscript</span>,<span class="keyword">HoldFirst</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我曾经写过一篇关于Mathematica中下标与赋值问题的&lt;a href=&quot;https://miroox.github.io/2018/08/SubscriptAndDerivateInMma/&quot;&gt;文章&lt;/a&gt;，不过那篇文章重点解决的是符号关联的问题。但有时，我们可能会遇到另一种问题，比如&lt;/p&gt;&lt;img src=&quot;/blog/2019/01/SubcriptInMma-Addendum/Subscript.png&quot; title=&quot;Subscript&quot;&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://miRoox.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="踩坑" scheme="http://miRoox.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
  <entry>
    <title>突然发现部分Wolfram演示项目支持在线运行了</title>
    <link href="http://miroox.github.io/blog/2018/12/WolframOnlineDemo/"/>
    <id>http://miroox.github.io/blog/2018/12/WolframOnlineDemo/</id>
    <published>2018-12-01T12:09:39.000Z</published>
    <updated>2020-01-30T04:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题，已经有<strong>部分</strong>Wolfram演示项目支持在线运行，尽管这个功能貌似还在测试中。</p><a id="more"></a><p>甚至还支持以内联框架的形式嵌入网页。比如下面这个例子就来自 <a href="https://demonstrations.wolfram.com/FraunhoferDiffractionThroughARectangularAperture" target="_blank" rel="noopener">https://demonstrations.wolfram.com/FraunhoferDiffractionThroughARectangularAperture</a>。</p><iframe src="https://www.wolframcloud.com/objects/demonstrations/FraunhoferDiffractionThroughARectangularAperture?_view=EMBED" width="420" height="480" frameborder="0" loading="lazy" allowfullscreen></iframe><p>不过这个在线运行机制似乎是基于 <a href="https://www.wolfram.com/cloud/" target="_blank" rel="noopener">Wolfram Cloud</a> 实现的，而不是 <a href="https://webassembly.org/" target="_blank" rel="noopener">Web Assembly</a> 之类的本地计算，因此响应速度会有点慢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如题，已经有&lt;strong&gt;部分&lt;/strong&gt;Wolfram演示项目支持在线运行，尽管这个功能貌似还在测试中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码编程" scheme="http://miRoox.github.io/blog/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Wolfram" scheme="http://miRoox.github.io/blog/tags/Wolfram/"/>
    
  </entry>
  
</feed>
